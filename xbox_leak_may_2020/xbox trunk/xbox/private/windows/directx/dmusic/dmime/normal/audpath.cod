; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	..\audpath.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0BJ@NCJKLKPM@Incrementing?5?$CFlx?5to?5?$CFld?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BJ@CKLEGGCI@Decrementing?5?$CFlx?5to?5?$CFld?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BJ@MOPENDEN@Found?5shared?5Buffer?5?$CFlx?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@FBLDFMCD@Created?5Buffer?5?$CFlx?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0GA@ONALGHCJ@Audiopath?5Creation?5error?3?5Reques@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0HM@FFONCBGO@Error?3?5Attempt?5to?5load?5an?5effect@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CP@DMLIBLBB@AudioPath?5Configuration?5failed?5l@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EO@KIFLFOOK@Error?3?5Failure?5loading?5port?5conf@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BI@KKLMPNJD@Creating?5AudioPath?5?$CFlx?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BJ@IGMLCEHI@?$CFs?3?5Invalid?5pointer?5ppv?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CB@NHMFCKLP@?$CFs?3?5Invalid?5pointer?5?$CIvoid?$CK?$CJ?$CGiid?6@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EB@HBMHDLLO@Warning?3?5Request?5to?5query?5unknow@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BO@IBOJFPEI@?$CFs?3?5Invalid?5argument?5lVolume?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BN@MDFJNLGO@?$CFs?3?5Invalid?5argument?5lPitch?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BO@EMDDDLDF@?$CFs?3?5Invalid?5pointer?5ppObject?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DG@HOFLBGEC@Invalid?5buffer?5or?5stage?5id?5passe@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CP@CIDKKOPL@Error?3?5Audiopath?5does?5not?5suppor@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CP@BHAJIHMA@Warning?3?5Requested?5AudioPath?5obj@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BN@PIBBOBHG@Audiopath?5?$CFlx?5Activate?3?5?$CFld?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DI@CMFHAAD@Warning?3?5Attempt?5to?5activate?5alr@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DM@GFNFLPMP@Warning?3?5Attempt?5to?5deactivate?5a@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CE@IGLHMFAG@?$CFs?3?5Invalid?5pointer?5pdwPChannelO@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EG@OPHKJFGH@Error?3?5Audiopath?5failed?5request?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BL@KLPIMHHM@?$CFs?3?5Invalid?5pointer?5pPMsg?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EJ@FAHOIMCJ@Error?3?5Attempting?5to?5play?5on?5an?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DJ@JGOKDJAP@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@BLHJFHEJ@pPath?5?$CB?$DN?5GetHead?$CI?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EJ@ENIGIDFJ@Error?3?5Attempt?5to?5create?5mixbin?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EH@FEDPIBJE@Warning?3?5Request?5to?5query?5unknow@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CH@DNOFJOKI@offsetof?$CIDMUS_OBJECTDESC?0?5dwSize@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@JDNNJMNO@?$CFs?$EA?$CFs?3?5?$CFs?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EH@OOGGANMB@?$CFs?3?5pDesc?5does?5not?5point?5to?5as?5m@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CA@DAJLLPMH@?$CFs?3?5pDesc?9?$DOdwSize?5is?5too?5small?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BO@DNADCDLB@?$CFs?3?5Invalid?5pointer?5pClassID?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DN@BMALPPLF@Error?3?5Failed?5parsing?5?9?5file?5is?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DG@BIDDMOBM@Error?3?5AudioPath?5Configuration?5f@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02BGAOHDMM@?$CBp?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
;	COMDAT ??0CBufferNode@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CBufferNode@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@CBufferNode@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@CBufferNode@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCBufferNode@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Activate@CBufferNode@@QAEJH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FinalDeactivate@CBufferNode@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CBufferManager@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CBufferManager@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@CBufferManager@@QAEJPAVCPerformance@@PAU_DMUS_AUDIOPARAMS@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FinalDeactivate@CBufferManager@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clear@CBufferManager@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBufferNode@CBufferManager@@QAEPAVCBufferNode@@ABU_GUID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateBuffer@CBufferManager@@QAEJPAVCBufferConfig@@PAPAV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCBufferConfig@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CBufferConnect@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Load@CBufferConnect@@QAEJPAVCRiffParser@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateRunTimeVersion@CBufferConnect@@QAEPAV1@PAVCPortConfig@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCBufferConnect@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CBufferConnect@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateRunTimeVersion@CBufferConnectList@@QAEJPAV1@PAVCPortConfig@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clear@CBufferConnectList@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Activate@CBufferConfig@@QAEJH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CBufferConfig@@QAE@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CBufferConfig@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DecideType@CBufferConfig@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Load@CBufferConfig@@QAEJPAUIStream@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clear@CBufferConfigList@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBufferNode@CBufferConfigList@@QAEPAVCBufferNode@@ABU_GUID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Activate@CBufferConfigList@@QAEJH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateRunTimeVersion@CBufferConfigList@@QAEJPAV1@PAVCBufferManager@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CPortConfig@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CBufferConnectList@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CBufferConfigList@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CPortConfig@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Activate@CPortConfig@@QAEJH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateRunTimeVersion@CPortConfig@@QAEJPAPAV1@PAVCAudioPath@@PAVCBufferManager@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBufferNode@CPortConfig@@QAEPAVCBufferNode@@ABU_GUID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Load@CPortConfig@@QAEJPAVCRiffParser@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Activate@CPortConfigList@@QAEJH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateRunTimeVersion@CPortConfigList@@QAEJPAV1@PAVCAudioPath@@PAVCBufferManager@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UsesPort@CPortConfigList@@QAEHPAUIDirectMusicPort@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clear@CPortConfigList@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCPortConfig@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CAudioPath@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IDirectMusicAudioPath@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IDirectMusicGraph@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CPortConfigList@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CAudioPath@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@CAudioPath@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@CAudioPath@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCAudioPath@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?QueryInterface@CAudioPath@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetVolume@CAudioPath@@UAGJJK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetPitch@CAudioPath@@UAGJJK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetObjectInPath@CAudioPath@@UAGJKKKABU_GUID@@K0PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Activate@CAudioPath@@UAGJH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ConvertPChannel@CAudioPath@@UAGJKPAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Shutdown@CAudioPath@@QAGJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InsertTool@CAudioPath@@UAGJPAUIDirectMusicTool@@PAKKJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTool@CAudioPath@@UAGJKPAPAUIDirectMusicTool@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveTool@CAudioPath@@UAGJPAUIDirectMusicTool@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StampPMsg@CAudioPath@@UAGJPAU_DMUS_PMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetGraph@CAudioPath@@QAEPAVCGraph@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Deactivate@CAudioPath@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetGraph@CAudioPath@@QAEXPAVCGraph@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBufferNode@CAudioPath@@QAEPAVCBufferNode@@ABU_GUID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@CAudioPath@@QAEJPAUIUnknown@@PAVCPerformance@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ConnectToPorts@CAudioPath@@QAEJPAVCPerformance@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clear@CAudioPathList@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBufferNode@CAudioPathList@@QAEPAVCBufferNode@@ABU_GUID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UsesPort@CAudioPathList@@QAEHPAUIDirectMusicPort@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CAudioPathConfig@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IPersistStream@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IDirectMusicObject@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IPersist@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CAudioPathConfig@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateStandardConfig@CAudioPathConfig@@SGPAV1@KKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCAudioPathConfig@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?QueryInterface@CAudioPathConfig@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@CAudioPathConfig@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@CAudioPathConfig@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDescriptor@CAudioPathConfig@@UAGJPAU_DMUS_OBJECTDESC@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetDescriptor@CAudioPathConfig@@UAGJPAU_DMUS_OBJECTDESC@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ParseDescriptor@CAudioPathConfig@@UAGJPAUIStream@@PAU_DMUS_OBJECTDESC@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassID@CAudioPathConfig@@UAGJPAU_GUID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsDirty@CAudioPathConfig@@UAGJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Load@CAudioPathConfig@@UAGJPAUIStream@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Load@CAudioPathConfig@@QAEJPAVCRiffParser@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Save@CAudioPathConfig@@UAGJPAUIStream@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSizeMax@CAudioPathConfig@@UAGJPAT_ULARGE_INTEGER@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TList@UTriggerInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetHead@?$TList@UTriggerInfo@@@@QBEPAV?$TListItem@UTriggerInfo@@@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CleanUp@?$TList@UTriggerInfo@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddHead@?$TList@UTriggerInfo@@@@QAEXPAV?$TListItem@UTriggerInfo@@@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TList@ULyricInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetHead@?$TList@ULyricInfo@@@@QBEPAV?$TListItem@ULyricInfo@@@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CleanUp@?$TList@ULyricInfo@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddHead@?$TList@ULyricInfo@@@@QAEXPAV?$TListItem@ULyricInfo@@@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TListItem@UTriggerInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNext@?$TListItem@UTriggerInfo@@@@QBEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetItemValue@?$TListItem@UTriggerInfo@@@@QAEAAUTriggerInfo@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TListItem@ULyricInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNext@?$TListItem@ULyricInfo@@@@QBEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetItemValue@?$TListItem@ULyricInfo@@@@QAEAAULyricInfo@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$ComPtr@UIDirectMusicLoader@@@SmartRef@@QAE@PAUIDirectMusicLoader@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$ComPtr@UIDirectMusicLoader@@@SmartRef@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$ComPtr@UIDirectMusicLoader@@@SmartRef@@QAEPAUIDirectMusicLoader@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??I?$ComPtr@UIDirectMusicLoader@@@SmartRef@@QAEPAPAUIDirectMusicLoader@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EventCompare@?$CmpStruct@UTriggerInfo@@@@SGHAAUTriggerInfo@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EventCompare@?$CmpStruct@ULyricInfo@@@@SGHAAULyricInfo@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CStandardStateData@ULyricInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1LyricInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetNext@?$TListItem@UTriggerInfo@@@@QAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetNext@?$TListItem@ULyricInfo@@@@QAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$ComPtr@UIDirectMusicLoader@@@SmartRef@@QAEAAV01@PAUIDirectMusicLoader@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MergeSort@?$TList@UTriggerInfo@@@@QAEXP6GHAAUTriggerInfo@@0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reverse@?$TList@UTriggerInfo@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@UTriggerInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MergeSort@?$TList@ULyricInfo@@@@QAEXP6GHAAULyricInfo@@0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reverse@?$TList@ULyricInfo@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@ULyricInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@UWaveItem@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@UParamInfo@CParamControlTrack@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@_J@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@UObjectInfo@CParamControlTrack@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1ObjectInfo@CParamControlTrack@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MergeSort@?$TListItem@UTriggerInfo@@@@QAEPAV1@P6GHAAUTriggerInfo@@0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MergeSort@?$TListItem@ULyricInfo@@@@QAEPAV1@P6GHAAULyricInfo@@0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Divide@?$TListItem@UTriggerInfo@@@@AAEXAAPAV1@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Merge@?$TListItem@UTriggerInfo@@@@AAEPAV1@PAV1@P6GHAAUTriggerInfo@@1@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Divide@?$TListItem@ULyricInfo@@@@AAEXAAPAV1@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Merge@?$TListItem@ULyricInfo@@@@AAEPAV1@PAV1@P6GHAAULyricInfo@@1@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?QueryInterface@CAudioPathConfig@@W3AGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@CAudioPathConfig@@W3AGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@CAudioPathConfig@@W3AGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?QueryInterface@CAudioPath@@W3AGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@CAudioPath@@W3AGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@CAudioPath@@W3AGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TList@UParamInfo@CParamControlTrack@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Delete@?$TListItem@UParamInfo@CParamControlTrack@@@@SGXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$TListItem@UParamInfo@CParamControlTrack@@@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1ParamInfo@CParamControlTrack@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1WaveItem@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1WString@SmartRef@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0DJ@BKGKOLMN@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0LyricInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0WString@SmartRef@@QAE@PBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1TriggerInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0TriggerInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Delete@?$TListItem@ULyricInfo@@@@SGXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$TListItem@ULyricInfo@@@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Delete@?$TListItem@UTriggerInfo@@@@SGXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$TListItem@UTriggerInfo@@@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??Load@CAudioPathConfig@@UAGJPAUIStream@@@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??GetClassID@CAudioPathConfig@@UAGJPAU_GUID@@@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BO@LHMABAKO@?$CFs?3?5Invalid?5pointer?5pIStream?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??ParseDescriptor@CAudioPathConfig@@UAGJPAUIStream@@PAU_DMUS_OBJECTDESC@@@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??SetDescriptor@CAudioPathConfig@@UAGJPAU_DMUS_OBJECTDESC@@@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??GetDescriptor@CAudioPathConfig@@UAGJPAU_DMUS_OBJECTDESC@@@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??QueryInterface@CAudioPathConfig@@UAGJABU_GUID@@PAPAX@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?AddHead@CBufferConnectList@@QAEXPAVCBufferConnect@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddHead@AList@@QAEXPAVAListItem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetNext@AListItem@@QAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddHead@CPortConfigList@@QAEXPAVCPortConfig@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddHead@CBufferConfigList@@QAEXPAVCBufferConfig@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CAudioPathConfig@@6BIDirectMusicObject@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CAudioPathConfig@@6BIPersistStream@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?UsesPort@CAudioPath@@QAEHPAUIDirectMusicPort@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNext@CAudioPath@@QAEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNext@AListItem@@QBEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetHead@CAudioPathList@@QAEPAVCAudioPath@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetHead@AList@@QBEPAVAListItem@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddHead@CAudioPathList@@QAEXPAVCAudioPath@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@CAudioPathList@@QAEXPAVCAudioPath@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@AList@@QAEXPAVAListItem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??StampPMsg@CAudioPath@@UAGJPAU_DMUS_PMSG@@@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??ConvertPChannel@CAudioPath@@UAGJKPAK@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?QueryInterface@IDirectSoundBuffer@@QAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@IDirectSoundBuffer@@QAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBuffer@CBufferNode@@QAEPAUIDirectSoundBuffer@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??GetObjectInPath@CAudioPath@@UAGJKKKABU_GUID@@K0PAPAX@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??SetPitch@CAudioPath@@UAGJJK@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??SetVolume@CAudioPath@@UAGJJK@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??QueryInterface@CAudioPath@@UAGJABU_GUID@@PAPAX@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?DeleteCriticalSection@@YGXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IUnknown@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CAudioPath@@6BIDirectMusicGraph@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CAudioPath@@6BIDirectMusicAudioPath@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?RemoveHead@CPortConfigList@@QAEPAVCPortConfig@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveHead@AList@@QAEPAVAListItem@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddTail@CPortConfigList@@QAEXPAVCPortConfig@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNext@CPortConfig@@QAEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetHead@CPortConfigList@@QAEPAVCPortConfig@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStream@CRiffParser@@QAEPAUIStream@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddTail@CBufferConfigList@@QAEXPAVCBufferConfig@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNext@CBufferConfig@@QAEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetHead@CBufferConfigList@@QAEPAVCBufferConfig@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveHead@CBufferConfigList@@QAEPAVCBufferConfig@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __GUID_00000000_0000_0000_0000_000000000000
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?RemoveHead@CBufferConnectList@@QAEPAVCBufferConnect@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddTail@CBufferConnectList@@QAEXPAVCBufferConnect@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNext@CBufferConnect@@QAEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetHead@CBufferConnectList@@QAEPAVCBufferConnect@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_V@YAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_U@YAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddHead@CBufferManager@@QAEXPAVCBufferNode@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateSoundBuffer@IDirectSound@@QAGJPBU_DSBUFFERDESC@@PAPAUIDirectSoundBuffer@@PAUIUnknown@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetMixBinHeadroom@IDirectSound@@QAGJKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _==@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _IsEqualGUID@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNext@CBufferNode@@AAEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetHead@CBufferManager@@QAEPAVCBufferNode@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0AList@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@IDirectSoundBuffer@@QAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3@YAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@CBufferManager@@QAEXPAVCBufferNode@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0AListItem@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	??0CBufferNode@@QAE@XZ				; CBufferNode::CBufferNode
PUBLIC	??0AListItem@@QAE@XZ				; AListItem::AListItem
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\dmime\audpath.cpp
;	COMDAT ??0CBufferNode@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CBufferNode@@QAE@XZ PROC NEAR			; CBufferNode::CBufferNode, COMDAT
; _this$ = ecx

; 9    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0AListItem@@QAE@XZ	; AListItem::AListItem

; 10   :     m_lActivateCount = 0;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [eax+48], 0

; 11   :     m_cRef = 1;

  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	c7 41 34 01 00
	00 00		 mov	 DWORD PTR [ecx+52], 1

; 12   :     m_pBuffer = NULL;

  00023	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00026	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0

; 13   :     m_pManager = NULL;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0

; 14   :     m_dwMixBin = 0;

  00037	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0

; 15   : #ifdef XBOX
; 16   :     m_MixBinsHeader.bControllers[0] = 0;

  00041	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00044	c6 42 28 00	 mov	 BYTE PTR [edx+40], 0

; 17   : #endif
; 18   : }

  00048	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
??0CBufferNode@@QAE@XZ ENDP				; CBufferNode::CBufferNode
_TEXT	ENDS
PUBLIC	??1CBufferNode@@QAE@XZ				; CBufferNode::~CBufferNode
PUBLIC	?FinalDeactivate@CBufferNode@@AAEXXZ		; CBufferNode::FinalDeactivate
PUBLIC	?Remove@CBufferManager@@QAEXPAVCBufferNode@@@Z	; CBufferManager::Remove
; Function compile flags: /Odt
;	COMDAT ??1CBufferNode@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1CBufferNode@@QAE@XZ PROC NEAR			; CBufferNode::~CBufferNode, COMDAT
; _this$ = ecx

; 22   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 23   :     FinalDeactivate();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?FinalDeactivate@CBufferNode@@AAEXXZ ; CBufferNode::FinalDeactivate

; 24   :     if (m_pManager)

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  00016	74 0f		 je	 SHORT $L69421

; 25   :     {
; 26   :         m_pManager->Remove(this);

  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	51		 push	 ecx
  0001c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001f	8b 4a 1c	 mov	 ecx, DWORD PTR [edx+28]
  00022	e8 00 00 00 00	 call	 ?Remove@CBufferManager@@QAEXPAVCBufferNode@@@Z ; CBufferManager::Remove
$L69421:

; 27   :     }
; 28   : }

  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
??1CBufferNode@@QAE@XZ ENDP				; CBufferNode::~CBufferNode
_TEXT	ENDS
PUBLIC	?AddRef@CBufferNode@@QAEKXZ			; CBufferNode::AddRef
EXTRN	__InterlockedIncrement@4:NEAR
; Function compile flags: /Odt
;	COMDAT ?AddRef@CBufferNode@@QAEKXZ
_TEXT	SEGMENT
_this$ = -4
?AddRef@CBufferNode@@QAEKXZ PROC NEAR			; CBufferNode::AddRef, COMDAT
; _this$ = ecx

; 31   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 32   :     return InterlockedIncrement(&m_cRef);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 34	 add	 eax, 52			; 00000034H
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 __InterlockedIncrement@4

; 33   : }

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?AddRef@CBufferNode@@QAEKXZ ENDP			; CBufferNode::AddRef
_TEXT	ENDS
PUBLIC	?Release@CBufferNode@@QAEKXZ			; CBufferNode::Release
PUBLIC	??_GCBufferNode@@QAEPAXI@Z			; CBufferNode::`scalar deleting destructor'
EXTRN	__InterlockedDecrement@4:NEAR
; Function compile flags: /Odt
;	COMDAT ?Release@CBufferNode@@QAEKXZ
_TEXT	SEGMENT
tv72 = -16
_this$ = -12
$T71515 = -8
$T71514 = -4
?Release@CBufferNode@@QAEKXZ PROC NEAR			; CBufferNode::Release, COMDAT
; _this$ = ecx

; 36   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 37   :     if (!InterlockedDecrement(&m_cRef))

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 34	 add	 eax, 52			; 00000034H
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 __InterlockedDecrement@4
  00015	85 c0		 test	 eax, eax
  00017	75 2c		 jne	 SHORT $L69429

; 38   :     {
; 39   :         delete this;

  00019	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	89 4d f8	 mov	 DWORD PTR $T71515[ebp], ecx
  0001f	8b 55 f8	 mov	 edx, DWORD PTR $T71515[ebp]
  00022	89 55 fc	 mov	 DWORD PTR $T71514[ebp], edx
  00025	83 7d fc 00	 cmp	 DWORD PTR $T71514[ebp], 0
  00029	74 0f		 je	 SHORT $L71516
  0002b	6a 01		 push	 1
  0002d	8b 4d fc	 mov	 ecx, DWORD PTR $T71514[ebp]
  00030	e8 00 00 00 00	 call	 ??_GCBufferNode@@QAEPAXI@Z
  00035	89 45 f0	 mov	 DWORD PTR tv72[ebp], eax
  00038	eb 07		 jmp	 SHORT $L71517
$L71516:
  0003a	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR tv72[ebp], 0
$L71517:

; 40   :         return 0;

  00041	33 c0		 xor	 eax, eax
  00043	eb 06		 jmp	 SHORT $L69428
$L69429:

; 41   :     }
; 42   : 
; 43   :     return m_cRef;

  00045	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00048	8b 40 34	 mov	 eax, DWORD PTR [eax+52]
$L69428:

; 44   : }

  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
?Release@CBufferNode@@QAEKXZ ENDP			; CBufferNode::Release
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??_GCBufferNode@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4
___flags$ = 8
??_GCBufferNode@@QAEPAXI@Z PROC NEAR			; CBufferNode::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CBufferNode@@QAE@XZ	; CBufferNode::~CBufferNode
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $L69435
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$L69435:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GCBufferNode@@QAEPAXI@Z ENDP				; CBufferNode::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?Activate@CBufferNode@@QAEJH@Z			; CBufferNode::Activate
; Function compile flags: /Odt
;	COMDAT ?Activate@CBufferNode@@QAEJH@Z
_TEXT	SEGMENT
_this$ = -8
_hr$ = -4
_fActivate$ = 8
?Activate@CBufferNode@@QAEJH@Z PROC NEAR		; CBufferNode::Activate, COMDAT
; _this$ = ecx

; 48   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 49   :     HRESULT hr = S_OK;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 50   :     if (m_pBuffer)

  00010	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00017	74 4a		 je	 SHORT $L69442

; 51   :     {
; 52   :         if (fActivate)

  00019	83 7d 08 00	 cmp	 DWORD PTR _fActivate$[ebp], 0
  0001d	74 17		 je	 SHORT $L69443

; 53   :         {
; 54   :             if (!m_lActivateCount)
; 55   :             {
; 56   : #ifndef XBOX
; 57   :                 // Don't bother starting if the primary buffer.
; 58   :                 if (SUCCEEDED(hr) && !(m_BufferHeader.dwFlags & DMUS_BUFFERF_PRIMARY))
; 59   :                 {
; 60   :                     TraceI(2,"Play buffer %lx\n",m_pBuffer);
; 61   :                     hr = m_pBuffer->Play(0,0,DSBPLAY_LOOPING);
; 62   : #ifdef DBG
; 63   :                     if (FAILED(hr))
; 64   :                     {
; 65   :                         Trace(1,"Error: Activate on audiopath failed because buffer failed Play command.\n");
; 66   :                     }
; 67   : #endif
; 68   :                 }
; 69   : #endif
; 70   :             }
; 71   :             if (hr == S_OK)

  0001f	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00023	75 0f		 jne	 SHORT $L69446

; 72   :             {
; 73   :                 m_lActivateCount++;

  00025	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00028	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  0002b	83 c0 01	 add	 eax, 1
  0002e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	89 41 30	 mov	 DWORD PTR [ecx+48], eax
$L69446:

; 74   :             }
; 75   :             TraceI(3,"Incrementing %lx to %ld\n",m_pBuffer,m_lActivateCount);
; 76   :         }
; 77   :         else

  00034	eb 2d		 jmp	 SHORT $L69442
$L69443:

; 78   :         {
; 79   :             if (m_lActivateCount > 0)

  00036	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00039	83 7a 30 00	 cmp	 DWORD PTR [edx+48], 0
  0003d	7e 24		 jle	 SHORT $L69442

; 80   :             {
; 81   :                 m_lActivateCount--;

  0003f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00042	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00045	83 e9 01	 sub	 ecx, 1
  00048	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0004b	89 4a 30	 mov	 DWORD PTR [edx+48], ecx

; 82   :                 if (!m_lActivateCount)
; 83   :                 {
; 84   : #ifndef XBOX
; 85   :                     // Don't bother stopping the primary buffer.
; 86   :                     if (!(m_BufferHeader.dwFlags & DMUS_BUFFERF_PRIMARY))
; 87   :                     {
; 88   :                         TraceI(2,"Stop buffer %lx\n",m_pBuffer);
; 89   :                         hr = m_pBuffer->Stop();
; 90   :                     }
; 91   : #endif
; 92   :                 }
; 93   :                 TraceI(3,"Decrementing %lx to %ld\n",m_pBuffer,m_lActivateCount);
; 94   :                 if (hr != S_OK)

  0004e	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00052	74 0f		 je	 SHORT $L69442

; 95   :                 {
; 96   :                     m_lActivateCount++;

  00054	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00057	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  0005a	83 c2 01	 add	 edx, 1
  0005d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00060	89 50 30	 mov	 DWORD PTR [eax+48], edx
$L69442:

; 97   :                 }
; 98   :             }
; 99   :         }
; 100  :     }
; 101  :     return hr;

  00063	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]

; 102  : }

  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c2 04 00	 ret	 4
?Activate@CBufferNode@@QAEJH@Z ENDP			; CBufferNode::Activate
_TEXT	ENDS
PUBLIC	?Release@IDirectSoundBuffer@@QAGKXZ		; IDirectSoundBuffer::Release
; Function compile flags: /Odt
;	COMDAT ?FinalDeactivate@CBufferNode@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4
?FinalDeactivate@CBufferNode@@AAEXXZ PROC NEAR		; CBufferNode::FinalDeactivate, COMDAT
; _this$ = ecx

; 107  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 108  :     if (m_lActivateCount)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 78 30 00	 cmp	 DWORD PTR [eax+48], 0
  0000e	74 0a		 je	 SHORT $L69457

; 109  :     {
; 110  :         Activate(FALSE);

  00010	6a 00		 push	 0
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ?Activate@CBufferNode@@QAEJH@Z ; CBufferNode::Activate
$L69457:

; 111  :     }
; 112  :     if (m_pBuffer)

  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  00021	74 16		 je	 SHORT $L69456

; 113  :     {
; 114  :         m_pBuffer->Release();

  00023	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00026	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ?Release@IDirectSoundBuffer@@QAGKXZ ; IDirectSoundBuffer::Release

; 115  :         m_pBuffer = NULL;

  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
$L69456:

; 116  :     }
; 117  : }

  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
?FinalDeactivate@CBufferNode@@AAEXXZ ENDP		; CBufferNode::FinalDeactivate
_TEXT	ENDS
PUBLIC	??0CBufferManager@@QAE@XZ			; CBufferManager::CBufferManager
PUBLIC	??0AList@@QAE@XZ				; AList::AList
; Function compile flags: /Odt
;	COMDAT ??0CBufferManager@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CBufferManager@@QAE@XZ PROC NEAR			; CBufferManager::CBufferManager, COMDAT
; _this$ = ecx

; 120  : { 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0AList@@QAE@XZ	; AList::AList

; 121  : #ifdef DXAPI
; 122  :     m_pFirstBuffer = NULL;
; 123  :     m_pSinkConnect = NULL;
; 124  :     m_pSynthSink = NULL;
; 125  : #endif
; 126  :     m_pPerf = NULL; 

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 127  : } 

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
??0CBufferManager@@QAE@XZ ENDP				; CBufferManager::CBufferManager
_TEXT	ENDS
PUBLIC	??1CBufferManager@@QAE@XZ			; CBufferManager::~CBufferManager
PUBLIC	?Clear@CBufferManager@@QAEXXZ			; CBufferManager::Clear
; Function compile flags: /Odt
;	COMDAT ??1CBufferManager@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1CBufferManager@@QAE@XZ PROC NEAR			; CBufferManager::~CBufferManager, COMDAT
; _this$ = ecx

; 130  : {     

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 131  :     Clear();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?Clear@CBufferManager@@QAEXXZ ; CBufferManager::Clear

; 132  : #ifdef DXAPI
; 133  :     if (m_pSinkConnect)
; 134  :     {
; 135  :         m_pSinkConnect->Release();
; 136  :     }
; 137  :     if (m_pSynthSink)
; 138  :     {
; 139  :         m_pSynthSink->Release();
; 140  :     }
; 141  : #endif
; 142  : }

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1CBufferManager@@QAE@XZ ENDP				; CBufferManager::~CBufferManager
_TEXT	ENDS
PUBLIC	?Init@CBufferManager@@QAEJPAVCPerformance@@PAU_DMUS_AUDIOPARAMS@@@Z ; CBufferManager::Init
; Function compile flags: /Odt
;	COMDAT ?Init@CBufferManager@@QAEJPAVCPerformance@@PAU_DMUS_AUDIOPARAMS@@@Z
_TEXT	SEGMENT
_this$ = -4
_pPerf$ = 8
_pAudioParams$ = 12
?Init@CBufferManager@@QAEJPAVCPerformance@@PAU_DMUS_AUDIOPARAMS@@@Z PROC NEAR ; CBufferManager::Init, COMDAT
; _this$ = ecx

; 146  : { 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 147  :     m_pPerf = pPerf; 

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _pPerf$[ebp]
  0000f	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 148  :     m_AudioParams = *pAudioParams;

  00012	8b 75 0c	 mov	 esi, DWORD PTR _pAudioParams$[ebp]
  00015	8b 7d fc	 mov	 edi, DWORD PTR _this$[ebp]
  00018	83 c7 08	 add	 edi, 8
  0001b	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  00020	f3 a5		 rep movsd

; 149  : #ifdef DXAPI
; 150  :     HRESULT hr = S_OK;
; 151  :     CBufferNode *pNode = new CBufferNode;
; 152  :     if (pNode)
; 153  :     {
; 154  :         pNode->m_BufferHeader.guidBufferID = GUID_Buffer_Primary;
; 155  :         pNode->m_BufferHeader.dwFlags = DMUS_BUFFERF_SHARED | DMUS_BUFFERF_DEFINED | DMUS_BUFFERF_PRIMARY;
; 156  :         pNode->m_pManager = this;
; 157  :         AddHead(pNode);
; 158  :         // Create the primary buffer. This will be used for requests to access the listener.
; 159  :         DSBUFFERDESC dsbdesc; 
; 160  :         memset(&dsbdesc, 0, sizeof(dsbdesc));
; 161  :         dsbdesc.dwSize = sizeof(dsbdesc); 
; 162  :         dsbdesc.dwFlags = DSBCAPS_PRIMARYBUFFER | DSBCAPS_CTRL3D; 
; 163  : 
; 164  :         // create primary buffer
; 165  :         if (SUCCEEDED(hr = pPerf->m_pDirectSound->CreateSoundBuffer(&dsbdesc, &pNode->m_pBuffer, NULL)))
; 166  :         {
; 167  :             WAVEFORMATEX wfPrimary; 
; 168  :             memset(&wfPrimary, 0, sizeof(wfPrimary)); 
; 169  : 
; 170  :             if (SUCCEEDED(hr = pNode->m_pBuffer->GetFormat(&wfPrimary, sizeof(wfPrimary), NULL)))
; 171  :             {
; 172  :                 assert(wfPrimary.wFormatTag == WAVE_FORMAT_PCM);
; 173  : 
; 174  :                 BOOL fUpgrade = FALSE;
; 175  :                 if (wfPrimary.nSamplesPerSec < m_AudioParams.dwSampleRate)
; 176  :                 {
; 177  :                     wfPrimary.nSamplesPerSec = m_AudioParams.dwSampleRate;
; 178  :                     fUpgrade = TRUE;
; 179  :                 }
; 180  :                 if (wfPrimary.wBitsPerSample < 16)
; 181  :                 {
; 182  :                     wfPrimary.wBitsPerSample = 16;
; 183  :                     fUpgrade = TRUE;
; 184  :                 }
; 185  : 
; 186  :                 if (fUpgrade)
; 187  :                 {
; 188  :                     wfPrimary.nBlockAlign = wfPrimary.nChannels * (wfPrimary.wBitsPerSample / 8);
; 189  :                     wfPrimary.nAvgBytesPerSec = wfPrimary.nSamplesPerSec * wfPrimary.nBlockAlign;
; 190  : 
; 191  :                     // the existing format is of lesser quality than we desire, so let's upgrade it
; 192  :                     if (FAILED(hr = pNode->m_pBuffer->SetFormat( &wfPrimary )))
; 193  :                     {
; 194  :                         if (hr == DSERR_PRIOLEVELNEEDED)
; 195  :                         {
; 196  :                             // okay, so maybe the app doen't want us changing primary buffer
; 197  :                             Trace(0, "SynthSink - SetFormat on primary buffer failed, lacking priority\n");
; 198  :                         }
; 199  :                         else
; 200  :                         {
; 201  :                             Trace(0, "SynthSink - Activation failed, couldn't set primary buffer format\n");
; 202  :                         }
; 203  :                     }
; 204  :                 }
; 205  :             }
; 206  :         }
; 207  :     }
; 208  :     return hr;
; 209  : #else
; 210  :     return S_OK;

  00022	33 c0		 xor	 eax, eax

; 211  : #endif
; 212  : 
; 213  : }

  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
?Init@CBufferManager@@QAEJPAVCPerformance@@PAU_DMUS_AUDIOPARAMS@@@Z ENDP ; CBufferManager::Init
_TEXT	ENDS
PUBLIC	?GetNext@CBufferNode@@AAEPAV1@XZ		; CBufferNode::GetNext
PUBLIC	?GetHead@CBufferManager@@QAEPAVCBufferNode@@XZ	; CBufferManager::GetHead
PUBLIC	?FinalDeactivate@CBufferManager@@QAEXXZ		; CBufferManager::FinalDeactivate
; Function compile flags: /Odt
;	COMDAT ?FinalDeactivate@CBufferManager@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8
_pNode$ = -4
?FinalDeactivate@CBufferManager@@QAEXXZ PROC NEAR	; CBufferManager::FinalDeactivate, COMDAT
; _this$ = ecx

; 300  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 301  : #ifdef DXAPI
; 302  :     // Kill dummy buffer.
; 303  :     if (m_pFirstBuffer)
; 304  :     {
; 305  :         m_pFirstBuffer->Activate(FALSE);
; 306  :         delete m_pFirstBuffer;
; 307  :         m_pFirstBuffer = NULL;
; 308  :     }
; 309  : #endif
; 310  :     CBufferNode *pNode = GetHead();

  00009	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?GetHead@CBufferManager@@QAEPAVCBufferNode@@XZ ; CBufferManager::GetHead
  00011	89 45 fc	 mov	 DWORD PTR _pNode$[ebp], eax

; 311  :     for (;pNode;pNode = pNode->GetNext())

  00014	eb 0b		 jmp	 SHORT $L69475
$L69476:
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _pNode$[ebp]
  00019	e8 00 00 00 00	 call	 ?GetNext@CBufferNode@@AAEPAV1@XZ ; CBufferNode::GetNext
  0001e	89 45 fc	 mov	 DWORD PTR _pNode$[ebp], eax
$L69475:
  00021	83 7d fc 00	 cmp	 DWORD PTR _pNode$[ebp], 0
  00025	74 0a		 je	 SHORT $L69473

; 312  :     {
; 313  :         pNode->FinalDeactivate();

  00027	8b 4d fc	 mov	 ecx, DWORD PTR _pNode$[ebp]
  0002a	e8 00 00 00 00	 call	 ?FinalDeactivate@CBufferNode@@AAEXXZ ; CBufferNode::FinalDeactivate

; 314  :     }

  0002f	eb e5		 jmp	 SHORT $L69476
$L69473:

; 315  : #ifdef DXAPI
; 316  :     if (m_pSynthSink)
; 317  :     {
; 318  :         m_pSynthSink->Activate(FALSE);
; 319  :         m_pSynthSink->Release();
; 320  :         m_pSynthSink = NULL;
; 321  :     }
; 322  :     if (m_pSinkConnect)
; 323  :     {
; 324  :         m_pSinkConnect->SetMasterClock(NULL);
; 325  :         m_pSinkConnect->Release();
; 326  :         m_pSinkConnect = NULL;
; 327  :     }
; 328  : #endif
; 329  : }

  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
?FinalDeactivate@CBufferManager@@QAEXXZ ENDP		; CBufferManager::FinalDeactivate
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?Clear@CBufferManager@@QAEXXZ
_TEXT	SEGMENT
tv72 = -20
_this$ = -16
$T71543 = -12
$T71542 = -8
_pNode$ = -4
?Clear@CBufferManager@@QAEXXZ PROC NEAR			; CBufferManager::Clear, COMDAT
; _this$ = ecx

; 332  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 333  :     CBufferNode *pNode;
; 334  :     FinalDeactivate();

  00009	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?FinalDeactivate@CBufferManager@@QAEXXZ ; CBufferManager::FinalDeactivate
$L69483:

; 335  :     while (pNode = GetHead())

  00011	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?GetHead@CBufferManager@@QAEPAVCBufferNode@@XZ ; CBufferManager::GetHead
  00019	89 45 fc	 mov	 DWORD PTR _pNode$[ebp], eax
  0001c	83 7d fc 00	 cmp	 DWORD PTR _pNode$[ebp], 0
  00020	74 2a		 je	 SHORT $L69480

; 336  :     {
; 337  :         delete pNode;

  00022	8b 45 fc	 mov	 eax, DWORD PTR _pNode$[ebp]
  00025	89 45 f4	 mov	 DWORD PTR $T71543[ebp], eax
  00028	8b 4d f4	 mov	 ecx, DWORD PTR $T71543[ebp]
  0002b	89 4d f8	 mov	 DWORD PTR $T71542[ebp], ecx
  0002e	83 7d f8 00	 cmp	 DWORD PTR $T71542[ebp], 0
  00032	74 0f		 je	 SHORT $L71544
  00034	6a 01		 push	 1
  00036	8b 4d f8	 mov	 ecx, DWORD PTR $T71542[ebp]
  00039	e8 00 00 00 00	 call	 ??_GCBufferNode@@QAEPAXI@Z
  0003e	89 45 ec	 mov	 DWORD PTR tv72[ebp], eax
  00041	eb 07		 jmp	 SHORT $L71545
$L71544:
  00043	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv72[ebp], 0
$L71545:

; 338  :     }

  0004a	eb c5		 jmp	 SHORT $L69483
$L69480:

; 339  : }

  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
?Clear@CBufferManager@@QAEXXZ ENDP			; CBufferManager::Clear
_TEXT	ENDS
PUBLIC	?GetBufferNode@CBufferManager@@QAEPAVCBufferNode@@ABU_GUID@@@Z ; CBufferManager::GetBufferNode
PUBLIC	_==@8
; Function compile flags: /Odt
;	COMDAT ?GetBufferNode@CBufferManager@@QAEPAVCBufferNode@@ABU_GUID@@@Z
_TEXT	SEGMENT
_this$ = -8
_pNode$ = -4
_guidBufferID$ = 8
?GetBufferNode@CBufferManager@@QAEPAVCBufferNode@@ABU_GUID@@@Z PROC NEAR ; CBufferManager::GetBufferNode, COMDAT
; _this$ = ecx

; 343  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 344  :     CBufferNode *pNode = GetHead();

  00009	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?GetHead@CBufferManager@@QAEPAVCBufferNode@@XZ ; CBufferManager::GetHead
  00011	89 45 fc	 mov	 DWORD PTR _pNode$[ebp], eax

; 345  :     for (;pNode;pNode = pNode->GetNext())

  00014	eb 0b		 jmp	 SHORT $L69492
$L69493:
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _pNode$[ebp]
  00019	e8 00 00 00 00	 call	 ?GetNext@CBufferNode@@AAEPAV1@XZ ; CBufferNode::GetNext
  0001e	89 45 fc	 mov	 DWORD PTR _pNode$[ebp], eax
$L69492:
  00021	83 7d fc 00	 cmp	 DWORD PTR _pNode$[ebp], 0
  00025	74 20		 je	 SHORT $L69494

; 346  :     {
; 347  :         if (pNode->m_BufferHeader.guidBufferID == guidBufferID)

  00027	8b 45 08	 mov	 eax, DWORD PTR _guidBufferID$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _pNode$[ebp]
  0002e	83 c1 08	 add	 ecx, 8
  00031	51		 push	 ecx
  00032	e8 00 00 00 00	 call	 _==@8
  00037	85 c0		 test	 eax, eax
  00039	74 0a		 je	 SHORT $L69495

; 348  :         {
; 349  :             pNode->AddRef();

  0003b	8b 4d fc	 mov	 ecx, DWORD PTR _pNode$[ebp]
  0003e	e8 00 00 00 00	 call	 ?AddRef@CBufferNode@@QAEKXZ ; CBufferNode::AddRef

; 350  :             break;

  00043	eb 02		 jmp	 SHORT $L69494
$L69495:

; 351  :         }
; 352  :     }

  00045	eb cf		 jmp	 SHORT $L69493
$L69494:

; 353  :     return pNode;

  00047	8b 45 fc	 mov	 eax, DWORD PTR _pNode$[ebp]

; 354  : }

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c2 04 00	 ret	 4
?GetBufferNode@CBufferManager@@QAEPAVCBufferNode@@ABU_GUID@@@Z ENDP ; CBufferManager::GetBufferNode
_TEXT	ENDS
PUBLIC	_IsEqualGUID@8
; Function compile flags: /Odt
; File c:\xbox\public\sdk\inc\guiddef.h
;	COMDAT _==@8
_TEXT	SEGMENT
_guidOne$ = 8
_guidOther$ = 12
_==@8	PROC NEAR					; COMDAT

; 188  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 189  :     return IsEqualGUID(guidOne,guidOther);

  00003	8b 45 0c	 mov	 eax, DWORD PTR _guidOther$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR _guidOne$[ebp]
  0000a	51		 push	 ecx
  0000b	e8 00 00 00 00	 call	 _IsEqualGUID@8

; 190  : }

  00010	5d		 pop	 ebp
  00011	c2 08 00	 ret	 8
_==@8	ENDP
_TEXT	ENDS
EXTRN	_memcmp:NEAR
; Function compile flags: /Odt
;	COMDAT _IsEqualGUID@8
_TEXT	SEGMENT
_rguid1$ = 8
_rguid2$ = 12
_IsEqualGUID@8 PROC NEAR				; COMDAT

; 155  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 156  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

  00003	6a 10		 push	 16			; 00000010H
  00005	8b 45 0c	 mov	 eax, DWORD PTR _rguid2$[ebp]
  00008	50		 push	 eax
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _rguid1$[ebp]
  0000c	51		 push	 ecx
  0000d	e8 00 00 00 00	 call	 _memcmp
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	f7 d8		 neg	 eax
  00017	1b c0		 sbb	 eax, eax
  00019	40		 inc	 eax

; 157  : }

  0001a	5d		 pop	 ebp
  0001b	c2 08 00	 ret	 8
_IsEqualGUID@8 ENDP
_TEXT	ENDS
PUBLIC	?AddHead@CBufferManager@@QAEXPAVCBufferNode@@@Z	; CBufferManager::AddHead
PUBLIC	?CreateBuffer@CBufferManager@@QAEJPAVCBufferConfig@@PAPAV2@@Z ; CBufferManager::CreateBuffer
PUBLIC	??0CBufferConfig@@QAE@K@Z			; CBufferConfig::CBufferConfig
PUBLIC	??_GCBufferConfig@@QAEPAXI@Z			; CBufferConfig::`scalar deleting destructor'
PUBLIC	?CreateSoundBuffer@IDirectSound@@QAGJPBU_DSBUFFERDESC@@PAPAUIDirectSoundBuffer@@PAUIUnknown@@@Z ; IDirectSound::CreateSoundBuffer
PUBLIC	?SetMixBinHeadroom@IDirectSound@@QAGJKK@Z	; IDirectSound::SetMixBinHeadroom
PUBLIC	??_C@_0GA@ONALGHCJ@Audiopath?5Creation?5error?3?5Reques@ ; `string'
EXTRN	?DebugTrace@@YAXHPADZZ:NEAR			; DebugTrace
EXTRN	??0CMIXBINS@@QAE@XZ:NEAR			; CMIXBINS::CMIXBINS
EXTRN	?GetMixBins@CMIXBINS@@QAEPBU_DSMIXBINS@@XZ:NEAR	; CMIXBINS::GetMixBins
EXTRN	?CreateFromMask@CMIXBINS@@QAEXK@Z:NEAR		; CMIXBINS::CreateFromMask
EXTRN	??1CMIXBINS@@QAE@XZ:NEAR			; CMIXBINS::~CMIXBINS
;	COMDAT ??_C@_0GA@ONALGHCJ@Audiopath?5Creation?5error?3?5Reques@
; File c:\xbox\private\windows\directx\dmusic\dmime\audpath.cpp
CONST	SEGMENT
??_C@_0GA@ONALGHCJ@Audiopath?5Creation?5error?3?5Reques@ DB 'Audiopath Cr'
	DB	'eation error: Requested buffer when DMUS_AUDIOF_BUFFERS not e'
	DB	'nabled via InitAudio.', 0aH, 00H		; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?CreateBuffer@CBufferManager@@QAEJPAVCBufferConfig@@PAPAV2@@Z
_TEXT	SEGMENT
tv209 = -176
tv202 = -172
tv153 = -168
tv140 = -164
tv75 = -160
_this$ = -156
$T71569 = -152
$T71568 = -148
$T71565 = -144
$T71564 = -140
$T71561 = -136
$T71558 = -132
_MixBins$69541 = -128
_BufferDesc$69523 = -48
_dwMixBin$69522 = -24
_pNode$69509 = -16
_pNode$69517 = -12
_pNew$69504 = -8
_hr$ = -4
_pConfig$ = 8
_ppNew$ = 12
?CreateBuffer@CBufferManager@@QAEJPAVCBufferConfig@@PAPAV2@@Z PROC NEAR ; CBufferManager::CreateBuffer, COMDAT
; _this$ = ecx

; 359  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec b0 00 00
	00		 sub	 esp, 176		; 000000b0H
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	89 8d 64 ff ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 360  :     HRESULT hr = S_OK;

  00011	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 361  :     if (m_AudioParams.dwFeatures & DMUS_AUDIOF_BUFFERS)

  00018	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00021	83 e1 20	 and	 ecx, 32			; 00000020H
  00024	85 c9		 test	 ecx, ecx
  00026	0f 84 54 03 00
	00		 je	 $L69503

; 362  :     {
; 363  : //        ASSERT(m_pSinkConnect);
; 364  :         CBufferConfig *pNew = new CBufferConfig(pConfig->m_dwStandardBufferID);

  0002c	6a 30		 push	 48			; 00000030H
  0002e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00033	83 c4 04	 add	 esp, 4
  00036	89 85 7c ff ff
	ff		 mov	 DWORD PTR $T71558[ebp], eax
  0003c	83 bd 7c ff ff
	ff 00		 cmp	 DWORD PTR $T71558[ebp], 0
  00043	74 1a		 je	 SHORT $L71559
  00045	8b 55 08	 mov	 edx, DWORD PTR _pConfig$[ebp]
  00048	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0004b	50		 push	 eax
  0004c	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR $T71558[ebp]
  00052	e8 00 00 00 00	 call	 ??0CBufferConfig@@QAE@K@Z ; CBufferConfig::CBufferConfig
  00057	89 85 60 ff ff
	ff		 mov	 DWORD PTR tv75[ebp], eax
  0005d	eb 0a		 jmp	 SHORT $L71560
$L71559:
  0005f	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv75[ebp], 0
$L71560:
  00069	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR tv75[ebp]
  0006f	89 4d f8	 mov	 DWORD PTR _pNew$69504[ebp], ecx

; 365  :         if (pNew)

  00072	83 7d f8 00	 cmp	 DWORD PTR _pNew$69504[ebp], 0
  00076	0f 84 b0 02 00
	00		 je	 $L69507

; 366  :         {
; 367  :             *ppNew = pNew;

  0007c	8b 55 0c	 mov	 edx, DWORD PTR _ppNew$[ebp]
  0007f	8b 45 f8	 mov	 eax, DWORD PTR _pNew$69504[ebp]
  00082	89 02		 mov	 DWORD PTR [edx], eax

; 368  :             pNew->m_BufferHeader = pConfig->m_BufferHeader;

  00084	8b 75 08	 mov	 esi, DWORD PTR _pConfig$[ebp]
  00087	83 c6 0c	 add	 esi, 12			; 0000000cH
  0008a	8b 7d f8	 mov	 edi, DWORD PTR _pNew$69504[ebp]
  0008d	83 c7 0c	 add	 edi, 12			; 0000000cH
  00090	b9 05 00 00 00	 mov	 ecx, 5
  00095	f3 a5		 rep movsd

; 369  :             if (pConfig->m_BufferHeader.dwFlags & DMUS_BUFFERF_SHARED)

  00097	8b 4d 08	 mov	 ecx, DWORD PTR _pConfig$[ebp]
  0009a	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0009d	83 e2 01	 and	 edx, 1
  000a0	85 d2		 test	 edx, edx
  000a2	74 5f		 je	 SHORT $L69508

; 370  :             {
; 371  :                 // Check to see if there already is a buffer in the list with this GUID.
; 372  :                 CBufferNode *pNode = GetHead();

  000a4	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  000aa	e8 00 00 00 00	 call	 ?GetHead@CBufferManager@@QAEPAVCBufferNode@@XZ ; CBufferManager::GetHead
  000af	89 45 f0	 mov	 DWORD PTR _pNode$69509[ebp], eax

; 373  :                 for (;pNode;pNode = pNode->GetNext())

  000b2	eb 0b		 jmp	 SHORT $L69510
$L69511:
  000b4	8b 4d f0	 mov	 ecx, DWORD PTR _pNode$69509[ebp]
  000b7	e8 00 00 00 00	 call	 ?GetNext@CBufferNode@@AAEPAV1@XZ ; CBufferNode::GetNext
  000bc	89 45 f0	 mov	 DWORD PTR _pNode$69509[ebp], eax
$L69510:
  000bf	83 7d f0 00	 cmp	 DWORD PTR _pNode$69509[ebp], 0
  000c3	74 3e		 je	 SHORT $L69508

; 374  :                 {
; 375  :                     if (pNode->m_BufferHeader.dwFlags & DMUS_BUFFERF_SHARED)

  000c5	8b 45 f0	 mov	 eax, DWORD PTR _pNode$69509[ebp]
  000c8	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  000cb	83 e1 01	 and	 ecx, 1
  000ce	85 c9		 test	 ecx, ecx
  000d0	74 2f		 je	 SHORT $L69513

; 376  :                     {
; 377  :                         if (pNode->m_BufferHeader.guidBufferID == pConfig->m_BufferHeader.guidBufferID)

  000d2	8b 55 08	 mov	 edx, DWORD PTR _pConfig$[ebp]
  000d5	83 c2 0c	 add	 edx, 12			; 0000000cH
  000d8	52		 push	 edx
  000d9	8b 45 f0	 mov	 eax, DWORD PTR _pNode$69509[ebp]
  000dc	83 c0 08	 add	 eax, 8
  000df	50		 push	 eax
  000e0	e8 00 00 00 00	 call	 _==@8
  000e5	85 c0		 test	 eax, eax
  000e7	74 18		 je	 SHORT $L69513

; 378  :                         {
; 379  :                             pNew->m_pBufferNode = pNode;

  000e9	8b 4d f8	 mov	 ecx, DWORD PTR _pNew$69504[ebp]
  000ec	8b 55 f0	 mov	 edx, DWORD PTR _pNode$69509[ebp]
  000ef	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 380  :                             pNode->AddRef();

  000f2	8b 4d f0	 mov	 ecx, DWORD PTR _pNode$69509[ebp]
  000f5	e8 00 00 00 00	 call	 ?AddRef@CBufferNode@@QAEKXZ ; CBufferNode::AddRef

; 381  :                             TraceI(2,"Found shared Buffer %lx\n",pNode->m_pBuffer);
; 382  :                             return S_OK;

  000fa	33 c0		 xor	 eax, eax
  000fc	e9 98 02 00 00	 jmp	 $L69500
$L69513:

; 383  :                         }
; 384  :                     }
; 385  :                 }

  00101	eb b1		 jmp	 SHORT $L69511
$L69508:

; 386  :             }
; 387  :             // Either the buffer does not already exist, or it is not to be shared, so
; 388  :             // create a new buffer node and requested buffer.
; 389  :             CBufferNode *pNode = new CBufferNode;

  00103	6a 38		 push	 56			; 00000038H
  00105	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0010a	83 c4 04	 add	 esp, 4
  0010d	89 85 78 ff ff
	ff		 mov	 DWORD PTR $T71561[ebp], eax
  00113	83 bd 78 ff ff
	ff 00		 cmp	 DWORD PTR $T71561[ebp], 0
  0011a	74 13		 je	 SHORT $L71562
  0011c	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR $T71561[ebp]
  00122	e8 00 00 00 00	 call	 ??0CBufferNode@@QAE@XZ	; CBufferNode::CBufferNode
  00127	89 85 5c ff ff
	ff		 mov	 DWORD PTR tv140[ebp], eax
  0012d	eb 0a		 jmp	 SHORT $L71563
$L71562:
  0012f	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv140[ebp], 0
$L71563:
  00139	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR tv140[ebp]
  0013f	89 45 f4	 mov	 DWORD PTR _pNode$69517[ebp], eax

; 390  :             if (pNode)

  00142	83 7d f4 00	 cmp	 DWORD PTR _pNode$69517[ebp], 0
  00146	0f 84 d9 01 00
	00		 je	 $L69520

; 391  :             {
; 392  :                 pNode->m_BufferHeader = pConfig->m_BufferHeader;

  0014c	8b 75 08	 mov	 esi, DWORD PTR _pConfig$[ebp]
  0014f	83 c6 0c	 add	 esi, 12			; 0000000cH
  00152	8b 7d f4	 mov	 edi, DWORD PTR _pNode$69517[ebp]
  00155	83 c7 08	 add	 edi, 8
  00158	b9 05 00 00 00	 mov	 ecx, 5
  0015d	f3 a5		 rep movsd

; 393  : #ifdef XBOX
; 394  :                 pNode->m_MixBinsHeader = pConfig->m_MixBinsHeader;

  0015f	8b 4d 08	 mov	 ecx, DWORD PTR _pConfig$[ebp]
  00162	83 c1 24	 add	 ecx, 36			; 00000024H
  00165	8b 55 f4	 mov	 edx, DWORD PTR _pNode$69517[ebp]
  00168	83 c2 24	 add	 edx, 36			; 00000024H
  0016b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0016d	89 02		 mov	 DWORD PTR [edx], eax
  0016f	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00172	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00175	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00178	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 395  : #endif
; 396  : #ifndef XBOX
; 397  :                 // Predefined buffer type?
; 398  :                 if (pConfig->m_BufferHeader.dwFlags & DMUS_BUFFERF_DEFINED)
; 399  :                 {
; 400  :                     // Must be a standard type. Create by hand.
; 401  :                     CBufferNode *pSendNode = NULL;
; 402  :                     DSBUFFERDESC BufferDesc;
; 403  :                     WAVEFORMATEX WaveFormat;
; 404  :                     DWORD dwFunctionIDs[2];
; 405  :                     CLSID clsidDMO;
; 406  :                     BOOL fDMO = FALSE;
; 407  :                     DWORD dwNumFunctionIDs;
; 408  :                     memset(&BufferDesc, 0, sizeof(BufferDesc));
; 409  :                     BufferDesc.dwSize  = sizeof(BufferDesc);
; 410  :                     BufferDesc.lpwfxFormat = &WaveFormat;
; 411  :                     BufferDesc.dwBufferBytes = 0;
; 412  :                     BufferDesc.dwFlags = 0;
; 413  :                     memset(&WaveFormat,0,sizeof(WaveFormat));
; 414  :                     WaveFormat.nChannels = 2;
; 415  :                     switch (pConfig->m_dwStandardBufferID)
; 416  :                     {
; 417  :                     case BUFFER_REVERB :
; 418  :                     case BUFFER_CHORUS :
; 419  :                         dwFunctionIDs[0] = DSBUSID_REVERB_SEND;
; 420  :                         dwNumFunctionIDs = 1;
; 421  :                         WaveFormat.nChannels = 2;
; 422  :                         BufferDesc.dwFlags = DSBCAPS_GLOBALFOCUS | DSBCAPS_CTRLVOLUME | DSBCAPS_CTRLPAN | DSBCAPS_LOCDEFER;
; 423  :                         clsidDMO = GUID_DSFX_WAVES_REVERB;
; 424  :                         fDMO = TRUE;
; 425  :                         break;
; 426  :                     case BUFFER_ENVREVERB :
; 427  :                         dwNumFunctionIDs = 0;
; 428  :                         WaveFormat.nChannels = 2;
; 429  :                         BufferDesc.dwFlags = DSBCAPS_MIXIN | DSBCAPS_GLOBALFOCUS | DSBCAPS_CTRLPAN | DSBCAPS_CTRLVOLUME;
; 430  :                         clsidDMO = GUID_DSFX_STANDARD_I3DL2REVERB;
; 431  :                         fDMO = TRUE;
; 432  :                         if (!(m_AudioParams.dwFeatures & DMUS_AUDIOF_BUFFERS))
; 433  :                         {
; 434  :                             hr = DMUS_E_AUDIOPATH_NOBUFFER;
; 435  :                             Trace(1,"Audiopath Creation error: Requested Environmental reverb buffer when DMUS_AUDIOF_ENVIRON not enabled via InitAudio.\n"); 
; 436  :                         }
; 437  :                         break;
; 438  :                         // Following removed for DX8, should be reintroduced for Whistler and DX8.1...
; 439  :                     case BUFFER_3D :
; 440  :                         clsidDMO = GUID_DSFX_STANDARD_I3DL2SOURCE;
; 441  :                         fDMO = TRUE;
; 442  :                         pSendNode = GetBufferNode(GUID_Buffer_EnvReverb);
; 443  :                         if (!pSendNode)
; 444  :                         {
; 445  :                             Trace(1,"Error: Failed creating 3D audiopath because the environmental reverb audiopath has not been created.\n");
; 446  :                             hr = DMUS_E_AUDIOPATH_NOGLOBALFXBUFFER;
; 447  :                             break;
; 448  :                         }
; 449  :                     case BUFFER_3D_DRY :
; 450  :                         dwFunctionIDs[0] = DSBUSID_DYNAMIC_0;
; 451  :                         dwNumFunctionIDs = 1;
; 452  :                         WaveFormat.nChannels = 1;
; 453  :                         BufferDesc.dwFlags = DSBCAPS_GLOBALFOCUS | DSBCAPS_CTRLVOLUME | DSBCAPS_CTRLFREQUENCY |
; 454  :                             DSBCAPS_CTRL3D | DSBCAPS_MUTE3DATMAXDISTANCE | DSBCAPS_LOCDEFER;
; 455  :                         BufferDesc.guid3DAlgorithm = DS3DALG_NO_VIRTUALIZATION;
; 456  :                         break;
; 457  :                     case BUFFER_MONO :
; 458  :                         dwFunctionIDs[0] = DSBUSID_LEFT;
; 459  :                         dwNumFunctionIDs = 1;
; 460  :                         WaveFormat.nChannels = 1;
; 461  :                         BufferDesc.dwFlags = DSBCAPS_GLOBALFOCUS | DSBCAPS_CTRLVOLUME | DSBCAPS_CTRLFREQUENCY | DSBCAPS_CTRLPAN | DSBCAPS_LOCDEFER;
; 462  :                         break;
; 463  :                     case BUFFER_STEREO :
; 464  :                         BufferDesc.dwFlags = DSBCAPS_CTRLFREQUENCY;
; 465  :                     case BUFFER_MUSIC :
; 466  :                         dwFunctionIDs[0] = DSBUSID_LEFT;
; 467  :                         dwFunctionIDs[1] = DSBUSID_RIGHT;
; 468  :                         dwNumFunctionIDs = 2;
; 469  :                         WaveFormat.nChannels = 2;
; 470  :                         BufferDesc.dwFlags |= DSBCAPS_GLOBALFOCUS | DSBCAPS_CTRLPAN | DSBCAPS_CTRLVOLUME | DSBCAPS_LOCDEFER;
; 471  :                         break;
; 472  :                     default:
; 473  :                         hr = E_INVALIDARG;
; 474  :                     }
; 475  :                     if (SUCCEEDED(hr))
; 476  :                     {
; 477  :                         WaveFormat.nBlockAlign = WaveFormat.nChannels * 2;
; 478  :                         WaveFormat.nSamplesPerSec = m_AudioParams.dwSampleRate;
; 479  :                         WaveFormat.nAvgBytesPerSec = WaveFormat.nChannels * WaveFormat.nSamplesPerSec * 2;
; 480  :                         WaveFormat.wBitsPerSample = 16;
; 481  :                         WaveFormat.wFormatTag = WAVE_FORMAT_PCM;
; 482  :                         // Ensure that the mixin flag and number of bus ids are in sync (you can't combine mixin with buses.)
; 483  :                         if ((pConfig->m_BufferHeader.dwFlags & DMUS_BUFFERF_MIXIN) || (dwNumFunctionIDs == 0))
; 484  :                         {
; 485  :                             dwNumFunctionIDs = 0;
; 486  :                             BufferDesc.dwFlags |= DSBCAPS_MIXIN;
; 487  :                             pConfig->m_BufferHeader.dwFlags |= DMUS_BUFFERF_MIXIN;
; 488  :                             BufferDesc.dwFlags &= ~DSBCAPS_LOCDEFER;
; 489  :                         }
; 490  :                         hr = m_pSinkConnect->CreateSoundBuffer(&BufferDesc, &dwFunctionIDs[0], dwNumFunctionIDs,
; 491  :                                                                pConfig->m_BufferHeader.guidBufferID, &pNode->m_pBuffer);
; 492  : #ifdef DBG
; 493  :                         if (FAILED(hr))
; 494  :                         {
; 495  :                             if (pConfig->m_BufferHeader.dwFlags & DMUS_BUFFERF_MIXIN)
; 496  :                             {
; 497  :                                 Trace(1,"Error: Failed creating global (MIXIN) buffer for standard path.\n");
; 498  :                             }
; 499  :                             else
; 500  :                             {
; 501  :                                 Trace(1,"Error: Failed creating buffer for standard path.\n");
; 502  :                             }
; 503  :                         }
; 504  : #endif
; 505  :                     }
; 506  :                     if (SUCCEEDED(hr))
; 507  :                     {
; 508  :                         if (fDMO)
; 509  :                         {
; 510  :                             IDirectSoundBuffer8 *pBuff8;
; 511  :                             if (SUCCEEDED(pNode->m_pBuffer->QueryInterface(IID_IDirectSoundBuffer8,(void **)&pBuff8)))
; 512  :                             {
; 513  :                                 DWORD dwResult;
; 514  :                                 DSEFFECTDESC FXDesc;
; 515  :                                 FXDesc.dwSize = sizeof(DSEFFECTDESC);
; 516  :                                 FXDesc.dwFlags = 0;
; 517  :                                 FXDesc.guidDSFXClass = clsidDMO;
; 518  :                                 FXDesc.dwReserved1 = 0;
; 519  :                                 FXDesc.dwReserved2 = 0;
; 520  :                                 if (pSendNode)
; 521  :                                 {
; 522  :                                     FXDesc.dwReserved1 = DWORD_PTR(pSendNode->GetBuffer());
; 523  :                                 }
; 524  :                                 hr = pBuff8->SetFX(1, &FXDesc, &dwResult);
; 525  :                                 if (FXDesc.dwReserved1)
; 526  :                                 {
; 527  :                                     ((IDirectSoundBuffer*)FXDesc.dwReserved1)->Release();
; 528  :                                 }
; 529  :                                 pBuff8->Release();
; 530  :                             }
; 531  :                         }
; 532  :                     }
; 533  :                     if (pSendNode)
; 534  :                     {
; 535  :                         pSendNode->Release();
; 536  :                     }
; 537  :                 }
; 538  :                 else
; 539  :                 {
; 540  :                     pConfig->m_BufferHeader.dwFlags &= ~DMUS_BUFFERF_MIXIN;
; 541  :                     hr = m_pSinkConnect->CreateSoundBufferFromConfig(pConfig->m_pBufferConfig,&pNode->m_pBuffer);
; 542  :                     if (SUCCEEDED(hr))
; 543  :                     {
; 544  :                         // We need to know if this is a mixin buffer so we can identify it later.
; 545  :                         DWORD dwBusIDs[32];
; 546  :                         DWORD dwFuncIDs[32];
; 547  :                         DWORD dwCount = 32;
; 548  :                         dwFuncIDs[0] = 0;
; 549  :                         if (SUCCEEDED(m_pSinkConnect->GetSoundBufferBusIDs((CBuffer *)pNode->m_pBuffer,dwBusIDs,dwFuncIDs,&dwCount)))
; 550  :                         {
; 551  :                             if (dwFuncIDs[0] == 0xFFFFFFFF)
; 552  :                             {
; 553  :                                 pConfig->m_BufferHeader.dwFlags |= DMUS_BUFFERF_MIXIN;
; 554  :                             }
; 555  :                         }
; 556  :                     }   
; 557  :                     else
; 558  :                     {
; 559  :                         Trace(1,"Error: Failed creation of buffer defined in audio path configuration file.\n");
; 560  :                     }
; 561  :                 }
; 562  : #else   // XBOX
; 563  :                 // Predefined buffer type?
; 564  :                 if (pConfig->m_BufferHeader.dwFlags & DMUS_BUFFERF_DEFINED)

  0017b	8b 55 08	 mov	 edx, DWORD PTR _pConfig$[ebp]
  0017e	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00181	83 e0 02	 and	 eax, 2
  00184	85 c0		 test	 eax, eax
  00186	0f 84 1f 01 00
	00		 je	 $L69521

; 565  :                 {
; 566  :                     // Must be a standard type. Create by hand.
; 567  :                     DWORD dwMixBin = 0;

  0018c	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _dwMixBin$69522[ebp], 0

; 568  :                     DSBUFFERDESC BufferDesc;
; 569  :                     BufferDesc.lpwfxFormat = NULL;

  00193	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _BufferDesc$69523[ebp+12], 0

; 570  :                     BufferDesc.dwSize = sizeof(BufferDesc);

  0019a	c7 45 d0 18 00
	00 00		 mov	 DWORD PTR _BufferDesc$69523[ebp], 24 ; 00000018H

; 571  :                     BufferDesc.dwBufferBytes = 0;

  001a1	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _BufferDesc$69523[ebp+8], 0

; 572  :                     BufferDesc.dwInputMixBin = 0;

  001a8	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _BufferDesc$69523[ebp+20], 0

; 573  :                     BufferDesc.dwFlags = DSBCAPS_CTRLVOLUME | DSBCAPS_MIXIN;

  001af	c7 45 d4 80 20
	00 00		 mov	 DWORD PTR _BufferDesc$69523[ebp+4], 8320 ; 00002080H

; 574  : 
; 575  :                     LPDIRECTSOUND pDSound;
; 576  :                     switch (pConfig->m_dwStandardBufferID)
; 577  :                     {

  001b6	8b 4d 08	 mov	 ecx, DWORD PTR _pConfig$[ebp]
  001b9	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  001bc	89 95 58 ff ff
	ff		 mov	 DWORD PTR tv153[ebp], edx
  001c2	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR tv153[ebp]
  001c8	83 e8 01	 sub	 eax, 1
  001cb	89 85 58 ff ff
	ff		 mov	 DWORD PTR tv153[ebp], eax
  001d1	83 bd 58 ff ff
	ff 09		 cmp	 DWORD PTR tv153[ebp], 9
  001d8	77 6c		 ja	 SHORT $L69536
  001da	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR tv153[ebp]
  001e0	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $L71572[ecx*4]
$L69529:

; 578  :                     case BUFFER_REVERB :
; 579  :                         dwMixBin = (1 << DSMIXBIN_FXSEND_0);

  001e7	c7 45 e8 00 08
	00 00		 mov	 DWORD PTR _dwMixBin$69522[ebp], 2048 ; 00000800H

; 580  : 
; 581  :                         //
; 582  :                         // set mixbin headroom to 2 (to reduce it by another 6db)
; 583  :                         // since we duplicate the reverb mixbin on the mixbin mask
; 584  :                         // causing any sounds send to it to double. 
; 585  :                         //
; 586  : 
; 587  :                         m_pPerf->m_pDirectSound->SetMixBinHeadroom(DSMIXBIN_FXSEND_0,2);

  001ee	6a 02		 push	 2
  001f0	6a 0b		 push	 11			; 0000000bH
  001f2	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  001f8	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  001fb	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  001fe	51		 push	 ecx
  001ff	e8 00 00 00 00	 call	 ?SetMixBinHeadroom@IDirectSound@@QAGJKK@Z ; IDirectSound::SetMixBinHeadroom

; 588  : 
; 589  :                         break;

  00204	eb 47		 jmp	 SHORT $L69526
$L69530:

; 590  :                     case BUFFER_CHORUS :
; 591  :                         dwMixBin = (1 << DSMIXBIN_FXSEND_1);

  00206	c7 45 e8 00 10
	00 00		 mov	 DWORD PTR _dwMixBin$69522[ebp], 4096 ; 00001000H

; 592  : 
; 593  :                         //
; 594  :                         // same for chorus
; 595  :                         //
; 596  : 
; 597  :                         m_pPerf->m_pDirectSound->SetMixBinHeadroom(DSMIXBIN_FXSEND_1,2);

  0020d	6a 02		 push	 2
  0020f	6a 0c		 push	 12			; 0000000cH
  00211	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00217	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0021a	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0021d	51		 push	 ecx
  0021e	e8 00 00 00 00	 call	 ?SetMixBinHeadroom@IDirectSound@@QAGJKK@Z ; IDirectSound::SetMixBinHeadroom

; 598  : 
; 599  :                         break;

  00223	eb 28		 jmp	 SHORT $L69526
$L69531:

; 600  : //                    case BUFFER_ENVREVERB :
; 601  : //                        break;      // Not supported.
; 602  :                     case BUFFER_3D :
; 603  :                     case BUFFER_3D_DRY :
; 604  :                         BufferDesc.dwFlags = DSBCAPS_CTRLVOLUME | DSBCAPS_CTRL3D | DSBCAPS_MIXIN;

  00225	c7 45 d4 90 20
	00 00		 mov	 DWORD PTR _BufferDesc$69523[ebp+4], 8336 ; 00002090H

; 605  :                         break;

  0022c	eb 1f		 jmp	 SHORT $L69526
$L69532:

; 606  :                     case BUFFER_MONO :
; 607  : //                        dwBufferMixBin = DSMIXBIN_FRONT_LEFT | DSMIXBIN_FRONT_RIGHT | DSMIXBIN_FRONT_CENTER | DSMIXBIN_BACK_LEFT | DSMIXBIN_BACK_RIGHT | DSMIXBIN_LOW_FREQUENCY;
; 608  :                         break;

  0022e	eb 1d		 jmp	 SHORT $L69526
$L69533:

; 609  :                     case BUFFER_STEREO :
; 610  : //                        dwBufferMixBin = DSMIXBIN_FRONT_LEFT | DSMIXBIN_FRONT_RIGHT;
; 611  :                         break;

  00230	eb 1b		 jmp	 SHORT $L69526
$L69534:

; 612  :                     case BUFFER_MUSIC :
; 613  :                         dwMixBin = (1 << DSMIXBIN_FRONT_LEFT) | (1 << DSMIXBIN_FRONT_RIGHT);

  00232	c7 45 e8 03 00
	00 00		 mov	 DWORD PTR _dwMixBin$69522[ebp], 3

; 614  :                         break;

  00239	eb 12		 jmp	 SHORT $L69526
$L69535:

; 615  :                     case BUFFER_MIXBINS :
; 616  :                         dwMixBin = pConfig->m_MixBinsHeader.dwMixBins;

  0023b	8b 55 08	 mov	 edx, DWORD PTR _pConfig$[ebp]
  0023e	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00241	89 45 e8	 mov	 DWORD PTR _dwMixBin$69522[ebp], eax

; 617  :                         break;

  00244	eb 07		 jmp	 SHORT $L69526
$L69536:

; 618  :                     default:
; 619  :                         hr = E_INVALIDARG;

  00246	c7 45 fc 57 00
	07 80		 mov	 DWORD PTR _hr$[ebp], -2147024809 ; 80070057H
$L69526:

; 620  :                     }
; 621  :                     if (SUCCEEDED(hr))

  0024d	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00251	7c 56		 jl	 SHORT $L69539

; 622  :                     {
; 623  :                         if (!dwMixBin)

  00253	83 7d e8 00	 cmp	 DWORD PTR _dwMixBin$69522[ebp], 0
  00257	75 47		 jne	 SHORT $L69540

; 624  :                         {
; 625  :                              //Right before CreateSoundBuffer, we translate the DWORD into a CMixBins class which we then 
; 626  :                              // cast to an LPCDSMIXBINS struct (very fast).
; 627  :                              CMIXBINS MixBins;

  00259	8d 4d 80	 lea	 ecx, DWORD PTR _MixBins$69541[ebp]
  0025c	e8 00 00 00 00	 call	 ??0CMIXBINS@@QAE@XZ	; CMIXBINS::CMIXBINS

; 628  :                              MixBins.CreateFromMask(0);

  00261	6a 00		 push	 0
  00263	8d 4d 80	 lea	 ecx, DWORD PTR _MixBins$69541[ebp]
  00266	e8 00 00 00 00	 call	 ?CreateFromMask@CMIXBINS@@QAEXK@Z ; CMIXBINS::CreateFromMask

; 629  :                              BufferDesc.lpMixBins = MixBins.GetMixBins();                        

  0026b	8d 4d 80	 lea	 ecx, DWORD PTR _MixBins$69541[ebp]
  0026e	e8 00 00 00 00	 call	 ?GetMixBins@CMIXBINS@@QAEPBU_DSMIXBINS@@XZ ; CMIXBINS::GetMixBins
  00273	89 45 e0	 mov	 DWORD PTR _BufferDesc$69523[ebp+16], eax

; 630  :                              hr = m_pPerf->m_pDirectSound->CreateSoundBuffer(&BufferDesc,&pNode->m_pBuffer,NULL);

  00276	6a 00		 push	 0
  00278	8b 4d f4	 mov	 ecx, DWORD PTR _pNode$69517[ebp]
  0027b	83 c1 04	 add	 ecx, 4
  0027e	51		 push	 ecx
  0027f	8d 55 d0	 lea	 edx, DWORD PTR _BufferDesc$69523[ebp]
  00282	52		 push	 edx
  00283	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00289	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0028c	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0028f	52		 push	 edx
  00290	e8 00 00 00 00	 call	 ?CreateSoundBuffer@IDirectSound@@QAGJPBU_DSBUFFERDESC@@PAPAUIDirectSoundBuffer@@PAUIUnknown@@@Z ; IDirectSound::CreateSoundBuffer
  00295	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 631  :                         }

  00298	8d 4d 80	 lea	 ecx, DWORD PTR _MixBins$69541[ebp]
  0029b	e8 00 00 00 00	 call	 ??1CMIXBINS@@QAE@XZ	; CMIXBINS::~CMIXBINS
$L69540:

; 632  :                         pNode->m_dwMixBin = dwMixBin;

  002a0	8b 45 f4	 mov	 eax, DWORD PTR _pNode$69517[ebp]
  002a3	8b 4d e8	 mov	 ecx, DWORD PTR _dwMixBin$69522[ebp]
  002a6	89 48 20	 mov	 DWORD PTR [eax+32], ecx
$L69539:

; 633  :                     }
; 634  :                 }
; 635  :                 else

  002a9	eb 0f		 jmp	 SHORT $L69542
$L69521:

; 636  :                 {
; 637  :                     pConfig->m_BufferHeader.dwFlags &= ~DMUS_BUFFERF_MIXIN;

  002ab	8b 55 08	 mov	 edx, DWORD PTR _pConfig$[ebp]
  002ae	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  002b1	83 e0 f7	 and	 eax, -9			; fffffff7H
  002b4	8b 4d 08	 mov	 ecx, DWORD PTR _pConfig$[ebp]
  002b7	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
$L69542:

; 638  : //                    hr = m_pSinkConnect->CreateSoundBufferFromConfig(pConfig->m_pBufferConfig,&pNode->m_pBuffer);
; 639  :                 }
; 640  : #endif  // XBOX
; 641  : 
; 642  :                 if (SUCCEEDED(hr))

  002ba	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  002be	7c 26		 jl	 SHORT $L69544

; 643  :                 {
; 644  :                     TraceI(2,"Created Buffer %lx\n",pNode->m_pBuffer);
; 645  :                     pNew->m_pBufferNode = pNode;

  002c0	8b 55 f8	 mov	 edx, DWORD PTR _pNew$69504[ebp]
  002c3	8b 45 f4	 mov	 eax, DWORD PTR _pNode$69517[ebp]
  002c6	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 646  :                     pNode->m_pManager = this;

  002c9	8b 4d f4	 mov	 ecx, DWORD PTR _pNode$69517[ebp]
  002cc	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  002d2	89 51 1c	 mov	 DWORD PTR [ecx+28], edx

; 647  :                     AddHead(pNode);

  002d5	8b 45 f4	 mov	 eax, DWORD PTR _pNode$69517[ebp]
  002d8	50		 push	 eax
  002d9	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  002df	e8 00 00 00 00	 call	 ?AddHead@CBufferManager@@QAEXPAVCBufferNode@@@Z ; CBufferManager::AddHead

; 648  :                 }
; 649  :                 else

  002e4	eb 3d		 jmp	 SHORT $L69546
$L69544:

; 650  :                 {
; 651  :                     delete pNode;

  002e6	8b 4d f4	 mov	 ecx, DWORD PTR _pNode$69517[ebp]
  002e9	89 8d 70 ff ff
	ff		 mov	 DWORD PTR $T71565[ebp], ecx
  002ef	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR $T71565[ebp]
  002f5	89 95 74 ff ff
	ff		 mov	 DWORD PTR $T71564[ebp], edx
  002fb	83 bd 74 ff ff
	ff 00		 cmp	 DWORD PTR $T71564[ebp], 0
  00302	74 15		 je	 SHORT $L71566
  00304	6a 01		 push	 1
  00306	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR $T71564[ebp]
  0030c	e8 00 00 00 00	 call	 ??_GCBufferNode@@QAEPAXI@Z
  00311	89 85 54 ff ff
	ff		 mov	 DWORD PTR tv202[ebp], eax
  00317	eb 0a		 jmp	 SHORT $L69546
$L71566:
  00319	c7 85 54 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv202[ebp], 0
$L69546:

; 652  :                 }
; 653  :             }
; 654  :             else

  00323	eb 07		 jmp	 SHORT $L69507
$L69520:

; 655  :             {
; 656  :                 hr = E_OUTOFMEMORY;

  00325	c7 45 fc 0e 00
	07 80		 mov	 DWORD PTR _hr$[ebp], -2147024882 ; 8007000eH
$L69507:

; 657  :             }
; 658  :         }
; 659  :         if (FAILED(hr) && pNew)

  0032c	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00330	7d 4c		 jge	 SHORT $L69552
  00332	83 7d f8 00	 cmp	 DWORD PTR _pNew$69504[ebp], 0
  00336	74 46		 je	 SHORT $L69552

; 660  :         {
; 661  :             delete pNew;

  00338	8b 45 f8	 mov	 eax, DWORD PTR _pNew$69504[ebp]
  0033b	89 85 68 ff ff
	ff		 mov	 DWORD PTR $T71569[ebp], eax
  00341	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR $T71569[ebp]
  00347	89 8d 6c ff ff
	ff		 mov	 DWORD PTR $T71568[ebp], ecx
  0034d	83 bd 6c ff ff
	ff 00		 cmp	 DWORD PTR $T71568[ebp], 0
  00354	74 15		 je	 SHORT $L71570
  00356	6a 01		 push	 1
  00358	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR $T71568[ebp]
  0035e	e8 00 00 00 00	 call	 ??_GCBufferConfig@@QAEPAXI@Z
  00363	89 85 50 ff ff
	ff		 mov	 DWORD PTR tv209[ebp], eax
  00369	eb 0a		 jmp	 SHORT $L71571
$L71570:
  0036b	c7 85 50 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv209[ebp], 0
$L71571:

; 662  :             *ppNew = NULL;

  00375	8b 55 0c	 mov	 edx, DWORD PTR _ppNew$[ebp]
  00378	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
$L69552:

; 663  :         }
; 664  :     }
; 665  :     else

  0037e	eb 16		 jmp	 SHORT $L69555
$L69503:

; 666  :     {
; 667  :         hr = DMUS_E_AUDIOPATH_NOBUFFER;

  00380	c7 45 fc 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H

; 668  :         Trace(0,"Audiopath Creation error: Requested buffer when DMUS_AUDIOF_BUFFERS not enabled via InitAudio.\n"); 

  00387	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0GA@ONALGHCJ@Audiopath?5Creation?5error?3?5Reques@
  0038c	6a 00		 push	 0
  0038e	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00393	83 c4 08	 add	 esp, 8
$L69555:

; 669  :     }
; 670  :     return hr;

  00396	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]
$L69500:

; 671  : }

  00399	5f		 pop	 edi
  0039a	5e		 pop	 esi
  0039b	8b e5		 mov	 esp, ebp
  0039d	5d		 pop	 ebp
  0039e	c2 08 00	 ret	 8
$L71572:
  003a1	00 00 00 00	 DD	 $L69529
  003a5	00 00 00 00	 DD	 $L69536
  003a9	00 00 00 00	 DD	 $L69531
  003ad	00 00 00 00	 DD	 $L69531
  003b1	00 00 00 00	 DD	 $L69536
  003b5	00 00 00 00	 DD	 $L69532
  003b9	00 00 00 00	 DD	 $L69533
  003bd	00 00 00 00	 DD	 $L69534
  003c1	00 00 00 00	 DD	 $L69530
  003c5	00 00 00 00	 DD	 $L69535
?CreateBuffer@CBufferManager@@QAEJPAVCBufferConfig@@PAPAV2@@Z ENDP ; CBufferManager::CreateBuffer
_TEXT	ENDS
PUBLIC	??1CBufferConfig@@QAE@XZ			; CBufferConfig::~CBufferConfig
; Function compile flags: /Odt
;	COMDAT ??_GCBufferConfig@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4
___flags$ = 8
??_GCBufferConfig@@QAEPAXI@Z PROC NEAR			; CBufferConfig::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CBufferConfig@@QAE@XZ ; CBufferConfig::~CBufferConfig
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $L69561
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$L69561:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GCBufferConfig@@QAEPAXI@Z ENDP			; CBufferConfig::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??0CBufferConnect@@QAE@XZ			; CBufferConnect::CBufferConnect
; Function compile flags: /Odt
;	COMDAT ??0CBufferConnect@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CBufferConnect@@QAE@XZ PROC NEAR			; CBufferConnect::CBufferConnect, COMDAT
; _this$ = ecx

; 675  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0AListItem@@QAE@XZ	; AListItem::AListItem

; 676  :     m_ppBufferNodes = NULL;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 677  :     m_pguidBufferIDs = NULL;

  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 678  :     m_ConnectHeader.dwBufferCount = 0;

  00023	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00026	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0

; 679  : }

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
??0CBufferConnect@@QAE@XZ ENDP				; CBufferConnect::CBufferConnect
_TEXT	ENDS
PUBLIC	?Load@CBufferConnect@@QAEJPAVCRiffParser@@@Z	; CBufferConnect::Load
EXTRN	?Read@CRiffParser@@QAEJPAXK@Z:NEAR		; CRiffParser::Read
; Function compile flags: /Odt
;	COMDAT ?Load@CBufferConnect@@QAEJPAVCRiffParser@@@Z
_TEXT	SEGMENT
_this$ = -16
$T71582 = -12
_dwBufferCount$69573 = -8
_hr$ = -4
_pParser$ = 8
?Load@CBufferConnect@@QAEJPAVCRiffParser@@@Z PROC NEAR	; CBufferConnect::Load, COMDAT
; _this$ = ecx

; 683  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 684  :     HRESULT hr = pParser->Read(&m_ConnectHeader, sizeof(DMUS_IO_PCHANNELTOBUFFER_HEADER));

  00009	6a 10		 push	 16			; 00000010H
  0000b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0000e	83 c0 04	 add	 eax, 4
  00011	50		 push	 eax
  00012	8b 4d 08	 mov	 ecx, DWORD PTR _pParser$[ebp]
  00015	e8 00 00 00 00	 call	 ?Read@CRiffParser@@QAEJPAXK@Z ; CRiffParser::Read
  0001a	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 685  :     if (SUCCEEDED(hr))

  0001d	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00021	7c 4f		 jl	 SHORT $L69572

; 686  :     {
; 687  :         DWORD dwBufferCount = m_ConnectHeader.dwBufferCount;

  00023	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00029	89 55 f8	 mov	 DWORD PTR _dwBufferCount$69573[ebp], edx

; 688  :         m_pguidBufferIDs = new GUID[dwBufferCount];

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _dwBufferCount$69573[ebp]
  0002f	c1 e0 04	 shl	 eax, 4
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00038	83 c4 04	 add	 esp, 4
  0003b	89 45 f4	 mov	 DWORD PTR $T71582[ebp], eax
  0003e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00041	8b 55 f4	 mov	 edx, DWORD PTR $T71582[ebp]
  00044	89 51 14	 mov	 DWORD PTR [ecx+20], edx

; 689  :         if (m_pguidBufferIDs )

  00047	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  0004e	74 1b		 je	 SHORT $L69576

; 690  :         {
; 691  :             hr = pParser->Read(m_pguidBufferIDs,sizeof(GUID)*dwBufferCount);

  00050	8b 4d f8	 mov	 ecx, DWORD PTR _dwBufferCount$69573[ebp]
  00053	c1 e1 04	 shl	 ecx, 4
  00056	51		 push	 ecx
  00057	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0005a	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0005d	50		 push	 eax
  0005e	8b 4d 08	 mov	 ecx, DWORD PTR _pParser$[ebp]
  00061	e8 00 00 00 00	 call	 ?Read@CRiffParser@@QAEJPAXK@Z ; CRiffParser::Read
  00066	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 692  :         }
; 693  :         else

  00069	eb 07		 jmp	 SHORT $L69572
$L69576:

; 694  :         {
; 695  :             hr = E_OUTOFMEMORY;

  0006b	c7 45 fc 0e 00
	07 80		 mov	 DWORD PTR _hr$[ebp], -2147024882 ; 8007000eH
$L69572:

; 696  :         }
; 697  :     }
; 698  :     return hr;

  00072	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]

; 699  : }

  00075	8b e5		 mov	 esp, ebp
  00077	5d		 pop	 ebp
  00078	c2 04 00	 ret	 4
?Load@CBufferConnect@@QAEJPAVCRiffParser@@@Z ENDP	; CBufferConnect::Load
_TEXT	ENDS
PUBLIC	?CreateRunTimeVersion@CBufferConnect@@QAEPAV1@PAVCPortConfig@@@Z ; CBufferConnect::CreateRunTimeVersion
PUBLIC	??_GCBufferConnect@@QAEPAXI@Z			; CBufferConnect::`scalar deleting destructor'
PUBLIC	?GetBufferNode@CPortConfig@@QAEPAVCBufferNode@@ABU_GUID@@@Z ; CPortConfig::GetBufferNode
; Function compile flags: /Odt
;	COMDAT ?CreateRunTimeVersion@CBufferConnect@@QAEPAV1@PAVCPortConfig@@@Z
_TEXT	SEGMENT
tv133 = -36
tv69 = -32
_this$ = -28
$T71591 = -24
$T71590 = -20
$T71589 = -16
$T71586 = -12
_dwIndex$69591 = -8
_pCopy$ = -4
_pParent$ = 8
?CreateRunTimeVersion@CBufferConnect@@QAEPAV1@PAVCPortConfig@@@Z PROC NEAR ; CBufferConnect::CreateRunTimeVersion, COMDAT
; _this$ = ecx

; 703  : { 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 704  :     CBufferConnect *pCopy = new CBufferConnect;

  00009	6a 1c		 push	 28			; 0000001cH
  0000b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00010	83 c4 04	 add	 esp, 4
  00013	89 45 f4	 mov	 DWORD PTR $T71586[ebp], eax
  00016	83 7d f4 00	 cmp	 DWORD PTR $T71586[ebp], 0
  0001a	74 0d		 je	 SHORT $L71587
  0001c	8b 4d f4	 mov	 ecx, DWORD PTR $T71586[ebp]
  0001f	e8 00 00 00 00	 call	 ??0CBufferConnect@@QAE@XZ ; CBufferConnect::CBufferConnect
  00024	89 45 e0	 mov	 DWORD PTR tv69[ebp], eax
  00027	eb 07		 jmp	 SHORT $L71588
$L71587:
  00029	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$L71588:
  00030	8b 45 e0	 mov	 eax, DWORD PTR tv69[ebp]
  00033	89 45 fc	 mov	 DWORD PTR _pCopy$[ebp], eax

; 705  :     if (pCopy && m_pguidBufferIDs)

  00036	83 7d fc 00	 cmp	 DWORD PTR _pCopy$[ebp], 0
  0003a	0f 84 c7 00 00
	00		 je	 $L69587
  00040	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	83 79 14 00	 cmp	 DWORD PTR [ecx+20], 0
  00047	0f 84 ba 00 00
	00		 je	 $L69587

; 706  :     {
; 707  :         pCopy->m_ConnectHeader = m_ConnectHeader;

  0004d	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  00050	83 c2 04	 add	 edx, 4
  00053	8b 45 fc	 mov	 eax, DWORD PTR _pCopy$[ebp]
  00056	83 c0 04	 add	 eax, 4
  00059	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0005b	89 08		 mov	 DWORD PTR [eax], ecx
  0005d	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00060	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00063	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  00066	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00069	8b 52 0c	 mov	 edx, DWORD PTR [edx+12]
  0006c	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 708  :         pCopy->m_ppBufferNodes = new CBufferNode *[m_ConnectHeader.dwBufferCount];

  0006f	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00072	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00075	c1 e1 02	 shl	 ecx, 2
  00078	51		 push	 ecx
  00079	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  0007e	83 c4 04	 add	 esp, 4
  00081	89 45 f0	 mov	 DWORD PTR $T71589[ebp], eax
  00084	8b 55 fc	 mov	 edx, DWORD PTR _pCopy$[ebp]
  00087	8b 45 f0	 mov	 eax, DWORD PTR $T71589[ebp]
  0008a	89 42 18	 mov	 DWORD PTR [edx+24], eax

; 709  :         if (pCopy->m_ppBufferNodes)

  0008d	8b 4d fc	 mov	 ecx, DWORD PTR _pCopy$[ebp]
  00090	83 79 18 00	 cmp	 DWORD PTR [ecx+24], 0
  00094	74 42		 je	 SHORT $L69590

; 710  :         {
; 711  :             for (DWORD dwIndex = 0; dwIndex < m_ConnectHeader.dwBufferCount; dwIndex++)

  00096	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _dwIndex$69591[ebp], 0
  0009d	eb 09		 jmp	 SHORT $L69592
$L69593:
  0009f	8b 55 f8	 mov	 edx, DWORD PTR _dwIndex$69591[ebp]
  000a2	83 c2 01	 add	 edx, 1
  000a5	89 55 f8	 mov	 DWORD PTR _dwIndex$69591[ebp], edx
$L69592:
  000a8	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  000ab	8b 4d f8	 mov	 ecx, DWORD PTR _dwIndex$69591[ebp]
  000ae	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  000b1	73 23		 jae	 SHORT $L69594

; 712  :             {
; 713  :                 pCopy->m_ppBufferNodes[dwIndex] = pParent->GetBufferNode(m_pguidBufferIDs[dwIndex]);

  000b3	8b 55 f8	 mov	 edx, DWORD PTR _dwIndex$69591[ebp]
  000b6	c1 e2 04	 shl	 edx, 4
  000b9	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  000bc	03 50 14	 add	 edx, DWORD PTR [eax+20]
  000bf	52		 push	 edx
  000c0	8b 4d 08	 mov	 ecx, DWORD PTR _pParent$[ebp]
  000c3	e8 00 00 00 00	 call	 ?GetBufferNode@CPortConfig@@QAEPAVCBufferNode@@ABU_GUID@@@Z ; CPortConfig::GetBufferNode
  000c8	8b 4d fc	 mov	 ecx, DWORD PTR _pCopy$[ebp]
  000cb	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  000ce	8b 4d f8	 mov	 ecx, DWORD PTR _dwIndex$69591[ebp]
  000d1	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax

; 714  :             }

  000d4	eb c9		 jmp	 SHORT $L69593
$L69594:

; 715  :         }
; 716  :         else

  000d6	eb 2f		 jmp	 SHORT $L69587
$L69590:

; 717  :         {
; 718  :             delete pCopy;

  000d8	8b 55 fc	 mov	 edx, DWORD PTR _pCopy$[ebp]
  000db	89 55 e8	 mov	 DWORD PTR $T71591[ebp], edx
  000de	8b 45 e8	 mov	 eax, DWORD PTR $T71591[ebp]
  000e1	89 45 ec	 mov	 DWORD PTR $T71590[ebp], eax
  000e4	83 7d ec 00	 cmp	 DWORD PTR $T71590[ebp], 0
  000e8	74 0f		 je	 SHORT $L71592
  000ea	6a 01		 push	 1
  000ec	8b 4d ec	 mov	 ecx, DWORD PTR $T71590[ebp]
  000ef	e8 00 00 00 00	 call	 ??_GCBufferConnect@@QAEPAXI@Z
  000f4	89 45 dc	 mov	 DWORD PTR tv133[ebp], eax
  000f7	eb 07		 jmp	 SHORT $L71593
$L71592:
  000f9	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR tv133[ebp], 0
$L71593:

; 719  :             pCopy = NULL;

  00100	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pCopy$[ebp], 0
$L69587:

; 720  :         }
; 721  :     }
; 722  :     return pCopy;

  00107	8b 45 fc	 mov	 eax, DWORD PTR _pCopy$[ebp]

; 723  : }

  0010a	8b e5		 mov	 esp, ebp
  0010c	5d		 pop	 ebp
  0010d	c2 04 00	 ret	 4
?CreateRunTimeVersion@CBufferConnect@@QAEPAV1@PAVCPortConfig@@@Z ENDP ; CBufferConnect::CreateRunTimeVersion
_TEXT	ENDS
PUBLIC	??1CBufferConnect@@QAE@XZ			; CBufferConnect::~CBufferConnect
; Function compile flags: /Odt
;	COMDAT ??_GCBufferConnect@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4
___flags$ = 8
??_GCBufferConnect@@QAEPAXI@Z PROC NEAR			; CBufferConnect::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CBufferConnect@@QAE@XZ ; CBufferConnect::~CBufferConnect
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $L69601
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$L69601:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GCBufferConnect@@QAEPAXI@Z ENDP			; CBufferConnect::`scalar deleting destructor'
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??1CBufferConnect@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
$T71601 = -12
$T71600 = -8
_dwIndex$69606 = -4
??1CBufferConnect@@QAE@XZ PROC NEAR			; CBufferConnect::~CBufferConnect, COMDAT
; _this$ = ecx

; 728  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 729  :     if (m_ppBufferNodes)

  00009	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 18 00	 cmp	 DWORD PTR [eax+24], 0
  00010	74 54		 je	 SHORT $L69605

; 730  :     {
; 731  :         for (DWORD dwIndex = 0; dwIndex < m_ConnectHeader.dwBufferCount; dwIndex++)

  00012	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _dwIndex$69606[ebp], 0
  00019	eb 09		 jmp	 SHORT $L69607
$L69608:
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _dwIndex$69606[ebp]
  0001e	83 c1 01	 add	 ecx, 1
  00021	89 4d fc	 mov	 DWORD PTR _dwIndex$69606[ebp], ecx
$L69607:
  00024	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00027	8b 45 fc	 mov	 eax, DWORD PTR _dwIndex$69606[ebp]
  0002a	3b 42 0c	 cmp	 eax, DWORD PTR [edx+12]
  0002d	73 22		 jae	 SHORT $L69609

; 732  :         {
; 733  :             if (m_ppBufferNodes[dwIndex]) m_ppBufferNodes[dwIndex]->Release();

  0002f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00035	8b 45 fc	 mov	 eax, DWORD PTR _dwIndex$69606[ebp]
  00038	83 3c 82 00	 cmp	 DWORD PTR [edx+eax*4], 0
  0003c	74 11		 je	 SHORT $L69610
  0003e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00041	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00044	8b 45 fc	 mov	 eax, DWORD PTR _dwIndex$69606[ebp]
  00047	8b 0c 82	 mov	 ecx, DWORD PTR [edx+eax*4]
  0004a	e8 00 00 00 00	 call	 ?Release@CBufferNode@@QAEKXZ ; CBufferNode::Release
$L69610:

; 734  :         }

  0004f	eb ca		 jmp	 SHORT $L69608
$L69609:

; 735  :         delete [] m_ppBufferNodes;

  00051	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00057	89 55 f8	 mov	 DWORD PTR $T71600[ebp], edx
  0005a	8b 45 f8	 mov	 eax, DWORD PTR $T71600[ebp]
  0005d	50		 push	 eax
  0005e	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00063	83 c4 04	 add	 esp, 4
$L69605:

; 736  :     }
; 737  :     if (m_pguidBufferIDs)

  00066	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00069	83 79 14 00	 cmp	 DWORD PTR [ecx+20], 0
  0006d	74 15		 je	 SHORT $L69604

; 738  :     {
; 739  :         delete [] m_pguidBufferIDs;

  0006f	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00072	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00075	89 45 f4	 mov	 DWORD PTR $T71601[ebp], eax
  00078	8b 4d f4	 mov	 ecx, DWORD PTR $T71601[ebp]
  0007b	51		 push	 ecx
  0007c	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00081	83 c4 04	 add	 esp, 4
$L69604:

; 740  :     }
; 741  : }

  00084	8b e5		 mov	 esp, ebp
  00086	5d		 pop	 ebp
  00087	c3		 ret	 0
??1CBufferConnect@@QAE@XZ ENDP				; CBufferConnect::~CBufferConnect
_TEXT	ENDS
PUBLIC	?GetNext@CBufferConnect@@QAEPAV1@XZ		; CBufferConnect::GetNext
PUBLIC	?GetHead@CBufferConnectList@@QAEPAVCBufferConnect@@XZ ; CBufferConnectList::GetHead
PUBLIC	?AddTail@CBufferConnectList@@QAEXPAVCBufferConnect@@@Z ; CBufferConnectList::AddTail
PUBLIC	?CreateRunTimeVersion@CBufferConnectList@@QAEJPAV1@PAVCPortConfig@@@Z ; CBufferConnectList::CreateRunTimeVersion
; Function compile flags: /Odt
;	COMDAT ?CreateRunTimeVersion@CBufferConnectList@@QAEJPAV1@PAVCPortConfig@@@Z
_TEXT	SEGMENT
_this$ = -12
_pScan$ = -8
_pCopy$ = -4
_pDestination$ = 8
_pParent$ = 12
?CreateRunTimeVersion@CBufferConnectList@@QAEJPAV1@PAVCPortConfig@@@Z PROC NEAR ; CBufferConnectList::CreateRunTimeVersion, COMDAT
; _this$ = ecx

; 745  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 746  :     CBufferConnect *pScan = GetHead();

  00009	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?GetHead@CBufferConnectList@@QAEPAVCBufferConnect@@XZ ; CBufferConnectList::GetHead
  00011	89 45 f8	 mov	 DWORD PTR _pScan$[ebp], eax

; 747  :     CBufferConnect *pCopy;
; 748  :     for (;pScan;pScan = pScan->GetNext())

  00014	eb 0b		 jmp	 SHORT $L69621
$L69622:
  00016	8b 4d f8	 mov	 ecx, DWORD PTR _pScan$[ebp]
  00019	e8 00 00 00 00	 call	 ?GetNext@CBufferConnect@@QAEPAV1@XZ ; CBufferConnect::GetNext
  0001e	89 45 f8	 mov	 DWORD PTR _pScan$[ebp], eax
$L69621:
  00021	83 7d f8 00	 cmp	 DWORD PTR _pScan$[ebp], 0
  00025	74 2c		 je	 SHORT $L69623

; 749  :     {
; 750  :         pCopy = pScan->CreateRunTimeVersion(pParent);

  00027	8b 45 0c	 mov	 eax, DWORD PTR _pParent$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d f8	 mov	 ecx, DWORD PTR _pScan$[ebp]
  0002e	e8 00 00 00 00	 call	 ?CreateRunTimeVersion@CBufferConnect@@QAEPAV1@PAVCPortConfig@@@Z ; CBufferConnect::CreateRunTimeVersion
  00033	89 45 fc	 mov	 DWORD PTR _pCopy$[ebp], eax

; 751  :         if (pCopy)

  00036	83 7d fc 00	 cmp	 DWORD PTR _pCopy$[ebp], 0
  0003a	74 0e		 je	 SHORT $L69624

; 752  :         {
; 753  :             pDestination->AddTail(pCopy);

  0003c	8b 4d fc	 mov	 ecx, DWORD PTR _pCopy$[ebp]
  0003f	51		 push	 ecx
  00040	8b 4d 08	 mov	 ecx, DWORD PTR _pDestination$[ebp]
  00043	e8 00 00 00 00	 call	 ?AddTail@CBufferConnectList@@QAEXPAVCBufferConnect@@@Z ; CBufferConnectList::AddTail

; 754  :         }
; 755  :         else

  00048	eb 07		 jmp	 SHORT $L69625
$L69624:

; 756  :         {
; 757  :             return E_OUTOFMEMORY;

  0004a	b8 0e 00 07 80	 mov	 eax, -2147024882	; 8007000eH
  0004f	eb 04		 jmp	 SHORT $L69618
$L69625:

; 758  :         }
; 759  :     }

  00051	eb c3		 jmp	 SHORT $L69622
$L69623:

; 760  :     return S_OK;

  00053	33 c0		 xor	 eax, eax
$L69618:

; 761  : }

  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c2 08 00	 ret	 8
?CreateRunTimeVersion@CBufferConnectList@@QAEJPAV1@PAVCPortConfig@@@Z ENDP ; CBufferConnectList::CreateRunTimeVersion
_TEXT	ENDS
PUBLIC	?RemoveHead@CBufferConnectList@@QAEPAVCBufferConnect@@XZ ; CBufferConnectList::RemoveHead
PUBLIC	?Clear@CBufferConnectList@@QAEXXZ		; CBufferConnectList::Clear
; Function compile flags: /Odt
;	COMDAT ?Clear@CBufferConnectList@@QAEXXZ
_TEXT	SEGMENT
tv71 = -20
_this$ = -16
$T71609 = -12
$T71608 = -8
_pBuffer$ = -4
?Clear@CBufferConnectList@@QAEXXZ PROC NEAR		; CBufferConnectList::Clear, COMDAT
; _this$ = ecx

; 765  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
$L69633:

; 766  :     CBufferConnect *pBuffer;
; 767  :     while (pBuffer = RemoveHead())

  00009	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?RemoveHead@CBufferConnectList@@QAEPAVCBufferConnect@@XZ ; CBufferConnectList::RemoveHead
  00011	89 45 fc	 mov	 DWORD PTR _pBuffer$[ebp], eax
  00014	83 7d fc 00	 cmp	 DWORD PTR _pBuffer$[ebp], 0
  00018	74 2a		 je	 SHORT $L69630

; 768  :     {
; 769  :         delete pBuffer;

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _pBuffer$[ebp]
  0001d	89 45 f4	 mov	 DWORD PTR $T71609[ebp], eax
  00020	8b 4d f4	 mov	 ecx, DWORD PTR $T71609[ebp]
  00023	89 4d f8	 mov	 DWORD PTR $T71608[ebp], ecx
  00026	83 7d f8 00	 cmp	 DWORD PTR $T71608[ebp], 0
  0002a	74 0f		 je	 SHORT $L71610
  0002c	6a 01		 push	 1
  0002e	8b 4d f8	 mov	 ecx, DWORD PTR $T71608[ebp]
  00031	e8 00 00 00 00	 call	 ??_GCBufferConnect@@QAEPAXI@Z
  00036	89 45 ec	 mov	 DWORD PTR tv71[ebp], eax
  00039	eb 07		 jmp	 SHORT $L71611
$L71610:
  0003b	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
$L71611:

; 770  :     }

  00042	eb c5		 jmp	 SHORT $L69633
$L69630:

; 771  : }

  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
?Clear@CBufferConnectList@@QAEXXZ ENDP			; CBufferConnectList::Clear
_TEXT	ENDS
PUBLIC	?Activate@CBufferConfig@@QAEJH@Z		; CBufferConfig::Activate
; Function compile flags: /Odt
;	COMDAT ?Activate@CBufferConfig@@QAEJH@Z
_TEXT	SEGMENT
_this$ = -4
_fActivate$ = 8
?Activate@CBufferConfig@@QAEJH@Z PROC NEAR		; CBufferConfig::Activate, COMDAT
; _this$ = ecx

; 775  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 776  :     if (m_pBufferNode)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  0000e	74 11		 je	 SHORT $L69641

; 777  :     {
; 778  :         return m_pBufferNode->Activate(fActivate);

  00010	8b 4d 08	 mov	 ecx, DWORD PTR _fActivate$[ebp]
  00013	51		 push	 ecx
  00014	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00017	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  0001a	e8 00 00 00 00	 call	 ?Activate@CBufferNode@@QAEJH@Z ; CBufferNode::Activate
  0001f	eb 02		 jmp	 SHORT $L69640
$L69641:

; 779  :     }
; 780  :     return S_OK;

  00021	33 c0		 xor	 eax, eax
$L69640:

; 781  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
?Activate@CBufferConfig@@QAEJH@Z ENDP			; CBufferConfig::Activate
_TEXT	ENDS
PUBLIC	__GUID_00000000_0000_0000_0000_000000000000
EXTRN	_GUID_Buffer_Reverb:BYTE
EXTRN	_GUID_Buffer_EnvReverb:BYTE
EXTRN	_GUID_Buffer_Stereo:BYTE
EXTRN	_GUID_Buffer_3D_Dry:BYTE
EXTRN	_GUID_Buffer_Mono:BYTE
EXTRN	_GUID_Buffer_3D:BYTE
EXTRN	_GUID_Buffer_Chorus:BYTE
EXTRN	_GUID_Buffer_MixBins:BYTE
;	COMDAT __GUID_00000000_0000_0000_0000_000000000000
CONST	SEGMENT
__GUID_00000000_0000_0000_0000_000000000000 DD 00H
	DW	00H
	DW	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ??0CBufferConfig@@QAE@K@Z
_TEXT	SEGMENT
tv74 = -8
_this$ = -4
_dwType$ = 8
??0CBufferConfig@@QAE@K@Z PROC NEAR			; CBufferConfig::CBufferConfig, COMDAT
; _this$ = ecx

; 785  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0AListItem@@QAE@XZ	; AListItem::AListItem

; 786  :     m_pBufferNode = NULL;

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 787  :     m_BufferHeader.guidBufferID = GUID_NULL;

  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00021	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __GUID_00000000_0000_0000_0000_000000000000
  00027	89 11		 mov	 DWORD PTR [ecx], edx
  00029	a1 04 00 00 00	 mov	 eax, DWORD PTR __GUID_00000000_0000_0000_0000_000000000000+4
  0002e	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00031	8b 15 08 00 00
	00		 mov	 edx, DWORD PTR __GUID_00000000_0000_0000_0000_000000000000+8
  00037	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  0003a	a1 0c 00 00 00	 mov	 eax, DWORD PTR __GUID_00000000_0000_0000_0000_000000000000+12
  0003f	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 788  :     m_BufferHeader.dwFlags = DMUS_BUFFERF_DEFINED;

  00042	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	c7 41 1c 02 00
	00 00		 mov	 DWORD PTR [ecx+28], 2

; 789  :     m_dwStandardBufferID = dwType;

  0004c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0004f	8b 45 08	 mov	 eax, DWORD PTR _dwType$[ebp]
  00052	89 42 20	 mov	 DWORD PTR [edx+32], eax

; 790  : #ifdef XBOX
; 791  :     m_MixBinsHeader.bControllers[0] = 0;

  00055	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00058	c6 41 28 00	 mov	 BYTE PTR [ecx+40], 0

; 792  : #endif
; 793  :     switch (dwType)
; 794  :     {

  0005c	8b 55 08	 mov	 edx, DWORD PTR _dwType$[ebp]
  0005f	89 55 f8	 mov	 DWORD PTR tv74[ebp], edx
  00062	8b 45 f8	 mov	 eax, DWORD PTR tv74[ebp]
  00065	83 e8 01	 sub	 eax, 1
  00068	89 45 f8	 mov	 DWORD PTR tv74[ebp], eax
  0006b	83 7d f8 09	 cmp	 DWORD PTR tv74[ebp], 9
  0006f	0f 87 b9 01 00
	00		 ja	 $L69661
  00075	8b 4d f8	 mov	 ecx, DWORD PTR tv74[ebp]
  00078	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $L71618[ecx*4]
$L69652:

; 795  :     case BUFFER_REVERB :
; 796  :         m_BufferHeader.guidBufferID = GUID_Buffer_Reverb;

  0007f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00082	83 c2 0c	 add	 edx, 12			; 0000000cH
  00085	a1 00 00 00 00	 mov	 eax, DWORD PTR _GUID_Buffer_Reverb
  0008a	89 02		 mov	 DWORD PTR [edx], eax
  0008c	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR _GUID_Buffer_Reverb+4
  00092	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00095	a1 08 00 00 00	 mov	 eax, DWORD PTR _GUID_Buffer_Reverb+8
  0009a	89 42 08	 mov	 DWORD PTR [edx+8], eax
  0009d	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _GUID_Buffer_Reverb+12
  000a3	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 797  :         m_BufferHeader.dwFlags = DMUS_BUFFERF_SHARED | DMUS_BUFFERF_DEFINED;

  000a6	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000a9	c7 42 1c 03 00
	00 00		 mov	 DWORD PTR [edx+28], 3

; 798  :         break;

  000b0	e9 83 01 00 00	 jmp	 $L69649
$L69653:

; 799  :     case BUFFER_ENVREVERB :
; 800  :         m_BufferHeader.guidBufferID = GUID_Buffer_EnvReverb;

  000b5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000b8	83 c0 0c	 add	 eax, 12			; 0000000cH
  000bb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _GUID_Buffer_EnvReverb
  000c1	89 08		 mov	 DWORD PTR [eax], ecx
  000c3	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR _GUID_Buffer_EnvReverb+4
  000c9	89 50 04	 mov	 DWORD PTR [eax+4], edx
  000cc	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR _GUID_Buffer_EnvReverb+8
  000d2	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  000d5	8b 15 0c 00 00
	00		 mov	 edx, DWORD PTR _GUID_Buffer_EnvReverb+12
  000db	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 801  :         m_BufferHeader.dwFlags = DMUS_BUFFERF_SHARED | DMUS_BUFFERF_DEFINED | DMUS_BUFFERF_MIXIN;

  000de	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000e1	c7 40 1c 0b 00
	00 00		 mov	 DWORD PTR [eax+28], 11	; 0000000bH

; 802  :         break;

  000e8	e9 4b 01 00 00	 jmp	 $L69649
$L69654:

; 803  :     case BUFFER_3D_DRY :
; 804  :         m_BufferHeader.guidBufferID = GUID_Buffer_3D_Dry;

  000ed	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000f0	83 c1 0c	 add	 ecx, 12			; 0000000cH
  000f3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _GUID_Buffer_3D_Dry
  000f9	89 11		 mov	 DWORD PTR [ecx], edx
  000fb	a1 04 00 00 00	 mov	 eax, DWORD PTR _GUID_Buffer_3D_Dry+4
  00100	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00103	8b 15 08 00 00
	00		 mov	 edx, DWORD PTR _GUID_Buffer_3D_Dry+8
  00109	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  0010c	a1 0c 00 00 00	 mov	 eax, DWORD PTR _GUID_Buffer_3D_Dry+12
  00111	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 805  :         break;

  00114	e9 1f 01 00 00	 jmp	 $L69649
$L69655:

; 806  :     case BUFFER_MONO :
; 807  :         m_BufferHeader.guidBufferID = GUID_Buffer_Mono;

  00119	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0011c	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0011f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _GUID_Buffer_Mono
  00125	89 11		 mov	 DWORD PTR [ecx], edx
  00127	a1 04 00 00 00	 mov	 eax, DWORD PTR _GUID_Buffer_Mono+4
  0012c	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0012f	8b 15 08 00 00
	00		 mov	 edx, DWORD PTR _GUID_Buffer_Mono+8
  00135	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00138	a1 0c 00 00 00	 mov	 eax, DWORD PTR _GUID_Buffer_Mono+12
  0013d	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 808  :         break;

  00140	e9 f3 00 00 00	 jmp	 $L69649
$L69656:

; 809  :     case BUFFER_STEREO :
; 810  :         m_BufferHeader.guidBufferID = GUID_Buffer_Stereo;

  00145	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00148	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0014b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _GUID_Buffer_Stereo
  00151	89 11		 mov	 DWORD PTR [ecx], edx
  00153	a1 04 00 00 00	 mov	 eax, DWORD PTR _GUID_Buffer_Stereo+4
  00158	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0015b	8b 15 08 00 00
	00		 mov	 edx, DWORD PTR _GUID_Buffer_Stereo+8
  00161	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00164	a1 0c 00 00 00	 mov	 eax, DWORD PTR _GUID_Buffer_Stereo+12
  00169	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 811  :         break;

  0016c	e9 c7 00 00 00	 jmp	 $L69649
$L69657:

; 812  :     case BUFFER_MUSIC :
; 813  :         m_BufferHeader.guidBufferID = GUID_Buffer_Stereo;

  00171	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00174	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00177	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _GUID_Buffer_Stereo
  0017d	89 11		 mov	 DWORD PTR [ecx], edx
  0017f	a1 04 00 00 00	 mov	 eax, DWORD PTR _GUID_Buffer_Stereo+4
  00184	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00187	8b 15 08 00 00
	00		 mov	 edx, DWORD PTR _GUID_Buffer_Stereo+8
  0018d	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00190	a1 0c 00 00 00	 mov	 eax, DWORD PTR _GUID_Buffer_Stereo+12
  00195	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 814  :         m_BufferHeader.dwFlags = DMUS_BUFFERF_SHARED | DMUS_BUFFERF_DEFINED;

  00198	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0019b	c7 41 1c 03 00
	00 00		 mov	 DWORD PTR [ecx+28], 3

; 815  :         break;

  001a2	e9 91 00 00 00	 jmp	 $L69649
$L69658:

; 816  : #ifndef DXAPI
; 817  :     case BUFFER_3D :
; 818  :         m_BufferHeader.guidBufferID = GUID_Buffer_3D;

  001a7	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  001aa	83 c2 0c	 add	 edx, 12			; 0000000cH
  001ad	a1 00 00 00 00	 mov	 eax, DWORD PTR _GUID_Buffer_3D
  001b2	89 02		 mov	 DWORD PTR [edx], eax
  001b4	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR _GUID_Buffer_3D+4
  001ba	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  001bd	a1 08 00 00 00	 mov	 eax, DWORD PTR _GUID_Buffer_3D+8
  001c2	89 42 08	 mov	 DWORD PTR [edx+8], eax
  001c5	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _GUID_Buffer_3D+12
  001cb	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 819  :         break;

  001ce	eb 68		 jmp	 SHORT $L69649
$L69659:

; 820  :     case BUFFER_CHORUS :
; 821  :         m_BufferHeader.guidBufferID = GUID_Buffer_Chorus;

  001d0	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  001d3	83 c2 0c	 add	 edx, 12			; 0000000cH
  001d6	a1 00 00 00 00	 mov	 eax, DWORD PTR _GUID_Buffer_Chorus
  001db	89 02		 mov	 DWORD PTR [edx], eax
  001dd	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR _GUID_Buffer_Chorus+4
  001e3	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  001e6	a1 08 00 00 00	 mov	 eax, DWORD PTR _GUID_Buffer_Chorus+8
  001eb	89 42 08	 mov	 DWORD PTR [edx+8], eax
  001ee	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _GUID_Buffer_Chorus+12
  001f4	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 822  :         m_BufferHeader.dwFlags = DMUS_BUFFERF_SHARED | DMUS_BUFFERF_DEFINED;

  001f7	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  001fa	c7 42 1c 03 00
	00 00		 mov	 DWORD PTR [edx+28], 3

; 823  :         break;

  00201	eb 35		 jmp	 SHORT $L69649
$L69660:

; 824  :     case BUFFER_MIXBINS :
; 825  :         m_BufferHeader.guidBufferID = GUID_Buffer_MixBins;

  00203	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00206	83 c0 0c	 add	 eax, 12			; 0000000cH
  00209	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _GUID_Buffer_MixBins
  0020f	89 08		 mov	 DWORD PTR [eax], ecx
  00211	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR _GUID_Buffer_MixBins+4
  00217	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0021a	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR _GUID_Buffer_MixBins+8
  00220	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00223	8b 15 0c 00 00
	00		 mov	 edx, DWORD PTR _GUID_Buffer_MixBins+12
  00229	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 826  :         break;

  0022c	eb 0a		 jmp	 SHORT $L69649
$L69661:

; 827  : #endif
; 828  :     default:
; 829  :         m_BufferHeader.dwFlags = 0;

  0022e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00231	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0
$L69649:

; 830  :         break;
; 831  :     }
; 832  :     m_pBufferConfig = NULL;

  00238	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0023b	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 833  : }

  00242	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00245	8b e5		 mov	 esp, ebp
  00247	5d		 pop	 ebp
  00248	c2 04 00	 ret	 4
$L71618:
  0024b	00 00 00 00	 DD	 $L69652
  0024f	00 00 00 00	 DD	 $L69653
  00253	00 00 00 00	 DD	 $L69658
  00257	00 00 00 00	 DD	 $L69654
  0025b	00 00 00 00	 DD	 $L69661
  0025f	00 00 00 00	 DD	 $L69655
  00263	00 00 00 00	 DD	 $L69656
  00267	00 00 00 00	 DD	 $L69657
  0026b	00 00 00 00	 DD	 $L69659
  0026f	00 00 00 00	 DD	 $L69660
??0CBufferConfig@@QAE@K@Z ENDP				; CBufferConfig::CBufferConfig
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??1CBufferConfig@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1CBufferConfig@@QAE@XZ PROC NEAR			; CBufferConfig::~CBufferConfig, COMDAT
; _this$ = ecx

; 837  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 838  :     if (m_pBufferNode)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  0000e	74 0b		 je	 SHORT $L69665

; 839  :         m_pBufferNode->Release();

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00016	e8 00 00 00 00	 call	 ?Release@CBufferNode@@QAEKXZ ; CBufferNode::Release
$L69665:

; 840  :     if (m_pBufferConfig)

  0001b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001e	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  00022	74 12		 je	 SHORT $L69664

; 841  :         m_pBufferConfig->Release();

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0002a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0002d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00030	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00032	50		 push	 eax
  00033	ff 51 08	 call	 DWORD PTR [ecx+8]
$L69664:

; 842  : }

  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
??1CBufferConfig@@QAE@XZ ENDP				; CBufferConfig::~CBufferConfig
_TEXT	ENDS
PUBLIC	?DecideType@CBufferConfig@@QAEXXZ		; CBufferConfig::DecideType
; Function compile flags: /Odt
;	COMDAT ?DecideType@CBufferConfig@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?DecideType@CBufferConfig@@QAEXXZ PROC NEAR		; CBufferConfig::DecideType, COMDAT
; _this$ = ecx

; 846  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 847  :     if (m_BufferHeader.guidBufferID == GUID_Buffer_Reverb)

  00007	68 00 00 00 00	 push	 OFFSET FLAT:_GUID_Buffer_Reverb
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 _==@8
  00018	85 c0		 test	 eax, eax
  0001a	74 0f		 je	 SHORT $L69670

; 848  :     {
; 849  :         m_dwStandardBufferID = BUFFER_REVERB;

  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	c7 41 20 01 00
	00 00		 mov	 DWORD PTR [ecx+32], 1

; 850  :     }
; 851  :     else if (m_BufferHeader.guidBufferID == GUID_Buffer_EnvReverb)

  00026	e9 ee 00 00 00	 jmp	 $L69669
$L69670:
  0002b	68 00 00 00 00	 push	 OFFSET FLAT:_GUID_Buffer_EnvReverb
  00030	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00033	83 c2 0c	 add	 edx, 12			; 0000000cH
  00036	52		 push	 edx
  00037	e8 00 00 00 00	 call	 _==@8
  0003c	85 c0		 test	 eax, eax
  0003e	74 0f		 je	 SHORT $L69672

; 852  :     {
; 853  :         m_dwStandardBufferID = BUFFER_ENVREVERB;

  00040	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00043	c7 40 20 02 00
	00 00		 mov	 DWORD PTR [eax+32], 2

; 854  :     }
; 855  : #ifndef DXAPI
; 856  :     else if (m_BufferHeader.guidBufferID == GUID_Buffer_3D)

  0004a	e9 ca 00 00 00	 jmp	 $L69669
$L69672:
  0004f	68 00 00 00 00	 push	 OFFSET FLAT:_GUID_Buffer_3D
  00054	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00057	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0005a	51		 push	 ecx
  0005b	e8 00 00 00 00	 call	 _==@8
  00060	85 c0		 test	 eax, eax
  00062	74 0f		 je	 SHORT $L69674

; 857  :     {
; 858  :         m_dwStandardBufferID = BUFFER_3D;

  00064	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00067	c7 42 20 03 00
	00 00		 mov	 DWORD PTR [edx+32], 3

; 859  :     }
; 860  :     else if (m_BufferHeader.guidBufferID == GUID_Buffer_Chorus)

  0006e	e9 a6 00 00 00	 jmp	 $L69669
$L69674:
  00073	68 00 00 00 00	 push	 OFFSET FLAT:_GUID_Buffer_Chorus
  00078	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0007b	83 c0 0c	 add	 eax, 12			; 0000000cH
  0007e	50		 push	 eax
  0007f	e8 00 00 00 00	 call	 _==@8
  00084	85 c0		 test	 eax, eax
  00086	74 0f		 je	 SHORT $L69676

; 861  :     {
; 862  :         m_dwStandardBufferID = BUFFER_CHORUS;

  00088	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0008b	c7 41 20 09 00
	00 00		 mov	 DWORD PTR [ecx+32], 9

; 863  :     }
; 864  : #endif
; 865  :     else if (m_BufferHeader.guidBufferID == GUID_Buffer_3D_Dry)

  00092	e9 82 00 00 00	 jmp	 $L69669
$L69676:
  00097	68 00 00 00 00	 push	 OFFSET FLAT:_GUID_Buffer_3D_Dry
  0009c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0009f	83 c2 0c	 add	 edx, 12			; 0000000cH
  000a2	52		 push	 edx
  000a3	e8 00 00 00 00	 call	 _==@8
  000a8	85 c0		 test	 eax, eax
  000aa	74 0c		 je	 SHORT $L69678

; 866  :     {
; 867  :         m_dwStandardBufferID = BUFFER_3D_DRY;

  000ac	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000af	c7 40 20 04 00
	00 00		 mov	 DWORD PTR [eax+32], 4

; 868  :     }
; 869  :     else if (m_BufferHeader.guidBufferID == GUID_Buffer_Mono)

  000b6	eb 61		 jmp	 SHORT $L69669
$L69678:
  000b8	68 00 00 00 00	 push	 OFFSET FLAT:_GUID_Buffer_Mono
  000bd	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c0	83 c1 0c	 add	 ecx, 12			; 0000000cH
  000c3	51		 push	 ecx
  000c4	e8 00 00 00 00	 call	 _==@8
  000c9	85 c0		 test	 eax, eax
  000cb	74 0c		 je	 SHORT $L69680

; 870  :     {
; 871  :         m_dwStandardBufferID = BUFFER_MONO;

  000cd	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000d0	c7 42 20 06 00
	00 00		 mov	 DWORD PTR [edx+32], 6

; 872  :     }
; 873  :     else if (m_BufferHeader.guidBufferID == GUID_Buffer_Stereo)

  000d7	eb 40		 jmp	 SHORT $L69669
$L69680:
  000d9	68 00 00 00 00	 push	 OFFSET FLAT:_GUID_Buffer_Stereo
  000de	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000e1	83 c0 0c	 add	 eax, 12			; 0000000cH
  000e4	50		 push	 eax
  000e5	e8 00 00 00 00	 call	 _==@8
  000ea	85 c0		 test	 eax, eax
  000ec	74 0c		 je	 SHORT $L69682

; 874  :     {
; 875  :         m_dwStandardBufferID = BUFFER_STEREO;

  000ee	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000f1	c7 41 20 07 00
	00 00		 mov	 DWORD PTR [ecx+32], 7

; 876  :     }
; 877  : #ifdef XBOX
; 878  :     else if (m_BufferHeader.guidBufferID == GUID_Buffer_MixBins)

  000f8	eb 1f		 jmp	 SHORT $L69669
$L69682:
  000fa	68 00 00 00 00	 push	 OFFSET FLAT:_GUID_Buffer_MixBins
  000ff	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00102	83 c2 0c	 add	 edx, 12			; 0000000cH
  00105	52		 push	 edx
  00106	e8 00 00 00 00	 call	 _==@8
  0010b	85 c0		 test	 eax, eax
  0010d	74 0a		 je	 SHORT $L69669

; 879  :     {
; 880  :         m_dwStandardBufferID = BUFFER_MIXBINS;

  0010f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00112	c7 40 20 0a 00
	00 00		 mov	 DWORD PTR [eax+32], 10	; 0000000aH
$L69669:

; 881  :     }
; 882  : #endif
; 883  : }

  00119	8b e5		 mov	 esp, ebp
  0011b	5d		 pop	 ebp
  0011c	c3		 ret	 0
?DecideType@CBufferConfig@@QAEXXZ ENDP			; CBufferConfig::DecideType
_TEXT	ENDS
PUBLIC	??_C@_0HM@FFONCBGO@Error?3?5Attempt?5to?5load?5an?5effect@ ; `string'
PUBLIC	?Load@CBufferConfig@@QAEJPAUIStream@@@Z		; CBufferConfig::Load
;	COMDAT ??_C@_0HM@FFONCBGO@Error?3?5Attempt?5to?5load?5an?5effect@
CONST	SEGMENT
??_C@_0HM@FFONCBGO@Error?3?5Attempt?5to?5load?5an?5effect@ DB 'Error: Att'
	DB	'empt to load an effects configuration within an AudioPath. XB'
	DB	'OX does not support these yet. File load will fail.', 0aH, 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?Load@CBufferConfig@@QAEJPAUIStream@@@Z
_TEXT	SEGMENT
_this$ = -4
_pStream$ = 8
?Load@CBufferConfig@@QAEJPAUIStream@@@Z PROC NEAR	; CBufferConfig::Load, COMDAT
; _this$ = ecx

; 889  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 890  : #ifndef XBOX
; 891  :     IPersistStream *pPersist;
; 892  :     HRESULT hr = DirectMusicCreateInstance( CLSID_DirectSoundBufferConfig,
; 893  :         NULL, IID_IPersistStream,
; 894  :         (void**)&pPersist );
; 895  :     if (SUCCEEDED(hr))
; 896  :     {
; 897  :         hr = pPersist->Load(pStream);
; 898  :         if (SUCCEEDED(hr))
; 899  :         {
; 900  :             m_pBufferConfig = pPersist;
; 901  :             IDirectMusicObject *pObject;
; 902  :             hr = pPersist->QueryInterface(IID_IDirectMusicObject,(void **) &pObject);
; 903  :             if (SUCCEEDED(hr))
; 904  :             {
; 905  :                 DMUS_OBJECTDESC Desc;
; 906  :                 Desc.dwSize = sizeof(Desc);
; 907  :                 pObject->GetDescriptor(&Desc);
; 908  :                 if (Desc.dwValidData & DMUS_OBJ_OBJECT)
; 909  :                 {
; 910  :                     m_BufferHeader.guidBufferID = Desc.guidObject;
; 911  :                 }
; 912  :                 else
; 913  :                 {
; 914  :                     Trace(1,"Error: Unable to load Buffer Configuration in AudioPath Config - Missing buffer GUID in file.\n");
; 915  :                     hr = E_FAIL;
; 916  :                 }
; 917  :                 pObject->Release();
; 918  :             }
; 919  :         }
; 920  :         else
; 921  :         {
; 922  :             pPersist->Release();
; 923  :         }
; 924  :     }
; 925  :     return hr;
; 926  : #else // XBOX
; 927  :     Trace(1,"Error: Attempt to load an effects configuration within an AudioPath. XBOX does not support these yet. File load will fail.\n");

  00007	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0HM@FFONCBGO@Error?3?5Attempt?5to?5load?5an?5effect@
  0000c	6a 01		 push	 1
  0000e	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00013	83 c4 08	 add	 esp, 8

; 928  : 	return E_FAIL;

  00016	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H

; 929  : #endif
; 930  : }

  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?Load@CBufferConfig@@QAEJPAUIStream@@@Z ENDP		; CBufferConfig::Load
_TEXT	ENDS
PUBLIC	?RemoveHead@CBufferConfigList@@QAEPAVCBufferConfig@@XZ ; CBufferConfigList::RemoveHead
PUBLIC	?Clear@CBufferConfigList@@QAEXXZ		; CBufferConfigList::Clear
; Function compile flags: /Odt
;	COMDAT ?Clear@CBufferConfigList@@QAEXXZ
_TEXT	SEGMENT
tv71 = -20
_this$ = -16
$T71632 = -12
$T71631 = -8
_pBuffer$ = -4
?Clear@CBufferConfigList@@QAEXXZ PROC NEAR		; CBufferConfigList::Clear, COMDAT
; _this$ = ecx

; 934  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
$L69696:

; 935  :     CBufferConfig *pBuffer;
; 936  :     while (pBuffer = RemoveHead())

  00009	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?RemoveHead@CBufferConfigList@@QAEPAVCBufferConfig@@XZ ; CBufferConfigList::RemoveHead
  00011	89 45 fc	 mov	 DWORD PTR _pBuffer$[ebp], eax
  00014	83 7d fc 00	 cmp	 DWORD PTR _pBuffer$[ebp], 0
  00018	74 2a		 je	 SHORT $L69693

; 937  :     {
; 938  :         delete pBuffer;

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _pBuffer$[ebp]
  0001d	89 45 f4	 mov	 DWORD PTR $T71632[ebp], eax
  00020	8b 4d f4	 mov	 ecx, DWORD PTR $T71632[ebp]
  00023	89 4d f8	 mov	 DWORD PTR $T71631[ebp], ecx
  00026	83 7d f8 00	 cmp	 DWORD PTR $T71631[ebp], 0
  0002a	74 0f		 je	 SHORT $L71633
  0002c	6a 01		 push	 1
  0002e	8b 4d f8	 mov	 ecx, DWORD PTR $T71631[ebp]
  00031	e8 00 00 00 00	 call	 ??_GCBufferConfig@@QAEPAXI@Z
  00036	89 45 ec	 mov	 DWORD PTR tv71[ebp], eax
  00039	eb 07		 jmp	 SHORT $L71634
$L71633:
  0003b	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
$L71634:

; 939  :     }

  00042	eb c5		 jmp	 SHORT $L69696
$L69693:

; 940  : }

  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
?Clear@CBufferConfigList@@QAEXXZ ENDP			; CBufferConfigList::Clear
_TEXT	ENDS
PUBLIC	?GetNext@CBufferConfig@@QAEPAV1@XZ		; CBufferConfig::GetNext
PUBLIC	?GetHead@CBufferConfigList@@QAEPAVCBufferConfig@@XZ ; CBufferConfigList::GetHead
PUBLIC	?GetBufferNode@CBufferConfigList@@QAEPAVCBufferNode@@ABU_GUID@@@Z ; CBufferConfigList::GetBufferNode
; Function compile flags: /Odt
;	COMDAT ?GetBufferNode@CBufferConfigList@@QAEPAVCBufferNode@@ABU_GUID@@@Z
_TEXT	SEGMENT
_this$ = -12
_pBuff$ = -8
_pBuffer$ = -4
_guidBufferID$ = 8
?GetBufferNode@CBufferConfigList@@QAEPAVCBufferNode@@ABU_GUID@@@Z PROC NEAR ; CBufferConfigList::GetBufferNode, COMDAT
; _this$ = ecx

; 944  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 945  :     CBufferNode *pBuff = NULL;

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _pBuff$[ebp], 0

; 946  :     CBufferConfig *pBuffer;
; 947  :     for (pBuffer = GetHead();pBuffer;pBuffer = pBuffer->GetNext())

  00010	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?GetHead@CBufferConfigList@@QAEPAVCBufferConfig@@XZ ; CBufferConfigList::GetHead
  00018	89 45 fc	 mov	 DWORD PTR _pBuffer$[ebp], eax
  0001b	eb 0b		 jmp	 SHORT $L69706
$L69707:
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _pBuffer$[ebp]
  00020	e8 00 00 00 00	 call	 ?GetNext@CBufferConfig@@QAEPAV1@XZ ; CBufferConfig::GetNext
  00025	89 45 fc	 mov	 DWORD PTR _pBuffer$[ebp], eax
$L69706:
  00028	83 7d fc 00	 cmp	 DWORD PTR _pBuffer$[ebp], 0
  0002c	74 35		 je	 SHORT $L69708

; 948  :     {
; 949  :         if (pBuffer->m_BufferHeader.guidBufferID == guidBufferID)

  0002e	8b 45 08	 mov	 eax, DWORD PTR _guidBufferID$[ebp]
  00031	50		 push	 eax
  00032	8b 4d fc	 mov	 ecx, DWORD PTR _pBuffer$[ebp]
  00035	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00038	51		 push	 ecx
  00039	e8 00 00 00 00	 call	 _==@8
  0003e	85 c0		 test	 eax, eax
  00040	74 1f		 je	 SHORT $L69709

; 950  :         {
; 951  :             if (pBuffer->m_pBufferNode)

  00042	8b 55 fc	 mov	 edx, DWORD PTR _pBuffer$[ebp]
  00045	83 7a 08 00	 cmp	 DWORD PTR [edx+8], 0
  00049	74 14		 je	 SHORT $L69710

; 952  :             {
; 953  :                 pBuffer->m_pBufferNode->AddRef();

  0004b	8b 45 fc	 mov	 eax, DWORD PTR _pBuffer$[ebp]
  0004e	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00051	e8 00 00 00 00	 call	 ?AddRef@CBufferNode@@QAEKXZ ; CBufferNode::AddRef

; 954  :                 pBuff = pBuffer->m_pBufferNode;

  00056	8b 4d fc	 mov	 ecx, DWORD PTR _pBuffer$[ebp]
  00059	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0005c	89 55 f8	 mov	 DWORD PTR _pBuff$[ebp], edx
$L69710:

; 955  :             }
; 956  :             break;

  0005f	eb 02		 jmp	 SHORT $L69708
$L69709:

; 957  :         }
; 958  :     }

  00061	eb ba		 jmp	 SHORT $L69707
$L69708:

; 959  :     return pBuff;

  00063	8b 45 f8	 mov	 eax, DWORD PTR _pBuff$[ebp]

; 960  : }

  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c2 04 00	 ret	 4
?GetBufferNode@CBufferConfigList@@QAEPAVCBufferNode@@ABU_GUID@@@Z ENDP ; CBufferConfigList::GetBufferNode
_TEXT	ENDS
PUBLIC	?Activate@CBufferConfigList@@QAEJH@Z		; CBufferConfigList::Activate
; Function compile flags: /Odt
;	COMDAT ?Activate@CBufferConfigList@@QAEJH@Z
_TEXT	SEGMENT
_this$ = -16
_pUndo$69723 = -12
_hr$ = -8
_pBuffer$ = -4
_fActivate$ = 8
?Activate@CBufferConfigList@@QAEJH@Z PROC NEAR		; CBufferConfigList::Activate, COMDAT
; _this$ = ecx

; 964  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 965  :     HRESULT hr = S_OK;

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 966  :     CBufferConfig *pBuffer;
; 967  :     for (pBuffer = GetHead();pBuffer;pBuffer = pBuffer->GetNext())

  00010	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?GetHead@CBufferConfigList@@QAEPAVCBufferConfig@@XZ ; CBufferConfigList::GetHead
  00018	89 45 fc	 mov	 DWORD PTR _pBuffer$[ebp], eax
  0001b	eb 0b		 jmp	 SHORT $L69718
$L69719:
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _pBuffer$[ebp]
  00020	e8 00 00 00 00	 call	 ?GetNext@CBufferConfig@@QAEPAV1@XZ ; CBufferConfig::GetNext
  00025	89 45 fc	 mov	 DWORD PTR _pBuffer$[ebp], eax
$L69718:
  00028	83 7d fc 00	 cmp	 DWORD PTR _pBuffer$[ebp], 0
  0002c	74 53		 je	 SHORT $L69720

; 968  :     {
; 969  :         hr = pBuffer->Activate(fActivate);

  0002e	8b 45 08	 mov	 eax, DWORD PTR _fActivate$[ebp]
  00031	50		 push	 eax
  00032	8b 4d fc	 mov	 ecx, DWORD PTR _pBuffer$[ebp]
  00035	e8 00 00 00 00	 call	 ?Activate@CBufferConfig@@QAEJH@Z ; CBufferConfig::Activate
  0003a	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax

; 970  :         if (FAILED(hr))

  0003d	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00041	7d 3c		 jge	 SHORT $L69722

; 971  :         {
; 972  :             CBufferConfig *pUndo;
; 973  :             for (pUndo = GetHead();pUndo && (pUndo != pBuffer);pUndo = pUndo->GetNext())

  00043	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	e8 00 00 00 00	 call	 ?GetHead@CBufferConfigList@@QAEPAVCBufferConfig@@XZ ; CBufferConfigList::GetHead
  0004b	89 45 f4	 mov	 DWORD PTR _pUndo$69723[ebp], eax
  0004e	eb 0b		 jmp	 SHORT $L69724
$L69725:
  00050	8b 4d f4	 mov	 ecx, DWORD PTR _pUndo$69723[ebp]
  00053	e8 00 00 00 00	 call	 ?GetNext@CBufferConfig@@QAEPAV1@XZ ; CBufferConfig::GetNext
  00058	89 45 f4	 mov	 DWORD PTR _pUndo$69723[ebp], eax
$L69724:
  0005b	83 7d f4 00	 cmp	 DWORD PTR _pUndo$69723[ebp], 0
  0005f	74 1c		 je	 SHORT $L69726
  00061	8b 4d f4	 mov	 ecx, DWORD PTR _pUndo$69723[ebp]
  00064	3b 4d fc	 cmp	 ecx, DWORD PTR _pBuffer$[ebp]
  00067	74 14		 je	 SHORT $L69726

; 974  :             {
; 975  :                 pUndo->Activate(!fActivate);

  00069	33 d2		 xor	 edx, edx
  0006b	83 7d 08 00	 cmp	 DWORD PTR _fActivate$[ebp], 0
  0006f	0f 94 c2	 sete	 dl
  00072	52		 push	 edx
  00073	8b 4d f4	 mov	 ecx, DWORD PTR _pUndo$69723[ebp]
  00076	e8 00 00 00 00	 call	 ?Activate@CBufferConfig@@QAEJH@Z ; CBufferConfig::Activate

; 976  :             }

  0007b	eb d3		 jmp	 SHORT $L69725
$L69726:

; 977  :             break;

  0007d	eb 02		 jmp	 SHORT $L69720
$L69722:

; 978  :         }
; 979  :     }

  0007f	eb 9c		 jmp	 SHORT $L69719
$L69720:

; 980  :     return hr;

  00081	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]

; 981  : }

  00084	8b e5		 mov	 esp, ebp
  00086	5d		 pop	 ebp
  00087	c2 04 00	 ret	 4
?Activate@CBufferConfigList@@QAEJH@Z ENDP		; CBufferConfigList::Activate
_TEXT	ENDS
PUBLIC	?AddTail@CBufferConfigList@@QAEXPAVCBufferConfig@@@Z ; CBufferConfigList::AddTail
PUBLIC	?CreateRunTimeVersion@CBufferConfigList@@QAEJPAV1@PAVCBufferManager@@@Z ; CBufferConfigList::CreateRunTimeVersion
; Function compile flags: /Odt
;	COMDAT ?CreateRunTimeVersion@CBufferConfigList@@QAEJPAV1@PAVCBufferManager@@@Z
_TEXT	SEGMENT
_this$ = -16
_pNew$69738 = -12
_hr$ = -8
_pBuffer$ = -4
_pCopy$ = 8
_pManager$ = 12
?CreateRunTimeVersion@CBufferConfigList@@QAEJPAV1@PAVCBufferManager@@@Z PROC NEAR ; CBufferConfigList::CreateRunTimeVersion, COMDAT
; _this$ = ecx

; 990  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 991  :     HRESULT hr = S_OK;

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 992  :     CBufferConfig *pBuffer;
; 993  :     for (pBuffer = GetHead();pBuffer;pBuffer = pBuffer->GetNext())

  00010	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?GetHead@CBufferConfigList@@QAEPAVCBufferConfig@@XZ ; CBufferConfigList::GetHead
  00018	89 45 fc	 mov	 DWORD PTR _pBuffer$[ebp], eax
  0001b	eb 0b		 jmp	 SHORT $L69735
$L69736:
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _pBuffer$[ebp]
  00020	e8 00 00 00 00	 call	 ?GetNext@CBufferConfig@@QAEPAV1@XZ ; CBufferConfig::GetNext
  00025	89 45 fc	 mov	 DWORD PTR _pBuffer$[ebp], eax
$L69735:
  00028	83 7d fc 00	 cmp	 DWORD PTR _pBuffer$[ebp], 0
  0002c	74 32		 je	 SHORT $L69737

; 994  :     {
; 995  :         CBufferConfig *pNew = NULL;

  0002e	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _pNew$69738[ebp], 0

; 996  :         hr = pManager->CreateBuffer(pBuffer,&pNew);

  00035	8d 45 f4	 lea	 eax, DWORD PTR _pNew$69738[ebp]
  00038	50		 push	 eax
  00039	8b 4d fc	 mov	 ecx, DWORD PTR _pBuffer$[ebp]
  0003c	51		 push	 ecx
  0003d	8b 4d 0c	 mov	 ecx, DWORD PTR _pManager$[ebp]
  00040	e8 00 00 00 00	 call	 ?CreateBuffer@CBufferManager@@QAEJPAVCBufferConfig@@PAPAV2@@Z ; CBufferManager::CreateBuffer
  00045	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax

; 997  :         if (SUCCEEDED(hr))

  00048	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0004c	7c 0e		 jl	 SHORT $L69740

; 998  :         {
; 999  :             pCopy->AddTail(pNew);

  0004e	8b 55 f4	 mov	 edx, DWORD PTR _pNew$69738[ebp]
  00051	52		 push	 edx
  00052	8b 4d 08	 mov	 ecx, DWORD PTR _pCopy$[ebp]
  00055	e8 00 00 00 00	 call	 ?AddTail@CBufferConfigList@@QAEXPAVCBufferConfig@@@Z ; CBufferConfigList::AddTail

; 1000 :         }
; 1001 :         else

  0005a	eb 02		 jmp	 SHORT $L69741
$L69740:

; 1002 :         {
; 1003 :             break;

  0005c	eb 02		 jmp	 SHORT $L69737
$L69741:

; 1004 :         }
; 1005 :     }

  0005e	eb bd		 jmp	 SHORT $L69736
$L69737:

; 1006 :     return hr;

  00060	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]

; 1007 : }

  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c2 08 00	 ret	 8
?CreateRunTimeVersion@CBufferConfigList@@QAEJPAV1@PAVCBufferManager@@@Z ENDP ; CBufferConfigList::CreateRunTimeVersion
_TEXT	ENDS
PUBLIC	??0CBufferConfigList@@QAE@XZ			; CBufferConfigList::CBufferConfigList
PUBLIC	??0CBufferConnectList@@QAE@XZ			; CBufferConnectList::CBufferConnectList
PUBLIC	??0CPortConfig@@QAE@XZ				; CPortConfig::CPortConfig
EXTRN	_GUID_Synth_Default:BYTE
; Function compile flags: /Odt
;	COMDAT ??0CPortConfig@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CPortConfig@@QAE@XZ PROC NEAR			; CPortConfig::CPortConfig, COMDAT
; _this$ = ecx

; 1012 : { 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0AListItem@@QAE@XZ	; AListItem::AListItem
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	83 c1 48	 add	 ecx, 72			; 00000048H
  00015	e8 00 00 00 00	 call	 ??0CBufferConnectList@@QAE@XZ
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	83 c1 4c	 add	 ecx, 76			; 0000004cH
  00020	e8 00 00 00 00	 call	 ??0CBufferConfigList@@QAE@XZ

; 1013 :     m_fAlreadyHere = FALSE;

  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	c7 40 58 00 00
	00 00		 mov	 DWORD PTR [eax+88], 0

; 1014 :     m_pPort = NULL;

  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	c7 41 54 00 00
	00 00		 mov	 DWORD PTR [ecx+84], 0

; 1015 :     m_dwPortID = 0;

  00039	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0003c	c7 42 44 00 00
	00 00		 mov	 DWORD PTR [edx+68], 0

; 1016 :     m_pParent = NULL;

  00043	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00046	c7 40 50 00 00
	00 00		 mov	 DWORD PTR [eax+80], 0

; 1017 :     m_PortHeader.guidPort = GUID_Synth_Default;     // Default synth, as specified by DMUS_AUDPARAMS.

  0004d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	83 c1 04	 add	 ecx, 4
  00053	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _GUID_Synth_Default
  00059	89 11		 mov	 DWORD PTR [ecx], edx
  0005b	a1 04 00 00 00	 mov	 eax, DWORD PTR _GUID_Synth_Default+4
  00060	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00063	8b 15 08 00 00
	00		 mov	 edx, DWORD PTR _GUID_Synth_Default+8
  00069	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  0006c	a1 0c 00 00 00	 mov	 eax, DWORD PTR _GUID_Synth_Default+12
  00071	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 1018 :     m_PortHeader.dwFlags = DMUS_PORTCONFIGF_DRUMSON10;

  00074	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00077	c7 41 1c 01 00
	00 00		 mov	 DWORD PTR [ecx+28], 1

; 1019 :     m_PortHeader.dwPChannelBase = 0;

  0007e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00081	c7 42 14 00 00
	00 00		 mov	 DWORD PTR [edx+20], 0

; 1020 :     m_PortHeader.dwPChannelCount = 32;

  00088	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0008b	c7 40 18 20 00
	00 00		 mov	 DWORD PTR [eax+24], 32	; 00000020H

; 1021 :     m_PortParams.dwChannelGroups = 2;

  00092	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00095	c7 41 2c 02 00
	00 00		 mov	 DWORD PTR [ecx+44], 2

; 1022 :     m_PortParams.dwSize = sizeof(DMUS_PORTPARAMS8);

  0009c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0009f	c7 42 20 24 00
	00 00		 mov	 DWORD PTR [edx+32], 36	; 00000024H

; 1023 :     m_PortParams.dwValidParams = DMUS_PORTPARAMS_CHANNELGROUPS | DMUS_PORTPARAMS_FEATURES;

  000a6	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a9	c7 40 24 82 00
	00 00		 mov	 DWORD PTR [eax+36], 130	; 00000082H

; 1024 :     m_PortParams.dwFeatures = DMUS_PORT_FEATURE_AUDIOPATH | DMUS_PORT_FEATURE_STREAMING;

  000b0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b3	c7 41 40 03 00
	00 00		 mov	 DWORD PTR [ecx+64], 3

; 1025 : }

  000ba	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000bd	8b e5		 mov	 esp, ebp
  000bf	5d		 pop	 ebp
  000c0	c3		 ret	 0
??0CPortConfig@@QAE@XZ ENDP				; CPortConfig::CPortConfig
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0CBufferConnectList@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CBufferConnectList@@QAE@XZ PROC NEAR			; CBufferConnectList::CBufferConnectList, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0AList@@QAE@XZ	; AList::AList
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0CBufferConnectList@@QAE@XZ ENDP			; CBufferConnectList::CBufferConnectList
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0CBufferConfigList@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CBufferConfigList@@QAE@XZ PROC NEAR			; CBufferConfigList::CBufferConfigList, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0AList@@QAE@XZ	; AList::AList
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0CBufferConfigList@@QAE@XZ ENDP			; CBufferConfigList::CBufferConfigList
_TEXT	ENDS
PUBLIC	??1CPortConfig@@QAE@XZ				; CPortConfig::~CPortConfig
; Function compile flags: /Odt
;	COMDAT ??1CPortConfig@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1CPortConfig@@QAE@XZ PROC NEAR			; CPortConfig::~CPortConfig, COMDAT
; _this$ = ecx

; 1029 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1030 :     if (m_pPort) m_pPort->Release();

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 78 54 00	 cmp	 DWORD PTR [eax+84], 0
  0000e	74 12		 je	 SHORT $L69753
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 51 54	 mov	 edx, DWORD PTR [ecx+84]
  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  0001c	8b 12		 mov	 edx, DWORD PTR [edx]
  0001e	51		 push	 ecx
  0001f	ff 52 08	 call	 DWORD PTR [edx+8]
$L69753:

; 1031 :     m_BufferConnectList.Clear();

  00022	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	83 c1 48	 add	 ecx, 72			; 00000048H
  00028	e8 00 00 00 00	 call	 ?Clear@CBufferConnectList@@QAEXXZ ; CBufferConnectList::Clear

; 1032 :     m_BufferConfigList.Clear();

  0002d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	83 c1 4c	 add	 ecx, 76			; 0000004cH
  00033	e8 00 00 00 00	 call	 ?Clear@CBufferConfigList@@QAEXXZ ; CBufferConfigList::Clear

; 1033 : }

  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??1CPortConfig@@QAE@XZ ENDP				; CPortConfig::~CPortConfig
_TEXT	ENDS
PUBLIC	?Activate@CPortConfig@@QAEJH@Z			; CPortConfig::Activate
; Function compile flags: /Odt
;	COMDAT ?Activate@CPortConfig@@QAEJH@Z
_TEXT	SEGMENT
_this$ = -12
_hrTemp$69761 = -8
_hr$ = -4
_fActivate$ = 8
?Activate@CPortConfig@@QAEJH@Z PROC NEAR		; CPortConfig::Activate, COMDAT
; _this$ = ecx

; 1038 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1039 :     HRESULT hr = m_BufferConfigList.Activate(fActivate);

  00009	8b 45 08	 mov	 eax, DWORD PTR _fActivate$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	83 c1 4c	 add	 ecx, 76			; 0000004cH
  00013	e8 00 00 00 00	 call	 ?Activate@CBufferConfigList@@QAEJH@Z ; CBufferConfigList::Activate
  00018	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 1040 :     if (SUCCEEDED(hr) && fActivate && m_pPort)

  0001b	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0001f	7c 32		 jl	 SHORT $L69760
  00021	83 7d 08 00	 cmp	 DWORD PTR _fActivate$[ebp], 0
  00025	74 2c		 je	 SHORT $L69760
  00027	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	83 79 54 00	 cmp	 DWORD PTR [ecx+84], 0
  0002e	74 23		 je	 SHORT $L69760

; 1041 :     {
; 1042 :         HRESULT hrTemp = m_pPort->Activate(TRUE);

  00030	6a 01		 push	 1
  00032	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00035	8b 42 54	 mov	 eax, DWORD PTR [edx+84]
  00038	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	8b 51 54	 mov	 edx, DWORD PTR [ecx+84]
  0003e	8b 00		 mov	 eax, DWORD PTR [eax]
  00040	52		 push	 edx
  00041	ff 50 3c	 call	 DWORD PTR [eax+60]
  00044	89 45 f8	 mov	 DWORD PTR _hrTemp$69761[ebp], eax

; 1043 :         if (FAILED(hrTemp))

  00047	83 7d f8 00	 cmp	 DWORD PTR _hrTemp$69761[ebp], 0
  0004b	7d 06		 jge	 SHORT $L69760

; 1044 :         {
; 1045 :             hr = hrTemp;

  0004d	8b 4d f8	 mov	 ecx, DWORD PTR _hrTemp$69761[ebp]
  00050	89 4d fc	 mov	 DWORD PTR _hr$[ebp], ecx
$L69760:

; 1046 :         }
; 1047 :     }
; 1048 :     return hr;

  00053	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]

; 1049 : }

  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c2 04 00	 ret	 4
?Activate@CPortConfig@@QAEJH@Z ENDP			; CPortConfig::Activate
_TEXT	ENDS
PUBLIC	?CreateRunTimeVersion@CPortConfig@@QAEJPAPAV1@PAVCAudioPath@@PAVCBufferManager@@@Z ; CPortConfig::CreateRunTimeVersion
; Function compile flags: /Odt
;	COMDAT ?CreateRunTimeVersion@CPortConfig@@QAEJPAPAV1@PAVCAudioPath@@PAVCBufferManager@@@Z
_TEXT	SEGMENT
tv69 = -20
_this$ = -16
$T71662 = -12
_hr$ = -8
_pCopy$ = -4
_ppCopy$ = 8
_pParent$ = 12
_pManager$ = 16
?CreateRunTimeVersion@CPortConfig@@QAEJPAPAV1@PAVCAudioPath@@PAVCBufferManager@@@Z PROC NEAR ; CPortConfig::CreateRunTimeVersion, COMDAT
; _this$ = ecx

; 1053 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1054 :     HRESULT hr = E_OUTOFMEMORY;

  0000b	c7 45 f8 0e 00
	07 80		 mov	 DWORD PTR _hr$[ebp], -2147024882 ; 8007000eH

; 1055 :     CPortConfig *pCopy = new CPortConfig();

  00012	6a 5c		 push	 92			; 0000005cH
  00014	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00019	83 c4 04	 add	 esp, 4
  0001c	89 45 f4	 mov	 DWORD PTR $T71662[ebp], eax
  0001f	83 7d f4 00	 cmp	 DWORD PTR $T71662[ebp], 0
  00023	74 0d		 je	 SHORT $L71663
  00025	8b 4d f4	 mov	 ecx, DWORD PTR $T71662[ebp]
  00028	e8 00 00 00 00	 call	 ??0CPortConfig@@QAE@XZ	; CPortConfig::CPortConfig
  0002d	89 45 ec	 mov	 DWORD PTR tv69[ebp], eax
  00030	eb 07		 jmp	 SHORT $L71664
$L71663:
  00032	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$L71664:
  00039	8b 45 ec	 mov	 eax, DWORD PTR tv69[ebp]
  0003c	89 45 fc	 mov	 DWORD PTR _pCopy$[ebp], eax

; 1056 :     if (pCopy)

  0003f	83 7d fc 00	 cmp	 DWORD PTR _pCopy$[ebp], 0
  00043	74 67		 je	 SHORT $L69775

; 1057 :     {
; 1058 :         pCopy->m_pParent = pParent;

  00045	8b 4d fc	 mov	 ecx, DWORD PTR _pCopy$[ebp]
  00048	8b 55 0c	 mov	 edx, DWORD PTR _pParent$[ebp]
  0004b	89 51 50	 mov	 DWORD PTR [ecx+80], edx

; 1059 :         pCopy->m_PortHeader = m_PortHeader;

  0004e	8b 75 f0	 mov	 esi, DWORD PTR _this$[ebp]
  00051	83 c6 04	 add	 esi, 4
  00054	8b 7d fc	 mov	 edi, DWORD PTR _pCopy$[ebp]
  00057	83 c7 04	 add	 edi, 4
  0005a	b9 07 00 00 00	 mov	 ecx, 7
  0005f	f3 a5		 rep movsd

; 1060 :         pCopy->m_PortParams = m_PortParams;

  00061	8b 75 f0	 mov	 esi, DWORD PTR _this$[ebp]
  00064	83 c6 20	 add	 esi, 32			; 00000020H
  00067	8b 7d fc	 mov	 edi, DWORD PTR _pCopy$[ebp]
  0006a	83 c7 20	 add	 edi, 32			; 00000020H
  0006d	b9 09 00 00 00	 mov	 ecx, 9
  00072	f3 a5		 rep movsd

; 1061 :         hr = m_BufferConfigList.CreateRunTimeVersion(&pCopy->m_BufferConfigList,pManager);

  00074	8b 45 10	 mov	 eax, DWORD PTR _pManager$[ebp]
  00077	50		 push	 eax
  00078	8b 4d fc	 mov	 ecx, DWORD PTR _pCopy$[ebp]
  0007b	83 c1 4c	 add	 ecx, 76			; 0000004cH
  0007e	51		 push	 ecx
  0007f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00082	83 c1 4c	 add	 ecx, 76			; 0000004cH
  00085	e8 00 00 00 00	 call	 ?CreateRunTimeVersion@CBufferConfigList@@QAEJPAV1@PAVCBufferManager@@@Z ; CBufferConfigList::CreateRunTimeVersion
  0008a	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax

; 1062 :         if (SUCCEEDED(hr))

  0008d	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00091	7c 19		 jl	 SHORT $L69775

; 1063 :         {
; 1064 :             hr = m_BufferConnectList.CreateRunTimeVersion(&pCopy->m_BufferConnectList,pCopy);

  00093	8b 55 fc	 mov	 edx, DWORD PTR _pCopy$[ebp]
  00096	52		 push	 edx
  00097	8b 45 fc	 mov	 eax, DWORD PTR _pCopy$[ebp]
  0009a	83 c0 48	 add	 eax, 72			; 00000048H
  0009d	50		 push	 eax
  0009e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000a1	83 c1 48	 add	 ecx, 72			; 00000048H
  000a4	e8 00 00 00 00	 call	 ?CreateRunTimeVersion@CBufferConnectList@@QAEJPAV1@PAVCPortConfig@@@Z ; CBufferConnectList::CreateRunTimeVersion
  000a9	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax
$L69775:

; 1065 :         }
; 1066 :     }
; 1067 :     *ppCopy = pCopy;

  000ac	8b 4d 08	 mov	 ecx, DWORD PTR _ppCopy$[ebp]
  000af	8b 55 fc	 mov	 edx, DWORD PTR _pCopy$[ebp]
  000b2	89 11		 mov	 DWORD PTR [ecx], edx

; 1068 :     return hr;

  000b4	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]

; 1069 : }

  000b7	5f		 pop	 edi
  000b8	5e		 pop	 esi
  000b9	8b e5		 mov	 esp, ebp
  000bb	5d		 pop	 ebp
  000bc	c2 0c 00	 ret	 12			; 0000000cH
?CreateRunTimeVersion@CPortConfig@@QAEJPAPAV1@PAVCAudioPath@@PAVCBufferManager@@@Z ENDP ; CPortConfig::CreateRunTimeVersion
_TEXT	ENDS
PUBLIC	?GetBufferNode@CAudioPath@@QAEPAVCBufferNode@@ABU_GUID@@@Z ; CAudioPath::GetBufferNode
; Function compile flags: /Odt
;	COMDAT ?GetBufferNode@CPortConfig@@QAEPAVCBufferNode@@ABU_GUID@@@Z
_TEXT	SEGMENT
_this$ = -8
_pBuff$ = -4
_guidBuffer$ = 8
?GetBufferNode@CPortConfig@@QAEPAVCBufferNode@@ABU_GUID@@@Z PROC NEAR ; CPortConfig::GetBufferNode, COMDAT
; _this$ = ecx

; 1073 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1074 :     CBufferNode *pBuff = NULL;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pBuff$[ebp], 0

; 1075 :     pBuff = m_BufferConfigList.GetBufferNode(guidBuffer);

  00010	8b 45 08	 mov	 eax, DWORD PTR _guidBuffer$[ebp]
  00013	50		 push	 eax
  00014	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	83 c1 4c	 add	 ecx, 76			; 0000004cH
  0001a	e8 00 00 00 00	 call	 ?GetBufferNode@CBufferConfigList@@QAEPAVCBufferNode@@ABU_GUID@@@Z ; CBufferConfigList::GetBufferNode
  0001f	89 45 fc	 mov	 DWORD PTR _pBuff$[ebp], eax

; 1076 :     if (!pBuff && !m_fAlreadyHere)

  00022	83 7d fc 00	 cmp	 DWORD PTR _pBuff$[ebp], 0
  00026	75 2f		 jne	 SHORT $L69783
  00028	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	83 79 58 00	 cmp	 DWORD PTR [ecx+88], 0
  0002f	75 26		 jne	 SHORT $L69783

; 1077 :     {
; 1078 :         m_fAlreadyHere = TRUE;

  00031	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00034	c7 42 58 01 00
	00 00		 mov	 DWORD PTR [edx+88], 1

; 1079 :         pBuff = m_pParent->GetBufferNode(guidBuffer);

  0003b	8b 45 08	 mov	 eax, DWORD PTR _guidBuffer$[ebp]
  0003e	50		 push	 eax
  0003f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	8b 49 50	 mov	 ecx, DWORD PTR [ecx+80]
  00045	e8 00 00 00 00	 call	 ?GetBufferNode@CAudioPath@@QAEPAVCBufferNode@@ABU_GUID@@@Z ; CAudioPath::GetBufferNode
  0004a	89 45 fc	 mov	 DWORD PTR _pBuff$[ebp], eax

; 1080 :         m_fAlreadyHere = FALSE;

  0004d	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00050	c7 42 58 00 00
	00 00		 mov	 DWORD PTR [edx+88], 0
$L69783:

; 1081 :     }
; 1082 :     return pBuff;

  00057	8b 45 fc	 mov	 eax, DWORD PTR _pBuff$[ebp]

; 1083 : } 

  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c2 04 00	 ret	 4
?GetBufferNode@CPortConfig@@QAEPAVCBufferNode@@ABU_GUID@@@Z ENDP ; CPortConfig::GetBufferNode
_TEXT	ENDS
PUBLIC	?Load@CPortConfig@@QAEJPAVCRiffParser@@@Z	; CPortConfig::Load
PUBLIC	??_C@_0CP@DMLIBLBB@AudioPath?5Configuration?5failed?5l@ ; `string'
PUBLIC	??_C@_0EO@KIFLFOOK@Error?3?5Failure?5loading?5port?5conf@ ; `string'
PUBLIC	?GetStream@CRiffParser@@QAEPAUIStream@@XZ	; CRiffParser::GetStream
EXTRN	?NextChunk@CRiffParser@@QAEHPAJ@Z:NEAR		; CRiffParser::NextChunk
EXTRN	?EnterList@CRiffParser@@QAEXPAU_RIFFIO@@@Z:NEAR	; CRiffParser::EnterList
EXTRN	?LeaveList@CRiffParser@@QAEXXZ:NEAR		; CRiffParser::LeaveList
EXTRN	?SeekBack@CRiffParser@@QAEJXZ:NEAR		; CRiffParser::SeekBack
EXTRN	?SeekForward@CRiffParser@@QAEJXZ:NEAR		; CRiffParser::SeekForward
;	COMDAT ??_C@_0CP@DMLIBLBB@AudioPath?5Configuration?5failed?5l@
CONST	SEGMENT
??_C@_0CP@DMLIBLBB@AudioPath?5Configuration?5failed?5l@ DB 'AudioPath Con'
	DB	'figuration failed loading buffer', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EO@KIFLFOOK@Error?3?5Failure?5loading?5port?5conf@
CONST	SEGMENT
??_C@_0EO@KIFLFOOK@Error?3?5Failure?5loading?5port?5conf@ DB 'Error: Fail'
	DB	'ure loading port configuration chunk in Audio Path Configurat'
	DB	'ion.', 0aH, 00H				; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?Load@CPortConfig@@QAEJPAVCRiffParser@@@Z
_TEXT	SEGMENT
tv216 = -152
tv197 = -148
tv190 = -144
tv153 = -140
tv145 = -136
tv128 = -132
tv90 = -128
tv83 = -124
tv70 = -120
_this$ = -116
$T71686 = -112
$T71685 = -108
$T71682 = -104
$T71679 = -100
$T71678 = -96
$T71674 = -92
$T71671 = -88
_pSource$69959 = -84
_pSource$69883 = -80
_pBufferConnect$69866 = -76
_ckChild$69840 = -72
_hr$ = -40
_dwLoadedBoth$ = -36
_ckNext$ = -32
_pParser$ = 8
?Load@CPortConfig@@QAEJPAVCRiffParser@@@Z PROC NEAR	; CPortConfig::Load, COMDAT
; _this$ = ecx

; 1087 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 98 00 00
	00		 sub	 esp, 152		; 00000098H
  00009	89 4d 8c	 mov	 DWORD PTR _this$[ebp], ecx

; 1088 :     RIFFIO ckNext;
; 1089 :     HRESULT hr = S_OK;

  0000c	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 1090 :     DWORD dwLoadedBoth = 0;

  00013	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _dwLoadedBoth$[ebp], 0

; 1091 :     pParser->EnterList(&ckNext);

  0001a	8d 45 e0	 lea	 eax, DWORD PTR _ckNext$[ebp]
  0001d	50		 push	 eax
  0001e	8b 4d 08	 mov	 ecx, DWORD PTR _pParser$[ebp]
  00021	e8 00 00 00 00	 call	 ?EnterList@CRiffParser@@QAEXPAU_RIFFIO@@@Z ; CRiffParser::EnterList
$L69793:

; 1092 :     while (pParser->NextChunk(&hr))

  00026	8d 4d d8	 lea	 ecx, DWORD PTR _hr$[ebp]
  00029	51		 push	 ecx
  0002a	8b 4d 08	 mov	 ecx, DWORD PTR _pParser$[ebp]
  0002d	e8 00 00 00 00	 call	 ?NextChunk@CRiffParser@@QAEHPAJ@Z ; CRiffParser::NextChunk
  00032	85 c0		 test	 eax, eax
  00034	0f 84 9f 03 00
	00		 je	 $L69794

; 1093 :     {
; 1094 :         switch(ckNext.ckid)
; 1095 :         {

  0003a	8b 55 e0	 mov	 edx, DWORD PTR _ckNext$[ebp]
  0003d	89 55 88	 mov	 DWORD PTR tv70[ebp], edx
  00040	81 7d 88 70 63
	66 68		 cmp	 DWORD PTR tv70[ebp], 1751540592 ; 68666370H
  00047	77 20		 ja	 SHORT $L71689
  00049	81 7d 88 70 63
	66 68		 cmp	 DWORD PTR tv70[ebp], 1751540592 ; 68666370H
  00050	74 25		 je	 SHORT $L69807
  00052	81 7d 88 52 49
	46 46		 cmp	 DWORD PTR tv70[ebp], 1179011410 ; 46464952H
  00059	74 60		 je	 SHORT $L69827
  0005b	81 7d 88 4c 49
	53 54		 cmp	 DWORD PTR tv70[ebp], 1414744396 ; 5453494cH
  00062	74 57		 je	 SHORT $L69827
  00064	e9 6b 03 00 00	 jmp	 $L69796
$L71689:
  00069	81 7d 88 70 70
	72 68		 cmp	 DWORD PTR tv70[ebp], 1752330352 ; 68727070H
  00070	74 27		 je	 SHORT $L69817
  00072	e9 5d 03 00 00	 jmp	 $L69796
$L69807:

; 1096 :         case DMUS_FOURCC_PORTCONFIG_ITEM:
; 1097 :             hr = pParser->Read(&m_PortHeader, sizeof(DMUS_IO_PORTCONFIG_HEADER));

  00077	6a 1c		 push	 28			; 0000001cH
  00079	8b 45 8c	 mov	 eax, DWORD PTR _this$[ebp]
  0007c	83 c0 04	 add	 eax, 4
  0007f	50		 push	 eax
  00080	8b 4d 08	 mov	 ecx, DWORD PTR _pParser$[ebp]
  00083	e8 00 00 00 00	 call	 ?Read@CRiffParser@@QAEJPAXK@Z ; CRiffParser::Read
  00088	89 45 d8	 mov	 DWORD PTR _hr$[ebp], eax

; 1098 :             dwLoadedBoth |= 1;

  0008b	8b 4d dc	 mov	 ecx, DWORD PTR _dwLoadedBoth$[ebp]
  0008e	83 c9 01	 or	 ecx, 1
  00091	89 4d dc	 mov	 DWORD PTR _dwLoadedBoth$[ebp], ecx

; 1099 :             break;

  00094	e9 3b 03 00 00	 jmp	 $L69796
$L69817:

; 1100 :         case DMUS_FOURCC_PORTPARAMS_ITEM:
; 1101 :             hr = pParser->Read(&m_PortParams, sizeof(DMUS_PORTPARAMS8));

  00099	6a 24		 push	 36			; 00000024H
  0009b	8b 55 8c	 mov	 edx, DWORD PTR _this$[ebp]
  0009e	83 c2 20	 add	 edx, 32			; 00000020H
  000a1	52		 push	 edx
  000a2	8b 4d 08	 mov	 ecx, DWORD PTR _pParser$[ebp]
  000a5	e8 00 00 00 00	 call	 ?Read@CRiffParser@@QAEJPAXK@Z ; CRiffParser::Read
  000aa	89 45 d8	 mov	 DWORD PTR _hr$[ebp], eax

; 1102 :             dwLoadedBoth |= 2;

  000ad	8b 45 dc	 mov	 eax, DWORD PTR _dwLoadedBoth$[ebp]
  000b0	83 c8 02	 or	 eax, 2
  000b3	89 45 dc	 mov	 DWORD PTR _dwLoadedBoth$[ebp], eax

; 1103 :             break;

  000b6	e9 19 03 00 00	 jmp	 $L69796
$L69827:

; 1104 :         case FOURCC_LIST:
; 1105 :         case FOURCC_RIFF:
; 1106 :             switch(ckNext.fccType)
; 1107 :             {

  000bb	8b 4d e8	 mov	 ecx, DWORD PTR _ckNext$[ebp+8]
  000be	89 4d 84	 mov	 DWORD PTR tv83[ebp], ecx
  000c1	81 7d 84 44 53
	42 43		 cmp	 DWORD PTR tv83[ebp], 1128420164 ; 43425344H
  000c8	0f 84 47 02 00
	00		 je	 $L69958
  000ce	81 7d 84 64 62
	66 6c		 cmp	 DWORD PTR tv83[ebp], 1818649188 ; 6c666264H
  000d5	0f 84 b6 00 00
	00		 je	 $L69882
  000db	81 7d 84 70 63
	68 6c		 cmp	 DWORD PTR tv83[ebp], 1818780528 ; 6c686370H
  000e2	74 05		 je	 SHORT $L69849
  000e4	e9 eb 02 00 00	 jmp	 $L69796
$L69849:

; 1108 :                 RIFFIO ckChild;
; 1109 :                 case DMUS_FOURCC_PCHANNELS_LIST:
; 1110 :                     pParser->EnterList(&ckChild);

  000e9	8d 55 b8	 lea	 edx, DWORD PTR _ckChild$69840[ebp]
  000ec	52		 push	 edx
  000ed	8b 4d 08	 mov	 ecx, DWORD PTR _pParser$[ebp]
  000f0	e8 00 00 00 00	 call	 ?EnterList@CRiffParser@@QAEXPAU_RIFFIO@@@Z ; CRiffParser::EnterList
$L69851:

; 1111 :                     while (pParser->NextChunk(&hr))

  000f5	8d 45 d8	 lea	 eax, DWORD PTR _hr$[ebp]
  000f8	50		 push	 eax
  000f9	8b 4d 08	 mov	 ecx, DWORD PTR _pParser$[ebp]
  000fc	e8 00 00 00 00	 call	 ?NextChunk@CRiffParser@@QAEHPAJ@Z ; CRiffParser::NextChunk
  00101	85 c0		 test	 eax, eax
  00103	74 7f		 je	 SHORT $L69852

; 1112 :                     {
; 1113 :                         switch( ckChild.ckid )
; 1114 :                         {

  00105	8b 4d b8	 mov	 ecx, DWORD PTR _ckChild$69840[ebp]
  00108	89 4d 80	 mov	 DWORD PTR tv90[ebp], ecx
  0010b	81 7d 80 70 63
	68 68		 cmp	 DWORD PTR tv90[ebp], 1751671664 ; 68686370H
  00112	74 02		 je	 SHORT $L69865
  00114	eb 69		 jmp	 SHORT $L69854
$L69865:

; 1115 :                         case DMUS_FOURCC_PCHANNELS_ITEM:
; 1116 :                             {
; 1117 :                                 CBufferConnect *pBufferConnect = new CBufferConnect;

  00116	6a 1c		 push	 28			; 0000001cH
  00118	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0011d	83 c4 04	 add	 esp, 4
  00120	89 45 a8	 mov	 DWORD PTR $T71671[ebp], eax
  00123	83 7d a8 00	 cmp	 DWORD PTR $T71671[ebp], 0
  00127	74 10		 je	 SHORT $L71672
  00129	8b 4d a8	 mov	 ecx, DWORD PTR $T71671[ebp]
  0012c	e8 00 00 00 00	 call	 ??0CBufferConnect@@QAE@XZ ; CBufferConnect::CBufferConnect
  00131	89 85 7c ff ff
	ff		 mov	 DWORD PTR tv128[ebp], eax
  00137	eb 0a		 jmp	 SHORT $L71673
$L71672:
  00139	c7 85 7c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv128[ebp], 0
$L71673:
  00143	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR tv128[ebp]
  00149	89 55 b4	 mov	 DWORD PTR _pBufferConnect$69866[ebp], edx

; 1118 :                                 if (pBufferConnect)

  0014c	83 7d b4 00	 cmp	 DWORD PTR _pBufferConnect$69866[ebp], 0
  00150	74 26		 je	 SHORT $L69869

; 1119 :                                 {
; 1120 :                                     hr = pBufferConnect->Load(pParser);

  00152	8b 45 08	 mov	 eax, DWORD PTR _pParser$[ebp]
  00155	50		 push	 eax
  00156	8b 4d b4	 mov	 ecx, DWORD PTR _pBufferConnect$69866[ebp]
  00159	e8 00 00 00 00	 call	 ?Load@CBufferConnect@@QAEJPAVCRiffParser@@@Z ; CBufferConnect::Load
  0015e	89 45 d8	 mov	 DWORD PTR _hr$[ebp], eax

; 1121 :                                     if (SUCCEEDED(hr))

  00161	83 7d d8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00165	7c 0f		 jl	 SHORT $L69871

; 1122 :                                     {
; 1123 :                                         m_BufferConnectList.AddTail(pBufferConnect);

  00167	8b 4d b4	 mov	 ecx, DWORD PTR _pBufferConnect$69866[ebp]
  0016a	51		 push	 ecx
  0016b	8b 4d 8c	 mov	 ecx, DWORD PTR _this$[ebp]
  0016e	83 c1 48	 add	 ecx, 72			; 00000048H
  00171	e8 00 00 00 00	 call	 ?AddTail@CBufferConnectList@@QAEXPAVCBufferConnect@@@Z ; CBufferConnectList::AddTail
$L69871:

; 1124 :                                     }
; 1125 :                                 }
; 1126 :                                 else

  00176	eb 07		 jmp	 SHORT $L69854
$L69869:

; 1127 :                                 {
; 1128 :                                     hr = E_OUTOFMEMORY;

  00178	c7 45 d8 0e 00
	07 80		 mov	 DWORD PTR _hr$[ebp], -2147024882 ; 8007000eH
$L69854:

; 1129 :                                 }
; 1130 :                             }
; 1131 :                             break;
; 1132 :                         }
; 1133 :                     }

  0017f	e9 71 ff ff ff	 jmp	 $L69851
$L69852:

; 1134 :                     pParser->LeaveList();

  00184	8b 4d 08	 mov	 ecx, DWORD PTR _pParser$[ebp]
  00187	e8 00 00 00 00	 call	 ?LeaveList@CRiffParser@@QAEXXZ ; CRiffParser::LeaveList

; 1135 :                     break;

  0018c	e9 43 02 00 00	 jmp	 $L69796
$L69882:

; 1136 :                 case DMUS_FOURCC_DSBUFFER_LIST:
; 1137 :                     {
; 1138 :                         CBufferConfig *pSource = new CBufferConfig(0);

  00191	6a 30		 push	 48			; 00000030H
  00193	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00198	83 c4 04	 add	 esp, 4
  0019b	89 45 a4	 mov	 DWORD PTR $T71674[ebp], eax
  0019e	83 7d a4 00	 cmp	 DWORD PTR $T71674[ebp], 0
  001a2	74 12		 je	 SHORT $L71675
  001a4	6a 00		 push	 0
  001a6	8b 4d a4	 mov	 ecx, DWORD PTR $T71674[ebp]
  001a9	e8 00 00 00 00	 call	 ??0CBufferConfig@@QAE@K@Z ; CBufferConfig::CBufferConfig
  001ae	89 85 78 ff ff
	ff		 mov	 DWORD PTR tv145[ebp], eax
  001b4	eb 0a		 jmp	 SHORT $L71676
$L71675:
  001b6	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv145[ebp], 0
$L71676:
  001c0	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR tv145[ebp]
  001c6	89 55 b0	 mov	 DWORD PTR _pSource$69883[ebp], edx

; 1139 :                         if (pSource)

  001c9	83 7d b0 00	 cmp	 DWORD PTR _pSource$69883[ebp], 0
  001cd	0f 84 36 01 00
	00		 je	 $L69886

; 1140 :                         {
; 1141 :                             pParser->EnterList(&ckChild);

  001d3	8d 45 b8	 lea	 eax, DWORD PTR _ckChild$69840[ebp]
  001d6	50		 push	 eax
  001d7	8b 4d 08	 mov	 ecx, DWORD PTR _pParser$[ebp]
  001da	e8 00 00 00 00	 call	 ?EnterList@CRiffParser@@QAEXPAU_RIFFIO@@@Z ; CRiffParser::EnterList
$L69888:

; 1142 :                             while (pParser->NextChunk(&hr))

  001df	8d 4d d8	 lea	 ecx, DWORD PTR _hr$[ebp]
  001e2	51		 push	 ecx
  001e3	8b 4d 08	 mov	 ecx, DWORD PTR _pParser$[ebp]
  001e6	e8 00 00 00 00	 call	 ?NextChunk@CRiffParser@@QAEHPAJ@Z ; CRiffParser::NextChunk
  001eb	85 c0		 test	 eax, eax
  001ed	0f 84 c7 00 00
	00		 je	 $L69889

; 1143 :                             {
; 1144 :                                 switch( ckChild.ckid )
; 1145 :                                 {

  001f3	8b 55 b8	 mov	 edx, DWORD PTR _ckChild$69840[ebp]
  001f6	89 95 74 ff ff
	ff		 mov	 DWORD PTR tv153[ebp], edx
  001fc	81 bd 74 ff ff
	ff 64 64 61 68	 cmp	 DWORD PTR tv153[ebp], 1751213156 ; 68616464H
  00206	77 29		 ja	 SHORT $L71677
  00208	81 bd 74 ff ff
	ff 64 64 61 68	 cmp	 DWORD PTR tv153[ebp], 1751213156 ; 68616464H
  00212	74 2b		 je	 SHORT $L69902
  00214	81 bd 74 ff ff
	ff 52 49 46 46	 cmp	 DWORD PTR tv153[ebp], 1179011410 ; 46464952H
  0021e	74 53		 je	 SHORT $L69922
  00220	81 bd 74 ff ff
	ff 4c 49 53 54	 cmp	 DWORD PTR tv153[ebp], 1414744396 ; 5453494cH
  0022a	74 47		 je	 SHORT $L69922
  0022c	e9 84 00 00 00	 jmp	 $L69891
$L71677:
  00231	81 bd 74 ff ff
	ff 6d 78 62 6e	 cmp	 DWORD PTR tv153[ebp], 1851947117 ; 6e62786dH
  0023b	74 20		 je	 SHORT $L69912
  0023d	eb 76		 jmp	 SHORT $L69891
$L69902:

; 1146 :                                 case DMUS_FOURCC_DSBUFFATTR_ITEM:
; 1147 :                                     hr = pParser->Read(&pSource->m_BufferHeader, 
; 1148 :                                         sizeof(DMUS_IO_BUFFER_ATTRIBUTES_HEADER));

  0023f	6a 14		 push	 20			; 00000014H
  00241	8b 45 b0	 mov	 eax, DWORD PTR _pSource$69883[ebp]
  00244	83 c0 0c	 add	 eax, 12			; 0000000cH
  00247	50		 push	 eax
  00248	8b 4d 08	 mov	 ecx, DWORD PTR _pParser$[ebp]
  0024b	e8 00 00 00 00	 call	 ?Read@CRiffParser@@QAEJPAXK@Z ; CRiffParser::Read
  00250	89 45 d8	 mov	 DWORD PTR _hr$[ebp], eax

; 1149 :                                     pSource->DecideType();

  00253	8b 4d b0	 mov	 ecx, DWORD PTR _pSource$69883[ebp]
  00256	e8 00 00 00 00	 call	 ?DecideType@CBufferConfig@@QAEXXZ ; CBufferConfig::DecideType

; 1150 :                                     break;

  0025b	eb 58		 jmp	 SHORT $L69891
$L69912:

; 1151 :                                 case DMUS_FOURCC_MIXBINS_ITEM:
; 1152 :                                     hr = pParser->Read(&pSource->m_MixBinsHeader, 
; 1153 :                                         sizeof(DMUS_IO_BUFFER_MIXBINS_HEADER));

  0025d	6a 0c		 push	 12			; 0000000cH
  0025f	8b 4d b0	 mov	 ecx, DWORD PTR _pSource$69883[ebp]
  00262	83 c1 24	 add	 ecx, 36			; 00000024H
  00265	51		 push	 ecx
  00266	8b 4d 08	 mov	 ecx, DWORD PTR _pParser$[ebp]
  00269	e8 00 00 00 00	 call	 ?Read@CRiffParser@@QAEJPAXK@Z ; CRiffParser::Read
  0026e	89 45 d8	 mov	 DWORD PTR _hr$[ebp], eax

; 1154 :                                     break;

  00271	eb 42		 jmp	 SHORT $L69891
$L69922:

; 1155 :                                 case FOURCC_LIST:
; 1156 :                                 case FOURCC_RIFF:
; 1157 :                                     if ( ckChild.fccType == DMUS_FOURCC_DSBC_FORM)

  00273	81 7d c0 44 53
	42 43		 cmp	 DWORD PTR _ckChild$69840[ebp+8], 1128420164 ; 43425344H
  0027a	75 39		 jne	 SHORT $L69891

; 1158 :                                     {
; 1159 :                                         pParser->SeekBack();

  0027c	8b 4d 08	 mov	 ecx, DWORD PTR _pParser$[ebp]
  0027f	e8 00 00 00 00	 call	 ?SeekBack@CRiffParser@@QAEJXZ ; CRiffParser::SeekBack

; 1160 :                                         hr = pSource->Load(pParser->GetStream());

  00284	8b 4d 08	 mov	 ecx, DWORD PTR _pParser$[ebp]
  00287	e8 00 00 00 00	 call	 ?GetStream@CRiffParser@@QAEPAUIStream@@XZ ; CRiffParser::GetStream
  0028c	50		 push	 eax
  0028d	8b 4d b0	 mov	 ecx, DWORD PTR _pSource$69883[ebp]
  00290	e8 00 00 00 00	 call	 ?Load@CBufferConfig@@QAEJPAUIStream@@@Z ; CBufferConfig::Load
  00295	89 45 d8	 mov	 DWORD PTR _hr$[ebp], eax

; 1161 :                                         pParser->SeekForward();

  00298	8b 4d 08	 mov	 ecx, DWORD PTR _pParser$[ebp]
  0029b	e8 00 00 00 00	 call	 ?SeekForward@CRiffParser@@QAEJXZ ; CRiffParser::SeekForward

; 1162 :                                         if (FAILED(hr))

  002a0	83 7d d8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  002a4	7d 0f		 jge	 SHORT $L69891

; 1163 :                                         {
; 1164 :                                             Trace(1,"AudioPath Configuration failed loading buffer\n");

  002a6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CP@DMLIBLBB@AudioPath?5Configuration?5failed?5l@
  002ab	6a 01		 push	 1
  002ad	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  002b2	83 c4 08	 add	 esp, 8
$L69891:

; 1165 :                                         }
; 1166 :                                     }
; 1167 :                                 }
; 1168 :                             }

  002b5	e9 25 ff ff ff	 jmp	 $L69888
$L69889:

; 1169 :                             pParser->LeaveList();

  002ba	8b 4d 08	 mov	 ecx, DWORD PTR _pParser$[ebp]
  002bd	e8 00 00 00 00	 call	 ?LeaveList@CRiffParser@@QAEXXZ ; CRiffParser::LeaveList

; 1170 :                             if (SUCCEEDED(hr))

  002c2	83 7d d8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  002c6	7c 11		 jl	 SHORT $L69944

; 1171 :                             {
; 1172 :                                 m_BufferConfigList.AddTail(pSource);

  002c8	8b 55 b0	 mov	 edx, DWORD PTR _pSource$69883[ebp]
  002cb	52		 push	 edx
  002cc	8b 4d 8c	 mov	 ecx, DWORD PTR _this$[ebp]
  002cf	83 c1 4c	 add	 ecx, 76			; 0000004cH
  002d2	e8 00 00 00 00	 call	 ?AddTail@CBufferConfigList@@QAEXPAVCBufferConfig@@@Z ; CBufferConfigList::AddTail

; 1173 :                             }
; 1174 :                             else

  002d7	eb 2e		 jmp	 SHORT $L69945
$L69944:

; 1175 :                             {
; 1176 :                                 delete pSource;

  002d9	8b 45 b0	 mov	 eax, DWORD PTR _pSource$69883[ebp]
  002dc	89 45 9c	 mov	 DWORD PTR $T71679[ebp], eax
  002df	8b 4d 9c	 mov	 ecx, DWORD PTR $T71679[ebp]
  002e2	89 4d a0	 mov	 DWORD PTR $T71678[ebp], ecx
  002e5	83 7d a0 00	 cmp	 DWORD PTR $T71678[ebp], 0
  002e9	74 12		 je	 SHORT $L71680
  002eb	6a 01		 push	 1
  002ed	8b 4d a0	 mov	 ecx, DWORD PTR $T71678[ebp]
  002f0	e8 00 00 00 00	 call	 ??_GCBufferConfig@@QAEPAXI@Z
  002f5	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv190[ebp], eax
  002fb	eb 0a		 jmp	 SHORT $L69945
$L71680:
  002fd	c7 85 70 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv190[ebp], 0
$L69945:

; 1177 :                             }
; 1178 :                         }
; 1179 :                         else

  00307	eb 07		 jmp	 SHORT $L69948
$L69886:

; 1180 :                         {
; 1181 :                             hr = E_OUTOFMEMORY;

  00309	c7 45 d8 0e 00
	07 80		 mov	 DWORD PTR _hr$[ebp], -2147024882 ; 8007000eH
$L69948:

; 1182 :                         }
; 1183 :                     }
; 1184 :                     break;

  00310	e9 bf 00 00 00	 jmp	 $L69796
$L69958:

; 1185 :                 case DMUS_FOURCC_DSBC_FORM:
; 1186 :                     {
; 1187 :                         CBufferConfig *pSource = new CBufferConfig(0);

  00315	6a 30		 push	 48			; 00000030H
  00317	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0031c	83 c4 04	 add	 esp, 4
  0031f	89 45 98	 mov	 DWORD PTR $T71682[ebp], eax
  00322	83 7d 98 00	 cmp	 DWORD PTR $T71682[ebp], 0
  00326	74 12		 je	 SHORT $L71683
  00328	6a 00		 push	 0
  0032a	8b 4d 98	 mov	 ecx, DWORD PTR $T71682[ebp]
  0032d	e8 00 00 00 00	 call	 ??0CBufferConfig@@QAE@K@Z ; CBufferConfig::CBufferConfig
  00332	89 85 6c ff ff
	ff		 mov	 DWORD PTR tv197[ebp], eax
  00338	eb 0a		 jmp	 SHORT $L71684
$L71683:
  0033a	c7 85 6c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv197[ebp], 0
$L71684:
  00344	8b 95 6c ff ff
	ff		 mov	 edx, DWORD PTR tv197[ebp]
  0034a	89 55 ac	 mov	 DWORD PTR _pSource$69959[ebp], edx

; 1188 :                         if (pSource)

  0034d	83 7d ac 00	 cmp	 DWORD PTR _pSource$69959[ebp], 0
  00351	74 7a		 je	 SHORT $L69962

; 1189 :                         {
; 1190 :                             pParser->SeekBack();

  00353	8b 4d 08	 mov	 ecx, DWORD PTR _pParser$[ebp]
  00356	e8 00 00 00 00	 call	 ?SeekBack@CRiffParser@@QAEJXZ ; CRiffParser::SeekBack

; 1191 :                             hr = pSource->Load(pParser->GetStream());

  0035b	8b 4d 08	 mov	 ecx, DWORD PTR _pParser$[ebp]
  0035e	e8 00 00 00 00	 call	 ?GetStream@CRiffParser@@QAEPAUIStream@@XZ ; CRiffParser::GetStream
  00363	50		 push	 eax
  00364	8b 4d ac	 mov	 ecx, DWORD PTR _pSource$69959[ebp]
  00367	e8 00 00 00 00	 call	 ?Load@CBufferConfig@@QAEJPAUIStream@@@Z ; CBufferConfig::Load
  0036c	89 45 d8	 mov	 DWORD PTR _hr$[ebp], eax

; 1192 :                             pParser->SeekForward();

  0036f	8b 4d 08	 mov	 ecx, DWORD PTR _pParser$[ebp]
  00372	e8 00 00 00 00	 call	 ?SeekForward@CRiffParser@@QAEJXZ ; CRiffParser::SeekForward

; 1193 :                             if (SUCCEEDED(hr))

  00377	83 7d d8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0037b	7c 11		 jl	 SHORT $L69964

; 1194 :                             {
; 1195 :                                 m_BufferConfigList.AddTail(pSource);

  0037d	8b 45 ac	 mov	 eax, DWORD PTR _pSource$69959[ebp]
  00380	50		 push	 eax
  00381	8b 4d 8c	 mov	 ecx, DWORD PTR _this$[ebp]
  00384	83 c1 4c	 add	 ecx, 76			; 0000004cH
  00387	e8 00 00 00 00	 call	 ?AddTail@CBufferConfigList@@QAEXPAVCBufferConfig@@@Z ; CBufferConfigList::AddTail

; 1196 :                             }
; 1197 :                             else

  0038c	eb 3d		 jmp	 SHORT $L69965
$L69964:

; 1198 :                             {
; 1199 :                                 Trace(1,"AudioPath Configuration failed loading buffer\n");

  0038e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CP@DMLIBLBB@AudioPath?5Configuration?5failed?5l@
  00393	6a 01		 push	 1
  00395	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0039a	83 c4 08	 add	 esp, 8

; 1200 :                                 delete pSource;

  0039d	8b 4d ac	 mov	 ecx, DWORD PTR _pSource$69959[ebp]
  003a0	89 4d 90	 mov	 DWORD PTR $T71686[ebp], ecx
  003a3	8b 55 90	 mov	 edx, DWORD PTR $T71686[ebp]
  003a6	89 55 94	 mov	 DWORD PTR $T71685[ebp], edx
  003a9	83 7d 94 00	 cmp	 DWORD PTR $T71685[ebp], 0
  003ad	74 12		 je	 SHORT $L71687
  003af	6a 01		 push	 1
  003b1	8b 4d 94	 mov	 ecx, DWORD PTR $T71685[ebp]
  003b4	e8 00 00 00 00	 call	 ??_GCBufferConfig@@QAEPAXI@Z
  003b9	89 85 68 ff ff
	ff		 mov	 DWORD PTR tv216[ebp], eax
  003bf	eb 0a		 jmp	 SHORT $L69965
$L71687:
  003c1	c7 85 68 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv216[ebp], 0
$L69965:

; 1201 :                             }
; 1202 :                         }
; 1203 :                         else

  003cb	eb 07		 jmp	 SHORT $L69796
$L69962:

; 1204 :                         {
; 1205 :                             hr = E_OUTOFMEMORY;

  003cd	c7 45 d8 0e 00
	07 80		 mov	 DWORD PTR _hr$[ebp], -2147024882 ; 8007000eH
$L69796:

; 1206 :                         }
; 1207 :                     }
; 1208 :                     break;                   
; 1209 :                 default:
; 1210 :                     break;
; 1211 :             }
; 1212 :             break;
; 1213 :         default:
; 1214 :             break;
; 1215 :         }
; 1216 :     }

  003d4	e9 4d fc ff ff	 jmp	 $L69793
$L69794:

; 1217 :     if (dwLoadedBoth != 3) 

  003d9	83 7d dc 03	 cmp	 DWORD PTR _dwLoadedBoth$[ebp], 3
  003dd	74 16		 je	 SHORT $L69972

; 1218 :     {
; 1219 :         hr = DMUS_E_CHUNKNOTFOUND;

  003df	c7 45 d8 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H

; 1220 :         Trace(1,"Error: Failure loading port configuration chunk in Audio Path Configuration.\n");

  003e6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EO@KIFLFOOK@Error?3?5Failure?5loading?5port?5conf@
  003eb	6a 01		 push	 1
  003ed	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  003f2	83 c4 08	 add	 esp, 8
$L69972:

; 1221 :     }
; 1222 : 
; 1223 :     // Make sure the channel groups in the portparams is large enough to handle the requested
; 1224 :     // channels in portheader.
; 1225 :     m_PortParams.dwChannelGroups = (m_PortHeader.dwPChannelCount + 15) / 16;

  003f5	8b 45 8c	 mov	 eax, DWORD PTR _this$[ebp]
  003f8	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  003fb	83 c1 0f	 add	 ecx, 15			; 0000000fH
  003fe	c1 e9 04	 shr	 ecx, 4
  00401	8b 55 8c	 mov	 edx, DWORD PTR _this$[ebp]
  00404	89 4a 2c	 mov	 DWORD PTR [edx+44], ecx

; 1226 :     m_PortParams.dwValidParams |= DMUS_PORTPARAMS_CHANNELGROUPS;

  00407	8b 45 8c	 mov	 eax, DWORD PTR _this$[ebp]
  0040a	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0040d	83 c9 02	 or	 ecx, 2
  00410	8b 55 8c	 mov	 edx, DWORD PTR _this$[ebp]
  00413	89 4a 24	 mov	 DWORD PTR [edx+36], ecx

; 1227 :     pParser->LeaveList();

  00416	8b 4d 08	 mov	 ecx, DWORD PTR _pParser$[ebp]
  00419	e8 00 00 00 00	 call	 ?LeaveList@CRiffParser@@QAEXXZ ; CRiffParser::LeaveList

; 1228 : 
; 1229 :     return hr;

  0041e	8b 45 d8	 mov	 eax, DWORD PTR _hr$[ebp]

; 1230 : }

  00421	8b e5		 mov	 esp, ebp
  00423	5d		 pop	 ebp
  00424	c2 04 00	 ret	 4
?Load@CPortConfig@@QAEJPAVCRiffParser@@@Z ENDP		; CPortConfig::Load
_TEXT	ENDS
PUBLIC	?GetNext@CPortConfig@@QAEPAV1@XZ		; CPortConfig::GetNext
PUBLIC	?GetHead@CPortConfigList@@QAEPAVCPortConfig@@XZ	; CPortConfigList::GetHead
PUBLIC	?Activate@CPortConfigList@@QAEJH@Z		; CPortConfigList::Activate
; Function compile flags: /Odt
;	COMDAT ?Activate@CPortConfigList@@QAEJH@Z
_TEXT	SEGMENT
_this$ = -16
_pUndo$69987 = -12
_hr$ = -8
_pPort$ = -4
_fActivate$ = 8
?Activate@CPortConfigList@@QAEJH@Z PROC NEAR		; CPortConfigList::Activate, COMDAT
; _this$ = ecx

; 1234 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1235 :     HRESULT hr = S_OK;

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 1236 :     CPortConfig *pPort;
; 1237 :     for (pPort = GetHead();pPort;pPort = pPort->GetNext())

  00010	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?GetHead@CPortConfigList@@QAEPAVCPortConfig@@XZ ; CPortConfigList::GetHead
  00018	89 45 fc	 mov	 DWORD PTR _pPort$[ebp], eax
  0001b	eb 0b		 jmp	 SHORT $L69982
$L69983:
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _pPort$[ebp]
  00020	e8 00 00 00 00	 call	 ?GetNext@CPortConfig@@QAEPAV1@XZ ; CPortConfig::GetNext
  00025	89 45 fc	 mov	 DWORD PTR _pPort$[ebp], eax
$L69982:
  00028	83 7d fc 00	 cmp	 DWORD PTR _pPort$[ebp], 0
  0002c	74 53		 je	 SHORT $L69984

; 1238 :     {
; 1239 :         hr = pPort->Activate(fActivate);

  0002e	8b 45 08	 mov	 eax, DWORD PTR _fActivate$[ebp]
  00031	50		 push	 eax
  00032	8b 4d fc	 mov	 ecx, DWORD PTR _pPort$[ebp]
  00035	e8 00 00 00 00	 call	 ?Activate@CPortConfig@@QAEJH@Z ; CPortConfig::Activate
  0003a	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax

; 1240 :         if (FAILED(hr))

  0003d	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00041	7d 3c		 jge	 SHORT $L69986

; 1241 :         {
; 1242 :             CPortConfig *pUndo;
; 1243 :             for (pUndo = GetHead();pUndo && (pUndo != pPort);pUndo = pUndo->GetNext())

  00043	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	e8 00 00 00 00	 call	 ?GetHead@CPortConfigList@@QAEPAVCPortConfig@@XZ ; CPortConfigList::GetHead
  0004b	89 45 f4	 mov	 DWORD PTR _pUndo$69987[ebp], eax
  0004e	eb 0b		 jmp	 SHORT $L69988
$L69989:
  00050	8b 4d f4	 mov	 ecx, DWORD PTR _pUndo$69987[ebp]
  00053	e8 00 00 00 00	 call	 ?GetNext@CPortConfig@@QAEPAV1@XZ ; CPortConfig::GetNext
  00058	89 45 f4	 mov	 DWORD PTR _pUndo$69987[ebp], eax
$L69988:
  0005b	83 7d f4 00	 cmp	 DWORD PTR _pUndo$69987[ebp], 0
  0005f	74 1c		 je	 SHORT $L69990
  00061	8b 4d f4	 mov	 ecx, DWORD PTR _pUndo$69987[ebp]
  00064	3b 4d fc	 cmp	 ecx, DWORD PTR _pPort$[ebp]
  00067	74 14		 je	 SHORT $L69990

; 1244 :             {
; 1245 :                 pUndo->Activate(!fActivate);

  00069	33 d2		 xor	 edx, edx
  0006b	83 7d 08 00	 cmp	 DWORD PTR _fActivate$[ebp], 0
  0006f	0f 94 c2	 sete	 dl
  00072	52		 push	 edx
  00073	8b 4d f4	 mov	 ecx, DWORD PTR _pUndo$69987[ebp]
  00076	e8 00 00 00 00	 call	 ?Activate@CPortConfig@@QAEJH@Z ; CPortConfig::Activate

; 1246 :             }

  0007b	eb d3		 jmp	 SHORT $L69989
$L69990:

; 1247 :             break;

  0007d	eb 02		 jmp	 SHORT $L69984
$L69986:

; 1248 :         }
; 1249 :     }

  0007f	eb 9c		 jmp	 SHORT $L69983
$L69984:

; 1250 :     return hr;

  00081	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]

; 1251 : }

  00084	8b e5		 mov	 esp, ebp
  00086	5d		 pop	 ebp
  00087	c2 04 00	 ret	 4
?Activate@CPortConfigList@@QAEJH@Z ENDP			; CPortConfigList::Activate
_TEXT	ENDS
PUBLIC	?AddTail@CPortConfigList@@QAEXPAVCPortConfig@@@Z ; CPortConfigList::AddTail
PUBLIC	?CreateRunTimeVersion@CPortConfigList@@QAEJPAV1@PAVCAudioPath@@PAVCBufferManager@@@Z ; CPortConfigList::CreateRunTimeVersion
; Function compile flags: /Odt
;	COMDAT ?CreateRunTimeVersion@CPortConfigList@@QAEJPAV1@PAVCAudioPath@@PAVCBufferManager@@@Z
_TEXT	SEGMENT
_this$ = -16
_hr$ = -12
_pScan$ = -8
_pCopy$ = -4
_pDestination$ = 8
_pParent$ = 12
_pManager$ = 16
?CreateRunTimeVersion@CPortConfigList@@QAEJPAV1@PAVCAudioPath@@PAVCBufferManager@@@Z PROC NEAR ; CPortConfigList::CreateRunTimeVersion, COMDAT
; _this$ = ecx

; 1255 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1256 :     HRESULT hr = S_OK;

  00009	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 1257 :     CPortConfig *pScan = GetHead();

  00010	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?GetHead@CPortConfigList@@QAEPAVCPortConfig@@XZ ; CPortConfigList::GetHead
  00018	89 45 f8	 mov	 DWORD PTR _pScan$[ebp], eax

; 1258 :     CPortConfig *pCopy;
; 1259 :     for (;pScan;pScan = pScan->GetNext())

  0001b	eb 0b		 jmp	 SHORT $L70001
$L70002:
  0001d	8b 4d f8	 mov	 ecx, DWORD PTR _pScan$[ebp]
  00020	e8 00 00 00 00	 call	 ?GetNext@CPortConfig@@QAEPAV1@XZ ; CPortConfig::GetNext
  00025	89 45 f8	 mov	 DWORD PTR _pScan$[ebp], eax
$L70001:
  00028	83 7d f8 00	 cmp	 DWORD PTR _pScan$[ebp], 0
  0002c	74 2f		 je	 SHORT $L70003

; 1260 :     {
; 1261 :         hr = pScan->CreateRunTimeVersion(&pCopy,pParent,pManager);

  0002e	8b 45 10	 mov	 eax, DWORD PTR _pManager$[ebp]
  00031	50		 push	 eax
  00032	8b 4d 0c	 mov	 ecx, DWORD PTR _pParent$[ebp]
  00035	51		 push	 ecx
  00036	8d 55 fc	 lea	 edx, DWORD PTR _pCopy$[ebp]
  00039	52		 push	 edx
  0003a	8b 4d f8	 mov	 ecx, DWORD PTR _pScan$[ebp]
  0003d	e8 00 00 00 00	 call	 ?CreateRunTimeVersion@CPortConfig@@QAEJPAPAV1@PAVCAudioPath@@PAVCBufferManager@@@Z ; CPortConfig::CreateRunTimeVersion
  00042	89 45 f4	 mov	 DWORD PTR _hr$[ebp], eax

; 1262 :         if (pCopy)

  00045	83 7d fc 00	 cmp	 DWORD PTR _pCopy$[ebp], 0
  00049	74 0e		 je	 SHORT $L70004

; 1263 :         {
; 1264 :             pDestination->AddTail(pCopy);

  0004b	8b 45 fc	 mov	 eax, DWORD PTR _pCopy$[ebp]
  0004e	50		 push	 eax
  0004f	8b 4d 08	 mov	 ecx, DWORD PTR _pDestination$[ebp]
  00052	e8 00 00 00 00	 call	 ?AddTail@CPortConfigList@@QAEXPAVCPortConfig@@@Z ; CPortConfigList::AddTail

; 1265 :         }
; 1266 :         else

  00057	eb 02		 jmp	 SHORT $L70005
$L70004:

; 1267 :         {
; 1268 :             break;

  00059	eb 02		 jmp	 SHORT $L70003
$L70005:

; 1269 :         }
; 1270 :     }

  0005b	eb c0		 jmp	 SHORT $L70002
$L70003:

; 1271 :     return hr;

  0005d	8b 45 f4	 mov	 eax, DWORD PTR _hr$[ebp]

; 1272 : }

  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c2 0c 00	 ret	 12			; 0000000cH
?CreateRunTimeVersion@CPortConfigList@@QAEJPAV1@PAVCAudioPath@@PAVCBufferManager@@@Z ENDP ; CPortConfigList::CreateRunTimeVersion
_TEXT	ENDS
PUBLIC	?UsesPort@CPortConfigList@@QAEHPAUIDirectMusicPort@@@Z ; CPortConfigList::UsesPort
; Function compile flags: /Odt
;	COMDAT ?UsesPort@CPortConfigList@@QAEHPAUIDirectMusicPort@@@Z
_TEXT	SEGMENT
_this$ = -8
_pScan$ = -4
_pPort$ = 8
?UsesPort@CPortConfigList@@QAEHPAUIDirectMusicPort@@@Z PROC NEAR ; CPortConfigList::UsesPort, COMDAT
; _this$ = ecx

; 1276 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1277 :     CPortConfig *pScan = GetHead();

  00009	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?GetHead@CPortConfigList@@QAEPAVCPortConfig@@XZ ; CPortConfigList::GetHead
  00011	89 45 fc	 mov	 DWORD PTR _pScan$[ebp], eax

; 1278 :     for (;pScan;pScan = pScan->GetNext())

  00014	eb 0b		 jmp	 SHORT $L70011
$L70012:
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _pScan$[ebp]
  00019	e8 00 00 00 00	 call	 ?GetNext@CPortConfig@@QAEPAV1@XZ ; CPortConfig::GetNext
  0001e	89 45 fc	 mov	 DWORD PTR _pScan$[ebp], eax
$L70011:
  00021	83 7d fc 00	 cmp	 DWORD PTR _pScan$[ebp], 0
  00025	74 14		 je	 SHORT $L70013

; 1279 :     {
; 1280 :         if (pScan->m_pPort == pPort) return TRUE;

  00027	8b 45 fc	 mov	 eax, DWORD PTR _pScan$[ebp]
  0002a	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  0002d	3b 4d 08	 cmp	 ecx, DWORD PTR _pPort$[ebp]
  00030	75 07		 jne	 SHORT $L70014
  00032	b8 01 00 00 00	 mov	 eax, 1
  00037	eb 04		 jmp	 SHORT $L70009
$L70014:

; 1281 :     } 

  00039	eb db		 jmp	 SHORT $L70012
$L70013:

; 1282 :     return FALSE;

  0003b	33 c0		 xor	 eax, eax
$L70009:

; 1283 : }

  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c2 04 00	 ret	 4
?UsesPort@CPortConfigList@@QAEHPAUIDirectMusicPort@@@Z ENDP ; CPortConfigList::UsesPort
_TEXT	ENDS
PUBLIC	??_GCPortConfig@@QAEPAXI@Z			; CPortConfig::`scalar deleting destructor'
PUBLIC	?RemoveHead@CPortConfigList@@QAEPAVCPortConfig@@XZ ; CPortConfigList::RemoveHead
PUBLIC	?Clear@CPortConfigList@@QAEXXZ			; CPortConfigList::Clear
; Function compile flags: /Odt
;	COMDAT ?Clear@CPortConfigList@@QAEXXZ
_TEXT	SEGMENT
tv71 = -20
_this$ = -16
$T71703 = -12
$T71702 = -8
_pPort$ = -4
?Clear@CPortConfigList@@QAEXXZ PROC NEAR		; CPortConfigList::Clear, COMDAT
; _this$ = ecx

; 1288 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
$L70020:

; 1289 :     CPortConfig *pPort;
; 1290 :     while (pPort = RemoveHead())

  00009	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?RemoveHead@CPortConfigList@@QAEPAVCPortConfig@@XZ ; CPortConfigList::RemoveHead
  00011	89 45 fc	 mov	 DWORD PTR _pPort$[ebp], eax
  00014	83 7d fc 00	 cmp	 DWORD PTR _pPort$[ebp], 0
  00018	74 2a		 je	 SHORT $L70017

; 1291 :     {
; 1292 :         delete pPort;

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _pPort$[ebp]
  0001d	89 45 f4	 mov	 DWORD PTR $T71703[ebp], eax
  00020	8b 4d f4	 mov	 ecx, DWORD PTR $T71703[ebp]
  00023	89 4d f8	 mov	 DWORD PTR $T71702[ebp], ecx
  00026	83 7d f8 00	 cmp	 DWORD PTR $T71702[ebp], 0
  0002a	74 0f		 je	 SHORT $L71704
  0002c	6a 01		 push	 1
  0002e	8b 4d f8	 mov	 ecx, DWORD PTR $T71702[ebp]
  00031	e8 00 00 00 00	 call	 ??_GCPortConfig@@QAEPAXI@Z
  00036	89 45 ec	 mov	 DWORD PTR tv71[ebp], eax
  00039	eb 07		 jmp	 SHORT $L71705
$L71704:
  0003b	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
$L71705:

; 1293 :     }

  00042	eb c5		 jmp	 SHORT $L70020
$L70017:

; 1294 : }

  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
?Clear@CPortConfigList@@QAEXXZ ENDP			; CPortConfigList::Clear
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??_GCPortConfig@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4
___flags$ = 8
??_GCPortConfig@@QAEPAXI@Z PROC NEAR			; CPortConfig::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CPortConfig@@QAE@XZ	; CPortConfig::~CPortConfig
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $L70027
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$L70027:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GCPortConfig@@QAEPAXI@Z ENDP				; CPortConfig::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??0IDirectMusicAudioPath@@QAE@XZ		; IDirectMusicAudioPath::IDirectMusicAudioPath
PUBLIC	??0IDirectMusicGraph@@QAE@XZ			; IDirectMusicGraph::IDirectMusicGraph
PUBLIC	??0CPortConfigList@@QAE@XZ			; CPortConfigList::CPortConfigList
PUBLIC	??0CAudioPath@@QAE@XZ				; CAudioPath::CAudioPath
PUBLIC	?QueryInterface@CAudioPath@@UAGJABU_GUID@@PAPAX@Z ; CAudioPath::QueryInterface
PUBLIC	?AddRef@CAudioPath@@UAGKXZ			; CAudioPath::AddRef
PUBLIC	?Release@CAudioPath@@UAGKXZ			; CAudioPath::Release
PUBLIC	?GetObjectInPath@CAudioPath@@UAGJKKKABU_GUID@@K0PAPAX@Z ; CAudioPath::GetObjectInPath
PUBLIC	?Activate@CAudioPath@@UAGJH@Z			; CAudioPath::Activate
PUBLIC	?SetVolume@CAudioPath@@UAGJJK@Z			; CAudioPath::SetVolume
PUBLIC	?ConvertPChannel@CAudioPath@@UAGJKPAK@Z		; CAudioPath::ConvertPChannel
PUBLIC	?SetPitch@CAudioPath@@UAGJJK@Z			; CAudioPath::SetPitch
PUBLIC	?InsertTool@CAudioPath@@UAGJPAUIDirectMusicTool@@PAKKJ@Z ; CAudioPath::InsertTool
PUBLIC	?GetTool@CAudioPath@@UAGJKPAPAUIDirectMusicTool@@@Z ; CAudioPath::GetTool
PUBLIC	?RemoveTool@CAudioPath@@UAGJPAUIDirectMusicTool@@@Z ; CAudioPath::RemoveTool
PUBLIC	?StampPMsg@CAudioPath@@UAGJPAU_DMUS_PMSG@@@Z	; CAudioPath::StampPMsg
PUBLIC	??_7CAudioPath@@6BIDirectMusicAudioPath@@@	; CAudioPath::`vftable'
PUBLIC	??_7CAudioPath@@6BIDirectMusicGraph@@@		; CAudioPath::`vftable'
PUBLIC	?QueryInterface@CAudioPath@@W3AGJABU_GUID@@PAPAX@Z ; CAudioPath::QueryInterface
PUBLIC	?AddRef@CAudioPath@@W3AGKXZ			; CAudioPath::AddRef
PUBLIC	?Release@CAudioPath@@W3AGKXZ			; CAudioPath::Release
EXTRN	??0CMemTrack@@QAE@K@Z:NEAR			; CMemTrack::CMemTrack
EXTRN	__imp__RtlInitializeCriticalSection@4:NEAR
;	COMDAT ??_7CAudioPath@@6BIDirectMusicAudioPath@@@
CONST	SEGMENT
??_7CAudioPath@@6BIDirectMusicAudioPath@@@ DD FLAT:?QueryInterface@CAudioPath@@UAGJABU_GUID@@PAPAX@Z ; CAudioPath::`vftable'
	DD	FLAT:?AddRef@CAudioPath@@UAGKXZ
	DD	FLAT:?Release@CAudioPath@@UAGKXZ
	DD	FLAT:?GetObjectInPath@CAudioPath@@UAGJKKKABU_GUID@@K0PAPAX@Z
	DD	FLAT:?Activate@CAudioPath@@UAGJH@Z
	DD	FLAT:?SetVolume@CAudioPath@@UAGJJK@Z
	DD	FLAT:?SetPitch@CAudioPath@@UAGJJK@Z
	DD	FLAT:?ConvertPChannel@CAudioPath@@UAGJKPAK@Z
CONST	ENDS
;	COMDAT ??_7CAudioPath@@6BIDirectMusicGraph@@@
CONST	SEGMENT
??_7CAudioPath@@6BIDirectMusicGraph@@@ DD FLAT:?QueryInterface@CAudioPath@@W3AGJABU_GUID@@PAPAX@Z ; CAudioPath::`vftable'
	DD	FLAT:?AddRef@CAudioPath@@W3AGKXZ
	DD	FLAT:?Release@CAudioPath@@W3AGKXZ
	DD	FLAT:?StampPMsg@CAudioPath@@UAGJPAU_DMUS_PMSG@@@Z
	DD	FLAT:?InsertTool@CAudioPath@@UAGJPAUIDirectMusicTool@@PAKKJ@Z
	DD	FLAT:?GetTool@CAudioPath@@UAGJKPAPAUIDirectMusicTool@@@Z
	DD	FLAT:?RemoveTool@CAudioPath@@UAGJPAUIDirectMusicTool@@@Z
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ??0CAudioPath@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CAudioPath@@QAE@XZ PROC NEAR				; CAudioPath::CAudioPath, COMDAT
; _this$ = ecx

; 1298 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0IDirectMusicAudioPath@@QAE@XZ
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	83 c1 04	 add	 ecx, 4
  00015	e8 00 00 00 00	 call	 ??0IDirectMusicGraph@@QAE@XZ
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	83 c1 08	 add	 ecx, 8
  00020	e8 00 00 00 00	 call	 ??0AListItem@@QAE@XZ	; AListItem::AListItem
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CAudioPath@@6BIDirectMusicAudioPath@@@
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET FLAT:??_7CAudioPath@@6BIDirectMusicGraph@@@
  00038	6a 09		 push	 9
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00040	e8 00 00 00 00	 call	 ??0CMemTrack@@QAE@K@Z	; CMemTrack::CMemTrack
  00045	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	83 c1 68	 add	 ecx, 104		; 00000068H
  0004b	e8 00 00 00 00	 call	 ??0CPortConfigList@@QAE@XZ
  00050	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	83 c1 6c	 add	 ecx, 108		; 0000006cH
  00056	e8 00 00 00 00	 call	 ??0CBufferConfigList@@QAE@XZ

; 1299 :     TraceI(2,"Creating AudioPath %lx\n",this);
; 1300 :     INITIALIZE_CRITICAL_SECTION(&m_CriticalSection);

  0005b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0005e	83 c2 2c	 add	 edx, 44			; 0000002cH
  00061	52		 push	 edx
  00062	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitializeCriticalSection@4

; 1301 :     m_fDeactivating = FALSE;

  00068	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006b	c7 40 28 00 00
	00 00		 mov	 DWORD PTR [eax+40], 0

; 1302 :     m_rtLastVolChange = 0;

  00072	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0
  0007c	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 1303 :     m_rtLastPitchChange = 0;

  00083	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00086	c7 42 20 00 00
	00 00		 mov	 DWORD PTR [edx+32], 0
  0008d	c7 42 24 00 00
	00 00		 mov	 DWORD PTR [edx+36], 0

; 1304 :     m_cRef = 0;

  00094	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00097	c7 40 4c 00 00
	00 00		 mov	 DWORD PTR [eax+76], 0

; 1305 :     m_fActive = FALSE;

  0009e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a1	c7 41 48 00 00
	00 00		 mov	 DWORD PTR [ecx+72], 0

; 1306 :     m_pdwVChannels = NULL;

  000a8	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000ab	c7 42 50 00 00
	00 00		 mov	 DWORD PTR [edx+80], 0

; 1307 :     m_pdwPChannels = NULL;

  000b2	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000b5	c7 40 54 00 00
	00 00		 mov	 DWORD PTR [eax+84], 0

; 1308 :     m_dwChannelCount = 0;

  000bc	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000bf	c7 41 58 00 00
	00 00		 mov	 DWORD PTR [ecx+88], 0

; 1309 :     m_pPerformance = NULL;

  000c6	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000c9	c7 42 60 00 00
	00 00		 mov	 DWORD PTR [edx+96], 0

; 1310 :     m_pGraph = NULL;

  000d0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000d3	c7 40 5c 00 00
	00 00		 mov	 DWORD PTR [eax+92], 0

; 1311 :     m_pConfig = NULL;

  000da	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000dd	c7 41 64 00 00
	00 00		 mov	 DWORD PTR [ecx+100], 0

; 1312 :     m_pUnkDispatch = NULL;

  000e4	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000e7	c7 42 70 00 00
	00 00		 mov	 DWORD PTR [edx+112], 0

; 1313 : }

  000ee	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000f1	8b e5		 mov	 esp, ebp
  000f3	5d		 pop	 ebp
  000f4	c3		 ret	 0
??0CAudioPath@@QAE@XZ ENDP				; CAudioPath::CAudioPath
_TEXT	ENDS
PUBLIC	??0IUnknown@@QAE@XZ				; IUnknown::IUnknown
; Function compile flags: /Odt
;	COMDAT ??0IDirectMusicAudioPath@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0IDirectMusicAudioPath@@QAE@XZ PROC NEAR		; IDirectMusicAudioPath::IDirectMusicAudioPath, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0IUnknown@@QAE@XZ
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0IDirectMusicAudioPath@@QAE@XZ ENDP			; IDirectMusicAudioPath::IDirectMusicAudioPath
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0IDirectMusicGraph@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0IDirectMusicGraph@@QAE@XZ PROC NEAR			; IDirectMusicGraph::IDirectMusicGraph, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0IUnknown@@QAE@XZ
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0IDirectMusicGraph@@QAE@XZ ENDP			; IDirectMusicGraph::IDirectMusicGraph
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0CPortConfigList@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CPortConfigList@@QAE@XZ PROC NEAR			; CPortConfigList::CPortConfigList, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0AList@@QAE@XZ	; AList::AList
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0CPortConfigList@@QAE@XZ ENDP				; CPortConfigList::CPortConfigList
_TEXT	ENDS
PUBLIC	??1CAudioPath@@QAE@XZ				; CAudioPath::~CAudioPath
PUBLIC	?Deactivate@CAudioPath@@QAEXXZ			; CAudioPath::Deactivate
PUBLIC	?DeleteCriticalSection@@YGXPAX@Z		; DeleteCriticalSection
EXTRN	??1CMemTrack@@QAE@XZ:NEAR			; CMemTrack::~CMemTrack
EXTRN	__imp__RtlEnterCriticalSection@4:NEAR
EXTRN	__imp__RtlLeaveCriticalSection@4:NEAR
; Function compile flags: /Odt
;	COMDAT ??1CAudioPath@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1CAudioPath@@QAE@XZ PROC NEAR				; CAudioPath::~CAudioPath, COMDAT
; _this$ = ecx

; 1317 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CAudioPath@@6BIDirectMusicAudioPath@@@
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET FLAT:??_7CAudioPath@@6BIDirectMusicGraph@@@

; 1318 :     ENTER_CRITICAL_SECTION(&m_CriticalSection);

  0001a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	83 c2 2c	 add	 edx, 44			; 0000002cH
  00020	52		 push	 edx
  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 1319 :     if (m_pUnkDispatch)

  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	83 78 70 00	 cmp	 DWORD PTR [eax+112], 0
  0002e	74 12		 je	 SHORT $L70041

; 1320 :     {
; 1321 :         m_pUnkDispatch->Release(); // free IDispatch implementation we may have borrowed

  00030	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	8b 51 70	 mov	 edx, DWORD PTR [ecx+112]
  00036	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00039	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  0003c	8b 12		 mov	 edx, DWORD PTR [edx]
  0003e	51		 push	 ecx
  0003f	ff 52 08	 call	 DWORD PTR [edx+8]
$L70041:

; 1322 :     }
; 1323 :     LEAVE_CRITICAL_SECTION(&m_CriticalSection);

  00042	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00045	83 c0 2c	 add	 eax, 44			; 0000002cH
  00048	50		 push	 eax
  00049	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 1324 :     Deactivate();

  0004f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00052	e8 00 00 00 00	 call	 ?Deactivate@CAudioPath@@QAEXXZ ; CAudioPath::Deactivate

; 1325 :     DELETE_CRITICAL_SECTION(&m_CriticalSection);

  00057	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005a	83 c1 2c	 add	 ecx, 44			; 0000002cH
  0005d	51		 push	 ecx
  0005e	e8 00 00 00 00	 call	 ?DeleteCriticalSection@@YGXPAX@Z ; DeleteCriticalSection

; 1326 : }

  00063	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00066	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00069	e8 00 00 00 00	 call	 ??1CMemTrack@@QAE@XZ	; CMemTrack::~CMemTrack
  0006e	8b e5		 mov	 esp, ebp
  00070	5d		 pop	 ebp
  00071	c3		 ret	 0
??1CAudioPath@@QAE@XZ ENDP				; CAudioPath::~CAudioPath
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?AddRef@CAudioPath@@UAGKXZ
_TEXT	SEGMENT
_this$ = 8
?AddRef@CAudioPath@@UAGKXZ PROC NEAR			; CAudioPath::AddRef, COMDAT

; 1329 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1330 :     return InterlockedIncrement(&m_cRef);

  00003	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00006	83 c0 4c	 add	 eax, 76			; 0000004cH
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 __InterlockedIncrement@4

; 1331 : }

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?AddRef@CAudioPath@@UAGKXZ ENDP				; CAudioPath::AddRef
_TEXT	ENDS
PUBLIC	??_GCAudioPath@@QAEPAXI@Z			; CAudioPath::`scalar deleting destructor'
; Function compile flags: /Odt
;	COMDAT ?Release@CAudioPath@@UAGKXZ
_TEXT	SEGMENT
tv72 = -12
$T71731 = -8
$T71730 = -4
_this$ = 8
?Release@CAudioPath@@UAGKXZ PROC NEAR			; CAudioPath::Release, COMDAT

; 1334 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1335 :     if (!InterlockedDecrement(&m_cRef))

  00006	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00009	83 c0 4c	 add	 eax, 76			; 0000004cH
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 __InterlockedDecrement@4
  00012	85 c0		 test	 eax, eax
  00014	75 2c		 jne	 SHORT $L70048

; 1336 :     {
; 1337 :         delete this;

  00016	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	89 4d f8	 mov	 DWORD PTR $T71731[ebp], ecx
  0001c	8b 55 f8	 mov	 edx, DWORD PTR $T71731[ebp]
  0001f	89 55 fc	 mov	 DWORD PTR $T71730[ebp], edx
  00022	83 7d fc 00	 cmp	 DWORD PTR $T71730[ebp], 0
  00026	74 0f		 je	 SHORT $L71732
  00028	6a 01		 push	 1
  0002a	8b 4d fc	 mov	 ecx, DWORD PTR $T71730[ebp]
  0002d	e8 00 00 00 00	 call	 ??_GCAudioPath@@QAEPAXI@Z
  00032	89 45 f4	 mov	 DWORD PTR tv72[ebp], eax
  00035	eb 07		 jmp	 SHORT $L71733
$L71732:
  00037	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv72[ebp], 0
$L71733:

; 1338 :         return 0;

  0003e	33 c0		 xor	 eax, eax
  00040	eb 06		 jmp	 SHORT $L70047
$L70048:

; 1339 :     }
; 1340 : 
; 1341 :     return m_cRef;

  00042	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00045	8b 40 4c	 mov	 eax, DWORD PTR [eax+76]
$L70047:

; 1342 : }

  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c2 04 00	 ret	 4
?Release@CAudioPath@@UAGKXZ ENDP			; CAudioPath::Release
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??_GCAudioPath@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4
___flags$ = 8
??_GCAudioPath@@QAEPAXI@Z PROC NEAR			; CAudioPath::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CAudioPath@@QAE@XZ	; CAudioPath::~CAudioPath
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $L70054
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$L70054:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GCAudioPath@@QAEPAXI@Z ENDP				; CAudioPath::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_C@_0BJ@IGMLCEHI@?$CFs?3?5Invalid?5pointer?5ppv?6?$AA@ ; `string'
PUBLIC	??_C@_0CB@NHMFCKLP@?$CFs?3?5Invalid?5pointer?5?$CIvoid?$CK?$CJ?$CGiid?6@ ; `string'
PUBLIC	??_C@_0EB@HBMHDLLO@Warning?3?5Request?5to?5query?5unknow@ ; `string'
EXTRN	_CLSID_AutDirectMusicAudioPath:BYTE
EXTRN	_IID_IDispatch:BYTE
EXTRN	_IID_CAudioPath:BYTE
EXTRN	_DebugBreak@0:NEAR
EXTRN	_IID_IUnknown:BYTE
EXTRN	_IID_IDirectMusicGraph:BYTE
EXTRN	_IID_IDirectMusicAudioPath:BYTE
EXTRN	_DirectMusicCreateInstance@16:NEAR
EXTRN	_IsBadReadPtr@8:NEAR
EXTRN	_IsBadWritePtr@8:NEAR
;	COMDAT ?__szValidateInterfaceName@?1??QueryInterface@CAudioPath@@UAGJABU_GUID@@PAPAX@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??QueryInterface@CAudioPath@@UAGJABU_GUID@@PAPAX@Z@4QBDB DB 'C'
	DB	'AudioPath::QueryInterface', 00H		; `CAudioPath::QueryInterface'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0BJ@IGMLCEHI@?$CFs?3?5Invalid?5pointer?5ppv?6?$AA@
CONST	SEGMENT
??_C@_0BJ@IGMLCEHI@?$CFs?3?5Invalid?5pointer?5ppv?6?$AA@ DB '%s: Invalid '
	DB	'pointer ppv', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@NHMFCKLP@?$CFs?3?5Invalid?5pointer?5?$CIvoid?$CK?$CJ?$CGiid?6@
CONST	SEGMENT
??_C@_0CB@NHMFCKLP@?$CFs?3?5Invalid?5pointer?5?$CIvoid?$CK?$CJ?$CGiid?6@ DB '%'
	DB	's: Invalid pointer (void*)&iid', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@HBMHDLLO@Warning?3?5Request?5to?5query?5unknow@
CONST	SEGMENT
??_C@_0EB@HBMHDLLO@Warning?3?5Request?5to?5query?5unknow@ DB 'Warning: Re'
	DB	'quest to query unknown interface on AudioPath object', 0aH, 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?QueryInterface@CAudioPath@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
tv128 = -4
_this$ = 8
_iid$ = 12
_ppv$ = 16
?QueryInterface@CAudioPath@@UAGJABU_GUID@@PAPAX@Z PROC NEAR ; CAudioPath::QueryInterface, COMDAT

; 1347 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1348 :     V_INAME(CAudioPath::QueryInterface);
; 1349 :     V_PTRPTR_WRITE(ppv);

  00004	6a 04		 push	 4
  00006	8b 45 10	 mov	 eax, DWORD PTR _ppv$[ebp]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  0000f	85 c0		 test	 eax, eax
  00011	74 19		 je	 SHORT $L70063
  00013	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??QueryInterface@CAudioPath@@UAGJABU_GUID@@PAPAX@Z@4QBDB
  00018	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BJ@IGMLCEHI@?$CFs?3?5Invalid?5pointer?5ppv?6?$AA@
  0001d	6a ff		 push	 -1
  0001f	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00024	83 c4 0c	 add	 esp, 12			; 0000000cH
  00027	e8 00 00 00 00	 call	 _DebugBreak@0
$L70063:

; 1350 :     V_REFGUID(iid);

  0002c	6a 10		 push	 16			; 00000010H
  0002e	8b 4d 0c	 mov	 ecx, DWORD PTR _iid$[ebp]
  00031	51		 push	 ecx
  00032	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  00037	85 c0		 test	 eax, eax
  00039	74 19		 je	 SHORT $L70067
  0003b	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??QueryInterface@CAudioPath@@UAGJABU_GUID@@PAPAX@Z@4QBDB
  00040	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CB@NHMFCKLP@?$CFs?3?5Invalid?5pointer?5?$CIvoid?$CK?$CJ?$CGiid?6@
  00045	6a ff		 push	 -1
  00047	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0004c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004f	e8 00 00 00 00	 call	 _DebugBreak@0
$L70067:

; 1351 : 
; 1352 :     *ppv = NULL;

  00054	8b 55 10	 mov	 edx, DWORD PTR _ppv$[ebp]
  00057	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 1353 :     if (iid == IID_IUnknown || iid == IID_IDirectMusicAudioPath)

  0005d	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IUnknown
  00062	8b 45 0c	 mov	 eax, DWORD PTR _iid$[ebp]
  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 _==@8
  0006b	85 c0		 test	 eax, eax
  0006d	75 12		 jne	 SHORT $L70070
  0006f	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IDirectMusicAudioPath
  00074	8b 4d 0c	 mov	 ecx, DWORD PTR _iid$[ebp]
  00077	51		 push	 ecx
  00078	e8 00 00 00 00	 call	 _==@8
  0007d	85 c0		 test	 eax, eax
  0007f	74 0d		 je	 SHORT $L70069
$L70070:

; 1354 :     {
; 1355 :         *ppv = static_cast<IDirectMusicAudioPath*>(this);

  00081	8b 55 10	 mov	 edx, DWORD PTR _ppv$[ebp]
  00084	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00087	89 02		 mov	 DWORD PTR [edx], eax

; 1356 :     } else

  00089	e9 ad 00 00 00	 jmp	 $L70072
$L70069:

; 1357 :     if (iid == IID_CAudioPath)

  0008e	68 00 00 00 00	 push	 OFFSET FLAT:_IID_CAudioPath
  00093	8b 4d 0c	 mov	 ecx, DWORD PTR _iid$[ebp]
  00096	51		 push	 ecx
  00097	e8 00 00 00 00	 call	 _==@8
  0009c	85 c0		 test	 eax, eax
  0009e	74 0d		 je	 SHORT $L70073

; 1358 :     {
; 1359 :         *ppv = static_cast<CAudioPath*>(this);

  000a0	8b 55 10	 mov	 edx, DWORD PTR _ppv$[ebp]
  000a3	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  000a6	89 02		 mov	 DWORD PTR [edx], eax

; 1360 :     } else 

  000a8	e9 8e 00 00 00	 jmp	 $L70072
$L70073:

; 1361 :     if (iid == IID_IDirectMusicGraph)

  000ad	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IDirectMusicGraph
  000b2	8b 4d 0c	 mov	 ecx, DWORD PTR _iid$[ebp]
  000b5	51		 push	 ecx
  000b6	e8 00 00 00 00	 call	 _==@8
  000bb	85 c0		 test	 eax, eax
  000bd	74 22		 je	 SHORT $L70076

; 1362 :     {
; 1363 :         *ppv = static_cast<IDirectMusicGraph*>(this);

  000bf	83 7d 08 00	 cmp	 DWORD PTR _this$[ebp], 0
  000c3	74 0b		 je	 SHORT $L71740
  000c5	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  000c8	83 c2 04	 add	 edx, 4
  000cb	89 55 fc	 mov	 DWORD PTR tv128[ebp], edx
  000ce	eb 07		 jmp	 SHORT $L71741
$L71740:
  000d0	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv128[ebp], 0
$L71741:
  000d7	8b 45 10	 mov	 eax, DWORD PTR _ppv$[ebp]
  000da	8b 4d fc	 mov	 ecx, DWORD PTR tv128[ebp]
  000dd	89 08		 mov	 DWORD PTR [eax], ecx

; 1364 :     }
; 1365 :     else if (iid == IID_IDispatch)

  000df	eb 5a		 jmp	 SHORT $L70072
$L70076:
  000e1	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IDispatch
  000e6	8b 55 0c	 mov	 edx, DWORD PTR _iid$[ebp]
  000e9	52		 push	 edx
  000ea	e8 00 00 00 00	 call	 _==@8
  000ef	85 c0		 test	 eax, eax
  000f1	74 48		 je	 SHORT $L70072

; 1366 :     {
; 1367 :         // A helper scripting object implements IDispatch, which we expose via COM aggregation.
; 1368 :         if (!m_pUnkDispatch)

  000f3	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  000f6	83 78 70 00	 cmp	 DWORD PTR [eax+112], 0
  000fa	75 1a		 jne	 SHORT $L70080

; 1369 :         {
; 1370 :             // Create the helper object
; 1371 :             DirectMusicCreateInstance(CLSID_AutDirectMusicAudioPath,
; 1372 :                 static_cast<IDirectMusicAudioPath*>(this),
; 1373 :                 IID_IUnknown,
; 1374 :                 reinterpret_cast<void**>(&m_pUnkDispatch));

  000fc	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000ff	83 c1 70	 add	 ecx, 112		; 00000070H
  00102	51		 push	 ecx
  00103	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IUnknown
  00108	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0010b	52		 push	 edx
  0010c	68 00 00 00 00	 push	 OFFSET FLAT:_CLSID_AutDirectMusicAudioPath
  00111	e8 00 00 00 00	 call	 _DirectMusicCreateInstance@16
$L70080:

; 1375 :         }
; 1376 :         if (m_pUnkDispatch)

  00116	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00119	83 78 70 00	 cmp	 DWORD PTR [eax+112], 0
  0011d	74 1c		 je	 SHORT $L70072

; 1377 :         {
; 1378 :             return m_pUnkDispatch->QueryInterface(IID_IDispatch, ppv);

  0011f	8b 4d 10	 mov	 ecx, DWORD PTR _ppv$[ebp]
  00122	51		 push	 ecx
  00123	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IDispatch
  00128	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0012b	8b 42 70	 mov	 eax, DWORD PTR [edx+112]
  0012e	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00131	8b 51 70	 mov	 edx, DWORD PTR [ecx+112]
  00134	8b 00		 mov	 eax, DWORD PTR [eax]
  00136	52		 push	 edx
  00137	ff 10		 call	 DWORD PTR [eax]
  00139	eb 2c		 jmp	 SHORT $L70059
$L70072:

; 1379 :         }
; 1380 :     }
; 1381 : 
; 1382 :     if (*ppv == NULL)

  0013b	8b 4d 10	 mov	 ecx, DWORD PTR _ppv$[ebp]
  0013e	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00141	75 16		 jne	 SHORT $L70084

; 1383 :     {
; 1384 :         Trace(4,"Warning: Request to query unknown interface on AudioPath object\n");

  00143	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@HBMHDLLO@Warning?3?5Request?5to?5query?5unknow@
  00148	6a 04		 push	 4
  0014a	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0014f	83 c4 08	 add	 esp, 8

; 1385 :         return E_NOINTERFACE;

  00152	b8 02 40 00 80	 mov	 eax, -2147467262	; 80004002H
  00157	eb 0e		 jmp	 SHORT $L70059
$L70084:

; 1386 :     }
; 1387 : 
; 1388 :     reinterpret_cast<IUnknown*>(this)->AddRef();

  00159	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0015c	8b 02		 mov	 eax, DWORD PTR [edx]
  0015e	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00161	51		 push	 ecx
  00162	ff 50 04	 call	 DWORD PTR [eax+4]

; 1389 :     return S_OK;

  00165	33 c0		 xor	 eax, eax
$L70059:

; 1390 : }

  00167	8b e5		 mov	 esp, ebp
  00169	5d		 pop	 ebp
  0016a	c2 0c 00	 ret	 12			; 0000000cH
?QueryInterface@CAudioPath@@UAGJABU_GUID@@PAPAX@Z ENDP	; CAudioPath::QueryInterface
_TEXT	ENDS
PUBLIC	??_C@_0BO@IBOJFPEI@?$CFs?3?5Invalid?5argument?5lVolume?6?$AA@ ; `string'
EXTRN	?VolumeToMidi@CParamMerger@@SGEJ@Z:NEAR		; CParamMerger::VolumeToMidi
EXTRN	?FlushVirtualTrack@CPerformance@@QAEJKJK@Z:NEAR	; CPerformance::FlushVirtualTrack
;	COMDAT ?__szValidateInterfaceName@?1??SetVolume@CAudioPath@@UAGJJK@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??SetVolume@CAudioPath@@UAGJJK@Z@4QBDB DB 'A'
	DB	'udioPath::SetVolume', 00H			; `CAudioPath::SetVolume'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0BO@IBOJFPEI@?$CFs?3?5Invalid?5argument?5lVolume?6?$AA@
CONST	SEGMENT
??_C@_0BO@IBOJFPEI@?$CFs?3?5Invalid?5argument?5lVolume?6?$AA@ DB '%s: Inv'
	DB	'alid argument lVolume', 0aH, 00H		; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?SetVolume@CAudioPath@@UAGJJK@Z
_TEXT	SEGMENT
tv236 = -40
tv235 = -32
tv215 = -28
_rtTimeNow$70109 = -24
_mtNow$70110 = -16
_hr$ = -12
_bMIDIVol$ = -5
_pCurve$ = -4
_this$ = 8
_lVolume$ = 12
_dwDuration$ = 16
?SetVolume@CAudioPath@@UAGJJK@Z PROC NEAR		; CAudioPath::SetVolume, COMDAT

; 1394 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H

; 1395 :     V_INAME(AudioPath::SetVolume);
; 1396 : #if defined(DBG) || defined(DXAPI)
; 1397 :     if (lVolume < DSBVOLUME_MIN || lVolume > DSBVOLUME_MAX)

  00006	81 7d 0c f0 d8
	ff ff		 cmp	 DWORD PTR _lVolume$[ebp], -10000 ; ffffd8f0H
  0000d	7c 06		 jl	 SHORT $L70097
  0000f	83 7d 0c 00	 cmp	 DWORD PTR _lVolume$[ebp], 0
  00013	7e 19		 jle	 SHORT $L70096
$L70097:

; 1398 :     {
; 1399 :         RIP_E_INVALIDARG(lVolume)

  00015	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??SetVolume@CAudioPath@@UAGJJK@Z@4QBDB
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@IBOJFPEI@?$CFs?3?5Invalid?5argument?5lVolume?6?$AA@
  0001f	6a ff		 push	 -1
  00021	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH
  00029	e8 00 00 00 00	 call	 _DebugBreak@0
$L70096:

; 1400 :     }
; 1401 : #endif
; 1402 :     HRESULT hr = E_FAIL; // This should never happen, since the audiopath is created by the performance. 

  0002e	c7 45 f4 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H

; 1403 :     BYTE bMIDIVol = CParamMerger::VolumeToMidi(lVolume);

  00035	8b 45 0c	 mov	 eax, DWORD PTR _lVolume$[ebp]
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 ?VolumeToMidi@CParamMerger@@SGEJ@Z ; CParamMerger::VolumeToMidi
  0003e	88 45 fb	 mov	 BYTE PTR _bMIDIVol$[ebp], al

; 1404 : 
; 1405 :     DMUS_CURVE_PMSG *pCurve;
; 1406 :     // Clamp to an hour!
; 1407 :     if (dwDuration > (60 * 60 * 1000)) dwDuration = (60 * 60 * 1000);

  00041	81 7d 10 80 ee
	36 00		 cmp	 DWORD PTR _dwDuration$[ebp], 3600000 ; 0036ee80H
  00048	76 07		 jbe	 SHORT $L70103
  0004a	c7 45 10 80 ee
	36 00		 mov	 DWORD PTR _dwDuration$[ebp], 3600000 ; 0036ee80H
$L70103:

; 1408 :     ENTER_CRITICAL_SECTION(&m_CriticalSection);

  00051	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	83 c1 2c	 add	 ecx, 44			; 0000002cH
  00057	51		 push	 ecx
  00058	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 1409 :     ENTER_API_CRITICAL_SECTION;
; 1410 :     if (m_pPerformance)

  0005e	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00061	83 7a 60 00	 cmp	 DWORD PTR [edx+96], 0
  00065	0f 84 bd 01 00
	00		 je	 $L70104

; 1411 :     {
; 1412 :         hr = m_pPerformance->AllocPMsg(sizeof(DMUS_CURVE_PMSG),(DMUS_PMSG **)&pCurve);

  0006b	8d 45 fc	 lea	 eax, DWORD PTR _pCurve$[ebp]
  0006e	50		 push	 eax
  0006f	6a 58		 push	 88			; 00000058H
  00071	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00074	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  00077	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0007a	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  0007d	8b 12		 mov	 edx, DWORD PTR [edx]
  0007f	51		 push	 ecx
  00080	ff 52 24	 call	 DWORD PTR [edx+36]
  00083	89 45 f4	 mov	 DWORD PTR _hr$[ebp], eax

; 1413 :         if (SUCCEEDED(hr))

  00086	83 7d f4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0008a	0f 8c 96 01 00
	00		 jl	 $L70108

; 1414 :         {
; 1415 :             REFERENCE_TIME rtTimeNow = 0;

  00090	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _rtTimeNow$70109[ebp], 0
  00097	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _rtTimeNow$70109[ebp+4], 0

; 1416 :             MUSIC_TIME mtNow;
; 1417 :             m_pPerformance->GetQueueTime(&rtTimeNow);

  0009e	8d 45 e8	 lea	 eax, DWORD PTR _rtTimeNow$70109[ebp]
  000a1	50		 push	 eax
  000a2	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000a5	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  000a8	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  000ab	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  000ae	8b 12		 mov	 edx, DWORD PTR [edx]
  000b0	51		 push	 ecx
  000b1	ff 92 84 00 00
	00		 call	 DWORD PTR [edx+132]

; 1418 :             // Get the equivalent music time so each copy of the curve doesn't need to recompute.
; 1419 :             m_pPerformance->ReferenceToMusicTime(rtTimeNow,&mtNow);

  000b7	8d 45 f0	 lea	 eax, DWORD PTR _mtNow$70110[ebp]
  000ba	50		 push	 eax
  000bb	8b 4d ec	 mov	 ecx, DWORD PTR _rtTimeNow$70109[ebp+4]
  000be	51		 push	 ecx
  000bf	8b 55 e8	 mov	 edx, DWORD PTR _rtTimeNow$70109[ebp]
  000c2	52		 push	 edx
  000c3	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  000c6	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  000c9	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  000cc	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  000cf	8b 09		 mov	 ecx, DWORD PTR [ecx]
  000d1	50		 push	 eax
  000d2	ff 51 18	 call	 DWORD PTR [ecx+24]

; 1420 :             // If this starts before a previous fade ended, invalidate it.
; 1421 :             if (m_rtLastVolChange > rtTimeNow)

  000d5	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  000d8	89 55 e4	 mov	 DWORD PTR tv215[ebp], edx
  000db	8b 45 e4	 mov	 eax, DWORD PTR tv215[ebp]
  000de	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  000e1	3b 4d ec	 cmp	 ecx, DWORD PTR _rtTimeNow$70109[ebp+4]
  000e4	7c 25		 jl	 SHORT $L70111
  000e6	7f 0b		 jg	 SHORT $L71745
  000e8	8b 55 e4	 mov	 edx, DWORD PTR tv215[ebp]
  000eb	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  000ee	3b 45 e8	 cmp	 eax, DWORD PTR _rtTimeNow$70109[ebp]
  000f1	76 18		 jbe	 SHORT $L70111
$L71745:

; 1422 :             {
; 1423 :                 m_pPerformance->FlushVirtualTrack(m_dwTrackID,mtNow,0);

  000f3	6a 00		 push	 0
  000f5	8b 4d f0	 mov	 ecx, DWORD PTR _mtNow$70110[ebp]
  000f8	51		 push	 ecx
  000f9	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  000fc	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  000ff	50		 push	 eax
  00100	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00103	8b 49 60	 mov	 ecx, DWORD PTR [ecx+96]
  00106	e8 00 00 00 00	 call	 ?FlushVirtualTrack@CPerformance@@QAEJKJK@Z ; CPerformance::FlushVirtualTrack
$L70111:

; 1424 :             }
; 1425 :             if (m_rtLastVolChange < (rtTimeNow + (dwDuration * 10000)))

  0010b	8b 55 10	 mov	 edx, DWORD PTR _dwDuration$[ebp]
  0010e	69 d2 10 27 00
	00		 imul	 edx, 10000		; 00002710H
  00114	33 c0		 xor	 eax, eax
  00116	8b 4d e8	 mov	 ecx, DWORD PTR _rtTimeNow$70109[ebp]
  00119	03 ca		 add	 ecx, edx
  0011b	8b 55 ec	 mov	 edx, DWORD PTR _rtTimeNow$70109[ebp+4]
  0011e	13 d0		 adc	 edx, eax
  00120	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00123	89 45 e0	 mov	 DWORD PTR tv235[ebp], eax
  00126	89 4d d8	 mov	 DWORD PTR tv236[ebp], ecx
  00129	89 55 dc	 mov	 DWORD PTR tv236[ebp+4], edx
  0012c	8b 4d e0	 mov	 ecx, DWORD PTR tv235[ebp]
  0012f	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00132	3b 55 dc	 cmp	 edx, DWORD PTR tv236[ebp+4]
  00135	7f 2b		 jg	 SHORT $L70112
  00137	7c 0b		 jl	 SHORT $L71746
  00139	8b 45 e0	 mov	 eax, DWORD PTR tv235[ebp]
  0013c	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0013f	3b 4d d8	 cmp	 ecx, DWORD PTR tv236[ebp]
  00142	73 1e		 jae	 SHORT $L70112
$L71746:

; 1426 :             {
; 1427 :                 m_rtLastVolChange = rtTimeNow + (dwDuration * 10000);

  00144	8b 55 10	 mov	 edx, DWORD PTR _dwDuration$[ebp]
  00147	69 d2 10 27 00
	00		 imul	 edx, 10000		; 00002710H
  0014d	33 c0		 xor	 eax, eax
  0014f	8b 4d e8	 mov	 ecx, DWORD PTR _rtTimeNow$70109[ebp]
  00152	03 ca		 add	 ecx, edx
  00154	8b 55 ec	 mov	 edx, DWORD PTR _rtTimeNow$70109[ebp+4]
  00157	13 d0		 adc	 edx, eax
  00159	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0015c	89 48 18	 mov	 DWORD PTR [eax+24], ecx
  0015f	89 50 1c	 mov	 DWORD PTR [eax+28], edx
$L70112:

; 1428 :             }
; 1429 : 			pCurve->dwVirtualTrackID = m_dwTrackID;

  00162	8b 4d fc	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  00165	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00168	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0016b	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 1430 :             pCurve->rtTime = rtTimeNow;

  0016e	8b 4d fc	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  00171	8b 55 e8	 mov	 edx, DWORD PTR _rtTimeNow$70109[ebp]
  00174	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00177	8b 45 ec	 mov	 eax, DWORD PTR _rtTimeNow$70109[ebp+4]
  0017a	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 1431 :             pCurve->mtTime = mtNow;

  0017d	8b 4d fc	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  00180	8b 55 f0	 mov	 edx, DWORD PTR _mtNow$70110[ebp]
  00183	89 51 10	 mov	 DWORD PTR [ecx+16], edx

; 1432 :             pCurve->dwFlags = DMUS_PMSGF_REFTIME | DMUS_PMSGF_MUSICTIME | 
; 1433 :                 DMUS_PMSGF_LOCKTOREFTIME | DMUS_PMSGF_DX8;

  00186	8b 45 fc	 mov	 eax, DWORD PTR _pCurve$[ebp]
  00189	c7 40 14 c3 00
	00 00		 mov	 DWORD PTR [eax+20], 195	; 000000c3H

; 1434 :             pCurve->dwPChannel = DMUS_PCHANNEL_BROADCAST_AUDIOPATH;

  00190	8b 4d fc	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  00193	c7 41 18 fe ff
	ff ff		 mov	 DWORD PTR [ecx+24], -2	; fffffffeH

; 1435 :             // dwVirtualTrackID: this isn't a track so leave as 0
; 1436 :             pCurve->dwType = DMUS_PMSGT_CURVE;

  0019a	8b 55 fc	 mov	 edx, DWORD PTR _pCurve$[ebp]
  0019d	c7 42 28 05 00
	00 00		 mov	 DWORD PTR [edx+40], 5

; 1437 :             pCurve->dwGroupID = -1; // this isn't a track so just say all groups

  001a4	8b 45 fc	 mov	 eax, DWORD PTR _pCurve$[ebp]
  001a7	c7 40 30 ff ff
	ff ff		 mov	 DWORD PTR [eax+48], -1

; 1438 : 
; 1439 :             // curve PMsg fields
; 1440 :             pCurve->mtDuration = dwDuration; // setting the DMUS_PMSGF_LOCKTOREFTIME is interpreted by the performance that mtDuration is milliseconds

  001ae	8b 4d fc	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  001b1	8b 55 10	 mov	 edx, DWORD PTR _dwDuration$[ebp]
  001b4	89 51 38	 mov	 DWORD PTR [ecx+56], edx

; 1441 :             // mtResetDuration: no reset so leave as 0
; 1442 :             pCurve->nStartValue = 127; //m_bLastVol;

  001b7	8b 45 fc	 mov	 eax, DWORD PTR _pCurve$[ebp]
  001ba	66 c7 40 44 7f
	00		 mov	 WORD PTR [eax+68], 127	; 0000007fH

; 1443 :             // nStartValue: will be ignored
; 1444 :             pCurve->nEndValue = bMIDIVol;

  001c0	66 0f b6 4d fb	 movzx	 cx, BYTE PTR _bMIDIVol$[ebp]
  001c5	8b 55 fc	 mov	 edx, DWORD PTR _pCurve$[ebp]
  001c8	66 89 4a 46	 mov	 WORD PTR [edx+70], cx

; 1445 :             // nResetValue: no reset so leave as 0
; 1446 :             pCurve->bType = DMUS_CURVET_CCCURVE;

  001cc	8b 45 fc	 mov	 eax, DWORD PTR _pCurve$[ebp]
  001cf	c6 40 50 04	 mov	 BYTE PTR [eax+80], 4

; 1447 :             /*if (dwDuration)
; 1448 :             {
; 1449 :                 if (bMIDIVol > 87)
; 1450 :                 {
; 1451 :                     // If fading up, make better for crossfade by fading in quickly at first.
; 1452 :                     pCurve->bCurveShape = DMUS_CURVES_LOG;
; 1453 :                 }
; 1454 :                 else if (bMIDIVol < 40)
; 1455 :                 {
; 1456 :                     // If fading out, make better for crossfade by fading out slowly at first.
; 1457 :                     pCurve->bCurveShape = DMUS_CURVES_EXP;
; 1458 :                 }
; 1459 :                 else
; 1460 :                 {
; 1461 :                     pCurve->bCurveShape = DMUS_CURVES_LINEAR;
; 1462 :                 }
; 1463 :             }
; 1464 :             else
; 1465 :             {
; 1466 :                 pCurve->bCurveShape = DMUS_CURVES_INSTANT;
; 1467 :             }*/
; 1468 :             pCurve->bCurveShape = dwDuration ? DMUS_CURVES_LINEAR : DMUS_CURVES_INSTANT;

  001d3	33 c9		 xor	 ecx, ecx
  001d5	83 7d 10 00	 cmp	 DWORD PTR _dwDuration$[ebp], 0
  001d9	0f 94 c1	 sete	 cl
  001dc	8b 55 fc	 mov	 edx, DWORD PTR _pCurve$[ebp]
  001df	88 4a 51	 mov	 BYTE PTR [edx+81], cl

; 1469 :             pCurve->bCCData = 7; // MIDI volume controller number

  001e2	8b 45 fc	 mov	 eax, DWORD PTR _pCurve$[ebp]
  001e5	c6 40 52 07	 mov	 BYTE PTR [eax+82], 7

; 1470 :             pCurve->bFlags = DMUS_CURVE_START_FROM_CURRENT;

  001e9	8b 4d fc	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  001ec	c6 41 53 02	 mov	 BYTE PTR [ecx+83], 2

; 1471 :             // wParamType: leave as zero since this isn't a NRPN/RPN curve
; 1472 :             pCurve->wMergeIndex = 0xFFFE; //  special merge index so this won't get stepped on. is a big number OK? define a constant for this value?

  001f0	8b 55 fc	 mov	 edx, DWORD PTR _pCurve$[ebp]
  001f3	66 c7 42 56 fe
	ff		 mov	 WORD PTR [edx+86], 65534 ; 0000fffeH

; 1473 : 
; 1474 :             // send it
; 1475 : 
; 1476 :             StampPMsg((DMUS_PMSG *)pCurve);

  001f9	8b 45 fc	 mov	 eax, DWORD PTR _pCurve$[ebp]
  001fc	50		 push	 eax
  001fd	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00200	83 c1 04	 add	 ecx, 4
  00203	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00206	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00209	51		 push	 ecx
  0020a	ff 50 0c	 call	 DWORD PTR [eax+12]

; 1477 :             hr = m_pPerformance->SendPMsg((DMUS_PMSG*)pCurve);

  0020d	8b 4d fc	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  00210	51		 push	 ecx
  00211	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00214	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  00217	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0021a	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  0021d	8b 00		 mov	 eax, DWORD PTR [eax]
  0021f	52		 push	 edx
  00220	ff 50 10	 call	 DWORD PTR [eax+16]
  00223	89 45 f4	 mov	 DWORD PTR _hr$[ebp], eax
$L70108:

; 1478 :         }
; 1479 :     }
; 1480 :     else

  00226	eb 07		 jmp	 SHORT $L70115
$L70104:

; 1481 :     {
; 1482 :         hr = DMUS_E_NOT_INIT;

  00228	c7 45 f4 62 11
	78 88		 mov	 DWORD PTR _hr$[ebp], -2005397150 ; 88781162H
$L70115:

; 1483 :     }
; 1484 :     LEAVE_CRITICAL_SECTION(&m_CriticalSection);

  0022f	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00232	83 c1 2c	 add	 ecx, 44			; 0000002cH
  00235	51		 push	 ecx
  00236	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 1485 :     LEAVE_API_CRITICAL_SECTION;
; 1486 :     return hr;

  0023c	8b 45 f4	 mov	 eax, DWORD PTR _hr$[ebp]

; 1487 : }

  0023f	8b e5		 mov	 esp, ebp
  00241	5d		 pop	 ebp
  00242	c2 0c 00	 ret	 12			; 0000000cH
?SetVolume@CAudioPath@@UAGJJK@Z ENDP			; CAudioPath::SetVolume
_TEXT	ENDS
PUBLIC	??_C@_0BN@MDFJNLGO@?$CFs?3?5Invalid?5argument?5lPitch?6?$AA@ ; `string'
;	COMDAT ?__szValidateInterfaceName@?1??SetPitch@CAudioPath@@UAGJJK@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??SetPitch@CAudioPath@@UAGJJK@Z@4QBDB DB 'Au'
	DB	'dioPath::SetPitch', 00H			; `CAudioPath::SetPitch'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0BN@MDFJNLGO@?$CFs?3?5Invalid?5argument?5lPitch?6?$AA@
CONST	SEGMENT
??_C@_0BN@MDFJNLGO@?$CFs?3?5Invalid?5argument?5lPitch?6?$AA@ DB '%s: Inva'
	DB	'lid argument lPitch', 0aH, 00H		; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?SetPitch@CAudioPath@@UAGJJK@Z
_TEXT	SEGMENT
tv232 = -36
tv231 = -28
tv204 = -24
_mtNow$70141 = -20
_rtTimeNow$70139 = -16
_hr$ = -8
_pCurve$ = -4
_this$ = 8
_lPitch$ = 12
_dwDuration$ = 16
?SetPitch@CAudioPath@@UAGJJK@Z PROC NEAR		; CAudioPath::SetPitch, COMDAT

; 1491 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H

; 1492 :     V_INAME(AudioPath::SetPitch);
; 1493 :     lPitch += 0x2000; // Bump up to center around 0x2000.

  00006	8b 45 0c	 mov	 eax, DWORD PTR _lPitch$[ebp]
  00009	05 00 20 00 00	 add	 eax, 8192		; 00002000H
  0000e	89 45 0c	 mov	 DWORD PTR _lPitch$[ebp], eax

; 1494 : #if defined(DBG) || defined(DXAPI)
; 1495 :     if (lPitch < 0 || lPitch > 0x3FFF)

  00011	83 7d 0c 00	 cmp	 DWORD PTR _lPitch$[ebp], 0
  00015	7c 09		 jl	 SHORT $L70128
  00017	81 7d 0c ff 3f
	00 00		 cmp	 DWORD PTR _lPitch$[ebp], 16383 ; 00003fffH
  0001e	7e 19		 jle	 SHORT $L70127
$L70128:

; 1496 :     {
; 1497 :         RIP_E_INVALIDARG(lPitch)

  00020	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??SetPitch@CAudioPath@@UAGJJK@Z@4QBDB
  00025	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BN@MDFJNLGO@?$CFs?3?5Invalid?5argument?5lPitch?6?$AA@
  0002a	6a ff		 push	 -1
  0002c	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00031	83 c4 0c	 add	 esp, 12			; 0000000cH
  00034	e8 00 00 00 00	 call	 _DebugBreak@0
$L70127:

; 1498 :     }
; 1499 : #endif
; 1500 :     HRESULT hr = E_FAIL; // This should never happen, since the audiopath is created by the performance. 

  00039	c7 45 f8 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H

; 1501 :     DMUS_CURVE_PMSG *pCurve;
; 1502 :     // Clamp to an hour!
; 1503 :     if (dwDuration > (60 * 60 * 1000)) dwDuration = (60 * 60 * 1000);

  00040	81 7d 10 80 ee
	36 00		 cmp	 DWORD PTR _dwDuration$[ebp], 3600000 ; 0036ee80H
  00047	76 07		 jbe	 SHORT $L70133
  00049	c7 45 10 80 ee
	36 00		 mov	 DWORD PTR _dwDuration$[ebp], 3600000 ; 0036ee80H
$L70133:

; 1504 :     ENTER_CRITICAL_SECTION(&m_CriticalSection);

  00050	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	83 c1 2c	 add	 ecx, 44			; 0000002cH
  00056	51		 push	 ecx
  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 1505 :     ENTER_API_CRITICAL_SECTION;
; 1506 :     if (m_pPerformance)

  0005d	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00060	83 7a 60 00	 cmp	 DWORD PTR [edx+96], 0
  00064	0f 84 b5 01 00
	00		 je	 $L70134

; 1507 :     {
; 1508 :         hr = m_pPerformance->AllocPMsg(sizeof(DMUS_CURVE_PMSG),(DMUS_PMSG **)&pCurve);

  0006a	8d 45 fc	 lea	 eax, DWORD PTR _pCurve$[ebp]
  0006d	50		 push	 eax
  0006e	6a 58		 push	 88			; 00000058H
  00070	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00073	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  00076	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00079	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  0007c	8b 12		 mov	 edx, DWORD PTR [edx]
  0007e	51		 push	 ecx
  0007f	ff 52 24	 call	 DWORD PTR [edx+36]
  00082	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax

; 1509 :         if (SUCCEEDED(hr))

  00085	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00089	0f 8c 8e 01 00
	00		 jl	 $L70138

; 1510 :         {
; 1511 :             REFERENCE_TIME rtTimeNow = 0;

  0008f	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _rtTimeNow$70139[ebp], 0
  00096	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _rtTimeNow$70139[ebp+4], 0

; 1512 :             m_pPerformance->GetQueueTime(&rtTimeNow);

  0009d	8d 45 f0	 lea	 eax, DWORD PTR _rtTimeNow$70139[ebp]
  000a0	50		 push	 eax
  000a1	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000a4	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  000a7	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  000aa	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  000ad	8b 12		 mov	 edx, DWORD PTR [edx]
  000af	51		 push	 ecx
  000b0	ff 92 84 00 00
	00		 call	 DWORD PTR [edx+132]

; 1513 :             // If this starts before a previous fade ended, invalidate it.
; 1514 :             if (m_rtLastPitchChange > rtTimeNow)

  000b6	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  000b9	89 45 e8	 mov	 DWORD PTR tv204[ebp], eax
  000bc	8b 4d e8	 mov	 ecx, DWORD PTR tv204[ebp]
  000bf	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  000c2	3b 55 f4	 cmp	 edx, DWORD PTR _rtTimeNow$70139[ebp+4]
  000c5	7c 43		 jl	 SHORT $L70140
  000c7	7f 0b		 jg	 SHORT $L71750
  000c9	8b 45 e8	 mov	 eax, DWORD PTR tv204[ebp]
  000cc	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  000cf	3b 4d f0	 cmp	 ecx, DWORD PTR _rtTimeNow$70139[ebp]
  000d2	76 36		 jbe	 SHORT $L70140
$L71750:

; 1515 :             {
; 1516 :                 MUSIC_TIME mtNow;
; 1517 :                 m_pPerformance->ReferenceToMusicTime(rtTimeNow,&mtNow);

  000d4	8d 55 ec	 lea	 edx, DWORD PTR _mtNow$70141[ebp]
  000d7	52		 push	 edx
  000d8	8b 45 f4	 mov	 eax, DWORD PTR _rtTimeNow$70139[ebp+4]
  000db	50		 push	 eax
  000dc	8b 4d f0	 mov	 ecx, DWORD PTR _rtTimeNow$70139[ebp]
  000df	51		 push	 ecx
  000e0	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  000e3	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  000e6	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000e9	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  000ec	8b 00		 mov	 eax, DWORD PTR [eax]
  000ee	52		 push	 edx
  000ef	ff 50 18	 call	 DWORD PTR [eax+24]

; 1518 :                 m_pPerformance->FlushVirtualTrack(m_dwTrackID,mtNow,0);

  000f2	6a 00		 push	 0
  000f4	8b 4d ec	 mov	 ecx, DWORD PTR _mtNow$70141[ebp]
  000f7	51		 push	 ecx
  000f8	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  000fb	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  000fe	50		 push	 eax
  000ff	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00102	8b 49 60	 mov	 ecx, DWORD PTR [ecx+96]
  00105	e8 00 00 00 00	 call	 ?FlushVirtualTrack@CPerformance@@QAEJKJK@Z ; CPerformance::FlushVirtualTrack
$L70140:

; 1519 :             }
; 1520 :             if (m_rtLastPitchChange < (rtTimeNow + (dwDuration * 10000)))

  0010a	8b 55 10	 mov	 edx, DWORD PTR _dwDuration$[ebp]
  0010d	69 d2 10 27 00
	00		 imul	 edx, 10000		; 00002710H
  00113	33 c0		 xor	 eax, eax
  00115	8b 4d f0	 mov	 ecx, DWORD PTR _rtTimeNow$70139[ebp]
  00118	03 ca		 add	 ecx, edx
  0011a	8b 55 f4	 mov	 edx, DWORD PTR _rtTimeNow$70139[ebp+4]
  0011d	13 d0		 adc	 edx, eax
  0011f	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00122	89 45 e4	 mov	 DWORD PTR tv231[ebp], eax
  00125	89 4d dc	 mov	 DWORD PTR tv232[ebp], ecx
  00128	89 55 e0	 mov	 DWORD PTR tv232[ebp+4], edx
  0012b	8b 4d e4	 mov	 ecx, DWORD PTR tv231[ebp]
  0012e	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00131	3b 55 e0	 cmp	 edx, DWORD PTR tv232[ebp+4]
  00134	7f 2b		 jg	 SHORT $L70142
  00136	7c 0b		 jl	 SHORT $L71751
  00138	8b 45 e4	 mov	 eax, DWORD PTR tv231[ebp]
  0013b	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0013e	3b 4d dc	 cmp	 ecx, DWORD PTR tv232[ebp]
  00141	73 1e		 jae	 SHORT $L70142
$L71751:

; 1521 :             {
; 1522 :                 m_rtLastPitchChange = rtTimeNow + (dwDuration * 10000);

  00143	8b 55 10	 mov	 edx, DWORD PTR _dwDuration$[ebp]
  00146	69 d2 10 27 00
	00		 imul	 edx, 10000		; 00002710H
  0014c	33 c0		 xor	 eax, eax
  0014e	8b 4d f0	 mov	 ecx, DWORD PTR _rtTimeNow$70139[ebp]
  00151	03 ca		 add	 ecx, edx
  00153	8b 55 f4	 mov	 edx, DWORD PTR _rtTimeNow$70139[ebp+4]
  00156	13 d0		 adc	 edx, eax
  00158	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0015b	89 48 20	 mov	 DWORD PTR [eax+32], ecx
  0015e	89 50 24	 mov	 DWORD PTR [eax+36], edx
$L70142:

; 1523 :             }
; 1524 :             pCurve->dwVirtualTrackID = m_dwTrackID;

  00161	8b 4d fc	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  00164	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00167	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0016a	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 1525 :             pCurve->rtTime = rtTimeNow;

  0016d	8b 4d fc	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  00170	8b 55 f0	 mov	 edx, DWORD PTR _rtTimeNow$70139[ebp]
  00173	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00176	8b 45 f4	 mov	 eax, DWORD PTR _rtTimeNow$70139[ebp+4]
  00179	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 1526 :             pCurve->dwFlags = DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME | DMUS_PMSGF_DX8;

  0017c	8b 4d fc	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  0017f	c7 41 14 c1 00
	00 00		 mov	 DWORD PTR [ecx+20], 193	; 000000c1H

; 1527 :             pCurve->dwPChannel = DMUS_PCHANNEL_BROADCAST_AUDIOPATH;

  00186	8b 55 fc	 mov	 edx, DWORD PTR _pCurve$[ebp]
  00189	c7 42 18 fe ff
	ff ff		 mov	 DWORD PTR [edx+24], -2	; fffffffeH

; 1528 :             // dwVirtualTrackID: this isn't a track so leave as 0
; 1529 :             pCurve->dwType = DMUS_PMSGT_CURVE;

  00190	8b 45 fc	 mov	 eax, DWORD PTR _pCurve$[ebp]
  00193	c7 40 28 05 00
	00 00		 mov	 DWORD PTR [eax+40], 5

; 1530 :             pCurve->dwGroupID = -1; // this isn't a track so just say all groups

  0019a	8b 4d fc	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  0019d	c7 41 30 ff ff
	ff ff		 mov	 DWORD PTR [ecx+48], -1

; 1531 : 
; 1532 :             // curve PMsg fields
; 1533 :             pCurve->mtDuration = dwDuration; // setting the DMUS_PMSGF_LOCKTOREFTIME is interpreted by the performance that mtDuration is milliseconds

  001a4	8b 55 fc	 mov	 edx, DWORD PTR _pCurve$[ebp]
  001a7	8b 45 10	 mov	 eax, DWORD PTR _dwDuration$[ebp]
  001aa	89 42 38	 mov	 DWORD PTR [edx+56], eax

; 1534 :             // mtResetDuration: no reset so leave as 0
; 1535 :             pCurve->nStartValue = 0;

  001ad	8b 4d fc	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  001b0	66 c7 41 44 00
	00		 mov	 WORD PTR [ecx+68], 0

; 1536 :             // nStartValue: will be ignored
; 1537 :             pCurve->nEndValue = (short) lPitch;

  001b6	8b 55 fc	 mov	 edx, DWORD PTR _pCurve$[ebp]
  001b9	66 8b 45 0c	 mov	 ax, WORD PTR _lPitch$[ebp]
  001bd	66 89 42 46	 mov	 WORD PTR [edx+70], ax

; 1538 :             // nResetValue: no reset so leave as 0
; 1539 :             pCurve->bType = DMUS_CURVET_PBCURVE;

  001c1	8b 4d fc	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  001c4	c6 41 50 03	 mov	 BYTE PTR [ecx+80], 3

; 1540 :             pCurve->bCurveShape = dwDuration ? DMUS_CURVES_LINEAR : DMUS_CURVES_INSTANT;

  001c8	33 d2		 xor	 edx, edx
  001ca	83 7d 10 00	 cmp	 DWORD PTR _dwDuration$[ebp], 0
  001ce	0f 94 c2	 sete	 dl
  001d1	8b 45 fc	 mov	 eax, DWORD PTR _pCurve$[ebp]
  001d4	88 50 51	 mov	 BYTE PTR [eax+81], dl

; 1541 :             // bCCData: Ignore, since this is pitch bend
; 1542 :             pCurve->bFlags = DMUS_CURVE_START_FROM_CURRENT;

  001d7	8b 4d fc	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  001da	c6 41 53 02	 mov	 BYTE PTR [ecx+83], 2

; 1543 :             pCurve->wParamType = 0x2000;  // PB Range equivalent to pitch cents units.

  001de	8b 55 fc	 mov	 edx, DWORD PTR _pCurve$[ebp]
  001e1	66 c7 42 54 00
	20		 mov	 WORD PTR [edx+84], 8192	; 00002000H

; 1544 :             pCurve->wMergeIndex = 0xFFFE; //  special merge index so this won't get stepped on. is a big number OK? define a constant for this value?

  001e7	8b 45 fc	 mov	 eax, DWORD PTR _pCurve$[ebp]
  001ea	66 c7 40 56 fe
	ff		 mov	 WORD PTR [eax+86], 65534 ; 0000fffeH

; 1545 : 
; 1546 :             // send it
; 1547 : 
; 1548 :             StampPMsg((DMUS_PMSG *)pCurve);

  001f0	8b 4d fc	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  001f3	51		 push	 ecx
  001f4	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  001f7	83 c2 04	 add	 edx, 4
  001fa	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  001fd	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00200	52		 push	 edx
  00201	ff 51 0c	 call	 DWORD PTR [ecx+12]

; 1549 :             hr = m_pPerformance->SendPMsg((DMUS_PMSG*)pCurve);

  00204	8b 55 fc	 mov	 edx, DWORD PTR _pCurve$[ebp]
  00207	52		 push	 edx
  00208	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0020b	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  0020e	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00211	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  00214	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00216	50		 push	 eax
  00217	ff 51 10	 call	 DWORD PTR [ecx+16]
  0021a	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax
$L70138:

; 1550 :         }
; 1551 :     }
; 1552 :     else

  0021d	eb 07		 jmp	 SHORT $L70146
$L70134:

; 1553 :     {
; 1554 :         hr = DMUS_E_NOT_INIT;

  0021f	c7 45 f8 62 11
	78 88		 mov	 DWORD PTR _hr$[ebp], -2005397150 ; 88781162H
$L70146:

; 1555 :     }
; 1556 :     LEAVE_CRITICAL_SECTION(&m_CriticalSection);

  00226	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00229	83 c2 2c	 add	 edx, 44			; 0000002cH
  0022c	52		 push	 edx
  0022d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 1557 :     LEAVE_API_CRITICAL_SECTION;
; 1558 :     return hr;

  00233	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]

; 1559 : }

  00236	8b e5		 mov	 esp, ebp
  00238	5d		 pop	 ebp
  00239	c2 0c 00	 ret	 12			; 0000000cH
?SetPitch@CAudioPath@@UAGJJK@Z ENDP			; CAudioPath::SetPitch
_TEXT	ENDS
PUBLIC	?QueryInterface@IDirectSoundBuffer@@QAGJABU_GUID@@PAPAX@Z ; IDirectSoundBuffer::QueryInterface
PUBLIC	?AddRef@IDirectSoundBuffer@@QAGKXZ		; IDirectSoundBuffer::AddRef
PUBLIC	?GetBuffer@CBufferNode@@QAEPAUIDirectSoundBuffer@@XZ ; CBufferNode::GetBuffer
PUBLIC	??_C@_0BO@EMDDDLDF@?$CFs?3?5Invalid?5pointer?5ppObject?6?$AA@ ; `string'
PUBLIC	??_C@_0DG@HOFLBGEC@Invalid?5buffer?5or?5stage?5id?5passe@ ; `string'
PUBLIC	??_C@_0CP@CIDKKOPL@Error?3?5Audiopath?5does?5not?5suppor@ ; `string'
PUBLIC	??_C@_0CP@BHAJIHMA@Warning?3?5Requested?5AudioPath?5obj@ ; `string'
EXTRN	??0CGraph@@QAE@XZ:NEAR				; CGraph::CGraph
EXTRN	?GetObjectInPath@CGraph@@QAEJKABU_GUID@@K0PAPAX@Z:NEAR ; CGraph::GetObjectInPath
EXTRN	?GetGraphInternal@CPerformance@@QAEJPAPAUIDirectMusicGraph@@@Z:NEAR ; CPerformance::GetGraphInternal
EXTRN	_IID_IDirectSoundBuffer:BYTE
EXTRN	?GetPort@CPerformance@@AAEJKPAPAUIDirectMusicPort@@@Z:NEAR ; CPerformance::GetPort
EXTRN	_GUID_All_Objects:BYTE
;	COMDAT ?__szValidateInterfaceName@?1??GetObjectInPath@CAudioPath@@UAGJKKKABU_GUID@@K0PAPAX@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??GetObjectInPath@CAudioPath@@UAGJKKKABU_GUID@@K0PAPAX@Z@4QBDB DB 'I'
	DB	'DirectMusicAudioPath::GetObjectInPath', 00H	; `CAudioPath::GetObjectInPath'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0BO@EMDDDLDF@?$CFs?3?5Invalid?5pointer?5ppObject?6?$AA@
CONST	SEGMENT
??_C@_0BO@EMDDDLDF@?$CFs?3?5Invalid?5pointer?5ppObject?6?$AA@ DB '%s: Inv'
	DB	'alid pointer ppObject', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@HOFLBGEC@Invalid?5buffer?5or?5stage?5id?5passe@
CONST	SEGMENT
??_C@_0DG@HOFLBGEC@Invalid?5buffer?5or?5stage?5id?5passe@ DB 'Invalid buf'
	DB	'fer or stage id passed to GetObjectInPath', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@CIDKKOPL@Error?3?5Audiopath?5does?5not?5suppor@
CONST	SEGMENT
??_C@_0CP@CIDKKOPL@Error?3?5Audiopath?5does?5not?5suppor@ DB 'Error: Audi'
	DB	'opath does not support stage 0x%lx', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@BHAJIHMA@Warning?3?5Requested?5AudioPath?5obj@
CONST	SEGMENT
??_C@_0CP@BHAJIHMA@Warning?3?5Requested?5AudioPath?5obj@ DB 'Warning: Req'
	DB	'uested AudioPath object not found', 0aH, 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?GetObjectInPath@CAudioPath@@UAGJKKKABU_GUID@@K0PAPAX@Z
_TEXT	SEGMENT
tv129 = -68
tv78 = -64
$T71755 = -60
_pBuffer$70265 = -56
_pConfig$70259 = -52
_pBuffer$70247 = -44
_fAllChannels$70233 = -40
_pConnect$70232 = -36
_pPort$70228 = -32
_pScan$70214 = -28
_fSuccess$70213 = -24
_pCGraph$70203 = -20
_pGraph$70200 = -16
_pGraph$70195 = -12
_pPortConfig$ = -8
_hr$ = -4
_this$ = 8
_dwPChannel$ = 12
_dwStage$ = 16
_dwBuffer$ = 20
_guidObject$ = 24
_dwIndex$ = 28
_iidInterface$ = 32
_ppObject$ = 36
?GetObjectInPath@CAudioPath@@UAGJKKKABU_GUID@@K0PAPAX@Z PROC NEAR ; CAudioPath::GetObjectInPath, COMDAT

; 1564 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H

; 1565 :     V_INAME(IDirectMusicAudioPath::GetObjectInPath);
; 1566 :     V_PTRPTR_WRITE(ppObject);

  00006	6a 04		 push	 4
  00008	8b 45 24	 mov	 eax, DWORD PTR _ppObject$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  00011	85 c0		 test	 eax, eax
  00013	74 19		 je	 SHORT $L70164
  00015	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??GetObjectInPath@CAudioPath@@UAGJKKKABU_GUID@@K0PAPAX@Z@4QBDB
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@EMDDDLDF@?$CFs?3?5Invalid?5pointer?5ppObject?6?$AA@
  0001f	6a ff		 push	 -1
  00021	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH
  00029	e8 00 00 00 00	 call	 _DebugBreak@0
$L70164:

; 1567 :     *ppObject = NULL;

  0002e	8b 4d 24	 mov	 ecx, DWORD PTR _ppObject$[ebp]
  00031	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 1568 : #ifdef XBOX
; 1569 : #ifdef DBG
; 1570 :     if (dwBuffer && ((dwStage < DMUS_PATH_BUFFER) || (dwStage >= DMUS_PATH_PRIMARY_BUFFER)))

  00037	83 7d 14 00	 cmp	 DWORD PTR _dwBuffer$[ebp], 0
  0003b	74 21		 je	 SHORT $L70166
  0003d	81 7d 10 00 60
	00 00		 cmp	 DWORD PTR _dwStage$[ebp], 24576 ; 00006000H
  00044	72 09		 jb	 SHORT $L70167
  00046	81 7d 10 00 80
	00 00		 cmp	 DWORD PTR _dwStage$[ebp], 32768 ; 00008000H
  0004d	72 0f		 jb	 SHORT $L70166
$L70167:

; 1571 :     {
; 1572 :         Trace(0,"Invalid buffer or stage id passed to GetObjectInPath\n");

  0004f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DG@HOFLBGEC@Invalid?5buffer?5or?5stage?5id?5passe@
  00054	6a 00		 push	 0
  00056	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0005b	83 c4 08	 add	 esp, 8
$L70166:

; 1573 :     }
; 1574 : #endif
; 1575 : #else
; 1576 :     if (dwBuffer && ((dwStage < DMUS_PATH_BUFFER) || (dwStage >= DMUS_PATH_PRIMARY_BUFFER)))
; 1577 :     {
; 1578 :         return DMUS_E_NOT_FOUND;
; 1579 :     }
; 1580 : #endif
; 1581 :     HRESULT hr = DMUS_E_NOT_FOUND;

  0005e	c7 45 fc 61 11
	78 88		 mov	 DWORD PTR _hr$[ebp], -2005397151 ; 88781161H

; 1582 :     CPortConfig *pPortConfig;
; 1583 :     ENTER_CRITICAL_SECTION(&m_CriticalSection);

  00065	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00068	83 c2 2c	 add	 edx, 44			; 0000002cH
  0006b	52		 push	 edx
  0006c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 1584 :     ENTER_API_CRITICAL_SECTION;
; 1585 :     switch (dwStage)
; 1586 :     {

  00072	8b 45 10	 mov	 eax, DWORD PTR _dwStage$[ebp]
  00075	89 45 c0	 mov	 DWORD PTR tv78[ebp], eax
  00078	81 7d c0 00 33
	00 00		 cmp	 DWORD PTR tv78[ebp], 13056 ; 00003300H
  0007f	77 61		 ja	 SHORT $L71758
  00081	81 7d c0 00 33
	00 00		 cmp	 DWORD PTR tv78[ebp], 13056 ; 00003300H
  00088	0f 84 04 02 00
	00		 je	 $L70198
  0008e	81 7d c0 00 23
	00 00		 cmp	 DWORD PTR tv78[ebp], 8960 ; 00002300H
  00095	77 2c		 ja	 SHORT $L71759
  00097	81 7d c0 00 23
	00 00		 cmp	 DWORD PTR tv78[ebp], 8960 ; 00002300H
  0009e	0f 84 34 01 00
	00		 je	 $L70189
  000a4	81 7d c0 00 20
	00 00		 cmp	 DWORD PTR tv78[ebp], 8192 ; 00002000H
  000ab	0f 84 85 00 00
	00		 je	 $L70179
  000b1	81 7d c0 00 22
	00 00		 cmp	 DWORD PTR tv78[ebp], 8704 ; 00002200H
  000b8	0f 84 9f 00 00
	00		 je	 $L70181
  000be	e9 8c 05 00 00	 jmp	 $L70271
$L71759:
  000c3	81 7d c0 00 30
	00 00		 cmp	 DWORD PTR tv78[ebp], 12288 ; 00003000H
  000ca	0f 84 38 01 00
	00		 je	 $L70191
  000d0	81 7d c0 00 32
	00 00		 cmp	 DWORD PTR tv78[ebp], 12800 ; 00003200H
  000d7	0f 84 61 01 00
	00		 je	 $L70193
  000dd	e9 6d 05 00 00	 jmp	 $L70271
$L71758:
  000e2	81 7d c0 00 61
	00 00		 cmp	 DWORD PTR tv78[ebp], 24832 ; 00006100H
  000e9	77 2c		 ja	 SHORT $L71760
  000eb	81 7d c0 00 61
	00 00		 cmp	 DWORD PTR tv78[ebp], 24832 ; 00006100H
  000f2	0f 84 70 03 00
	00		 je	 $L70231
  000f8	81 7d c0 00 40
	00 00		 cmp	 DWORD PTR tv78[ebp], 16384 ; 00004000H
  000ff	0f 84 f8 01 00
	00		 je	 $L70205
  00105	81 7d c0 00 60
	00 00		 cmp	 DWORD PTR tv78[ebp], 24576 ; 00006000H
  0010c	0f 84 56 03 00
	00		 je	 $L70231
  00112	e9 38 05 00 00	 jmp	 $L70271
$L71760:
  00117	81 7d c0 00 70
	00 00		 cmp	 DWORD PTR tv78[ebp], 28672 ; 00007000H
  0011e	0f 84 94 04 00
	00		 je	 $L70257
  00124	81 7d c0 00 71
	00 00		 cmp	 DWORD PTR tv78[ebp], 28928 ; 00007100H
  0012b	0f 84 87 04 00
	00		 je	 $L70257
  00131	e9 19 05 00 00	 jmp	 $L70271
$L70179:

; 1587 :     case DMUS_PATH_AUDIOPATH:
; 1588 :         if ((dwIndex == 0) && (dwPChannel == 0))

  00136	83 7d 1c 00	 cmp	 DWORD PTR _dwIndex$[ebp], 0
  0013a	75 1c		 jne	 SHORT $L70180
  0013c	83 7d 0c 00	 cmp	 DWORD PTR _dwPChannel$[ebp], 0
  00140	75 16		 jne	 SHORT $L70180

; 1589 :         {
; 1590 :             hr = QueryInterface(iidInterface,ppObject);

  00142	8b 4d 24	 mov	 ecx, DWORD PTR _ppObject$[ebp]
  00145	51		 push	 ecx
  00146	8b 55 20	 mov	 edx, DWORD PTR _iidInterface$[ebp]
  00149	52		 push	 edx
  0014a	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0014d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0014f	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00152	52		 push	 edx
  00153	ff 11		 call	 DWORD PTR [ecx]
  00155	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
$L70180:

; 1591 :         }
; 1592 :         break;

  00158	e9 0c 05 00 00	 jmp	 $L70176
$L70181:

; 1593 :     case DMUS_PATH_AUDIOPATH_GRAPH:
; 1594 :         if ((dwIndex == 0) && (dwPChannel == 0))

  0015d	83 7d 1c 00	 cmp	 DWORD PTR _dwIndex$[ebp], 0
  00161	75 70		 jne	 SHORT $L70182
  00163	83 7d 0c 00	 cmp	 DWORD PTR _dwPChannel$[ebp], 0
  00167	75 6a		 jne	 SHORT $L70182

; 1595 :         {
; 1596 :             if (!m_pGraph)

  00169	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0016c	83 78 5c 00	 cmp	 DWORD PTR [eax+92], 0
  00170	75 33		 jne	 SHORT $L70183

; 1597 :             {
; 1598 :                 m_pGraph = new CGraph;

  00172	68 70 03 00 00	 push	 880			; 00000370H
  00177	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0017c	83 c4 04	 add	 esp, 4
  0017f	89 45 c4	 mov	 DWORD PTR $T71755[ebp], eax
  00182	83 7d c4 00	 cmp	 DWORD PTR $T71755[ebp], 0
  00186	74 0d		 je	 SHORT $L71756
  00188	8b 4d c4	 mov	 ecx, DWORD PTR $T71755[ebp]
  0018b	e8 00 00 00 00	 call	 ??0CGraph@@QAE@XZ	; CGraph::CGraph
  00190	89 45 bc	 mov	 DWORD PTR tv129[ebp], eax
  00193	eb 07		 jmp	 SHORT $L71757
$L71756:
  00195	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR tv129[ebp], 0
$L71757:
  0019c	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0019f	8b 55 bc	 mov	 edx, DWORD PTR tv129[ebp]
  001a2	89 51 5c	 mov	 DWORD PTR [ecx+92], edx
$L70183:

; 1599 :             }
; 1600 :             if (m_pGraph)

  001a5	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  001a8	83 78 5c 00	 cmp	 DWORD PTR [eax+92], 0
  001ac	74 1e		 je	 SHORT $L70186

; 1601 :             {
; 1602 :                 hr = m_pGraph->QueryInterface(iidInterface,ppObject);

  001ae	8b 4d 24	 mov	 ecx, DWORD PTR _ppObject$[ebp]
  001b1	51		 push	 ecx
  001b2	8b 55 20	 mov	 edx, DWORD PTR _iidInterface$[ebp]
  001b5	52		 push	 edx
  001b6	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  001b9	8b 48 5c	 mov	 ecx, DWORD PTR [eax+92]
  001bc	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  001bf	8b 42 5c	 mov	 eax, DWORD PTR [edx+92]
  001c2	8b 09		 mov	 ecx, DWORD PTR [ecx]
  001c4	50		 push	 eax
  001c5	ff 11		 call	 DWORD PTR [ecx]
  001c7	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 1603 :             }
; 1604 :             else

  001ca	eb 07		 jmp	 SHORT $L70182
$L70186:

; 1605 :             {
; 1606 :                 hr = E_OUTOFMEMORY;

  001cc	c7 45 fc 0e 00
	07 80		 mov	 DWORD PTR _hr$[ebp], -2147024882 ; 8007000eH
$L70182:

; 1607 :             }
; 1608 :         }
; 1609 :         break;

  001d3	e9 91 04 00 00	 jmp	 $L70176
$L70189:

; 1610 :     case DMUS_PATH_AUDIOPATH_TOOL:
; 1611 :         if (m_pGraph)

  001d8	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  001db	83 7a 5c 00	 cmp	 DWORD PTR [edx+92], 0
  001df	74 22		 je	 SHORT $L70190

; 1612 :         {
; 1613 :             hr = m_pGraph->GetObjectInPath(dwPChannel,guidObject,dwIndex,iidInterface,ppObject);

  001e1	8b 45 24	 mov	 eax, DWORD PTR _ppObject$[ebp]
  001e4	50		 push	 eax
  001e5	8b 4d 20	 mov	 ecx, DWORD PTR _iidInterface$[ebp]
  001e8	51		 push	 ecx
  001e9	8b 55 1c	 mov	 edx, DWORD PTR _dwIndex$[ebp]
  001ec	52		 push	 edx
  001ed	8b 45 18	 mov	 eax, DWORD PTR _guidObject$[ebp]
  001f0	50		 push	 eax
  001f1	8b 4d 0c	 mov	 ecx, DWORD PTR _dwPChannel$[ebp]
  001f4	51		 push	 ecx
  001f5	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  001f8	8b 4a 5c	 mov	 ecx, DWORD PTR [edx+92]
  001fb	e8 00 00 00 00	 call	 ?GetObjectInPath@CGraph@@QAEJKABU_GUID@@K0PAPAX@Z ; CGraph::GetObjectInPath
  00200	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
$L70190:

; 1614 :         }
; 1615 :         break;

  00203	e9 61 04 00 00	 jmp	 $L70176
$L70191:

; 1616 :     case DMUS_PATH_PERFORMANCE:
; 1617 :         if (m_pPerformance && (dwIndex == 0) && (dwPChannel == 0))

  00208	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0020b	83 78 60 00	 cmp	 DWORD PTR [eax+96], 0
  0020f	74 28		 je	 SHORT $L70192
  00211	83 7d 1c 00	 cmp	 DWORD PTR _dwIndex$[ebp], 0
  00215	75 22		 jne	 SHORT $L70192
  00217	83 7d 0c 00	 cmp	 DWORD PTR _dwPChannel$[ebp], 0
  0021b	75 1c		 jne	 SHORT $L70192

; 1618 :         {
; 1619 :             hr = m_pPerformance->QueryInterface(iidInterface,ppObject);

  0021d	8b 4d 24	 mov	 ecx, DWORD PTR _ppObject$[ebp]
  00220	51		 push	 ecx
  00221	8b 55 20	 mov	 edx, DWORD PTR _iidInterface$[ebp]
  00224	52		 push	 edx
  00225	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00228	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  0022b	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0022e	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  00231	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00233	50		 push	 eax
  00234	ff 11		 call	 DWORD PTR [ecx]
  00236	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
$L70192:

; 1620 :         }
; 1621 :         break;

  00239	e9 2b 04 00 00	 jmp	 $L70176
$L70193:

; 1622 :     case DMUS_PATH_PERFORMANCE_GRAPH:
; 1623 :         if (m_pPerformance && (dwIndex == 0) && (dwPChannel == 0))

  0023e	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00241	83 7a 60 00	 cmp	 DWORD PTR [edx+96], 0
  00245	74 46		 je	 SHORT $L70194
  00247	83 7d 1c 00	 cmp	 DWORD PTR _dwIndex$[ebp], 0
  0024b	75 40		 jne	 SHORT $L70194
  0024d	83 7d 0c 00	 cmp	 DWORD PTR _dwPChannel$[ebp], 0
  00251	75 3a		 jne	 SHORT $L70194

; 1624 :         {
; 1625 :             IDirectMusicGraph *pGraph;
; 1626 :             if (SUCCEEDED(hr = m_pPerformance->GetGraphInternal(&pGraph)))

  00253	8d 45 f4	 lea	 eax, DWORD PTR _pGraph$70195[ebp]
  00256	50		 push	 eax
  00257	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0025a	8b 49 60	 mov	 ecx, DWORD PTR [ecx+96]
  0025d	e8 00 00 00 00	 call	 ?GetGraphInternal@CPerformance@@QAEJPAPAUIDirectMusicGraph@@@Z ; CPerformance::GetGraphInternal
  00262	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
  00265	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00269	7c 22		 jl	 SHORT $L70194

; 1627 :             {
; 1628 :                 hr = pGraph->QueryInterface(iidInterface,ppObject);

  0026b	8b 55 24	 mov	 edx, DWORD PTR _ppObject$[ebp]
  0026e	52		 push	 edx
  0026f	8b 45 20	 mov	 eax, DWORD PTR _iidInterface$[ebp]
  00272	50		 push	 eax
  00273	8b 4d f4	 mov	 ecx, DWORD PTR _pGraph$70195[ebp]
  00276	8b 11		 mov	 edx, DWORD PTR [ecx]
  00278	8b 45 f4	 mov	 eax, DWORD PTR _pGraph$70195[ebp]
  0027b	50		 push	 eax
  0027c	ff 12		 call	 DWORD PTR [edx]
  0027e	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 1629 :                 pGraph->Release();

  00281	8b 4d f4	 mov	 ecx, DWORD PTR _pGraph$70195[ebp]
  00284	8b 11		 mov	 edx, DWORD PTR [ecx]
  00286	8b 45 f4	 mov	 eax, DWORD PTR _pGraph$70195[ebp]
  00289	50		 push	 eax
  0028a	ff 52 08	 call	 DWORD PTR [edx+8]
$L70194:

; 1630 :             }
; 1631 :         }
; 1632 :         break;

  0028d	e9 d7 03 00 00	 jmp	 $L70176
$L70198:

; 1633 :     case DMUS_PATH_PERFORMANCE_TOOL:
; 1634 :         if (m_pPerformance)

  00292	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00295	83 79 60 00	 cmp	 DWORD PTR [ecx+96], 0
  00299	74 5d		 je	 SHORT $L70199

; 1635 :         {
; 1636 :             IDirectMusicGraph *pGraph;
; 1637 :             if (SUCCEEDED(hr = m_pPerformance->GetGraphInternal(&pGraph)))

  0029b	8d 55 f0	 lea	 edx, DWORD PTR _pGraph$70200[ebp]
  0029e	52		 push	 edx
  0029f	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  002a2	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  002a5	e8 00 00 00 00	 call	 ?GetGraphInternal@CPerformance@@QAEJPAPAUIDirectMusicGraph@@@Z ; CPerformance::GetGraphInternal
  002aa	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
  002ad	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  002b1	7c 45		 jl	 SHORT $L70199

; 1638 :             {
; 1639 :                 CGraph *pCGraph = (CGraph *) pGraph;

  002b3	8b 4d f0	 mov	 ecx, DWORD PTR _pGraph$70200[ebp]
  002b6	89 4d ec	 mov	 DWORD PTR _pCGraph$70203[ebp], ecx

; 1640 :                 // Convert from audiopath channel to performance channel.
; 1641 :                 ConvertPChannel( dwPChannel,&dwPChannel);

  002b9	8d 55 0c	 lea	 edx, DWORD PTR _dwPChannel$[ebp]
  002bc	52		 push	 edx
  002bd	8b 45 0c	 mov	 eax, DWORD PTR _dwPChannel$[ebp]
  002c0	50		 push	 eax
  002c1	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  002c4	8b 11		 mov	 edx, DWORD PTR [ecx]
  002c6	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  002c9	50		 push	 eax
  002ca	ff 52 1c	 call	 DWORD PTR [edx+28]

; 1642 :                 hr = pCGraph->GetObjectInPath(dwPChannel,guidObject,dwIndex,iidInterface,ppObject);

  002cd	8b 4d 24	 mov	 ecx, DWORD PTR _ppObject$[ebp]
  002d0	51		 push	 ecx
  002d1	8b 55 20	 mov	 edx, DWORD PTR _iidInterface$[ebp]
  002d4	52		 push	 edx
  002d5	8b 45 1c	 mov	 eax, DWORD PTR _dwIndex$[ebp]
  002d8	50		 push	 eax
  002d9	8b 4d 18	 mov	 ecx, DWORD PTR _guidObject$[ebp]
  002dc	51		 push	 ecx
  002dd	8b 55 0c	 mov	 edx, DWORD PTR _dwPChannel$[ebp]
  002e0	52		 push	 edx
  002e1	8b 4d ec	 mov	 ecx, DWORD PTR _pCGraph$70203[ebp]
  002e4	e8 00 00 00 00	 call	 ?GetObjectInPath@CGraph@@QAEJKABU_GUID@@K0PAPAX@Z ; CGraph::GetObjectInPath
  002e9	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 1643 :                 pGraph->Release();

  002ec	8b 45 f0	 mov	 eax, DWORD PTR _pGraph$70200[ebp]
  002ef	8b 08		 mov	 ecx, DWORD PTR [eax]
  002f1	8b 55 f0	 mov	 edx, DWORD PTR _pGraph$70200[ebp]
  002f4	52		 push	 edx
  002f5	ff 51 08	 call	 DWORD PTR [ecx+8]
$L70199:

; 1644 :             }
; 1645 :         }
; 1646 :         break;

  002f8	e9 6c 03 00 00	 jmp	 $L70176
$L70205:

; 1647 :     case DMUS_PATH_PORT:
; 1648 :         pPortConfig = m_PortConfigList.GetHead();

  002fd	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00300	83 c1 68	 add	 ecx, 104		; 00000068H
  00303	e8 00 00 00 00	 call	 ?GetHead@CPortConfigList@@QAEPAVCPortConfig@@XZ ; CPortConfigList::GetHead
  00308	89 45 f8	 mov	 DWORD PTR _pPortConfig$[ebp], eax

; 1649 :         for (;pPortConfig;pPortConfig = pPortConfig->GetNext())

  0030b	eb 0b		 jmp	 SHORT $L70206
$L70207:
  0030d	8b 4d f8	 mov	 ecx, DWORD PTR _pPortConfig$[ebp]
  00310	e8 00 00 00 00	 call	 ?GetNext@CPortConfig@@QAEPAV1@XZ ; CPortConfig::GetNext
  00315	89 45 f8	 mov	 DWORD PTR _pPortConfig$[ebp], eax
$L70206:
  00318	83 7d f8 00	 cmp	 DWORD PTR _pPortConfig$[ebp], 0
  0031c	0f 84 41 01 00
	00		 je	 $L70208

; 1650 :         {
; 1651 :             // First, see if this matches the port guid.
; 1652 :             if ((pPortConfig->m_PortHeader.guidPort == guidObject) || (guidObject == GUID_All_Objects))

  00322	8b 45 18	 mov	 eax, DWORD PTR _guidObject$[ebp]
  00325	50		 push	 eax
  00326	8b 4d f8	 mov	 ecx, DWORD PTR _pPortConfig$[ebp]
  00329	83 c1 04	 add	 ecx, 4
  0032c	51		 push	 ecx
  0032d	e8 00 00 00 00	 call	 _==@8
  00332	85 c0		 test	 eax, eax
  00334	75 16		 jne	 SHORT $L70210
  00336	68 00 00 00 00	 push	 OFFSET FLAT:_GUID_All_Objects
  0033b	8b 55 18	 mov	 edx, DWORD PTR _guidObject$[ebp]
  0033e	52		 push	 edx
  0033f	e8 00 00 00 00	 call	 _==@8
  00344	85 c0		 test	 eax, eax
  00346	0f 84 12 01 00
	00		 je	 $L70209
$L70210:

; 1653 :             {
; 1654 :                 // Then, see if we have a pchannel match.
; 1655 :                 if ((dwPChannel == DMUS_PCHANNEL_ALL) ||
; 1656 :                     ((pPortConfig->m_PortHeader.dwPChannelBase <= dwPChannel) &&
; 1657 :                     ((pPortConfig->m_PortHeader.dwPChannelBase + pPortConfig->m_PortHeader.dwPChannelCount) > dwPChannel)))

  0034c	83 7d 0c fb	 cmp	 DWORD PTR _dwPChannel$[ebp], -5 ; fffffffbH
  00350	74 24		 je	 SHORT $L70212
  00352	8b 45 f8	 mov	 eax, DWORD PTR _pPortConfig$[ebp]
  00355	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00358	3b 4d 0c	 cmp	 ecx, DWORD PTR _dwPChannel$[ebp]
  0035b	0f 87 fd 00 00
	00		 ja	 $L70209
  00361	8b 55 f8	 mov	 edx, DWORD PTR _pPortConfig$[ebp]
  00364	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00367	8b 4d f8	 mov	 ecx, DWORD PTR _pPortConfig$[ebp]
  0036a	03 41 18	 add	 eax, DWORD PTR [ecx+24]
  0036d	3b 45 0c	 cmp	 eax, DWORD PTR _dwPChannel$[ebp]
  00370	0f 86 e8 00 00
	00		 jbe	 $L70209
$L70212:

; 1658 :                 {
; 1659 :                     // If everything matches, there is always the chance that we have multiple instances of
; 1660 :                     // this in the list and we are actually looking at a second or third pointer to the same port.
; 1661 :                     // So, scan through the list again, making the exact same matches. If this port is found in
; 1662 :                     // an earlier instance, fail the match.
; 1663 :                     BOOL fSuccess = true;

  00376	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _fSuccess$70213[ebp], 1

; 1664 :                     CPortConfig *pScan = m_PortConfigList.GetHead();

  0037d	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00380	83 c1 68	 add	 ecx, 104		; 00000068H
  00383	e8 00 00 00 00	 call	 ?GetHead@CPortConfigList@@QAEPAVCPortConfig@@XZ ; CPortConfigList::GetHead
  00388	89 45 e4	 mov	 DWORD PTR _pScan$70214[ebp], eax

; 1665 :                     for (;pScan;pScan = pScan->GetNext())

  0038b	eb 0b		 jmp	 SHORT $L70215
$L70216:
  0038d	8b 4d e4	 mov	 ecx, DWORD PTR _pScan$70214[ebp]
  00390	e8 00 00 00 00	 call	 ?GetNext@CPortConfig@@QAEPAV1@XZ ; CPortConfig::GetNext
  00395	89 45 e4	 mov	 DWORD PTR _pScan$70214[ebp], eax
$L70215:
  00398	83 7d e4 00	 cmp	 DWORD PTR _pScan$70214[ebp], 0
  0039c	74 6b		 je	 SHORT $L70217

; 1666 :                     {
; 1667 :                         // First, see if this matches the port guid.
; 1668 :                         if ((pScan->m_PortHeader.guidPort == guidObject) || (guidObject == GUID_All_Objects))

  0039e	8b 55 18	 mov	 edx, DWORD PTR _guidObject$[ebp]
  003a1	52		 push	 edx
  003a2	8b 45 e4	 mov	 eax, DWORD PTR _pScan$70214[ebp]
  003a5	83 c0 04	 add	 eax, 4
  003a8	50		 push	 eax
  003a9	e8 00 00 00 00	 call	 _==@8
  003ae	85 c0		 test	 eax, eax
  003b0	75 12		 jne	 SHORT $L70219
  003b2	68 00 00 00 00	 push	 OFFSET FLAT:_GUID_All_Objects
  003b7	8b 4d 18	 mov	 ecx, DWORD PTR _guidObject$[ebp]
  003ba	51		 push	 ecx
  003bb	e8 00 00 00 00	 call	 _==@8
  003c0	85 c0		 test	 eax, eax
  003c2	74 43		 je	 SHORT $L70218
$L70219:

; 1669 :                         {
; 1670 :                             // Then, see if we have a pchannel match.
; 1671 :                             if ((dwPChannel == DMUS_PCHANNEL_ALL) ||
; 1672 :                                 ((pScan->m_PortHeader.dwPChannelBase <= dwPChannel) &&
; 1673 :                                 ((pScan->m_PortHeader.dwPChannelBase + pScan->m_PortHeader.dwPChannelCount) > dwPChannel)))

  003c4	83 7d 0c fb	 cmp	 DWORD PTR _dwPChannel$[ebp], -5 ; fffffffbH
  003c8	74 1c		 je	 SHORT $L70221
  003ca	8b 55 e4	 mov	 edx, DWORD PTR _pScan$70214[ebp]
  003cd	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  003d0	3b 45 0c	 cmp	 eax, DWORD PTR _dwPChannel$[ebp]
  003d3	77 32		 ja	 SHORT $L70218
  003d5	8b 4d e4	 mov	 ecx, DWORD PTR _pScan$70214[ebp]
  003d8	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  003db	8b 45 e4	 mov	 eax, DWORD PTR _pScan$70214[ebp]
  003de	03 50 18	 add	 edx, DWORD PTR [eax+24]
  003e1	3b 55 0c	 cmp	 edx, DWORD PTR _dwPChannel$[ebp]
  003e4	76 21		 jbe	 SHORT $L70218
$L70221:

; 1674 :                             {
; 1675 :                                 // If this is the same as the outer loop, we have arrived. 
; 1676 :                                 if (pScan == pPortConfig)

  003e6	8b 4d e4	 mov	 ecx, DWORD PTR _pScan$70214[ebp]
  003e9	3b 4d f8	 cmp	 ecx, DWORD PTR _pPortConfig$[ebp]
  003ec	75 02		 jne	 SHORT $L70222

; 1677 :                                 {
; 1678 :                                     break;

  003ee	eb 19		 jmp	 SHORT $L70217
$L70222:

; 1679 :                                 }
; 1680 :                                 else
; 1681 :                                 {
; 1682 :                                     // Else, if this points to the same port, we have failed.
; 1683 :                                     if (pScan->m_pPort == pPortConfig->m_pPort)

  003f0	8b 55 e4	 mov	 edx, DWORD PTR _pScan$70214[ebp]
  003f3	8b 45 f8	 mov	 eax, DWORD PTR _pPortConfig$[ebp]
  003f6	8b 4a 54	 mov	 ecx, DWORD PTR [edx+84]
  003f9	3b 48 54	 cmp	 ecx, DWORD PTR [eax+84]
  003fc	75 09		 jne	 SHORT $L70218

; 1684 :                                     {
; 1685 :                                         fSuccess = false;

  003fe	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _fSuccess$70213[ebp], 0

; 1686 :                                         break;

  00405	eb 02		 jmp	 SHORT $L70217
$L70218:

; 1687 :                                     }
; 1688 :                                 }
; 1689 :                             }
; 1690 :                         }
; 1691 :                     }

  00407	eb 84		 jmp	 SHORT $L70216
$L70217:

; 1692 :                     if (fSuccess)

  00409	83 7d e8 00	 cmp	 DWORD PTR _fSuccess$70213[ebp], 0
  0040d	74 4f		 je	 SHORT $L70209

; 1693 :                     {
; 1694 :                         if (dwIndex)

  0040f	83 7d 1c 00	 cmp	 DWORD PTR _dwIndex$[ebp], 0
  00413	74 0b		 je	 SHORT $L70226

; 1695 :                         {
; 1696 :                             dwIndex--;

  00415	8b 55 1c	 mov	 edx, DWORD PTR _dwIndex$[ebp]
  00418	83 ea 01	 sub	 edx, 1
  0041b	89 55 1c	 mov	 DWORD PTR _dwIndex$[ebp], edx

; 1697 :                         }
; 1698 :                         else 

  0041e	eb 3e		 jmp	 SHORT $L70209
$L70226:

; 1699 :                         {
; 1700 :                             IDirectMusicPort *pPort;
; 1701 :                             if (SUCCEEDED(m_pPerformance->GetPort(pPortConfig->m_dwPortID,&pPort)))

  00420	8d 45 e0	 lea	 eax, DWORD PTR _pPort$70228[ebp]
  00423	50		 push	 eax
  00424	8b 4d f8	 mov	 ecx, DWORD PTR _pPortConfig$[ebp]
  00427	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  0042a	52		 push	 edx
  0042b	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0042e	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00431	e8 00 00 00 00	 call	 ?GetPort@CPerformance@@AAEJKPAPAUIDirectMusicPort@@@Z ; CPerformance::GetPort
  00436	85 c0		 test	 eax, eax
  00438	7c 22		 jl	 SHORT $L70230

; 1702 :                             {
; 1703 :                                 hr = pPort->QueryInterface(iidInterface,ppObject);

  0043a	8b 4d 24	 mov	 ecx, DWORD PTR _ppObject$[ebp]
  0043d	51		 push	 ecx
  0043e	8b 55 20	 mov	 edx, DWORD PTR _iidInterface$[ebp]
  00441	52		 push	 edx
  00442	8b 45 e0	 mov	 eax, DWORD PTR _pPort$70228[ebp]
  00445	8b 08		 mov	 ecx, DWORD PTR [eax]
  00447	8b 55 e0	 mov	 edx, DWORD PTR _pPort$70228[ebp]
  0044a	52		 push	 edx
  0044b	ff 11		 call	 DWORD PTR [ecx]
  0044d	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 1704 :                                 pPort->Release();

  00450	8b 45 e0	 mov	 eax, DWORD PTR _pPort$70228[ebp]
  00453	8b 08		 mov	 ecx, DWORD PTR [eax]
  00455	8b 55 e0	 mov	 edx, DWORD PTR _pPort$70228[ebp]
  00458	52		 push	 edx
  00459	ff 51 08	 call	 DWORD PTR [ecx+8]
$L70230:

; 1705 :                             }
; 1706 :                             break;

  0045c	eb 05		 jmp	 SHORT $L70208
$L70209:

; 1707 :                         }
; 1708 :                     }
; 1709 :                 }
; 1710 :             }
; 1711 :         }

  0045e	e9 aa fe ff ff	 jmp	 $L70207
$L70208:

; 1712 :         break;

  00463	e9 01 02 00 00	 jmp	 $L70176
$L70231:

; 1713 : #ifdef DXAPI
; 1714 :     case DMUS_PATH_SINK:
; 1715 :         if (m_pPerformance && (dwIndex == 0) && (dwPChannel == 0) &&
; 1716 :             m_pPerformance->m_BufferManager.m_pSinkConnect)
; 1717 :         {
; 1718 :             hr = m_pPerformance->m_BufferManager.m_pSinkConnect->QueryInterface(iidInterface,ppObject);
; 1719 :         }
; 1720 :         break;
; 1721 : #endif
; 1722 :     case DMUS_PATH_BUFFER:
; 1723 :     case DMUS_PATH_BUFFER_DMO:
; 1724 :         {
; 1725 :             CBufferConnect *pConnect = NULL;

  00468	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _pConnect$70232[ebp], 0

; 1726 :             BOOL fAllChannels = (dwPChannel == DMUS_PCHANNEL_ALL);

  0046f	33 c0		 xor	 eax, eax
  00471	83 7d 0c fb	 cmp	 DWORD PTR _dwPChannel$[ebp], -5 ; fffffffbH
  00475	0f 94 c0	 sete	 al
  00478	89 45 d8	 mov	 DWORD PTR _fAllChannels$70233[ebp], eax

; 1727 :             pPortConfig = m_PortConfigList.GetHead();

  0047b	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0047e	83 c1 68	 add	 ecx, 104		; 00000068H
  00481	e8 00 00 00 00	 call	 ?GetHead@CPortConfigList@@QAEPAVCPortConfig@@XZ ; CPortConfigList::GetHead
  00486	89 45 f8	 mov	 DWORD PTR _pPortConfig$[ebp], eax

; 1728 :             for (;pPortConfig && FAILED(hr);pPortConfig = pPortConfig->GetNext())

  00489	eb 0b		 jmp	 SHORT $L70235
$L70236:
  0048b	8b 4d f8	 mov	 ecx, DWORD PTR _pPortConfig$[ebp]
  0048e	e8 00 00 00 00	 call	 ?GetNext@CPortConfig@@QAEPAV1@XZ ; CPortConfig::GetNext
  00493	89 45 f8	 mov	 DWORD PTR _pPortConfig$[ebp], eax
$L70235:
  00496	83 7d f8 00	 cmp	 DWORD PTR _pPortConfig$[ebp], 0
  0049a	0f 84 13 01 00
	00		 je	 $L70237
  004a0	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  004a4	0f 8d 09 01 00
	00		 jge	 $L70237

; 1729 :             {
; 1730 :                 if (fAllChannels || ((pPortConfig->m_PortHeader.dwPChannelBase <= dwPChannel) &&
; 1731 :                     ((pPortConfig->m_PortHeader.dwPChannelCount + 
; 1732 :                     pPortConfig->m_PortHeader.dwPChannelBase) > dwPChannel)))

  004aa	83 7d d8 00	 cmp	 DWORD PTR _fAllChannels$70233[ebp], 0
  004ae	75 24		 jne	 SHORT $L70239
  004b0	8b 4d f8	 mov	 ecx, DWORD PTR _pPortConfig$[ebp]
  004b3	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  004b6	3b 55 0c	 cmp	 edx, DWORD PTR _dwPChannel$[ebp]
  004b9	0f 87 ef 00 00
	00		 ja	 $L70238
  004bf	8b 45 f8	 mov	 eax, DWORD PTR _pPortConfig$[ebp]
  004c2	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  004c5	8b 55 f8	 mov	 edx, DWORD PTR _pPortConfig$[ebp]
  004c8	03 4a 14	 add	 ecx, DWORD PTR [edx+20]
  004cb	3b 4d 0c	 cmp	 ecx, DWORD PTR _dwPChannel$[ebp]
  004ce	0f 86 da 00 00
	00		 jbe	 $L70238
$L70239:

; 1733 :                 {
; 1734 :                     pConnect = pPortConfig->m_BufferConnectList.GetHead();

  004d4	8b 4d f8	 mov	 ecx, DWORD PTR _pPortConfig$[ebp]
  004d7	83 c1 48	 add	 ecx, 72			; 00000048H
  004da	e8 00 00 00 00	 call	 ?GetHead@CBufferConnectList@@QAEPAVCBufferConnect@@XZ ; CBufferConnectList::GetHead
  004df	89 45 dc	 mov	 DWORD PTR _pConnect$70232[ebp], eax
$L70241:

; 1735 :                     for (;pConnect;)

  004e2	83 7d dc 00	 cmp	 DWORD PTR _pConnect$70232[ebp], 0
  004e6	0f 84 c2 00 00
	00		 je	 $L70238

; 1736 :                     {
; 1737 :                         if (fAllChannels || ((pConnect->m_ConnectHeader.dwPChannelBase <= dwPChannel) &&
; 1738 :                             ((pConnect->m_ConnectHeader.dwPChannelCount + 
; 1739 :                             pConnect->m_ConnectHeader.dwPChannelBase) > dwPChannel)))

  004ec	83 7d d8 00	 cmp	 DWORD PTR _fAllChannels$70233[ebp], 0
  004f0	75 24		 jne	 SHORT $L70244
  004f2	8b 45 dc	 mov	 eax, DWORD PTR _pConnect$70232[ebp]
  004f5	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  004f8	3b 4d 0c	 cmp	 ecx, DWORD PTR _dwPChannel$[ebp]
  004fb	0f 87 97 00 00
	00		 ja	 $L70243
  00501	8b 55 dc	 mov	 edx, DWORD PTR _pConnect$70232[ebp]
  00504	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00507	8b 4d dc	 mov	 ecx, DWORD PTR _pConnect$70232[ebp]
  0050a	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  0050d	3b 45 0c	 cmp	 eax, DWORD PTR _dwPChannel$[ebp]
  00510	0f 86 82 00 00
	00		 jbe	 $L70243
$L70244:

; 1740 :                         {
; 1741 :                             // Found the buffer connect. Which buffer will be determined
; 1742 :                             // by dwBuffer. If dwBuffer is greater than the count of buffer,
; 1743 :                             // decrement and move on to the next pConnect.
; 1744 :                             if (pConnect->m_ConnectHeader.dwBufferCount > dwBuffer) 

  00516	8b 55 dc	 mov	 edx, DWORD PTR _pConnect$70232[ebp]
  00519	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0051c	3b 45 14	 cmp	 eax, DWORD PTR _dwBuffer$[ebp]
  0051f	76 6b		 jbe	 SHORT $L70245

; 1745 :                             {
; 1746 :                                 if (pConnect->m_ppBufferNodes[dwBuffer])

  00521	8b 4d dc	 mov	 ecx, DWORD PTR _pConnect$70232[ebp]
  00524	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00527	8b 45 14	 mov	 eax, DWORD PTR _dwBuffer$[ebp]
  0052a	83 3c 82 00	 cmp	 DWORD PTR [edx+eax*4], 0
  0052e	74 53		 je	 SHORT $L70246

; 1747 :                                 {
; 1748 :                                     IDirectSoundBuffer *pBuffer = pConnect->m_ppBufferNodes[dwBuffer]->GetBuffer();

  00530	8b 4d dc	 mov	 ecx, DWORD PTR _pConnect$70232[ebp]
  00533	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00536	8b 45 14	 mov	 eax, DWORD PTR _dwBuffer$[ebp]
  00539	8b 0c 82	 mov	 ecx, DWORD PTR [edx+eax*4]
  0053c	e8 00 00 00 00	 call	 ?GetBuffer@CBufferNode@@QAEPAUIDirectSoundBuffer@@XZ ; CBufferNode::GetBuffer
  00541	89 45 d4	 mov	 DWORD PTR _pBuffer$70247[ebp], eax

; 1749 :                                     if (pBuffer)

  00544	83 7d d4 00	 cmp	 DWORD PTR _pBuffer$70247[ebp], 0
  00548	74 39		 je	 SHORT $L70246

; 1750 :                                     {
; 1751 :                                         if (dwStage == DMUS_PATH_BUFFER)

  0054a	81 7d 10 00 60
	00 00		 cmp	 DWORD PTR _dwStage$[ebp], 24576 ; 00006000H
  00551	75 20		 jne	 SHORT $L70249

; 1752 :                                         {
; 1753 :                                             if (dwIndex == 0)

  00553	83 7d 1c 00	 cmp	 DWORD PTR _dwIndex$[ebp], 0
  00557	75 18		 jne	 SHORT $L70250

; 1754 :                                             {
; 1755 : #ifdef XBOX
; 1756 :                                                 hr = S_OK;

  00559	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 1757 :                                                 *ppObject = pBuffer;

  00560	8b 4d 24	 mov	 ecx, DWORD PTR _ppObject$[ebp]
  00563	8b 55 d4	 mov	 edx, DWORD PTR _pBuffer$70247[ebp]
  00566	89 11		 mov	 DWORD PTR [ecx], edx

; 1758 :                                                 pBuffer->AddRef();

  00568	8b 45 d4	 mov	 eax, DWORD PTR _pBuffer$70247[ebp]
  0056b	50		 push	 eax
  0056c	e8 00 00 00 00	 call	 ?AddRef@IDirectSoundBuffer@@QAGKXZ ; IDirectSoundBuffer::AddRef
$L70250:

; 1759 : #else
; 1760 :                                                 hr = pBuffer->QueryInterface(iidInterface,ppObject);
; 1761 : #endif
; 1762 :                                             }
; 1763 :                                         }
; 1764 :                                         else

  00571	eb 07		 jmp	 SHORT $L70252
$L70249:

; 1765 :                                         {
; 1766 :                                             IDirectSoundBuffer8 *pBuffer8;
; 1767 : #ifndef XBOX
; 1768 :                                             hr = pBuffer->QueryInterface(IID_IDirectSoundBuffer8,(void **) &pBuffer8);
; 1769 :                                             if (SUCCEEDED(hr))
; 1770 :                                             {
; 1771 :                                                 hr = pBuffer8->GetObjectInPath(guidObject,dwIndex,iidInterface,ppObject);
; 1772 :                                                 pBuffer8->Release();
; 1773 :                                             }
; 1774 : #else // XBOX
; 1775 : 											hr = E_FAIL; // TODO: What's the right thing to do here?

  00573	c7 45 fc 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L70252:

; 1776 : #endif // XBOX
; 1777 :                                         }
; 1778 :                                         pBuffer->Release();

  0057a	8b 4d d4	 mov	 ecx, DWORD PTR _pBuffer$70247[ebp]
  0057d	51		 push	 ecx
  0057e	e8 00 00 00 00	 call	 ?Release@IDirectSoundBuffer@@QAGKXZ ; IDirectSoundBuffer::Release
$L70246:

; 1779 :                                     }
; 1780 :                                 }
; 1781 :                                 pConnect = NULL;

  00583	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _pConnect$70232[ebp], 0

; 1782 :                             }
; 1783 :                             else

  0058a	eb 0c		 jmp	 SHORT $L70243
$L70245:

; 1784 :                             {
; 1785 :                                 dwBuffer -= pConnect->m_ConnectHeader.dwBufferCount;

  0058c	8b 55 dc	 mov	 edx, DWORD PTR _pConnect$70232[ebp]
  0058f	8b 45 14	 mov	 eax, DWORD PTR _dwBuffer$[ebp]
  00592	2b 42 0c	 sub	 eax, DWORD PTR [edx+12]
  00595	89 45 14	 mov	 DWORD PTR _dwBuffer$[ebp], eax
$L70243:

; 1786 :                             }
; 1787 :                         }
; 1788 :                         if (pConnect)

  00598	83 7d dc 00	 cmp	 DWORD PTR _pConnect$70232[ebp], 0
  0059c	74 0b		 je	 SHORT $L70256

; 1789 :                         {
; 1790 :                             pConnect = pConnect->GetNext();

  0059e	8b 4d dc	 mov	 ecx, DWORD PTR _pConnect$70232[ebp]
  005a1	e8 00 00 00 00	 call	 ?GetNext@CBufferConnect@@QAEPAV1@XZ ; CBufferConnect::GetNext
  005a6	89 45 dc	 mov	 DWORD PTR _pConnect$70232[ebp], eax
$L70256:

; 1791 :                         }
; 1792 :                     }

  005a9	e9 34 ff ff ff	 jmp	 $L70241
$L70238:

; 1793 :                 }
; 1794 :             }

  005ae	e9 d8 fe ff ff	 jmp	 $L70236
$L70237:

; 1795 :             
; 1796 :         }
; 1797 :         break;

  005b3	e9 b1 00 00 00	 jmp	 $L70176
$L70257:

; 1798 :     case DMUS_PATH_MIXIN_BUFFER :
; 1799 :     case DMUS_PATH_MIXIN_BUFFER_DMO :
; 1800 :         if (dwPChannel == 0) 

  005b8	83 7d 0c 00	 cmp	 DWORD PTR _dwPChannel$[ebp], 0
  005bc	0f 85 8b 00 00
	00		 jne	 $L70258

; 1801 :         {
; 1802 :             CBufferConfig *pConfig = m_BufferConfigList.GetHead();

  005c2	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  005c5	83 c1 6c	 add	 ecx, 108		; 0000006cH
  005c8	e8 00 00 00 00	 call	 ?GetHead@CBufferConfigList@@QAEPAVCBufferConfig@@XZ ; CBufferConfigList::GetHead
  005cd	89 45 cc	 mov	 DWORD PTR _pConfig$70259[ebp], eax

; 1803 :             for (;pConfig; pConfig = pConfig->GetNext())

  005d0	eb 0b		 jmp	 SHORT $L70260
$L70261:
  005d2	8b 4d cc	 mov	 ecx, DWORD PTR _pConfig$70259[ebp]
  005d5	e8 00 00 00 00	 call	 ?GetNext@CBufferConfig@@QAEPAV1@XZ ; CBufferConfig::GetNext
  005da	89 45 cc	 mov	 DWORD PTR _pConfig$70259[ebp], eax
$L70260:
  005dd	83 7d cc 00	 cmp	 DWORD PTR _pConfig$70259[ebp], 0
  005e1	74 6a		 je	 SHORT $L70258

; 1804 :             {
; 1805 :                 if (pConfig->m_BufferHeader.dwFlags & DMUS_BUFFERF_MIXIN)

  005e3	8b 4d cc	 mov	 ecx, DWORD PTR _pConfig$70259[ebp]
  005e6	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  005e9	83 e2 08	 and	 edx, 8
  005ec	85 d2		 test	 edx, edx
  005ee	74 5b		 je	 SHORT $L70263

; 1806 :                 {
; 1807 :                     if (!dwBuffer)

  005f0	83 7d 14 00	 cmp	 DWORD PTR _dwBuffer$[ebp], 0
  005f4	75 4c		 jne	 SHORT $L70264

; 1808 :                     {
; 1809 :                         IDirectSoundBuffer *pBuffer = pConfig->m_pBufferNode->GetBuffer();

  005f6	8b 45 cc	 mov	 eax, DWORD PTR _pConfig$70259[ebp]
  005f9	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  005fc	e8 00 00 00 00	 call	 ?GetBuffer@CBufferNode@@QAEPAUIDirectSoundBuffer@@XZ ; CBufferNode::GetBuffer
  00601	89 45 c8	 mov	 DWORD PTR _pBuffer$70265[ebp], eax

; 1810 :                         if (pBuffer)

  00604	83 7d c8 00	 cmp	 DWORD PTR _pBuffer$70265[ebp], 0
  00608	74 36		 je	 SHORT $L70266

; 1811 :                         {
; 1812 :                             if (dwStage == DMUS_PATH_MIXIN_BUFFER)

  0060a	81 7d 10 00 70
	00 00		 cmp	 DWORD PTR _dwStage$[ebp], 28672 ; 00007000H
  00611	75 1d		 jne	 SHORT $L70267

; 1813 :                             {
; 1814 :                                 if (dwIndex == 0)

  00613	83 7d 1c 00	 cmp	 DWORD PTR _dwIndex$[ebp], 0
  00617	75 15		 jne	 SHORT $L70268

; 1815 :                                 {
; 1816 : #ifdef XBOX
; 1817 :                                     hr = pBuffer->QueryInterface(IID_IDirectSoundBuffer,ppObject);

  00619	8b 4d 24	 mov	 ecx, DWORD PTR _ppObject$[ebp]
  0061c	51		 push	 ecx
  0061d	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IDirectSoundBuffer
  00622	8b 55 c8	 mov	 edx, DWORD PTR _pBuffer$70265[ebp]
  00625	52		 push	 edx
  00626	e8 00 00 00 00	 call	 ?QueryInterface@IDirectSoundBuffer@@QAGJABU_GUID@@PAPAX@Z ; IDirectSoundBuffer::QueryInterface
  0062b	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
$L70268:

; 1818 : #else
; 1819 :                                     hr = pBuffer->QueryInterface(iidInterface,ppObject);
; 1820 : #endif
; 1821 :                                 }
; 1822 :                             }
; 1823 :                             else

  0062e	eb 07		 jmp	 SHORT $L70269
$L70267:

; 1824 :                             {
; 1825 : #ifndef XBOX
; 1826 :                                 IDirectSoundBuffer8 *pBuffer8;
; 1827 :                                 hr = pBuffer->QueryInterface(IID_IDirectSoundBuffer8,(void **) &pBuffer8);
; 1828 :                                 if (SUCCEEDED(hr))
; 1829 :                                 {
; 1830 :                                     hr = pBuffer8->GetObjectInPath(guidObject,dwIndex,iidInterface,ppObject);
; 1831 :                                     pBuffer8->Release();
; 1832 :                                 }
; 1833 : #else // XBOX
; 1834 : 								hr = E_FAIL; // TODO: What's the right thing to do here?

  00630	c7 45 fc 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L70269:

; 1835 : #endif // XBOX
; 1836 :                             }
; 1837 :                             pBuffer->Release();

  00637	8b 45 c8	 mov	 eax, DWORD PTR _pBuffer$70265[ebp]
  0063a	50		 push	 eax
  0063b	e8 00 00 00 00	 call	 ?Release@IDirectSoundBuffer@@QAGKXZ ; IDirectSoundBuffer::Release
$L70266:

; 1838 :                         }
; 1839 :                         break;

  00640	eb 0b		 jmp	 SHORT $L70258
$L70264:

; 1840 :                     }
; 1841 :                     dwBuffer--;

  00642	8b 4d 14	 mov	 ecx, DWORD PTR _dwBuffer$[ebp]
  00645	83 e9 01	 sub	 ecx, 1
  00648	89 4d 14	 mov	 DWORD PTR _dwBuffer$[ebp], ecx
$L70263:

; 1842 :                 }
; 1843 :             }

  0064b	eb 85		 jmp	 SHORT $L70261
$L70258:

; 1844 :         }
; 1845 :         break;

  0064d	eb 1a		 jmp	 SHORT $L70176
$L70271:

; 1846 : #ifndef XBOX
; 1847 :     case DMUS_PATH_PRIMARY_BUFFER :
; 1848 :         if ((dwIndex == 0) && (dwPChannel == 0))
; 1849 :         {
; 1850 :             CBufferNode *pNode = m_pPerformance->m_BufferManager.GetBufferNode(GUID_Buffer_Primary);
; 1851 :             if (pNode)
; 1852 :             {
; 1853 :                 IDirectSoundBuffer *pBuffer = pNode->GetBuffer();
; 1854 :                 if (pBuffer)
; 1855 :                 {
; 1856 :                     hr = pBuffer->QueryInterface(iidInterface,ppObject);
; 1857 :                     pBuffer->Release();
; 1858 :                 }
; 1859 :                 pNode->Release();
; 1860 :             }
; 1861 :         }
; 1862 :         break;
; 1863 : #endif
; 1864 :     default:
; 1865 :         hr = E_INVALIDARG;

  0064f	c7 45 fc 57 00
	07 80		 mov	 DWORD PTR _hr$[ebp], -2147024809 ; 80070057H

; 1866 :         Trace(0,"Error: Audiopath does not support stage 0x%lx\n",dwStage);

  00656	8b 55 10	 mov	 edx, DWORD PTR _dwStage$[ebp]
  00659	52		 push	 edx
  0065a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CP@CIDKKOPL@Error?3?5Audiopath?5does?5not?5suppor@
  0065f	6a 00		 push	 0
  00661	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00666	83 c4 0c	 add	 esp, 12			; 0000000cH
$L70176:

; 1867 :     }
; 1868 :     LEAVE_CRITICAL_SECTION(&m_CriticalSection);

  00669	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0066c	83 c0 2c	 add	 eax, 44			; 0000002cH
  0066f	50		 push	 eax
  00670	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 1869 :     LEAVE_API_CRITICAL_SECTION;
; 1870 : #ifdef DBG
; 1871 :     if (hr == DMUS_E_NOT_FOUND)

  00676	81 7d fc 61 11
	78 88		 cmp	 DWORD PTR _hr$[ebp], -2005397151 ; 88781161H
  0067d	75 0f		 jne	 SHORT $L70278

; 1872 :     {
; 1873 :         Trace(3,"Warning: Requested AudioPath object not found\n");

  0067f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CP@BHAJIHMA@Warning?3?5Requested?5AudioPath?5obj@
  00684	6a 03		 push	 3
  00686	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0068b	83 c4 08	 add	 esp, 8
$L70278:

; 1874 :     }
; 1875 : #endif
; 1876 :     return hr;

  0068e	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]

; 1877 : }

  00691	8b e5		 mov	 esp, ebp
  00693	5d		 pop	 ebp
  00694	c2 20 00	 ret	 32			; 00000020H
?GetObjectInPath@CAudioPath@@UAGJKKKABU_GUID@@K0PAPAX@Z ENDP ; CAudioPath::GetObjectInPath
_TEXT	ENDS
PUBLIC	??_C@_0DI@CMFHAAD@Warning?3?5Attempt?5to?5activate?5alr@ ; `string'
PUBLIC	??_C@_0DM@GFNFLPMP@Warning?3?5Attempt?5to?5deactivate?5a@ ; `string'
;	COMDAT ??_C@_0DI@CMFHAAD@Warning?3?5Attempt?5to?5activate?5alr@
CONST	SEGMENT
??_C@_0DI@CMFHAAD@Warning?3?5Attempt?5to?5activate?5alr@ DB 'Warning: Att'
	DB	'empt to activate already active audiopath.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@GFNFLPMP@Warning?3?5Attempt?5to?5deactivate?5a@
CONST	SEGMENT
??_C@_0DM@GFNFLPMP@Warning?3?5Attempt?5to?5deactivate?5a@ DB 'Warning: At'
	DB	'tempt to deactivate already inactive audiopath.', 0aH, 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?Activate@CAudioPath@@UAGJH@Z
_TEXT	SEGMENT
_pPerf$70292 = -8
_hr$ = -4
_this$ = 8
_fActivate$ = 12
?Activate@CAudioPath@@UAGJH@Z PROC NEAR			; CAudioPath::Activate, COMDAT

; 1881 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1882 :     TraceI(2,"Audiopath %lx Activate: %ld\n",this,fActivate);
; 1883 :     if (fActivate == m_fActive)

  00006	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00009	8b 4d 0c	 mov	 ecx, DWORD PTR _fActivate$[ebp]
  0000c	3b 48 48	 cmp	 ecx, DWORD PTR [eax+72]
  0000f	75 30		 jne	 SHORT $L70285

; 1884 :     {
; 1885 : #ifdef DBG
; 1886 :         if (fActivate) Trace(2,"Warning: Attempt to activate already active audiopath.\n");

  00011	83 7d 0c 00	 cmp	 DWORD PTR _fActivate$[ebp], 0
  00015	74 11		 je	 SHORT $L70286
  00017	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@CMFHAAD@Warning?3?5Attempt?5to?5activate?5alr@
  0001c	6a 02		 push	 2
  0001e	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00023	83 c4 08	 add	 esp, 8

; 1887 :         else Trace(2,"Warning: Attempt to deactivate already inactive audiopath.\n");

  00026	eb 0f		 jmp	 SHORT $L70288
$L70286:
  00028	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DM@GFNFLPMP@Warning?3?5Attempt?5to?5deactivate?5a@
  0002d	6a 02		 push	 2
  0002f	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00034	83 c4 08	 add	 esp, 8
$L70288:

; 1888 : #endif
; 1889 :         return S_FALSE;

  00037	b8 01 00 00 00	 mov	 eax, 1
  0003c	e9 ce 00 00 00	 jmp	 $L70283
$L70285:

; 1890 :     }
; 1891 :     ENTER_API_CRITICAL_SECTION;
; 1892 :     m_fActive = fActivate;

  00041	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00044	8b 45 0c	 mov	 eax, DWORD PTR _fActivate$[ebp]
  00047	89 42 48	 mov	 DWORD PTR [edx+72], eax

; 1893 :     if (!fActivate && !m_fDeactivating)

  0004a	83 7d 0c 00	 cmp	 DWORD PTR _fActivate$[ebp], 0
  0004e	75 48		 jne	 SHORT $L70291
  00050	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	83 79 28 00	 cmp	 DWORD PTR [ecx+40], 0
  00057	75 3f		 jne	 SHORT $L70291

; 1894 :     {
; 1895 :         ENTER_CRITICAL_SECTION(&m_CriticalSection);

  00059	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0005c	83 c2 2c	 add	 edx, 44			; 0000002cH
  0005f	52		 push	 edx
  00060	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 1896 :         CPerformance *pPerf = m_pPerformance;

  00066	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00069	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  0006c	89 4d f8	 mov	 DWORD PTR _pPerf$70292[ebp], ecx

; 1897 :         LEAVE_CRITICAL_SECTION(&m_CriticalSection);

  0006f	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00072	83 c2 2c	 add	 edx, 44			; 0000002cH
  00075	52		 push	 edx
  00076	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 1898 :         if (pPerf)

  0007c	83 7d f8 00	 cmp	 DWORD PTR _pPerf$70292[ebp], 0
  00080	74 16		 je	 SHORT $L70291

; 1899 :         {
; 1900 :             // Kill anything currently playing on the audiopath.
; 1901 :             pPerf->StopEx(static_cast<IDirectMusicAudioPath*>(this),0,0);

  00082	6a 00		 push	 0
  00084	6a 00		 push	 0
  00086	6a 00		 push	 0
  00088	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0008b	50		 push	 eax
  0008c	8b 4d f8	 mov	 ecx, DWORD PTR _pPerf$70292[ebp]
  0008f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00091	8b 45 f8	 mov	 eax, DWORD PTR _pPerf$70292[ebp]
  00094	50		 push	 eax
  00095	ff 52 44	 call	 DWORD PTR [edx+68]
$L70291:

; 1902 :         }
; 1903 :     }
; 1904 :     ENTER_CRITICAL_SECTION(&m_CriticalSection);

  00098	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0009b	83 c1 2c	 add	 ecx, 44			; 0000002cH
  0009e	51		 push	 ecx
  0009f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 1905 :     HRESULT hr = m_BufferConfigList.Activate(fActivate);

  000a5	8b 55 0c	 mov	 edx, DWORD PTR _fActivate$[ebp]
  000a8	52		 push	 edx
  000a9	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000ac	83 c1 6c	 add	 ecx, 108		; 0000006cH
  000af	e8 00 00 00 00	 call	 ?Activate@CBufferConfigList@@QAEJH@Z ; CBufferConfigList::Activate
  000b4	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 1906 :     if (SUCCEEDED(hr))

  000b7	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000bb	7c 2d		 jl	 SHORT $L70297

; 1907 :     {
; 1908 :         hr = m_PortConfigList.Activate(fActivate);

  000bd	8b 45 0c	 mov	 eax, DWORD PTR _fActivate$[ebp]
  000c0	50		 push	 eax
  000c1	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000c4	83 c1 68	 add	 ecx, 104		; 00000068H
  000c7	e8 00 00 00 00	 call	 ?Activate@CPortConfigList@@QAEJH@Z ; CPortConfigList::Activate
  000cc	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 1909 :         if (FAILED(hr))

  000cf	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000d3	7d 15		 jge	 SHORT $L70297

; 1910 :         {
; 1911 :             m_BufferConfigList.Activate(!fActivate);

  000d5	33 c9		 xor	 ecx, ecx
  000d7	83 7d 0c 00	 cmp	 DWORD PTR _fActivate$[ebp], 0
  000db	0f 94 c1	 sete	 cl
  000de	51		 push	 ecx
  000df	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000e2	83 c1 6c	 add	 ecx, 108		; 0000006cH
  000e5	e8 00 00 00 00	 call	 ?Activate@CBufferConfigList@@QAEJH@Z ; CBufferConfigList::Activate
$L70297:

; 1912 :         }
; 1913 :     }
; 1914 :     LEAVE_CRITICAL_SECTION(&m_CriticalSection);

  000ea	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  000ed	83 c2 2c	 add	 edx, 44			; 0000002cH
  000f0	52		 push	 edx
  000f1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 1915 :     if (FAILED(hr))

  000f7	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000fb	7d 0f		 jge	 SHORT $L70301

; 1916 :     {
; 1917 :         m_fActive = !fActivate;

  000fd	33 c0		 xor	 eax, eax
  000ff	83 7d 0c 00	 cmp	 DWORD PTR _fActivate$[ebp], 0
  00103	0f 94 c0	 sete	 al
  00106	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00109	89 41 48	 mov	 DWORD PTR [ecx+72], eax
$L70301:

; 1918 :     }
; 1919 :     LEAVE_API_CRITICAL_SECTION;
; 1920 :     return hr;

  0010c	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]
$L70283:

; 1921 : }

  0010f	8b e5		 mov	 esp, ebp
  00111	5d		 pop	 ebp
  00112	c2 08 00	 ret	 8
?Activate@CAudioPath@@UAGJH@Z ENDP			; CAudioPath::Activate
_TEXT	ENDS
PUBLIC	??_C@_0CE@IGLHMFAG@?$CFs?3?5Invalid?5pointer?5pdwPChannelO@ ; `string'
PUBLIC	??_C@_0EG@OPHKJFGH@Error?3?5Audiopath?5failed?5request?5@ ; `string'
;	COMDAT ?__szValidateInterfaceName@?1??ConvertPChannel@CAudioPath@@UAGJKPAK@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??ConvertPChannel@CAudioPath@@UAGJKPAK@Z@4QBDB DB 'I'
	DB	'DirectMusicAudioPath::ConvertPChannel', 00H	; `CAudioPath::ConvertPChannel'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0CE@IGLHMFAG@?$CFs?3?5Invalid?5pointer?5pdwPChannelO@
CONST	SEGMENT
??_C@_0CE@IGLHMFAG@?$CFs?3?5Invalid?5pointer?5pdwPChannelO@ DB '%s: Inval'
	DB	'id pointer pdwPChannelOut', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@OPHKJFGH@Error?3?5Audiopath?5failed?5request?5@
CONST	SEGMENT
??_C@_0EG@OPHKJFGH@Error?3?5Audiopath?5failed?5request?5@ DB 'Error: Audi'
	DB	'opath failed request to convert out of range PChannel %ld', 0aH
	DB	00H						; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?ConvertPChannel@CAudioPath@@UAGJKPAK@Z
_TEXT	SEGMENT
_dwScan$ = -4
_this$ = 8
_dwPChannelIn$ = 12
_pdwPChannelOut$ = 16
?ConvertPChannel@CAudioPath@@UAGJKPAK@Z PROC NEAR	; CAudioPath::ConvertPChannel, COMDAT

; 1925 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1926 :     V_INAME(IDirectMusicAudioPath::ConvertPChannel);
; 1927 :     V_PTR_WRITE(pdwPChannelOut,DWORD);

  00004	6a 04		 push	 4
  00006	8b 45 10	 mov	 eax, DWORD PTR _pdwPChannelOut$[ebp]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  0000f	85 c0		 test	 eax, eax
  00011	74 19		 je	 SHORT $L70310
  00013	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??ConvertPChannel@CAudioPath@@UAGJKPAK@Z@4QBDB
  00018	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CE@IGLHMFAG@?$CFs?3?5Invalid?5pointer?5pdwPChannelO@
  0001d	6a ff		 push	 -1
  0001f	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00024	83 c4 0c	 add	 esp, 12			; 0000000cH
  00027	e8 00 00 00 00	 call	 _DebugBreak@0
$L70310:

; 1928 : 
; 1929 :     // If any special PMsg address (for example, broadcast), leave as is.
; 1930 :     if (dwPChannelIn >= DMUS_PCHANNEL_KILL_ME)

  0002c	83 7d 0c f0	 cmp	 DWORD PTR _dwPChannelIn$[ebp], -16 ; fffffff0H
  00030	72 0c		 jb	 SHORT $L70312

; 1931 :     {
; 1932 :         *pdwPChannelOut = dwPChannelIn;

  00032	8b 4d 10	 mov	 ecx, DWORD PTR _pdwPChannelOut$[ebp]
  00035	8b 55 0c	 mov	 edx, DWORD PTR _dwPChannelIn$[ebp]
  00038	89 11		 mov	 DWORD PTR [ecx], edx

; 1933 :         return S_OK;

  0003a	33 c0		 xor	 eax, eax
  0003c	eb 5d		 jmp	 SHORT $L70306
$L70312:

; 1934 :     }
; 1935 :     DWORD dwScan = 0;

  0003e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _dwScan$[ebp], 0

; 1936 :     for (;dwScan < m_dwChannelCount;dwScan++)

  00045	eb 09		 jmp	 SHORT $L70315
$L70316:
  00047	8b 45 fc	 mov	 eax, DWORD PTR _dwScan$[ebp]
  0004a	83 c0 01	 add	 eax, 1
  0004d	89 45 fc	 mov	 DWORD PTR _dwScan$[ebp], eax
$L70315:
  00050	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	8b 55 fc	 mov	 edx, DWORD PTR _dwScan$[ebp]
  00056	3b 51 58	 cmp	 edx, DWORD PTR [ecx+88]
  00059	73 28		 jae	 SHORT $L70317

; 1937 :     {
; 1938 :         if (m_pdwVChannels[dwScan] == dwPChannelIn)

  0005b	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  00061	8b 55 fc	 mov	 edx, DWORD PTR _dwScan$[ebp]
  00064	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  00067	3b 45 0c	 cmp	 eax, DWORD PTR _dwPChannelIn$[ebp]
  0006a	75 15		 jne	 SHORT $L70318

; 1939 :         {
; 1940 :             *pdwPChannelOut = m_pdwPChannels[dwScan];

  0006c	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0006f	8b 51 54	 mov	 edx, DWORD PTR [ecx+84]
  00072	8b 45 10	 mov	 eax, DWORD PTR _pdwPChannelOut$[ebp]
  00075	8b 4d fc	 mov	 ecx, DWORD PTR _dwScan$[ebp]
  00078	8b 14 8a	 mov	 edx, DWORD PTR [edx+ecx*4]
  0007b	89 10		 mov	 DWORD PTR [eax], edx

; 1941 :             return S_OK;

  0007d	33 c0		 xor	 eax, eax
  0007f	eb 1a		 jmp	 SHORT $L70306
$L70318:

; 1942 :         }
; 1943 :     }

  00081	eb c4		 jmp	 SHORT $L70316
$L70317:

; 1944 :     Trace(1,"Error: Audiopath failed request to convert out of range PChannel %ld\n",dwPChannelIn);

  00083	8b 45 0c	 mov	 eax, DWORD PTR _dwPChannelIn$[ebp]
  00086	50		 push	 eax
  00087	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EG@OPHKJFGH@Error?3?5Audiopath?5failed?5request?5@
  0008c	6a 01		 push	 1
  0008e	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00093	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1945 :     return DMUS_E_NOT_FOUND;

  00096	b8 61 11 78 88	 mov	 eax, -2005397151	; 88781161H
$L70306:

; 1946 : }

  0009b	8b e5		 mov	 esp, ebp
  0009d	5d		 pop	 ebp
  0009e	c2 0c 00	 ret	 12			; 0000000cH
?ConvertPChannel@CAudioPath@@UAGJKPAK@Z ENDP		; CAudioPath::ConvertPChannel
_TEXT	ENDS
PUBLIC	?Shutdown@CAudioPath@@QAGJXZ			; CAudioPath::Shutdown
; Function compile flags: /Odt
;	COMDAT ?Shutdown@CAudioPath@@QAGJXZ
_TEXT	SEGMENT
_this$ = 8
?Shutdown@CAudioPath@@QAGJXZ PROC NEAR			; CAudioPath::Shutdown, COMDAT

; 1949 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1950 :     return E_NOTIMPL;

  00003	b8 01 40 00 80	 mov	 eax, -2147467263	; 80004001H

; 1951 : }

  00008	5d		 pop	 ebp
  00009	c2 04 00	 ret	 4
?Shutdown@CAudioPath@@QAGJXZ ENDP			; CAudioPath::Shutdown
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?InsertTool@CAudioPath@@UAGJPAUIDirectMusicTool@@PAKKJ@Z
_TEXT	SEGMENT
_this$ = 8
_pTool$ = 12
_pdwPChannels$ = 16
_cPChannels$ = 20
_lIndex$ = 24
?InsertTool@CAudioPath@@UAGJPAUIDirectMusicTool@@PAKKJ@Z PROC NEAR ; CAudioPath::InsertTool, COMDAT

; 1958 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1959 :     return E_NOTIMPL;

  00003	b8 01 40 00 80	 mov	 eax, -2147467263	; 80004001H

; 1960 : }

  00008	5d		 pop	 ebp
  00009	c2 14 00	 ret	 20			; 00000014H
?InsertTool@CAudioPath@@UAGJPAUIDirectMusicTool@@PAKKJ@Z ENDP ; CAudioPath::InsertTool
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetTool@CAudioPath@@UAGJKPAPAUIDirectMusicTool@@@Z
_TEXT	SEGMENT
_this$ = 8
_dwIndex$ = 12
_ppTool$ = 16
?GetTool@CAudioPath@@UAGJKPAPAUIDirectMusicTool@@@Z PROC NEAR ; CAudioPath::GetTool, COMDAT

; 1965 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1966 :     return E_NOTIMPL;

  00003	b8 01 40 00 80	 mov	 eax, -2147467263	; 80004001H

; 1967 : }

  00008	5d		 pop	 ebp
  00009	c2 0c 00	 ret	 12			; 0000000cH
?GetTool@CAudioPath@@UAGJKPAPAUIDirectMusicTool@@@Z ENDP ; CAudioPath::GetTool
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?RemoveTool@CAudioPath@@UAGJPAUIDirectMusicTool@@@Z
_TEXT	SEGMENT
_this$ = 8
_pTool$ = 12
?RemoveTool@CAudioPath@@UAGJPAUIDirectMusicTool@@@Z PROC NEAR ; CAudioPath::RemoveTool, COMDAT

; 1971 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1972 :     return E_NOTIMPL;

  00003	b8 01 40 00 80	 mov	 eax, -2147467263	; 80004001H

; 1973 : }

  00008	5d		 pop	 ebp
  00009	c2 08 00	 ret	 8
?RemoveTool@CAudioPath@@UAGJPAUIDirectMusicTool@@@Z ENDP ; CAudioPath::RemoveTool
_TEXT	ENDS
PUBLIC	??_C@_0BL@KLPIMHHM@?$CFs?3?5Invalid?5pointer?5pPMsg?6?$AA@ ; `string'
PUBLIC	??_C@_0EJ@FAHOIMCJ@Error?3?5Attempting?5to?5play?5on?5an?5@ ; `string'
;	COMDAT ?__szValidateInterfaceName@?1??StampPMsg@CAudioPath@@UAGJPAU_DMUS_PMSG@@@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??StampPMsg@CAudioPath@@UAGJPAU_DMUS_PMSG@@@Z@4QBDB DB 'I'
	DB	'DirectMusicAudioPath::StampPMsg', 00H	; `CAudioPath::StampPMsg'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0BL@KLPIMHHM@?$CFs?3?5Invalid?5pointer?5pPMsg?6?$AA@
CONST	SEGMENT
??_C@_0BL@KLPIMHHM@?$CFs?3?5Invalid?5pointer?5pPMsg?6?$AA@ DB '%s: Invali'
	DB	'd pointer pPMsg', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EJ@FAHOIMCJ@Error?3?5Attempting?5to?5play?5on?5an?5@
CONST	SEGMENT
??_C@_0EJ@FAHOIMCJ@Error?3?5Attempting?5to?5play?5on?5an?5@ DB 'Error: At'
	DB	'tempting to play on an inactive AudioPath, PMsg being ignored'
	DB	'.', 0aH, 00H				; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?StampPMsg@CAudioPath@@UAGJPAU_DMUS_PMSG@@@Z
_TEXT	SEGMENT
tv159 = -28
tv142 = -24
_dwScan$70395 = -20
_pNewMsg$70389 = -16
_dwNewChannel$70386 = -12
_dwIndex$70382 = -8
_hr$ = -4
_this$ = 8
_pPMsg$ = 12
?StampPMsg@CAudioPath@@UAGJPAU_DMUS_PMSG@@@Z PROC NEAR	; CAudioPath::StampPMsg, COMDAT

; 1977 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 1978 :     V_INAME(IDirectMusicAudioPath::StampPMsg);
; 1979 :     V_BUFPTR_WRITE(pPMsg,sizeof(DMUS_PMSG));

  00006	6a 38		 push	 56			; 00000038H
  00008	8b 45 0c	 mov	 eax, DWORD PTR _pPMsg$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  00011	85 c0		 test	 eax, eax
  00013	74 19		 je	 SHORT $L70355
  00015	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??StampPMsg@CAudioPath@@UAGJPAU_DMUS_PMSG@@@Z@4QBDB
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BL@KLPIMHHM@?$CFs?3?5Invalid?5pointer?5pPMsg?6?$AA@
  0001f	6a ff		 push	 -1
  00021	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH
  00029	e8 00 00 00 00	 call	 _DebugBreak@0
$L70355:

; 1980 : 
; 1981 :     HRESULT hr = E_FAIL;

  0002e	c7 45 fc 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H

; 1982 :     
; 1983 :     if (!m_fActive)

  00035	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	83 79 44 00	 cmp	 DWORD PTR [ecx+68], 0
  0003c	75 35		 jne	 SHORT $L70359

; 1984 :     {
; 1985 :         // Only kill notes and wave messages, since they are the only PMsgs that make sound.
; 1986 :         if ((pPMsg->dwType == DMUS_PMSGT_NOTE) || (pPMsg->dwType == DMUS_PMSGT_WAVE))

  0003e	8b 55 0c	 mov	 edx, DWORD PTR _pPMsg$[ebp]
  00041	83 7a 28 01	 cmp	 DWORD PTR [edx+40], 1
  00045	74 09		 je	 SHORT $L70361
  00047	8b 45 0c	 mov	 eax, DWORD PTR _pPMsg$[ebp]
  0004a	83 78 28 0c	 cmp	 DWORD PTR [eax+40], 12	; 0000000cH
  0004e	75 23		 jne	 SHORT $L70359
$L70361:

; 1987 :         {
; 1988 :             pPMsg->dwPChannel = DMUS_PCHANNEL_KILL_ME;

  00050	8b 4d 0c	 mov	 ecx, DWORD PTR _pPMsg$[ebp]
  00053	c7 41 18 f0 ff
	ff ff		 mov	 DWORD PTR [ecx+24], -16	; fffffff0H

; 1989 :             Trace(1,"Error: Attempting to play on an inactive AudioPath, PMsg being ignored.\n");

  0005a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EJ@FAHOIMCJ@Error?3?5Attempting?5to?5play?5on?5an?5@
  0005f	6a 01		 push	 1
  00061	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00066	83 c4 08	 add	 esp, 8

; 1990 :             return DMUS_E_AUDIOPATH_INACTIVE;

  00069	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  0006e	e9 63 02 00 00	 jmp	 $L70351
$L70359:

; 1991 :         }
; 1992 :     }
; 1993 :     ENTER_CRITICAL_SECTION(&m_CriticalSection);

  00073	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00076	83 c2 28	 add	 edx, 40			; 00000028H
  00079	52		 push	 edx
  0007a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 1994 :     if (!m_pPerformance)

  00080	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00083	83 78 5c 00	 cmp	 DWORD PTR [eax+92], 0
  00087	75 17		 jne	 SHORT $L70364

; 1995 :     {
; 1996 :         LEAVE_CRITICAL_SECTION(&m_CriticalSection);

  00089	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0008c	83 c1 28	 add	 ecx, 40			; 00000028H
  0008f	51		 push	 ecx
  00090	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 1997 :         return DMUS_E_NOT_INIT;

  00096	b8 62 11 78 88	 mov	 eax, -2005397150	; 88781162H
  0009b	e9 36 02 00 00	 jmp	 $L70351
$L70364:

; 1998 :     }
; 1999 : 	ENTER_API_CRITICAL_SECTION;
; 2000 :     // First, check if the audio path has its own graph.
; 2001 :     if (m_pGraph)

  000a0	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  000a3	83 7a 58 00	 cmp	 DWORD PTR [edx+88], 0
  000a7	0f 84 9a 00 00
	00		 je	 $L70369

; 2002 :     {
; 2003 :         // Could return DMUS_S_LAST_TOOL, indicating end of graph. 
; 2004 :         // If so, we'll treat that as a failure and drop on through to the next graph...
; 2005 :         if( S_OK == ( hr = m_pGraph->StampPMsg( pPMsg )))

  000ad	8b 45 0c	 mov	 eax, DWORD PTR _pPMsg$[ebp]
  000b0	50		 push	 eax
  000b1	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000b4	8b 51 58	 mov	 edx, DWORD PTR [ecx+88]
  000b7	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  000ba	8b 48 58	 mov	 ecx, DWORD PTR [eax+88]
  000bd	8b 12		 mov	 edx, DWORD PTR [edx]
  000bf	51		 push	 ecx
  000c0	ff 52 0c	 call	 DWORD PTR [edx+12]
  000c3	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
  000c6	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000ca	75 7b		 jne	 SHORT $L70369

; 2006 :         {
; 2007 :             if( pPMsg->pGraph != this ) // Make sure this is set to point to the segstate embedded graph so it will come here again.

  000cc	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  000cf	83 e8 04	 sub	 eax, 4
  000d2	85 c0		 test	 eax, eax
  000d4	74 08		 je	 SHORT $L71782
  000d6	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000d9	89 4d e8	 mov	 DWORD PTR tv142[ebp], ecx
  000dc	eb 07		 jmp	 SHORT $L71783
$L71782:
  000de	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR tv142[ebp], 0
$L71783:
  000e5	8b 55 0c	 mov	 edx, DWORD PTR _pPMsg$[ebp]
  000e8	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  000eb	3b 45 e8	 cmp	 eax, DWORD PTR tv142[ebp]
  000ee	74 57		 je	 SHORT $L70369

; 2008 :             {
; 2009 :                 if( pPMsg->pGraph )

  000f0	8b 4d 0c	 mov	 ecx, DWORD PTR _pPMsg$[ebp]
  000f3	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  000f7	74 1c		 je	 SHORT $L70373

; 2010 :                 {
; 2011 :                     pPMsg->pGraph->Release();

  000f9	8b 55 0c	 mov	 edx, DWORD PTR _pPMsg$[ebp]
  000fc	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  000ff	8b 4d 0c	 mov	 ecx, DWORD PTR _pPMsg$[ebp]
  00102	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00105	8b 00		 mov	 eax, DWORD PTR [eax]
  00107	52		 push	 edx
  00108	ff 50 08	 call	 DWORD PTR [eax+8]

; 2012 :                     pPMsg->pGraph = NULL;

  0010b	8b 4d 0c	 mov	 ecx, DWORD PTR _pPMsg$[ebp]
  0010e	c7 41 24 00 00
	00 00		 mov	 DWORD PTR [ecx+36], 0
$L70373:

; 2013 :                 }
; 2014 :                 pPMsg->pGraph = this;

  00115	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00118	83 ea 04	 sub	 edx, 4
  0011b	85 d2		 test	 edx, edx
  0011d	74 08		 je	 SHORT $L71784
  0011f	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00122	89 45 e4	 mov	 DWORD PTR tv159[ebp], eax
  00125	eb 07		 jmp	 SHORT $L71785
$L71784:
  00127	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR tv159[ebp], 0
$L71785:
  0012e	8b 4d 0c	 mov	 ecx, DWORD PTR _pPMsg$[ebp]
  00131	8b 55 e4	 mov	 edx, DWORD PTR tv159[ebp]
  00134	89 51 24	 mov	 DWORD PTR [ecx+36], edx

; 2015 :                 AddRef();

  00137	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0013a	83 e8 04	 sub	 eax, 4
  0013d	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00140	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  00143	50		 push	 eax
  00144	ff 52 04	 call	 DWORD PTR [edx+4]
$L70369:

; 2016 :             }
; 2017 :         }
; 2018 :     }
; 2019 :     
; 2020 :     // If done with the graph, send to the performance. Also, check for the special case of 
; 2021 :     // DMUS_PCHANNEL_BROADCAST_AUDIOPATH. If so, duplicate the pMsg
; 2022 :     // and send all the copies with the appropriate pchannel values.
; 2023 :     // Otherwise, convert the vchannel to the matching pchannel (this is the
; 2024 :     // point where the pchannel mapping occurs.)
; 2025 :     if( FAILED(hr) || (hr == DMUS_S_LAST_TOOL))

  00147	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0014b	7c 0d		 jl	 SHORT $L70380
  0014d	81 7d fc 11 12
	78 08		 cmp	 DWORD PTR _hr$[ebp], 142086673 ; 08781211H
  00154	0f 85 6c 01 00
	00		 jne	 $L70379
$L70380:

; 2026 :     {
; 2027 :         if (pPMsg->dwPChannel == DMUS_PCHANNEL_BROADCAST_AUDIOPATH)

  0015a	8b 45 0c	 mov	 eax, DWORD PTR _pPMsg$[ebp]
  0015d	83 78 18 fe	 cmp	 DWORD PTR [eax+24], -2	; fffffffeH
  00161	0f 85 d4 00 00
	00		 jne	 $L70381

; 2028 :         {
; 2029 :             DWORD dwIndex;
; 2030 :             for (dwIndex = 1;dwIndex < m_dwChannelCount;dwIndex++)

  00167	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _dwIndex$70382[ebp], 1
  0016e	eb 09		 jmp	 SHORT $L70383
$L70384:
  00170	8b 4d f8	 mov	 ecx, DWORD PTR _dwIndex$70382[ebp]
  00173	83 c1 01	 add	 ecx, 1
  00176	89 4d f8	 mov	 DWORD PTR _dwIndex$70382[ebp], ecx
$L70383:
  00179	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0017c	8b 45 f8	 mov	 eax, DWORD PTR _dwIndex$70382[ebp]
  0017f	3b 42 54	 cmp	 eax, DWORD PTR [edx+84]
  00182	0f 83 85 00 00
	00		 jae	 $L70385

; 2031 :             {
; 2032 :                 DWORD dwNewChannel = m_pdwPChannels[dwIndex];

  00188	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0018b	8b 51 50	 mov	 edx, DWORD PTR [ecx+80]
  0018e	8b 45 f8	 mov	 eax, DWORD PTR _dwIndex$70382[ebp]
  00191	8b 0c 82	 mov	 ecx, DWORD PTR [edx+eax*4]
  00194	89 4d f4	 mov	 DWORD PTR _dwNewChannel$70386[ebp], ecx

; 2033 :                 // Don't broadcast any broadcast messages!
; 2034 :                 // And, if this is a transpose on the drum channel, don't send it.
; 2035 :                 if ((dwNewChannel < DMUS_PCHANNEL_BROADCAST_GROUPS) &&
; 2036 :                     ((pPMsg->dwType != DMUS_PMSGT_TRANSPOSE) || ((dwNewChannel & 0xF) != 9)))

  00197	83 7d f4 fc	 cmp	 DWORD PTR _dwNewChannel$70386[ebp], -4 ; fffffffcH
  0019b	73 6b		 jae	 SHORT $L70387
  0019d	8b 55 0c	 mov	 edx, DWORD PTR _pPMsg$[ebp]
  001a0	83 7a 28 08	 cmp	 DWORD PTR [edx+40], 8
  001a4	75 0b		 jne	 SHORT $L70388
  001a6	8b 45 f4	 mov	 eax, DWORD PTR _dwNewChannel$70386[ebp]
  001a9	83 e0 0f	 and	 eax, 15			; 0000000fH
  001ac	83 f8 09	 cmp	 eax, 9
  001af	74 57		 je	 SHORT $L70387
$L70388:

; 2037 :                 {
; 2038 :                     DMUS_PMSG *pNewMsg;
; 2039 :                     if (SUCCEEDED(m_pPerformance->ClonePMsg(pPMsg,&pNewMsg)))

  001b1	8d 4d f0	 lea	 ecx, DWORD PTR _pNewMsg$70389[ebp]
  001b4	51		 push	 ecx
  001b5	8b 55 0c	 mov	 edx, DWORD PTR _pPMsg$[ebp]
  001b8	52		 push	 edx
  001b9	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  001bc	8b 48 5c	 mov	 ecx, DWORD PTR [eax+92]
  001bf	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  001c2	8b 42 5c	 mov	 eax, DWORD PTR [edx+92]
  001c5	8b 09		 mov	 ecx, DWORD PTR [ecx]
  001c7	50		 push	 eax
  001c8	ff 51 48	 call	 DWORD PTR [ecx+72]
  001cb	85 c0		 test	 eax, eax
  001cd	7c 39		 jl	 SHORT $L70387

; 2040 :                     {
; 2041 :                         pNewMsg->dwPChannel = dwNewChannel;

  001cf	8b 55 f0	 mov	 edx, DWORD PTR _pNewMsg$70389[ebp]
  001d2	8b 45 f4	 mov	 eax, DWORD PTR _dwNewChannel$70386[ebp]
  001d5	89 42 18	 mov	 DWORD PTR [edx+24], eax

; 2042 :                         m_pPerformance->StampPMsg(pNewMsg);

  001d8	8b 4d f0	 mov	 ecx, DWORD PTR _pNewMsg$70389[ebp]
  001db	51		 push	 ecx
  001dc	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  001df	8b 42 5c	 mov	 eax, DWORD PTR [edx+92]
  001e2	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  001e5	8b 51 5c	 mov	 edx, DWORD PTR [ecx+92]
  001e8	83 c2 08	 add	 edx, 8
  001eb	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  001ee	52		 push	 edx
  001ef	ff 50 0c	 call	 DWORD PTR [eax+12]

; 2043 :                         m_pPerformance->SendPMsg(pNewMsg);

  001f2	8b 4d f0	 mov	 ecx, DWORD PTR _pNewMsg$70389[ebp]
  001f5	51		 push	 ecx
  001f6	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  001f9	8b 42 5c	 mov	 eax, DWORD PTR [edx+92]
  001fc	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  001ff	8b 51 5c	 mov	 edx, DWORD PTR [ecx+92]
  00202	8b 00		 mov	 eax, DWORD PTR [eax]
  00204	52		 push	 edx
  00205	ff 50 10	 call	 DWORD PTR [eax+16]
$L70387:

; 2044 :                     }
; 2045 :                 }
; 2046 :             }

  00208	e9 63 ff ff ff	 jmp	 $L70384
$L70385:

; 2047 :             // Now, set the pchannel for this one. First check that there are any
; 2048 :             // pchannels. If none, mark the PMsg to be deleted by the SendPMsg routine.
; 2049 :             // Also, mark it this way if the PMsg is a broadcast PMsg.
; 2050 :             pPMsg->dwPChannel = DMUS_PCHANNEL_KILL_ME;

  0020d	8b 4d 0c	 mov	 ecx, DWORD PTR _pPMsg$[ebp]
  00210	c7 41 18 f0 ff
	ff ff		 mov	 DWORD PTR [ecx+24], -16	; fffffff0H

; 2051 :             if (m_dwChannelCount)

  00217	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0021a	83 7a 54 00	 cmp	 DWORD PTR [edx+84], 0
  0021e	74 19		 je	 SHORT $L70392

; 2052 :             {
; 2053 :                 if (m_pdwPChannels[0] < DMUS_PCHANNEL_BROADCAST_GROUPS)

  00220	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00223	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  00226	83 39 fc	 cmp	 DWORD PTR [ecx], -4	; fffffffcH
  00229	73 0e		 jae	 SHORT $L70392

; 2054 :                 {
; 2055 :                     pPMsg->dwPChannel = m_pdwPChannels[0];

  0022b	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0022e	8b 42 50	 mov	 eax, DWORD PTR [edx+80]
  00231	8b 4d 0c	 mov	 ecx, DWORD PTR _pPMsg$[ebp]
  00234	8b 10		 mov	 edx, DWORD PTR [eax]
  00236	89 51 18	 mov	 DWORD PTR [ecx+24], edx
$L70392:

; 2056 :                 }
; 2057 :             }
; 2058 :         }
; 2059 :         else

  00239	eb 6e		 jmp	 SHORT $L70394
$L70381:

; 2060 :         {
; 2061 :             DWORD dwScan = 0;

  0023b	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _dwScan$70395[ebp], 0

; 2062 :             for (;dwScan < m_dwChannelCount;dwScan++)

  00242	eb 09		 jmp	 SHORT $L70396
$L70397:
  00244	8b 45 ec	 mov	 eax, DWORD PTR _dwScan$70395[ebp]
  00247	83 c0 01	 add	 eax, 1
  0024a	89 45 ec	 mov	 DWORD PTR _dwScan$70395[ebp], eax
$L70396:
  0024d	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00250	8b 55 ec	 mov	 edx, DWORD PTR _dwScan$70395[ebp]
  00253	3b 51 54	 cmp	 edx, DWORD PTR [ecx+84]
  00256	73 2a		 jae	 SHORT $L70398

; 2063 :             {
; 2064 :                 if (m_pdwVChannels[dwScan] == pPMsg->dwPChannel)

  00258	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0025b	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  0025e	8b 55 ec	 mov	 edx, DWORD PTR _dwScan$70395[ebp]
  00261	8b 45 0c	 mov	 eax, DWORD PTR _pPMsg$[ebp]
  00264	8b 0c 91	 mov	 ecx, DWORD PTR [ecx+edx*4]
  00267	3b 48 18	 cmp	 ecx, DWORD PTR [eax+24]
  0026a	75 14		 jne	 SHORT $L70399

; 2065 :                 {
; 2066 :                     pPMsg->dwPChannel = m_pdwPChannels[dwScan];

  0026c	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0026f	8b 42 50	 mov	 eax, DWORD PTR [edx+80]
  00272	8b 4d 0c	 mov	 ecx, DWORD PTR _pPMsg$[ebp]
  00275	8b 55 ec	 mov	 edx, DWORD PTR _dwScan$70395[ebp]
  00278	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]
  0027b	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 2067 :                     break;

  0027e	eb 02		 jmp	 SHORT $L70398
$L70399:

; 2068 :                 }
; 2069 :             }

  00280	eb c2		 jmp	 SHORT $L70397
$L70398:

; 2070 :             // If a map was not found, kill the message. 
; 2071 :             // But, ignore for notifications, since they really don't care about pchannel.
; 2072 :             // And, ignore for performance broadcast PMsgs.
; 2073 :             if ((dwScan == m_dwChannelCount) && 
; 2074 :                 (pPMsg->dwType != DMUS_PMSGT_NOTIFICATION) &&
; 2075 :                 (pPMsg->dwPChannel < DMUS_PCHANNEL_BROADCAST_GROUPS))

  00282	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00285	8b 55 ec	 mov	 edx, DWORD PTR _dwScan$70395[ebp]
  00288	3b 51 54	 cmp	 edx, DWORD PTR [ecx+84]
  0028b	75 1c		 jne	 SHORT $L70394
  0028d	8b 45 0c	 mov	 eax, DWORD PTR _pPMsg$[ebp]
  00290	83 78 28 03	 cmp	 DWORD PTR [eax+40], 3
  00294	74 13		 je	 SHORT $L70394
  00296	8b 4d 0c	 mov	 ecx, DWORD PTR _pPMsg$[ebp]
  00299	83 79 18 fc	 cmp	 DWORD PTR [ecx+24], -4	; fffffffcH
  0029d	73 0a		 jae	 SHORT $L70394

; 2076 :             {
; 2077 :                 pPMsg->dwPChannel = DMUS_PCHANNEL_KILL_ME;

  0029f	8b 55 0c	 mov	 edx, DWORD PTR _pPMsg$[ebp]
  002a2	c7 42 18 f0 ff
	ff ff		 mov	 DWORD PTR [edx+24], -16	; fffffff0H
$L70394:

; 2078 :             }
; 2079 :         }
; 2080 :         hr = m_pPerformance->StampPMsg(pPMsg);

  002a9	8b 45 0c	 mov	 eax, DWORD PTR _pPMsg$[ebp]
  002ac	50		 push	 eax
  002ad	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  002b0	8b 51 5c	 mov	 edx, DWORD PTR [ecx+92]
  002b3	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  002b6	8b 48 5c	 mov	 ecx, DWORD PTR [eax+92]
  002b9	83 c1 08	 add	 ecx, 8
  002bc	8b 52 08	 mov	 edx, DWORD PTR [edx+8]
  002bf	51		 push	 ecx
  002c0	ff 52 0c	 call	 DWORD PTR [edx+12]
  002c3	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
$L70379:

; 2081 :     }
; 2082 :     LEAVE_CRITICAL_SECTION(&m_CriticalSection);

  002c6	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  002c9	83 c0 28	 add	 eax, 40			; 00000028H
  002cc	50		 push	 eax
  002cd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 2083 : 	LEAVE_API_CRITICAL_SECTION;
; 2084 :     return hr;

  002d3	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]
$L70351:

; 2085 : }

  002d6	8b e5		 mov	 esp, ebp
  002d8	5d		 pop	 ebp
  002d9	c2 08 00	 ret	 8
?StampPMsg@CAudioPath@@UAGJPAU_DMUS_PMSG@@@Z ENDP	; CAudioPath::StampPMsg
_TEXT	ENDS
PUBLIC	?GetGraph@CAudioPath@@QAEPAVCGraph@@XZ		; CAudioPath::GetGraph
; Function compile flags: /Odt
;	COMDAT ?GetGraph@CAudioPath@@QAEPAVCGraph@@XZ
_TEXT	SEGMENT
_this$ = -8
_pGraph$ = -4
?GetGraph@CAudioPath@@QAEPAVCGraph@@XZ PROC NEAR	; CAudioPath::GetGraph, COMDAT
; _this$ = ecx

; 2089 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2090 :     CGraph *pGraph;
; 2091 :     ENTER_CRITICAL_SECTION(&m_CriticalSection);

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 2c	 add	 eax, 44			; 0000002cH
  0000f	50		 push	 eax
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 2092 :     // Return the graph, and AddRef if it exists.
; 2093 :     if (pGraph = m_pGraph)

  00016	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	8b 51 5c	 mov	 edx, DWORD PTR [ecx+92]
  0001c	89 55 fc	 mov	 DWORD PTR _pGraph$[ebp], edx
  0001f	83 7d fc 00	 cmp	 DWORD PTR _pGraph$[ebp], 0
  00023	74 12		 je	 SHORT $L70405

; 2094 :     {
; 2095 :         m_pGraph->AddRef();

  00025	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b 48 5c	 mov	 ecx, DWORD PTR [eax+92]
  0002b	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0002e	8b 42 5c	 mov	 eax, DWORD PTR [edx+92]
  00031	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00033	50		 push	 eax
  00034	ff 51 04	 call	 DWORD PTR [ecx+4]
$L70405:

; 2096 :     }
; 2097 :     LEAVE_CRITICAL_SECTION(&m_CriticalSection);

  00037	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0003a	83 c2 2c	 add	 edx, 44			; 0000002cH
  0003d	52		 push	 edx
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 2098 :     return pGraph;

  00044	8b 45 fc	 mov	 eax, DWORD PTR _pGraph$[ebp]

; 2099 : }

  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
?GetGraph@CAudioPath@@QAEPAVCGraph@@XZ ENDP		; CAudioPath::GetGraph
_TEXT	ENDS
PUBLIC	?Remove@CAudioPathList@@QAEXPAVCAudioPath@@@Z	; CAudioPathList::Remove
EXTRN	?RemoveUnusedPorts@CPerformance@@QAEXXZ:NEAR	; CPerformance::RemoveUnusedPorts
EXTRN	?ReleasePChannel@CPerformance@@AAEJK@Z:NEAR	; CPerformance::ReleasePChannel
; Function compile flags: /Odt
;	COMDAT ?Deactivate@CAudioPath@@QAEXXZ
_TEXT	SEGMENT
_this$ = -16
$T71793 = -12
$T71792 = -8
_dwIndex$70413 = -4
?Deactivate@CAudioPath@@QAEXXZ PROC NEAR		; CAudioPath::Deactivate, COMDAT
; _this$ = ecx

; 2102 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 2103 :     m_fDeactivating = TRUE;

  00009	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 40 28 01 00
	00 00		 mov	 DWORD PTR [eax+40], 1

; 2104 :     Activate(FALSE);

  00013	6a 00		 push	 0
  00015	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	50		 push	 eax
  0001e	ff 52 10	 call	 DWORD PTR [edx+16]

; 2105 :     ENTER_CRITICAL_SECTION(&m_CriticalSection);

  00021	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	83 c1 2c	 add	 ecx, 44			; 0000002cH
  00027	51		 push	 ecx
  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 2106 :     m_fActive = FALSE;

  0002e	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00031	c7 42 48 00 00
	00 00		 mov	 DWORD PTR [edx+72], 0

; 2107 :     m_PortConfigList.Clear();

  00038	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	83 c1 68	 add	 ecx, 104		; 00000068H
  0003e	e8 00 00 00 00	 call	 ?Clear@CPortConfigList@@QAEXXZ ; CPortConfigList::Clear

; 2108 :     m_BufferConfigList.Clear();

  00043	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	83 c1 6c	 add	 ecx, 108		; 0000006cH
  00049	e8 00 00 00 00	 call	 ?Clear@CBufferConfigList@@QAEXXZ ; CBufferConfigList::Clear

; 2109 :     if (m_pGraph)

  0004e	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00051	83 78 5c 00	 cmp	 DWORD PTR [eax+92], 0
  00055	74 1c		 je	 SHORT $L70409

; 2110 :     {
; 2111 :         m_pGraph->Release();

  00057	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005a	8b 51 5c	 mov	 edx, DWORD PTR [ecx+92]
  0005d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00060	8b 48 5c	 mov	 ecx, DWORD PTR [eax+92]
  00063	8b 12		 mov	 edx, DWORD PTR [edx]
  00065	51		 push	 ecx
  00066	ff 52 08	 call	 DWORD PTR [edx+8]

; 2112 :         m_pGraph = NULL;

  00069	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0006c	c7 40 5c 00 00
	00 00		 mov	 DWORD PTR [eax+92], 0
$L70409:

; 2113 :     }
; 2114 :     if (m_pConfig)

  00073	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00076	83 79 64 00	 cmp	 DWORD PTR [ecx+100], 0
  0007a	74 1c		 je	 SHORT $L70410

; 2115 :     {
; 2116 :         m_pConfig->Release();

  0007c	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0007f	8b 42 64	 mov	 eax, DWORD PTR [edx+100]
  00082	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00085	8b 51 64	 mov	 edx, DWORD PTR [ecx+100]
  00088	8b 00		 mov	 eax, DWORD PTR [eax]
  0008a	52		 push	 edx
  0008b	ff 50 08	 call	 DWORD PTR [eax+8]

; 2117 :         m_pConfig = NULL;

  0008e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00091	c7 41 64 00 00
	00 00		 mov	 DWORD PTR [ecx+100], 0
$L70410:

; 2118 :     }
; 2119 :     if (m_pPerformance)

  00098	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0009b	83 7a 60 00	 cmp	 DWORD PTR [edx+96], 0
  0009f	0f 84 af 00 00
	00		 je	 $L70411

; 2120 :     {
; 2121 :         if (m_pdwVChannels && m_pdwPChannels)

  000a5	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000a8	83 78 50 00	 cmp	 DWORD PTR [eax+80], 0
  000ac	74 6a		 je	 SHORT $L70412
  000ae	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000b1	83 79 54 00	 cmp	 DWORD PTR [ecx+84], 0
  000b5	74 61		 je	 SHORT $L70412

; 2122 :         {
; 2123 :             DWORD dwIndex;
; 2124 :             for (dwIndex = 0;dwIndex <m_dwChannelCount;dwIndex++)

  000b7	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _dwIndex$70413[ebp], 0
  000be	eb 09		 jmp	 SHORT $L70414
$L70415:
  000c0	8b 55 fc	 mov	 edx, DWORD PTR _dwIndex$70413[ebp]
  000c3	83 c2 01	 add	 edx, 1
  000c6	89 55 fc	 mov	 DWORD PTR _dwIndex$70413[ebp], edx
$L70414:
  000c9	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000cc	8b 4d fc	 mov	 ecx, DWORD PTR _dwIndex$70413[ebp]
  000cf	3b 48 58	 cmp	 ecx, DWORD PTR [eax+88]
  000d2	73 1a		 jae	 SHORT $L70416

; 2125 :             {
; 2126 :                 m_pPerformance->ReleasePChannel(m_pdwPChannels[dwIndex]);

  000d4	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  000d7	8b 42 54	 mov	 eax, DWORD PTR [edx+84]
  000da	8b 4d fc	 mov	 ecx, DWORD PTR _dwIndex$70413[ebp]
  000dd	8b 14 88	 mov	 edx, DWORD PTR [eax+ecx*4]
  000e0	52		 push	 edx
  000e1	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000e4	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  000e7	e8 00 00 00 00	 call	 ?ReleasePChannel@CPerformance@@AAEJK@Z ; CPerformance::ReleasePChannel

; 2127 :             }

  000ec	eb d2		 jmp	 SHORT $L70415
$L70416:

; 2128 :             delete [] m_pdwVChannels;

  000ee	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000f1	8b 51 50	 mov	 edx, DWORD PTR [ecx+80]
  000f4	89 55 f8	 mov	 DWORD PTR $T71792[ebp], edx
  000f7	8b 45 f8	 mov	 eax, DWORD PTR $T71792[ebp]
  000fa	50		 push	 eax
  000fb	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00100	83 c4 04	 add	 esp, 4

; 2129 :             delete [] m_pdwPChannels;

  00103	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00106	8b 51 54	 mov	 edx, DWORD PTR [ecx+84]
  00109	89 55 f4	 mov	 DWORD PTR $T71793[ebp], edx
  0010c	8b 45 f4	 mov	 eax, DWORD PTR $T71793[ebp]
  0010f	50		 push	 eax
  00110	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00115	83 c4 04	 add	 esp, 4
$L70412:

; 2130 :         }
; 2131 :         m_pPerformance->m_AudioPathList.Remove(this);

  00118	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0011b	51		 push	 ecx
  0011c	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0011f	8b 4a 60	 mov	 ecx, DWORD PTR [edx+96]
  00122	81 c1 94 00 00
	00		 add	 ecx, 148		; 00000094H
  00128	e8 00 00 00 00	 call	 ?Remove@CAudioPathList@@QAEXPAVCAudioPath@@@Z ; CAudioPathList::Remove

; 2132 :         m_pPerformance->RemoveUnusedPorts();

  0012d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00130	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00133	e8 00 00 00 00	 call	 ?RemoveUnusedPorts@CPerformance@@QAEXXZ ; CPerformance::RemoveUnusedPorts

; 2133 :         m_pPerformance->Release();

  00138	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0013b	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  0013e	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00141	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00144	8b 12		 mov	 edx, DWORD PTR [edx]
  00146	51		 push	 ecx
  00147	ff 52 08	 call	 DWORD PTR [edx+8]

; 2134 :         m_pPerformance = NULL;

  0014a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0014d	c7 40 60 00 00
	00 00		 mov	 DWORD PTR [eax+96], 0
$L70411:

; 2135 :     }
; 2136 :     m_fDeactivating = FALSE;

  00154	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00157	c7 41 28 00 00
	00 00		 mov	 DWORD PTR [ecx+40], 0

; 2137 :     LEAVE_CRITICAL_SECTION(&m_CriticalSection);

  0015e	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00161	83 c2 2c	 add	 edx, 44			; 0000002cH
  00164	52		 push	 edx
  00165	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 2138 : }

  0016b	8b e5		 mov	 esp, ebp
  0016d	5d		 pop	 ebp
  0016e	c3		 ret	 0
?Deactivate@CAudioPath@@QAEXXZ ENDP			; CAudioPath::Deactivate
_TEXT	ENDS
PUBLIC	?SetGraph@CAudioPath@@QAEXPAVCGraph@@@Z		; CAudioPath::SetGraph
; Function compile flags: /Odt
;	COMDAT ?SetGraph@CAudioPath@@QAEXPAVCGraph@@@Z
_TEXT	SEGMENT
_this$ = -4
_pGraph$ = 8
?SetGraph@CAudioPath@@QAEXPAVCGraph@@@Z PROC NEAR	; CAudioPath::SetGraph, COMDAT
; _this$ = ecx

; 2142 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2143 :     ENTER_CRITICAL_SECTION(&m_CriticalSection);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 2c	 add	 eax, 44			; 0000002cH
  0000d	50		 push	 eax
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 2144 :     // Is this a change?
; 2145 :     if (!m_pGraph)

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	83 79 5c 00	 cmp	 DWORD PTR [ecx+92], 0
  0001b	75 17		 jne	 SHORT $L70423

; 2146 :     {
; 2147 :         pGraph->Clone((IDirectMusicGraph **) &m_pGraph);

  0001d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00020	83 c2 5c	 add	 edx, 92			; 0000005cH
  00023	52		 push	 edx
  00024	8b 45 08	 mov	 eax, DWORD PTR _pGraph$[ebp]
  00027	83 c0 0c	 add	 eax, 12			; 0000000cH
  0002a	8b 4d 08	 mov	 ecx, DWORD PTR _pGraph$[ebp]
  0002d	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00030	50		 push	 eax
  00031	ff 52 0c	 call	 DWORD PTR [edx+12]
$L70423:

; 2148 :     }
; 2149 :     LEAVE_CRITICAL_SECTION(&m_CriticalSection);

  00034	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00037	83 c0 2c	 add	 eax, 44			; 0000002cH
  0003a	50		 push	 eax
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 2150 : }

  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
?SetGraph@CAudioPath@@QAEXPAVCGraph@@@Z ENDP		; CAudioPath::SetGraph
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetBufferNode@CAudioPath@@QAEPAVCBufferNode@@ABU_GUID@@@Z
_TEXT	SEGMENT
_this$ = -12
_pConfig$70431 = -8
_pBuff$ = -4
_guidBuffer$ = 8
?GetBufferNode@CAudioPath@@QAEPAVCBufferNode@@ABU_GUID@@@Z PROC NEAR ; CAudioPath::GetBufferNode, COMDAT
; _this$ = ecx

; 2155 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 2156 :     CBufferNode *pBuff = NULL;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pBuff$[ebp], 0

; 2157 :     ENTER_CRITICAL_SECTION(&m_CriticalSection);

  00010	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 2c	 add	 eax, 44			; 0000002cH
  00016	50		 push	 eax
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 2158 :     pBuff = m_BufferConfigList.GetBufferNode(guidBuffer);

  0001d	8b 4d 08	 mov	 ecx, DWORD PTR _guidBuffer$[ebp]
  00020	51		 push	 ecx
  00021	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	83 c1 6c	 add	 ecx, 108		; 0000006cH
  00027	e8 00 00 00 00	 call	 ?GetBufferNode@CBufferConfigList@@QAEPAVCBufferNode@@ABU_GUID@@@Z ; CBufferConfigList::GetBufferNode
  0002c	89 45 fc	 mov	 DWORD PTR _pBuff$[ebp], eax

; 2159 :     if (!pBuff)

  0002f	83 7d fc 00	 cmp	 DWORD PTR _pBuff$[ebp], 0
  00033	75 3a		 jne	 SHORT $L70430

; 2160 :     {
; 2161 :         CPortConfig *pConfig = m_PortConfigList.GetHead();

  00035	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	83 c1 68	 add	 ecx, 104		; 00000068H
  0003b	e8 00 00 00 00	 call	 ?GetHead@CPortConfigList@@QAEPAVCPortConfig@@XZ ; CPortConfigList::GetHead
  00040	89 45 f8	 mov	 DWORD PTR _pConfig$70431[ebp], eax

; 2162 :         for (;pConfig;pConfig = pConfig->GetNext())

  00043	eb 0b		 jmp	 SHORT $L70432
$L70433:
  00045	8b 4d f8	 mov	 ecx, DWORD PTR _pConfig$70431[ebp]
  00048	e8 00 00 00 00	 call	 ?GetNext@CPortConfig@@QAEPAV1@XZ ; CPortConfig::GetNext
  0004d	89 45 f8	 mov	 DWORD PTR _pConfig$70431[ebp], eax
$L70432:
  00050	83 7d f8 00	 cmp	 DWORD PTR _pConfig$70431[ebp], 0
  00054	74 19		 je	 SHORT $L70430

; 2163 :         {
; 2164 :             pBuff = pConfig->GetBufferNode(guidBuffer);

  00056	8b 55 08	 mov	 edx, DWORD PTR _guidBuffer$[ebp]
  00059	52		 push	 edx
  0005a	8b 4d f8	 mov	 ecx, DWORD PTR _pConfig$70431[ebp]
  0005d	e8 00 00 00 00	 call	 ?GetBufferNode@CPortConfig@@QAEPAVCBufferNode@@ABU_GUID@@@Z ; CPortConfig::GetBufferNode
  00062	89 45 fc	 mov	 DWORD PTR _pBuff$[ebp], eax

; 2165 :             if (pBuff)

  00065	83 7d fc 00	 cmp	 DWORD PTR _pBuff$[ebp], 0
  00069	74 02		 je	 SHORT $L70435

; 2166 :             {
; 2167 :                 break;

  0006b	eb 02		 jmp	 SHORT $L70430
$L70435:

; 2168 :             }
; 2169 :         }

  0006d	eb d6		 jmp	 SHORT $L70433
$L70430:

; 2170 :     }
; 2171 :     LEAVE_CRITICAL_SECTION(&m_CriticalSection);

  0006f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00072	83 c0 2c	 add	 eax, 44			; 0000002cH
  00075	50		 push	 eax
  00076	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 2172 :     if (!pBuff)

  0007c	83 7d fc 00	 cmp	 DWORD PTR _pBuff$[ebp], 0
  00080	75 18		 jne	 SHORT $L70436

; 2173 :     {
; 2174 :         pBuff = m_pPerformance->m_BufferManager.GetBufferNode(guidBuffer);

  00082	8b 4d 08	 mov	 ecx, DWORD PTR _guidBuffer$[ebp]
  00085	51		 push	 ecx
  00086	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00089	8b 4a 60	 mov	 ecx, DWORD PTR [edx+96]
  0008c	81 c1 98 00 00
	00		 add	 ecx, 152		; 00000098H
  00092	e8 00 00 00 00	 call	 ?GetBufferNode@CBufferManager@@QAEPAVCBufferNode@@ABU_GUID@@@Z ; CBufferManager::GetBufferNode
  00097	89 45 fc	 mov	 DWORD PTR _pBuff$[ebp], eax
$L70436:

; 2175 :     }
; 2176 :     return pBuff;

  0009a	8b 45 fc	 mov	 eax, DWORD PTR _pBuff$[ebp]

; 2177 : }

  0009d	8b e5		 mov	 esp, ebp
  0009f	5d		 pop	 ebp
  000a0	c2 04 00	 ret	 4
?GetBufferNode@CAudioPath@@QAEPAVCBufferNode@@ABU_GUID@@@Z ENDP ; CAudioPath::GetBufferNode
_TEXT	ENDS
PUBLIC	?Init@CAudioPath@@QAEJPAUIUnknown@@PAVCPerformance@@@Z ; CAudioPath::Init
PUBLIC	?ConnectToPorts@CAudioPath@@QAEJPAVCPerformance@@K@Z ; CAudioPath::ConnectToPorts
PUBLIC	?AddHead@CAudioPathList@@QAEXPAVCAudioPath@@@Z	; CAudioPathList::AddHead
EXTRN	_IID_CAudioPathConfig:BYTE
EXTRN	?g_lNewTrackID@@3JA:DWORD			; g_lNewTrackID
; Function compile flags: /Odt
;	COMDAT ?Init@CAudioPath@@QAEJPAUIUnknown@@PAVCPerformance@@@Z
_TEXT	SEGMENT
_this$ = -12
_hr$ = -8
_pSourceConfig$ = 8
_pPerf$ = 12
?Init@CAudioPath@@QAEJPAUIUnknown@@PAVCPerformance@@@Z PROC NEAR ; CAudioPath::Init, COMDAT
; _this$ = ecx

; 2183 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 2184 :     HRESULT hr = E_INVALIDARG;

  00009	c7 45 f8 57 00
	07 80		 mov	 DWORD PTR _hr$[ebp], -2147024809 ; 80070057H

; 2185 :     ENTER_CRITICAL_SECTION(&m_CriticalSection);

  00010	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 2c	 add	 eax, 44			; 0000002cH
  00016	50		 push	 eax
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 2186 : 	// Give the audiopath a uninque track id. This will be used to invalidate
; 2187 : 	// broadcast PMsgs sent to the audiopath.
; 2188 : 	DWORD dwTempID;
; 2189 : 	InterlockedIncrement(&g_lNewTrackID);

  0001d	68 00 00 00 00	 push	 OFFSET FLAT:?g_lNewTrackID@@3JA ; g_lNewTrackID
  00022	e8 00 00 00 00	 call	 __InterlockedIncrement@4

; 2190 : 	m_dwTrackID = g_lNewTrackID;

  00027	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_lNewTrackID@@3JA ; g_lNewTrackID
  00030	89 51 14	 mov	 DWORD PTR [ecx+20], edx

; 2191 :     m_pPerformance = pPerf;

  00033	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00036	8b 4d 0c	 mov	 ecx, DWORD PTR _pPerf$[ebp]
  00039	89 48 60	 mov	 DWORD PTR [eax+96], ecx

; 2192 :     pPerf->m_AudioPathList.AddHead(this);

  0003c	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0003f	52		 push	 edx
  00040	8b 4d 0c	 mov	 ecx, DWORD PTR _pPerf$[ebp]
  00043	81 c1 94 00 00
	00		 add	 ecx, 148		; 00000094H
  00049	e8 00 00 00 00	 call	 ?AddHead@CAudioPathList@@QAEXPAVCAudioPath@@@Z ; CAudioPathList::AddHead

; 2193 :     pPerf->AddRef();

  0004e	8b 45 0c	 mov	 eax, DWORD PTR _pPerf$[ebp]
  00051	8b 08		 mov	 ecx, DWORD PTR [eax]
  00053	8b 55 0c	 mov	 edx, DWORD PTR _pPerf$[ebp]
  00056	52		 push	 edx
  00057	ff 51 04	 call	 DWORD PTR [ecx+4]

; 2194 :     if (pPerf && pSourceConfig)

  0005a	83 7d 0c 00	 cmp	 DWORD PTR _pPerf$[ebp], 0
  0005e	0f 84 bd 00 00
	00		 je	 $L70446
  00064	83 7d 08 00	 cmp	 DWORD PTR _pSourceConfig$[ebp], 0
  00068	0f 84 b3 00 00
	00		 je	 $L70446

; 2195 :     {
; 2196 :         if (SUCCEEDED(hr = pSourceConfig->QueryInterface(IID_CAudioPathConfig,(void **) &m_pConfig)))

  0006e	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00071	83 c0 64	 add	 eax, 100		; 00000064H
  00074	50		 push	 eax
  00075	68 00 00 00 00	 push	 OFFSET FLAT:_IID_CAudioPathConfig
  0007a	8b 4d 08	 mov	 ecx, DWORD PTR _pSourceConfig$[ebp]
  0007d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0007f	8b 45 08	 mov	 eax, DWORD PTR _pSourceConfig$[ebp]
  00082	50		 push	 eax
  00083	ff 12		 call	 DWORD PTR [edx]
  00085	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax
  00088	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0008c	0f 8c 8f 00 00
	00		 jl	 $L70446

; 2197 :         {
; 2198 :             if (m_pConfig->m_pGraph)

  00092	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00095	8b 51 64	 mov	 edx, DWORD PTR [ecx+100]
  00098	83 7a 10 00	 cmp	 DWORD PTR [edx+16], 0
  0009c	74 12		 je	 SHORT $L70450

; 2199 :             {
; 2200 :                 SetGraph(m_pConfig->m_pGraph);

  0009e	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  000a1	8b 48 64	 mov	 ecx, DWORD PTR [eax+100]
  000a4	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  000a7	52		 push	 edx
  000a8	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000ab	e8 00 00 00 00	 call	 ?SetGraph@CAudioPath@@QAEXPAVCGraph@@@Z ; CAudioPath::SetGraph
$L70450:

; 2201 :             }
; 2202 : #ifdef DXAPI
; 2203 :             // The very first audio path has to create the sink.
; 2204 :             hr = pPerf->m_BufferManager.InitSink();
; 2205 : #endif          
; 2206 :             if (SUCCEEDED(hr))

  000b0	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000b4	7c 6b		 jl	 SHORT $L70446

; 2207 :             {
; 2208 :                 // First, install any global buffers that are required.
; 2209 :                 hr = m_pConfig->m_BufferConfigList.CreateRunTimeVersion(&m_BufferConfigList,&pPerf->m_BufferManager);

  000b6	8b 45 0c	 mov	 eax, DWORD PTR _pPerf$[ebp]
  000b9	05 98 00 00 00	 add	 eax, 152		; 00000098H
  000be	50		 push	 eax
  000bf	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000c2	83 c1 6c	 add	 ecx, 108		; 0000006cH
  000c5	51		 push	 ecx
  000c6	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  000c9	8b 4a 64	 mov	 ecx, DWORD PTR [edx+100]
  000cc	83 c1 18	 add	 ecx, 24			; 00000018H
  000cf	e8 00 00 00 00	 call	 ?CreateRunTimeVersion@CBufferConfigList@@QAEJPAV1@PAVCBufferManager@@@Z ; CBufferConfigList::CreateRunTimeVersion
  000d4	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax

; 2210 :                 if (SUCCEEDED(hr))

  000d7	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000db	7c 44		 jl	 SHORT $L70446

; 2211 :                 {
; 2212 :                     // Then, install the ports and buffers.
; 2213 :                     hr = m_pConfig->m_PortConfigList.CreateRunTimeVersion(&m_PortConfigList,this,&pPerf->m_BufferManager);

  000dd	8b 45 0c	 mov	 eax, DWORD PTR _pPerf$[ebp]
  000e0	05 98 00 00 00	 add	 eax, 152		; 00000098H
  000e5	50		 push	 eax
  000e6	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000e9	51		 push	 ecx
  000ea	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  000ed	83 c2 68	 add	 edx, 104		; 00000068H
  000f0	52		 push	 edx
  000f1	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  000f4	8b 48 64	 mov	 ecx, DWORD PTR [eax+100]
  000f7	83 c1 14	 add	 ecx, 20			; 00000014H
  000fa	e8 00 00 00 00	 call	 ?CreateRunTimeVersion@CPortConfigList@@QAEJPAV1@PAVCAudioPath@@PAVCBufferManager@@@Z ; CPortConfigList::CreateRunTimeVersion
  000ff	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax

; 2214 :                     if (SUCCEEDED(hr))

  00102	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00106	7c 19		 jl	 SHORT $L70446

; 2215 :                     {
; 2216 :                         hr = ConnectToPorts(pPerf,pPerf->m_AudioParams.dwSampleRate);

  00108	8b 4d 0c	 mov	 ecx, DWORD PTR _pPerf$[ebp]
  0010b	8b 91 dc 00 00
	00		 mov	 edx, DWORD PTR [ecx+220]
  00111	52		 push	 edx
  00112	8b 45 0c	 mov	 eax, DWORD PTR _pPerf$[ebp]
  00115	50		 push	 eax
  00116	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00119	e8 00 00 00 00	 call	 ?ConnectToPorts@CAudioPath@@QAEJPAVCPerformance@@K@Z ; CAudioPath::ConnectToPorts
  0011e	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax
$L70446:

; 2217 :                     }
; 2218 :                 }
; 2219 :             }
; 2220 :         }
; 2221 :     }
; 2222 :     LEAVE_CRITICAL_SECTION(&m_CriticalSection);

  00121	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00124	83 c1 2c	 add	 ecx, 44			; 0000002cH
  00127	51		 push	 ecx
  00128	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 2223 :     return hr;

  0012e	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]

; 2224 : }

  00131	8b e5		 mov	 esp, ebp
  00133	5d		 pop	 ebp
  00134	c2 08 00	 ret	 8
?Init@CAudioPath@@QAEJPAUIUnknown@@PAVCPerformance@@@Z ENDP ; CAudioPath::Init
_TEXT	ENDS
EXTRN	?AllocVChannel@CPerformance@@AAEJKKPAK00@Z:NEAR	; CPerformance::AllocVChannel
; Function compile flags: /Odt
;	COMDAT ?ConnectToPorts@CAudioPath@@QAEJPAVCPerformance@@K@Z
_TEXT	SEGMENT
_this$ = -84
$T71808 = -80
$T71807 = -76
$T71806 = -72
_dwGroup$70527 = -68
_dwDrumFlags$70524 = -64
_dwMChannel$70528 = -60
_dwCount$70519 = -56
_dwGroup$70513 = -52
_dwDrumFlags$70510 = -48
_dwMChannel$70514 = -44
_pPortP$70506 = -40
_pControllers$70497 = -36
_dwCount$70496 = -32
_dwMixBins$70495 = -28
_pBuffer$70498 = -24
_pConnect$70489 = -20
_dwIndex$70484 = -16
_hr$ = -12
_pConfig$ = -8
_dwChannelCount$ = -4
_pPerf$ = 8
_dwSampleRate$ = 12
?ConnectToPorts@CAudioPath@@QAEJPAVCPerformance@@K@Z PROC NEAR ; CAudioPath::ConnectToPorts, COMDAT
; _this$ = ecx

; 2231 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	89 4d ac	 mov	 DWORD PTR _this$[ebp], ecx

; 2232 :     HRESULT hr = S_OK;

  00009	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 2233 :     // Scan through the list of portconfigs and hook them up with active ports
; 2234 :     // in the performance. If a port is not available, create the port.
; 2235 :     CPortConfig *pConfig = m_PortConfigList.GetHead();

  00010	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 68	 add	 ecx, 104		; 00000068H
  00016	e8 00 00 00 00	 call	 ?GetHead@CPortConfigList@@QAEPAVCPortConfig@@XZ ; CPortConfigList::GetHead
  0001b	89 45 f8	 mov	 DWORD PTR _pConfig$[ebp], eax

; 2236 :     DWORD dwChannelCount = 0;   // Used to add up total PChannels needed.

  0001e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _dwChannelCount$[ebp], 0

; 2237 :     for (;pConfig && SUCCEEDED(hr);pConfig = pConfig->GetNext())

  00025	eb 0b		 jmp	 SHORT $L70467
$L70468:
  00027	8b 4d f8	 mov	 ecx, DWORD PTR _pConfig$[ebp]
  0002a	e8 00 00 00 00	 call	 ?GetNext@CPortConfig@@QAEPAV1@XZ ; CPortConfig::GetNext
  0002f	89 45 f8	 mov	 DWORD PTR _pConfig$[ebp], eax
$L70467:
  00032	83 7d f8 00	 cmp	 DWORD PTR _pConfig$[ebp], 0
  00036	74 14		 je	 SHORT $L70469
  00038	83 7d f4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0003c	7c 0e		 jl	 SHORT $L70469

; 2238 :     {
; 2239 :         // Given the configuration, either find a port with a matching id, or create one.
; 2240 : #ifdef DXAPI
; 2241 :         hr = pPerf->GetPathPort(pConfig);
; 2242 : #endif
; 2243 :         dwChannelCount += pConfig->m_PortHeader.dwPChannelCount;

  0003e	8b 45 f8	 mov	 eax, DWORD PTR _pConfig$[ebp]
  00041	8b 4d fc	 mov	 ecx, DWORD PTR _dwChannelCount$[ebp]
  00044	03 48 18	 add	 ecx, DWORD PTR [eax+24]
  00047	89 4d fc	 mov	 DWORD PTR _dwChannelCount$[ebp], ecx

; 2244 :     }

  0004a	eb db		 jmp	 SHORT $L70468
$L70469:

; 2245 :     if (SUCCEEDED(hr))

  0004c	83 7d f4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00050	7c 77		 jl	 SHORT $L70471

; 2246 :     {
; 2247 :         // Now, allocate the VChannels needed for each portconfig.
; 2248 :         m_pdwVChannels = new DWORD[dwChannelCount];

  00052	8b 55 fc	 mov	 edx, DWORD PTR _dwChannelCount$[ebp]
  00055	c1 e2 02	 shl	 edx, 2
  00058	52		 push	 edx
  00059	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  0005e	83 c4 04	 add	 esp, 4
  00061	89 45 b8	 mov	 DWORD PTR $T71806[ebp], eax
  00064	8b 45 ac	 mov	 eax, DWORD PTR _this$[ebp]
  00067	8b 4d b8	 mov	 ecx, DWORD PTR $T71806[ebp]
  0006a	89 48 50	 mov	 DWORD PTR [eax+80], ecx

; 2249 :         if (m_pdwVChannels)

  0006d	8b 55 ac	 mov	 edx, DWORD PTR _this$[ebp]
  00070	83 7a 50 00	 cmp	 DWORD PTR [edx+80], 0
  00074	74 4c		 je	 SHORT $L70474

; 2250 :         {
; 2251 :             m_pdwPChannels = new DWORD[dwChannelCount];

  00076	8b 45 fc	 mov	 eax, DWORD PTR _dwChannelCount$[ebp]
  00079	c1 e0 02	 shl	 eax, 2
  0007c	50		 push	 eax
  0007d	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00082	83 c4 04	 add	 esp, 4
  00085	89 45 b4	 mov	 DWORD PTR $T71807[ebp], eax
  00088	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  0008b	8b 55 b4	 mov	 edx, DWORD PTR $T71807[ebp]
  0008e	89 51 54	 mov	 DWORD PTR [ecx+84], edx

; 2252 :             if (!m_pdwPChannels)

  00091	8b 45 ac	 mov	 eax, DWORD PTR _this$[ebp]
  00094	83 78 54 00	 cmp	 DWORD PTR [eax+84], 0
  00098	75 26		 jne	 SHORT $L70477

; 2253 :             {
; 2254 :                 delete [] m_pdwVChannels;

  0009a	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  0009d	8b 51 50	 mov	 edx, DWORD PTR [ecx+80]
  000a0	89 55 b0	 mov	 DWORD PTR $T71808[ebp], edx
  000a3	8b 45 b0	 mov	 eax, DWORD PTR $T71808[ebp]
  000a6	50		 push	 eax
  000a7	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  000ac	83 c4 04	 add	 esp, 4

; 2255 :                 m_pdwVChannels = NULL;

  000af	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  000b2	c7 41 50 00 00
	00 00		 mov	 DWORD PTR [ecx+80], 0

; 2256 :                 hr = E_OUTOFMEMORY;

  000b9	c7 45 f4 0e 00
	07 80		 mov	 DWORD PTR _hr$[ebp], -2147024882 ; 8007000eH
$L70477:

; 2257 :             }
; 2258 :         }
; 2259 :         else

  000c0	eb 07		 jmp	 SHORT $L70471
$L70474:

; 2260 :         {
; 2261 :             hr = E_OUTOFMEMORY;

  000c2	c7 45 f4 0e 00
	07 80		 mov	 DWORD PTR _hr$[ebp], -2147024882 ; 8007000eH
$L70471:

; 2262 :         }
; 2263 :     }
; 2264 :     if (SUCCEEDED(hr))

  000c9	83 7d f4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000cd	0f 8c f7 02 00
	00		 jl	 $L70483

; 2265 :     {
; 2266 :         // Scan through the port configs and allocate the pchannels, copying the assignments
; 2267 :         // into virtual channel assignment arrays.
; 2268 :         pConfig = m_PortConfigList.GetHead();

  000d3	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  000d6	83 c1 68	 add	 ecx, 104		; 00000068H
  000d9	e8 00 00 00 00	 call	 ?GetHead@CPortConfigList@@QAEPAVCPortConfig@@XZ ; CPortConfigList::GetHead
  000de	89 45 f8	 mov	 DWORD PTR _pConfig$[ebp], eax

; 2269 :         DWORD dwIndex = 0;

  000e1	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _dwIndex$70484[ebp], 0

; 2270 :         for (;pConfig;pConfig = pConfig->GetNext())

  000e8	eb 0b		 jmp	 SHORT $L70485
$L70486:
  000ea	8b 4d f8	 mov	 ecx, DWORD PTR _pConfig$[ebp]
  000ed	e8 00 00 00 00	 call	 ?GetNext@CPortConfig@@QAEPAV1@XZ ; CPortConfig::GetNext
  000f2	89 45 f8	 mov	 DWORD PTR _pConfig$[ebp], eax
$L70485:
  000f5	83 7d f8 00	 cmp	 DWORD PTR _pConfig$[ebp], 0
  000f9	0f 84 cb 02 00
	00		 je	 $L70483

; 2271 :         {
; 2272 :             // If this port uses buffers, then connect them up. 
; 2273 :             if (((pConfig->m_PortParams.dwValidParams & DMUS_PORTPARAMS_FEATURES) && 
; 2274 :                 (pConfig->m_PortParams.dwFeatures & DMUS_PORT_FEATURE_AUDIOPATH)))

  000ff	8b 55 f8	 mov	 edx, DWORD PTR _pConfig$[ebp]
  00102	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00105	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0010a	85 c0		 test	 eax, eax
  0010c	0f 84 05 02 00
	00		 je	 $L70488
  00112	8b 4d f8	 mov	 ecx, DWORD PTR _pConfig$[ebp]
  00115	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  00118	83 e2 01	 and	 edx, 1
  0011b	85 d2		 test	 edx, edx
  0011d	0f 84 f4 01 00
	00		 je	 $L70488

; 2275 :             {
; 2276 :                 CBufferConnect *pConnect = pConfig->m_BufferConnectList.GetHead();

  00123	8b 4d f8	 mov	 ecx, DWORD PTR _pConfig$[ebp]
  00126	83 c1 48	 add	 ecx, 72			; 00000048H
  00129	e8 00 00 00 00	 call	 ?GetHead@CBufferConnectList@@QAEPAVCBufferConnect@@XZ ; CBufferConnectList::GetHead
  0012e	89 45 ec	 mov	 DWORD PTR _pConnect$70489[ebp], eax

; 2277 :                 for (;pConnect && SUCCEEDED(hr);pConnect = pConnect->GetNext())

  00131	eb 0b		 jmp	 SHORT $L70491
$L70492:
  00133	8b 4d ec	 mov	 ecx, DWORD PTR _pConnect$70489[ebp]
  00136	e8 00 00 00 00	 call	 ?GetNext@CBufferConnect@@QAEPAV1@XZ ; CBufferConnect::GetNext
  0013b	89 45 ec	 mov	 DWORD PTR _pConnect$70489[ebp], eax
$L70491:
  0013e	83 7d ec 00	 cmp	 DWORD PTR _pConnect$70489[ebp], 0
  00142	0f 84 ca 01 00
	00		 je	 $L70493
  00148	83 7d f4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0014c	0f 8c c0 01 00
	00		 jl	 $L70493

; 2278 :                 {
; 2279 :                     // For each connect block, there should be an array of buffers 
; 2280 :                     // to connect the range of PChannels to.
; 2281 :                     // For each PChannel, get a virtual pchannel and then assign
; 2282 :                     // it to the bus ids that belong to the buffers.
; 2283 :                     if (pConnect->m_ppBufferNodes)

  00152	8b 45 ec	 mov	 eax, DWORD PTR _pConnect$70489[ebp]
  00155	83 78 18 00	 cmp	 DWORD PTR [eax+24], 0
  00159	0f 84 ae 01 00
	00		 je	 $L70494

; 2284 :                     {
; 2285 : #ifdef DXAPI
; 2286 :                         DWORD dwCount = 0;
; 2287 :                         DWORD dwBusIDs[32];
; 2288 :                         DWORD *pdwBusIDBase = &dwBusIDs[0];
; 2289 :                         DWORD dwTotalRead = 0;
; 2290 :                         DWORD dwAmountLeft = 32;
; 2291 :                         for (;(dwCount < pConnect->m_ConnectHeader.dwBufferCount) && dwAmountLeft; dwCount++)
; 2292 :                         {
; 2293 :                             if (pConnect->m_ppBufferNodes[dwCount] && !(pConnect->m_ppBufferNodes[dwCount]->m_BufferHeader.dwFlags & DMUS_BUFFERF_PRIMARY))
; 2294 :                             {
; 2295 :                                 IDirectSoundBuffer *pBuffer = pConnect->m_ppBufferNodes[dwCount]->GetBuffer();
; 2296 :                                 if (pBuffer)
; 2297 :                                 {
; 2298 :                                     dwTotalRead = dwAmountLeft;
; 2299 :                                     hr = m_pPerformance->m_BufferManager.m_pSinkConnect->GetSoundBufferBusIDs((CBuffer *)pBuffer,pdwBusIDBase,NULL,&dwTotalRead);
; 2300 :                                     pBuffer->Release();
; 2301 :                                     if (FAILED(hr)) break;
; 2302 :                                     pdwBusIDBase += dwTotalRead; // Increment pointer by how many was read.
; 2303 :                                     dwAmountLeft -=  dwTotalRead;
; 2304 :                                 }
; 2305 :                             }
; 2306 :                         }
; 2307 :                         if (SUCCEEDED(hr))
; 2308 :                         {
; 2309 :                             dwTotalRead = 32 - dwAmountLeft;
; 2310 :                             // Now, allocate the pchannels and assign them to buses.
; 2311 :                             IDirectMusicPortP* pPortP = NULL;
; 2312 :                             if (SUCCEEDED(pConfig->m_pPort->QueryInterface(IID_IDirectMusicPortP, (void**)&pPortP)))
; 2313 :                             {
; 2314 :                                 for (dwCount = 0;dwCount < pConnect->m_ConnectHeader.dwPChannelCount; dwCount++)
; 2315 :                                 {
; 2316 :                                     DWORD dwDrumFlags = 0;
; 2317 :                                     m_pdwVChannels[dwIndex] = pConnect->m_ConnectHeader.dwPChannelBase + dwCount;
; 2318 :                                     if (pConfig->m_PortHeader.dwFlags & DMUS_PORTCONFIGF_DRUMSON10) 
; 2319 :                                     {
; 2320 :                                         dwDrumFlags = 1;
; 2321 :                                         if (((pConnect->m_ConnectHeader.dwPChannelBase + dwCount) & 0xF) == 9)
; 2322 :                                         {
; 2323 :                                             // This is a drum on channel 10.
; 2324 :                                             dwDrumFlags |= 2;
; 2325 :                                         }
; 2326 :                                     } 
; 2327 :                                     // Now, allocate a virtual pchannel for this and get back the equivalent group and midi channel.
; 2328 :                                     DWORD dwGroup;
; 2329 :                                     DWORD dwMChannel;
; 2330 :                                     hr = pPerf->AllocVChannel(pConfig->m_dwPortID,dwDrumFlags,&m_pdwPChannels[dwIndex],&dwGroup,&dwMChannel);
; 2331 :                                     if (dwTotalRead && SUCCEEDED(hr))
; 2332 :                                     {
; 2333 :                                         hr = pPortP->AssignChannelToBuses(dwGroup,dwMChannel,dwBusIDs,dwTotalRead);
; 2334 :                                     }
; 2335 :                                     dwIndex++;
; 2336 :                                 }
; 2337 :                                 pPortP->Release();
; 2338 :                             }
; 2339 :                         }
; 2340 : #else
; 2341 :                         // For XBOX, the problem is much simpler. We can either connect a channel to a 3D buffer,
; 2342 :                         // in which case we connect it directly to it, or we can connect it to some number of mixbins,
; 2343 :                         // which are all defined by bit flags.
; 2344 :                         DWORD dwMixBins = 0;

  0015f	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _dwMixBins$70495[ebp], 0

; 2345 :                         DWORD dwCount = 0;

  00166	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _dwCount$70496[ebp], 0

; 2346 :                         BYTE *pControllers = NULL;

  0016d	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _pControllers$70497[ebp], 0

; 2347 :                         IDirectSoundBuffer *pBuffer = NULL;     

  00174	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _pBuffer$70498[ebp], 0

; 2348 :                         for (;(dwCount < pConnect->m_ConnectHeader.dwBufferCount) ; dwCount++)

  0017b	eb 09		 jmp	 SHORT $L70499
$L70500:
  0017d	8b 4d e0	 mov	 ecx, DWORD PTR _dwCount$70496[ebp]
  00180	83 c1 01	 add	 ecx, 1
  00183	89 4d e0	 mov	 DWORD PTR _dwCount$70496[ebp], ecx
$L70499:
  00186	8b 55 ec	 mov	 edx, DWORD PTR _pConnect$70489[ebp]
  00189	8b 45 e0	 mov	 eax, DWORD PTR _dwCount$70496[ebp]
  0018c	3b 42 0c	 cmp	 eax, DWORD PTR [edx+12]
  0018f	73 7f		 jae	 SHORT $L70501

; 2349 :                         {
; 2350 :                             if (pConnect->m_ppBufferNodes[dwCount])

  00191	8b 4d ec	 mov	 ecx, DWORD PTR _pConnect$70489[ebp]
  00194	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00197	8b 45 e0	 mov	 eax, DWORD PTR _dwCount$70496[ebp]
  0019a	83 3c 82 00	 cmp	 DWORD PTR [edx+eax*4], 0
  0019e	74 6b		 je	 SHORT $L70502

; 2351 :                             {
; 2352 :                                 pBuffer = pConnect->m_ppBufferNodes[dwCount]->GetBuffer();

  001a0	8b 4d ec	 mov	 ecx, DWORD PTR _pConnect$70489[ebp]
  001a3	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  001a6	8b 45 e0	 mov	 eax, DWORD PTR _dwCount$70496[ebp]
  001a9	8b 0c 82	 mov	 ecx, DWORD PTR [edx+eax*4]
  001ac	e8 00 00 00 00	 call	 ?GetBuffer@CBufferNode@@QAEPAUIDirectSoundBuffer@@XZ ; CBufferNode::GetBuffer
  001b1	89 45 e8	 mov	 DWORD PTR _pBuffer$70498[ebp], eax

; 2353 :                                 if (pBuffer)

  001b4	83 7d e8 00	 cmp	 DWORD PTR _pBuffer$70498[ebp], 0
  001b8	74 02		 je	 SHORT $L70503

; 2354 :                                 {
; 2355 :                                     // Since we have the buffer, forget about the mixbins and fall through.
; 2356 :                                     break;

  001ba	eb 54		 jmp	 SHORT $L70501
$L70503:

; 2357 :                                 }
; 2358 :                                 if (pConnect->m_ppBufferNodes[dwCount]->m_dwMixBin) 

  001bc	8b 4d ec	 mov	 ecx, DWORD PTR _pConnect$70489[ebp]
  001bf	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  001c2	8b 45 e0	 mov	 eax, DWORD PTR _dwCount$70496[ebp]
  001c5	8b 0c 82	 mov	 ecx, DWORD PTR [edx+eax*4]
  001c8	83 79 20 00	 cmp	 DWORD PTR [ecx+32], 0
  001cc	74 15		 je	 SHORT $L70504

; 2359 :                                 {
; 2360 :                                     dwMixBins |= pConnect->m_ppBufferNodes[dwCount]->m_dwMixBin;

  001ce	8b 55 ec	 mov	 edx, DWORD PTR _pConnect$70489[ebp]
  001d1	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  001d4	8b 4d e0	 mov	 ecx, DWORD PTR _dwCount$70496[ebp]
  001d7	8b 14 88	 mov	 edx, DWORD PTR [eax+ecx*4]
  001da	8b 45 e4	 mov	 eax, DWORD PTR _dwMixBins$70495[ebp]
  001dd	0b 42 20	 or	 eax, DWORD PTR [edx+32]
  001e0	89 45 e4	 mov	 DWORD PTR _dwMixBins$70495[ebp], eax
$L70504:

; 2361 :                                 }
; 2362 :                                 if (pConnect->m_ppBufferNodes[dwCount]->m_MixBinsHeader.bControllers[0])

  001e3	8b 4d ec	 mov	 ecx, DWORD PTR _pConnect$70489[ebp]
  001e6	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  001e9	8b 45 e0	 mov	 eax, DWORD PTR _dwCount$70496[ebp]
  001ec	8b 0c 82	 mov	 ecx, DWORD PTR [edx+eax*4]
  001ef	0f b6 51 28	 movzx	 edx, BYTE PTR [ecx+40]
  001f3	85 d2		 test	 edx, edx
  001f5	74 14		 je	 SHORT $L70502

; 2363 :                                 {
; 2364 :                                     pControllers = &pConnect->m_ppBufferNodes[dwCount]->m_MixBinsHeader.bControllers[0];

  001f7	8b 45 ec	 mov	 eax, DWORD PTR _pConnect$70489[ebp]
  001fa	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  001fd	8b 55 e0	 mov	 edx, DWORD PTR _dwCount$70496[ebp]
  00200	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  00203	83 c0 28	 add	 eax, 40			; 00000028H
  00206	89 45 dc	 mov	 DWORD PTR _pControllers$70497[ebp], eax

; 2365 :                                     break;

  00209	eb 05		 jmp	 SHORT $L70501
$L70502:

; 2366 :                                 }
; 2367 :                             }
; 2368 :                         }

  0020b	e9 6d ff ff ff	 jmp	 $L70500
$L70501:

; 2369 : #ifdef DXAPI
; 2370 :                         IDirectMusicPortP* pPortP = NULL;
; 2371 :                         if (SUCCEEDED(pConfig->m_pPort->QueryInterface(IID_IDirectMusicPortP, (void**)&pPortP)))
; 2372 : #else
; 2373 :                         IDirectMusicSynthX* pPortP = pPerf->m_pSynth;

  00210	8b 4d 08	 mov	 ecx, DWORD PTR _pPerf$[ebp]
  00213	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00216	89 55 d8	 mov	 DWORD PTR _pPortP$70506[ebp], edx

; 2374 :                         pPortP->AddRef();

  00219	8b 45 d8	 mov	 eax, DWORD PTR _pPortP$70506[ebp]
  0021c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0021e	8b 55 d8	 mov	 edx, DWORD PTR _pPortP$70506[ebp]
  00221	52		 push	 edx
  00222	ff 51 04	 call	 DWORD PTR [ecx+4]

; 2375 : #endif
; 2376 :                         {
; 2377 :                             for (dwCount = 0;dwCount < pConnect->m_ConnectHeader.dwPChannelCount; dwCount++)

  00225	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _dwCount$70496[ebp], 0
  0022c	eb 09		 jmp	 SHORT $L70507
$L70508:
  0022e	8b 45 e0	 mov	 eax, DWORD PTR _dwCount$70496[ebp]
  00231	83 c0 01	 add	 eax, 1
  00234	89 45 e0	 mov	 DWORD PTR _dwCount$70496[ebp], eax
$L70507:
  00237	8b 4d ec	 mov	 ecx, DWORD PTR _pConnect$70489[ebp]
  0023a	8b 55 e0	 mov	 edx, DWORD PTR _dwCount$70496[ebp]
  0023d	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00240	0f 83 ac 00 00
	00		 jae	 $L70509

; 2378 :                             {
; 2379 :                                 DWORD dwDrumFlags = 0;

  00246	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _dwDrumFlags$70510[ebp], 0

; 2380 :                                 m_pdwVChannels[dwIndex] = pConnect->m_ConnectHeader.dwPChannelBase + dwCount;

  0024d	8b 45 ec	 mov	 eax, DWORD PTR _pConnect$70489[ebp]
  00250	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00253	03 4d e0	 add	 ecx, DWORD PTR _dwCount$70496[ebp]
  00256	8b 55 ac	 mov	 edx, DWORD PTR _this$[ebp]
  00259	8b 42 50	 mov	 eax, DWORD PTR [edx+80]
  0025c	8b 55 f0	 mov	 edx, DWORD PTR _dwIndex$70484[ebp]
  0025f	89 0c 90	 mov	 DWORD PTR [eax+edx*4], ecx

; 2381 :                                 if (pConfig->m_PortHeader.dwFlags & DMUS_PORTCONFIGF_DRUMSON10) 

  00262	8b 45 f8	 mov	 eax, DWORD PTR _pConfig$[ebp]
  00265	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00268	83 e1 01	 and	 ecx, 1
  0026b	85 c9		 test	 ecx, ecx
  0026d	74 21		 je	 SHORT $L70511

; 2382 :                                 {
; 2383 :                                     dwDrumFlags = 1;

  0026f	c7 45 d0 01 00
	00 00		 mov	 DWORD PTR _dwDrumFlags$70510[ebp], 1

; 2384 :                                     if (((pConnect->m_ConnectHeader.dwPChannelBase + dwCount) & 0xF) == 9)

  00276	8b 55 ec	 mov	 edx, DWORD PTR _pConnect$70489[ebp]
  00279	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0027c	03 45 e0	 add	 eax, DWORD PTR _dwCount$70496[ebp]
  0027f	83 e0 0f	 and	 eax, 15			; 0000000fH
  00282	83 f8 09	 cmp	 eax, 9
  00285	75 09		 jne	 SHORT $L70511

; 2385 :                                     {
; 2386 :                                         // This is a drum on channel 10.
; 2387 :                                         dwDrumFlags |= 2;

  00287	8b 4d d0	 mov	 ecx, DWORD PTR _dwDrumFlags$70510[ebp]
  0028a	83 c9 02	 or	 ecx, 2
  0028d	89 4d d0	 mov	 DWORD PTR _dwDrumFlags$70510[ebp], ecx
$L70511:

; 2388 :                                     }
; 2389 :                                 } 
; 2390 :                                 // Now, allocate a virtual pchannel for this and get back the equivalent group and midi channel.
; 2391 :                                 DWORD dwGroup;
; 2392 :                                 DWORD dwMChannel;
; 2393 :                                 hr = pPerf->AllocVChannel(pConfig->m_dwPortID,dwDrumFlags,&m_pdwPChannels[dwIndex],&dwGroup,&dwMChannel);

  00290	8d 55 d4	 lea	 edx, DWORD PTR _dwMChannel$70514[ebp]
  00293	52		 push	 edx
  00294	8d 45 cc	 lea	 eax, DWORD PTR _dwGroup$70513[ebp]
  00297	50		 push	 eax
  00298	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  0029b	8b 51 54	 mov	 edx, DWORD PTR [ecx+84]
  0029e	8b 45 f0	 mov	 eax, DWORD PTR _dwIndex$70484[ebp]
  002a1	8d 0c 82	 lea	 ecx, DWORD PTR [edx+eax*4]
  002a4	51		 push	 ecx
  002a5	8b 55 d0	 mov	 edx, DWORD PTR _dwDrumFlags$70510[ebp]
  002a8	52		 push	 edx
  002a9	8b 45 f8	 mov	 eax, DWORD PTR _pConfig$[ebp]
  002ac	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  002af	51		 push	 ecx
  002b0	8b 4d 08	 mov	 ecx, DWORD PTR _pPerf$[ebp]
  002b3	e8 00 00 00 00	 call	 ?AllocVChannel@CPerformance@@AAEJKKPAK00@Z ; CPerformance::AllocVChannel
  002b8	89 45 f4	 mov	 DWORD PTR _hr$[ebp], eax

; 2394 :                                 if (SUCCEEDED(hr))

  002bb	83 7d f4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  002bf	7c 23		 jl	 SHORT $L70516

; 2395 :                                 {
; 2396 :                                     hr = pPortP->AssignChannelToOutput(dwGroup,dwMChannel,pBuffer,dwMixBins,pControllers);

  002c1	8b 55 dc	 mov	 edx, DWORD PTR _pControllers$70497[ebp]
  002c4	52		 push	 edx
  002c5	8b 45 e4	 mov	 eax, DWORD PTR _dwMixBins$70495[ebp]
  002c8	50		 push	 eax
  002c9	8b 4d e8	 mov	 ecx, DWORD PTR _pBuffer$70498[ebp]
  002cc	51		 push	 ecx
  002cd	8b 55 d4	 mov	 edx, DWORD PTR _dwMChannel$70514[ebp]
  002d0	52		 push	 edx
  002d1	8b 45 cc	 mov	 eax, DWORD PTR _dwGroup$70513[ebp]
  002d4	50		 push	 eax
  002d5	8b 4d d8	 mov	 ecx, DWORD PTR _pPortP$70506[ebp]
  002d8	8b 11		 mov	 edx, DWORD PTR [ecx]
  002da	8b 45 d8	 mov	 eax, DWORD PTR _pPortP$70506[ebp]
  002dd	50		 push	 eax
  002de	ff 52 3c	 call	 DWORD PTR [edx+60]
  002e1	89 45 f4	 mov	 DWORD PTR _hr$[ebp], eax
$L70516:

; 2397 :                                 }
; 2398 :                                 dwIndex++;

  002e4	8b 4d f0	 mov	 ecx, DWORD PTR _dwIndex$70484[ebp]
  002e7	83 c1 01	 add	 ecx, 1
  002ea	89 4d f0	 mov	 DWORD PTR _dwIndex$70484[ebp], ecx

; 2399 :                             }

  002ed	e9 3c ff ff ff	 jmp	 $L70508
$L70509:

; 2400 :                             pPortP->Release();

  002f2	8b 55 d8	 mov	 edx, DWORD PTR _pPortP$70506[ebp]
  002f5	8b 02		 mov	 eax, DWORD PTR [edx]
  002f7	8b 4d d8	 mov	 ecx, DWORD PTR _pPortP$70506[ebp]
  002fa	51		 push	 ecx
  002fb	ff 50 08	 call	 DWORD PTR [eax+8]

; 2401 :                         }
; 2402 :                         if (pBuffer)

  002fe	83 7d e8 00	 cmp	 DWORD PTR _pBuffer$70498[ebp], 0
  00302	74 09		 je	 SHORT $L70494

; 2403 :                         {
; 2404 :                             pBuffer->Release();

  00304	8b 55 e8	 mov	 edx, DWORD PTR _pBuffer$70498[ebp]
  00307	52		 push	 edx
  00308	e8 00 00 00 00	 call	 ?Release@IDirectSoundBuffer@@QAGKXZ ; IDirectSoundBuffer::Release
$L70494:

; 2405 :                         }
; 2406 : #endif
; 2407 :                     }
; 2408 :                 }

  0030d	e9 21 fe ff ff	 jmp	 $L70492
$L70493:

; 2409 :             }
; 2410 :             else

  00312	e9 ae 00 00 00	 jmp	 $L70518
$L70488:

; 2411 :             {
; 2412 :                 DWORD dwCount;
; 2413 :                 for (dwCount = 0;SUCCEEDED(hr) && (dwCount < pConfig->m_PortHeader.dwPChannelCount); dwCount++)

  00317	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _dwCount$70519[ebp], 0
  0031e	eb 09		 jmp	 SHORT $L70521
$L70522:
  00320	8b 45 c8	 mov	 eax, DWORD PTR _dwCount$70519[ebp]
  00323	83 c0 01	 add	 eax, 1
  00326	89 45 c8	 mov	 DWORD PTR _dwCount$70519[ebp], eax
$L70521:
  00329	83 7d f4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0032d	0f 8c 92 00 00
	00		 jl	 $L70518
  00333	8b 4d f8	 mov	 ecx, DWORD PTR _pConfig$[ebp]
  00336	8b 55 c8	 mov	 edx, DWORD PTR _dwCount$70519[ebp]
  00339	3b 51 18	 cmp	 edx, DWORD PTR [ecx+24]
  0033c	0f 83 83 00 00
	00		 jae	 $L70518

; 2414 :                 {
; 2415 :                     DWORD dwDrumFlags = 0;

  00342	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _dwDrumFlags$70524[ebp], 0

; 2416 :                     m_pdwVChannels[dwIndex] = pConfig->m_PortHeader.dwPChannelBase + dwCount;

  00349	8b 45 f8	 mov	 eax, DWORD PTR _pConfig$[ebp]
  0034c	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0034f	03 4d c8	 add	 ecx, DWORD PTR _dwCount$70519[ebp]
  00352	8b 55 ac	 mov	 edx, DWORD PTR _this$[ebp]
  00355	8b 42 50	 mov	 eax, DWORD PTR [edx+80]
  00358	8b 55 f0	 mov	 edx, DWORD PTR _dwIndex$70484[ebp]
  0035b	89 0c 90	 mov	 DWORD PTR [eax+edx*4], ecx

; 2417 :                     if (pConfig->m_PortHeader.dwFlags & DMUS_PORTCONFIGF_DRUMSON10) 

  0035e	8b 45 f8	 mov	 eax, DWORD PTR _pConfig$[ebp]
  00361	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00364	83 e1 01	 and	 ecx, 1
  00367	85 c9		 test	 ecx, ecx
  00369	74 21		 je	 SHORT $L70525

; 2418 :                     {
; 2419 :                         dwDrumFlags = 1;

  0036b	c7 45 c0 01 00
	00 00		 mov	 DWORD PTR _dwDrumFlags$70524[ebp], 1

; 2420 :                         if (((pConfig->m_PortHeader.dwPChannelBase + dwCount) & 0xF) == 9)

  00372	8b 55 f8	 mov	 edx, DWORD PTR _pConfig$[ebp]
  00375	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00378	03 45 c8	 add	 eax, DWORD PTR _dwCount$70519[ebp]
  0037b	83 e0 0f	 and	 eax, 15			; 0000000fH
  0037e	83 f8 09	 cmp	 eax, 9
  00381	75 09		 jne	 SHORT $L70525

; 2421 :                         {
; 2422 :                             // This is a drum on channel 10.
; 2423 :                             dwDrumFlags |= 2;

  00383	8b 4d c0	 mov	 ecx, DWORD PTR _dwDrumFlags$70524[ebp]
  00386	83 c9 02	 or	 ecx, 2
  00389	89 4d c0	 mov	 DWORD PTR _dwDrumFlags$70524[ebp], ecx
$L70525:

; 2424 :                         }
; 2425 :                     } 
; 2426 :                     // Now, allocate a virtual pchannel for this.
; 2427 :                     DWORD dwGroup; // These won't be used since we won't be assigning pchannels on the port to buffers.
; 2428 :                     DWORD dwMChannel;
; 2429 :                     hr = pPerf->AllocVChannel(pConfig->m_dwPortID,dwDrumFlags,&m_pdwPChannels[dwIndex],&dwGroup,&dwMChannel);

  0038c	8d 55 c4	 lea	 edx, DWORD PTR _dwMChannel$70528[ebp]
  0038f	52		 push	 edx
  00390	8d 45 bc	 lea	 eax, DWORD PTR _dwGroup$70527[ebp]
  00393	50		 push	 eax
  00394	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  00397	8b 51 54	 mov	 edx, DWORD PTR [ecx+84]
  0039a	8b 45 f0	 mov	 eax, DWORD PTR _dwIndex$70484[ebp]
  0039d	8d 0c 82	 lea	 ecx, DWORD PTR [edx+eax*4]
  003a0	51		 push	 ecx
  003a1	8b 55 c0	 mov	 edx, DWORD PTR _dwDrumFlags$70524[ebp]
  003a4	52		 push	 edx
  003a5	8b 45 f8	 mov	 eax, DWORD PTR _pConfig$[ebp]
  003a8	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  003ab	51		 push	 ecx
  003ac	8b 4d 08	 mov	 ecx, DWORD PTR _pPerf$[ebp]
  003af	e8 00 00 00 00	 call	 ?AllocVChannel@CPerformance@@AAEJKKPAK00@Z ; CPerformance::AllocVChannel
  003b4	89 45 f4	 mov	 DWORD PTR _hr$[ebp], eax

; 2430 : /*                    Trace(0,"%ld: Mapping %ld to %ld (Port %ld, Group %ld, Channel %ld)\n",
; 2431 :                         dwIndex,m_pdwVChannels[dwIndex],m_pdwPChannels[dwIndex],
; 2432 :                         pConfig->m_dwPortID,dwGroup,dwMChannel);*/
; 2433 : 
; 2434 :                     dwIndex++;

  003b7	8b 55 f0	 mov	 edx, DWORD PTR _dwIndex$70484[ebp]
  003ba	83 c2 01	 add	 edx, 1
  003bd	89 55 f0	 mov	 DWORD PTR _dwIndex$70484[ebp], edx

; 2435 :                 }

  003c0	e9 5b ff ff ff	 jmp	 $L70522
$L70518:

; 2436 :             }
; 2437 :         }

  003c5	e9 20 fd ff ff	 jmp	 $L70486
$L70483:

; 2438 :     }
; 2439 :     m_dwChannelCount = dwChannelCount;

  003ca	8b 45 ac	 mov	 eax, DWORD PTR _this$[ebp]
  003cd	8b 4d fc	 mov	 ecx, DWORD PTR _dwChannelCount$[ebp]
  003d0	89 48 58	 mov	 DWORD PTR [eax+88], ecx

; 2440 :     return hr;

  003d3	8b 45 f4	 mov	 eax, DWORD PTR _hr$[ebp]

; 2441 : }

  003d6	8b e5		 mov	 esp, ebp
  003d8	5d		 pop	 ebp
  003d9	c2 08 00	 ret	 8
?ConnectToPorts@CAudioPath@@QAEJPAVCPerformance@@K@Z ENDP ; CAudioPath::ConnectToPorts
_TEXT	ENDS
PUBLIC	?Clear@CAudioPathList@@QAEXXZ			; CAudioPathList::Clear
PUBLIC	?GetHead@CAudioPathList@@QAEPAVCAudioPath@@XZ	; CAudioPathList::GetHead
PUBLIC	??_C@_0DJ@JGOKDJAP@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
PUBLIC	??_C@_0BD@BLHJFHEJ@pPath?5?$CB?$DN?5GetHead?$CI?$CJ?$AA@ ; `string'
EXTRN	?DebugAssert@@YGXPAD0K@Z:NEAR			; DebugAssert
;	COMDAT ??_C@_0DJ@JGOKDJAP@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT
??_C@_0DJ@JGOKDJAP@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\pr'
	DB	'ivate\windows\directx\dmusic\dmime\audpath.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@BLHJFHEJ@pPath?5?$CB?$DN?5GetHead?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_0BD@BLHJFHEJ@pPath?5?$CB?$DN?5GetHead?$CI?$CJ?$AA@ DB 'pPath != Get'
	DB	'Head()', 00H				; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?Clear@CAudioPathList@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8
_pPath$ = -4
?Clear@CAudioPathList@@QAEXXZ PROC NEAR			; CAudioPathList::Clear, COMDAT
; _this$ = ecx

; 2444 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
$L70534:

; 2445 :     CAudioPath *pPath;
; 2446 :     while (pPath = GetHead())

  00009	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?GetHead@CAudioPathList@@QAEPAVCAudioPath@@XZ ; CAudioPathList::GetHead
  00011	89 45 fc	 mov	 DWORD PTR _pPath$[ebp], eax
  00014	83 7d fc 00	 cmp	 DWORD PTR _pPath$[ebp], 0
  00018	74 2b		 je	 SHORT $L70531

; 2447 :     {
; 2448 :         pPath->Deactivate(); // This should also remove it from the list.

  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _pPath$[ebp]
  0001d	e8 00 00 00 00	 call	 ?Deactivate@CAudioPath@@QAEXXZ ; CAudioPath::Deactivate

; 2449 :         assert(pPath != GetHead()); // Make sure this is always the case!

  00022	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	e8 00 00 00 00	 call	 ?GetHead@CAudioPathList@@QAEPAVCAudioPath@@XZ ; CAudioPathList::GetHead
  0002a	39 45 fc	 cmp	 DWORD PTR _pPath$[ebp], eax
  0002d	75 14		 jne	 SHORT $L71812
  0002f	68 91 09 00 00	 push	 2449			; 00000991H
  00034	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@JGOKDJAP@c?3?2xbox?2private?2windows?2directx?2@
  00039	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@BLHJFHEJ@pPath?5?$CB?$DN?5GetHead?$CI?$CJ?$AA@
  0003e	e8 00 00 00 00	 call	 ?DebugAssert@@YGXPAD0K@Z ; DebugAssert
$L71812:

; 2450 :     }

  00043	eb c4		 jmp	 SHORT $L70534
$L70531:

; 2451 : }

  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
?Clear@CAudioPathList@@QAEXXZ ENDP			; CAudioPathList::Clear
_TEXT	ENDS
PUBLIC	?GetNext@CAudioPath@@QAEPAV1@XZ			; CAudioPath::GetNext
PUBLIC	?GetBufferNode@CAudioPathList@@QAEPAVCBufferNode@@ABU_GUID@@@Z ; CAudioPathList::GetBufferNode
; Function compile flags: /Odt
;	COMDAT ?GetBufferNode@CAudioPathList@@QAEPAVCBufferNode@@ABU_GUID@@@Z
_TEXT	SEGMENT
_this$ = -12
_pPath$ = -8
_pBuff$ = -4
_guidBufferID$ = 8
?GetBufferNode@CAudioPathList@@QAEPAVCBufferNode@@ABU_GUID@@@Z PROC NEAR ; CAudioPathList::GetBufferNode, COMDAT
; _this$ = ecx

; 2455 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 2456 :     CBufferNode *pBuff = NULL;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pBuff$[ebp], 0

; 2457 :     CAudioPath *pPath;
; 2458 :     for (pPath = GetHead();pPath;pPath = pPath->GetNext())

  00010	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?GetHead@CAudioPathList@@QAEPAVCAudioPath@@XZ ; CAudioPathList::GetHead
  00018	89 45 f8	 mov	 DWORD PTR _pPath$[ebp], eax
  0001b	eb 0b		 jmp	 SHORT $L70545
$L70546:
  0001d	8b 4d f8	 mov	 ecx, DWORD PTR _pPath$[ebp]
  00020	e8 00 00 00 00	 call	 ?GetNext@CAudioPath@@QAEPAV1@XZ ; CAudioPath::GetNext
  00025	89 45 f8	 mov	 DWORD PTR _pPath$[ebp], eax
$L70545:
  00028	83 7d f8 00	 cmp	 DWORD PTR _pPath$[ebp], 0
  0002c	74 19		 je	 SHORT $L70547

; 2459 :     {
; 2460 :         pBuff = pPath->GetBufferNode(guidBufferID);

  0002e	8b 45 08	 mov	 eax, DWORD PTR _guidBufferID$[ebp]
  00031	50		 push	 eax
  00032	8b 4d f8	 mov	 ecx, DWORD PTR _pPath$[ebp]
  00035	e8 00 00 00 00	 call	 ?GetBufferNode@CAudioPath@@QAEPAVCBufferNode@@ABU_GUID@@@Z ; CAudioPath::GetBufferNode
  0003a	89 45 fc	 mov	 DWORD PTR _pBuff$[ebp], eax

; 2461 :         if (pBuff)

  0003d	83 7d fc 00	 cmp	 DWORD PTR _pBuff$[ebp], 0
  00041	74 02		 je	 SHORT $L70548

; 2462 :         {
; 2463 :             break;

  00043	eb 02		 jmp	 SHORT $L70547
$L70548:

; 2464 :         }
; 2465 :     }

  00045	eb d6		 jmp	 SHORT $L70546
$L70547:

; 2466 :     return pBuff;

  00047	8b 45 fc	 mov	 eax, DWORD PTR _pBuff$[ebp]

; 2467 : }

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c2 04 00	 ret	 4
?GetBufferNode@CAudioPathList@@QAEPAVCBufferNode@@ABU_GUID@@@Z ENDP ; CAudioPathList::GetBufferNode
_TEXT	ENDS
PUBLIC	?UsesPort@CAudioPath@@QAEHPAUIDirectMusicPort@@@Z ; CAudioPath::UsesPort
PUBLIC	?UsesPort@CAudioPathList@@QAEHPAUIDirectMusicPort@@@Z ; CAudioPathList::UsesPort
; Function compile flags: /Odt
;	COMDAT ?UsesPort@CAudioPathList@@QAEHPAUIDirectMusicPort@@@Z
_TEXT	SEGMENT
_this$ = -8
_pPath$ = -4
_pPort$ = 8
?UsesPort@CAudioPathList@@QAEHPAUIDirectMusicPort@@@Z PROC NEAR ; CAudioPathList::UsesPort, COMDAT
; _this$ = ecx

; 2471 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2472 :     CAudioPath *pPath = GetHead();

  00009	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?GetHead@CAudioPathList@@QAEPAVCAudioPath@@XZ ; CAudioPathList::GetHead
  00011	89 45 fc	 mov	 DWORD PTR _pPath$[ebp], eax

; 2473 :     for (;pPath;pPath = pPath->GetNext())

  00014	eb 0b		 jmp	 SHORT $L70554
$L70555:
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _pPath$[ebp]
  00019	e8 00 00 00 00	 call	 ?GetNext@CAudioPath@@QAEPAV1@XZ ; CAudioPath::GetNext
  0001e	89 45 fc	 mov	 DWORD PTR _pPath$[ebp], eax
$L70554:
  00021	83 7d fc 00	 cmp	 DWORD PTR _pPath$[ebp], 0
  00025	74 19		 je	 SHORT $L70556

; 2474 :     {
; 2475 :         if (pPath->UsesPort(pPort))

  00027	8b 45 08	 mov	 eax, DWORD PTR _pPort$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _pPath$[ebp]
  0002e	e8 00 00 00 00	 call	 ?UsesPort@CAudioPath@@QAEHPAUIDirectMusicPort@@@Z ; CAudioPath::UsesPort
  00033	85 c0		 test	 eax, eax
  00035	74 07		 je	 SHORT $L70557

; 2476 :         {
; 2477 :             return TRUE;

  00037	b8 01 00 00 00	 mov	 eax, 1
  0003c	eb 04		 jmp	 SHORT $L70552
$L70557:

; 2478 :         }
; 2479 :     }

  0003e	eb d6		 jmp	 SHORT $L70555
$L70556:

; 2480 :     return FALSE;

  00040	33 c0		 xor	 eax, eax
$L70552:

; 2481 : }

  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c2 04 00	 ret	 4
?UsesPort@CAudioPathList@@QAEHPAUIDirectMusicPort@@@Z ENDP ; CAudioPathList::UsesPort
_TEXT	ENDS
PUBLIC	??0CInfo@@QAE@XZ				; CInfo::CInfo
PUBLIC	??0CAudioPathConfig@@QAE@XZ			; CAudioPathConfig::CAudioPathConfig
PUBLIC	?QueryInterface@CAudioPathConfig@@UAGJABU_GUID@@PAPAX@Z ; CAudioPathConfig::QueryInterface
PUBLIC	?AddRef@CAudioPathConfig@@UAGKXZ		; CAudioPathConfig::AddRef
PUBLIC	?Release@CAudioPathConfig@@UAGKXZ		; CAudioPathConfig::Release
PUBLIC	?GetClassID@CAudioPathConfig@@UAGJPAU_GUID@@@Z	; CAudioPathConfig::GetClassID
PUBLIC	?IsDirty@CAudioPathConfig@@UAGJXZ		; CAudioPathConfig::IsDirty
PUBLIC	?Load@CAudioPathConfig@@UAGJPAUIStream@@@Z	; CAudioPathConfig::Load
PUBLIC	?Save@CAudioPathConfig@@UAGJPAUIStream@@H@Z	; CAudioPathConfig::Save
PUBLIC	?GetSizeMax@CAudioPathConfig@@UAGJPAT_ULARGE_INTEGER@@@Z ; CAudioPathConfig::GetSizeMax
PUBLIC	?GetDescriptor@CAudioPathConfig@@UAGJPAU_DMUS_OBJECTDESC@@@Z ; CAudioPathConfig::GetDescriptor
PUBLIC	?SetDescriptor@CAudioPathConfig@@UAGJPAU_DMUS_OBJECTDESC@@@Z ; CAudioPathConfig::SetDescriptor
PUBLIC	?ParseDescriptor@CAudioPathConfig@@UAGJPAUIStream@@PAU_DMUS_OBJECTDESC@@@Z ; CAudioPathConfig::ParseDescriptor
PUBLIC	??_7CAudioPathConfig@@6BIPersistStream@@@	; CAudioPathConfig::`vftable'
PUBLIC	??_7CAudioPathConfig@@6BIDirectMusicObject@@@	; CAudioPathConfig::`vftable'
PUBLIC	?QueryInterface@CAudioPathConfig@@W3AGJABU_GUID@@PAPAX@Z ; CAudioPathConfig::QueryInterface
PUBLIC	?AddRef@CAudioPathConfig@@W3AGKXZ		; CAudioPathConfig::AddRef
PUBLIC	?Release@CAudioPathConfig@@W3AGKXZ		; CAudioPathConfig::Release
PUBLIC	??0IPersistStream@@QAE@XZ			; IPersistStream::IPersistStream
PUBLIC	??0IDirectMusicObject@@QAE@XZ			; IDirectMusicObject::IDirectMusicObject
;	COMDAT ??_7CAudioPathConfig@@6BIPersistStream@@@
CONST	SEGMENT
??_7CAudioPathConfig@@6BIPersistStream@@@ DD FLAT:?QueryInterface@CAudioPathConfig@@UAGJABU_GUID@@PAPAX@Z ; CAudioPathConfig::`vftable'
	DD	FLAT:?AddRef@CAudioPathConfig@@UAGKXZ
	DD	FLAT:?Release@CAudioPathConfig@@UAGKXZ
	DD	FLAT:?GetClassID@CAudioPathConfig@@UAGJPAU_GUID@@@Z
	DD	FLAT:?IsDirty@CAudioPathConfig@@UAGJXZ
	DD	FLAT:?Load@CAudioPathConfig@@UAGJPAUIStream@@@Z
	DD	FLAT:?Save@CAudioPathConfig@@UAGJPAUIStream@@H@Z
	DD	FLAT:?GetSizeMax@CAudioPathConfig@@UAGJPAT_ULARGE_INTEGER@@@Z
CONST	ENDS
;	COMDAT ??_7CAudioPathConfig@@6BIDirectMusicObject@@@
CONST	SEGMENT
??_7CAudioPathConfig@@6BIDirectMusicObject@@@ DD FLAT:?QueryInterface@CAudioPathConfig@@W3AGJABU_GUID@@PAPAX@Z ; CAudioPathConfig::`vftable'
	DD	FLAT:?AddRef@CAudioPathConfig@@W3AGKXZ
	DD	FLAT:?Release@CAudioPathConfig@@W3AGKXZ
	DD	FLAT:?GetDescriptor@CAudioPathConfig@@UAGJPAU_DMUS_OBJECTDESC@@@Z
	DD	FLAT:?SetDescriptor@CAudioPathConfig@@UAGJPAU_DMUS_OBJECTDESC@@@Z
	DD	FLAT:?ParseDescriptor@CAudioPathConfig@@UAGJPAUIStream@@PAU_DMUS_OBJECTDESC@@@Z
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ??0CAudioPathConfig@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CAudioPathConfig@@QAE@XZ PROC NEAR			; CAudioPathConfig::CAudioPathConfig, COMDAT
; _this$ = ecx

; 2484 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	6a 0a		 push	 10			; 0000000aH
  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	83 c1 08	 add	 ecx, 8
  0000f	e8 00 00 00 00	 call	 ??0CMemTrack@@QAE@K@Z	; CMemTrack::CMemTrack
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0IPersistStream@@QAE@XZ
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	83 c1 04	 add	 ecx, 4
  00022	e8 00 00 00 00	 call	 ??0IDirectMusicObject@@QAE@XZ
  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CAudioPathConfig@@6BIPersistStream@@@
  00030	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET FLAT:??_7CAudioPathConfig@@6BIDirectMusicObject@@@
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	83 c1 14	 add	 ecx, 20			; 00000014H
  00040	e8 00 00 00 00	 call	 ??0CPortConfigList@@QAE@XZ
  00045	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	83 c1 18	 add	 ecx, 24			; 00000018H
  0004b	e8 00 00 00 00	 call	 ??0CBufferConfigList@@QAE@XZ
  00050	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	83 c1 3c	 add	 ecx, 60			; 0000003cH
  00056	e8 00 00 00 00	 call	 ??0CInfo@@QAE@XZ	; CInfo::CInfo

; 2485 :     m_pGraph = NULL;

  0005b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0005e	c7 42 10 00 00
	00 00		 mov	 DWORD PTR [edx+16], 0

; 2486 :     m_cRef = 1;

  00065	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00068	c7 40 38 01 00
	00 00		 mov	 DWORD PTR [eax+56], 1

; 2487 :     m_pUnkDispatch = NULL;

  0006f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00072	c7 81 68 03 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+872], 0

; 2488 : 
; 2489 :     INITIALIZE_CRITICAL_SECTION(&m_CriticalSection);

  0007c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0007f	83 c2 1c	 add	 edx, 28			; 0000001cH
  00082	52		 push	 edx
  00083	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitializeCriticalSection@4

; 2490 :     IncrementDLLCount();
; 2491 : }

  00089	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0008c	8b e5		 mov	 esp, ebp
  0008e	5d		 pop	 ebp
  0008f	c3		 ret	 0
??0CAudioPathConfig@@QAE@XZ ENDP			; CAudioPathConfig::CAudioPathConfig
_TEXT	ENDS
PUBLIC	??0IPersist@@QAE@XZ				; IPersist::IPersist
; Function compile flags: /Odt
;	COMDAT ??0IPersistStream@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0IPersistStream@@QAE@XZ PROC NEAR			; IPersistStream::IPersistStream, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0IPersist@@QAE@XZ
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0IPersistStream@@QAE@XZ ENDP				; IPersistStream::IPersistStream
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0IDirectMusicObject@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0IDirectMusicObject@@QAE@XZ PROC NEAR			; IDirectMusicObject::IDirectMusicObject, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0IUnknown@@QAE@XZ
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0IDirectMusicObject@@QAE@XZ ENDP			; IDirectMusicObject::IDirectMusicObject
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0IPersist@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0IPersist@@QAE@XZ PROC NEAR				; IPersist::IPersist, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0IUnknown@@QAE@XZ
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0IPersist@@QAE@XZ ENDP				; IPersist::IPersist
_TEXT	ENDS
PUBLIC	??1CAudioPathConfig@@QAE@XZ			; CAudioPathConfig::~CAudioPathConfig
; Function compile flags: /Odt
;	COMDAT ??1CAudioPathConfig@@QAE@XZ
_TEXT	SEGMENT
tv67 = -8
_this$ = -4
??1CAudioPathConfig@@QAE@XZ PROC NEAR			; CAudioPathConfig::~CAudioPathConfig, COMDAT
; _this$ = ecx

; 2494 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CAudioPathConfig@@6BIPersistStream@@@
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET FLAT:??_7CAudioPathConfig@@6BIDirectMusicObject@@@

; 2495 :     if (m_pGraph)

  0001c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001f	83 7a 10 00	 cmp	 DWORD PTR [edx+16], 0
  00023	74 12		 je	 SHORT $L70570

; 2496 :     {
; 2497 :         m_pGraph->Release();

  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0002b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0002e	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00031	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00033	50		 push	 eax
  00034	ff 51 08	 call	 DWORD PTR [ecx+8]
$L70570:

; 2498 :     }
; 2499 :     if (m_pUnkDispatch)

  00037	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0003a	83 ba 68 03 00
	00 00		 cmp	 DWORD PTR [edx+872], 0
  00041	74 18		 je	 SHORT $L70571

; 2500 :     {
; 2501 :         m_pUnkDispatch->Release(); // free IDispatch implementation we may have borrowed

  00043	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00046	8b 88 68 03 00
	00		 mov	 ecx, DWORD PTR [eax+872]
  0004c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0004f	8b 82 68 03 00
	00		 mov	 eax, DWORD PTR [edx+872]
  00055	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00057	50		 push	 eax
  00058	ff 51 08	 call	 DWORD PTR [ecx+8]
$L70571:

; 2502 :     }
; 2503 :     m_PortConfigList.Clear();

  0005b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	83 c1 14	 add	 ecx, 20			; 00000014H
  00061	e8 00 00 00 00	 call	 ?Clear@CPortConfigList@@QAEXXZ ; CPortConfigList::Clear

; 2504 :     m_BufferConfigList.Clear();

  00066	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00069	83 c1 18	 add	 ecx, 24			; 00000018H
  0006c	e8 00 00 00 00	 call	 ?Clear@CBufferConfigList@@QAEXXZ ; CBufferConfigList::Clear

; 2505 :     DELETE_CRITICAL_SECTION(&m_CriticalSection);

  00071	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00074	83 c2 1c	 add	 edx, 28			; 0000001cH
  00077	52		 push	 edx
  00078	e8 00 00 00 00	 call	 ?DeleteCriticalSection@@YGXPAX@Z ; DeleteCriticalSection

; 2506 :     DecrementDLLCount();
; 2507 : }

  0007d	83 7d fc 00	 cmp	 DWORD PTR _this$[ebp], 0
  00081	74 0b		 je	 SHORT $L71834
  00083	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00086	83 c0 08	 add	 eax, 8
  00089	89 45 f8	 mov	 DWORD PTR tv67[ebp], eax
  0008c	eb 07		 jmp	 SHORT $L71835
$L71834:
  0008e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
$L71835:
  00095	8b 4d f8	 mov	 ecx, DWORD PTR tv67[ebp]
  00098	e8 00 00 00 00	 call	 ??1CMemTrack@@QAE@XZ	; CMemTrack::~CMemTrack
  0009d	8b e5		 mov	 esp, ebp
  0009f	5d		 pop	 ebp
  000a0	c3		 ret	 0
??1CAudioPathConfig@@QAE@XZ ENDP			; CAudioPathConfig::~CAudioPathConfig
_TEXT	ENDS
PUBLIC	?AddHead@CBufferConfigList@@QAEXPAVCBufferConfig@@@Z ; CBufferConfigList::AddHead
PUBLIC	?AddHead@CBufferConnectList@@QAEXPAVCBufferConnect@@@Z ; CBufferConnectList::AddHead
PUBLIC	?AddHead@CPortConfigList@@QAEXPAVCPortConfig@@@Z ; CPortConfigList::AddHead
PUBLIC	?CreateStandardConfig@CAudioPathConfig@@SGPAV1@KKK@Z ; CAudioPathConfig::CreateStandardConfig
PUBLIC	??_GCAudioPathConfig@@QAEPAXI@Z			; CAudioPathConfig::`scalar deleting destructor'
PUBLIC	??_C@_0EJ@ENIGIDFJ@Error?3?5Attempt?5to?5create?5mixbin?5@ ; `string'
;	COMDAT ??_C@_0EJ@ENIGIDFJ@Error?3?5Attempt?5to?5create?5mixbin?5@
CONST	SEGMENT
??_C@_0EJ@ENIGIDFJ@Error?3?5Attempt?5to?5create?5mixbin?5@ DB 'Error: Att'
	DB	'empt to create mixbin audiopath with more than 8 mixbins: %lx'
	DB	0aH, 00H					; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?CreateStandardConfig@CAudioPathConfig@@SGPAV1@KKK@Z
_TEXT	SEGMENT
tv256 = -220
tv245 = -216
tv214 = -212
tv207 = -208
tv197 = -204
tv150 = -200
tv143 = -196
tv134 = -192
tv71 = -188
tv69 = -184
$T71868 = -180
$T71867 = -176
$T71864 = -172
$T71863 = -168
$T71862 = -164
$T71859 = -160
$T71856 = -156
$T71855 = -152
$T71852 = -148
$T71849 = -144
$T71846 = -140
$T71845 = -136
$T71842 = -132
$T71839 = -128
_dwIndex$70642 = -124
_pConnect$70635 = -120
_pBuffer$70627 = -116
_dwIndex$70623 = -112
_pPort$70619 = -108
_pBuffer$70611 = -104
_dwMixCount$70598 = -100
_dwMixBins$70599 = -96
_MixBinsHeader$70587 = -92
_guidBufferIDs$70584 = -80
_fCreatePort$70586 = -32
_dwTypes$70582 = -28
_dwConnections$70585 = -16
_dwGlobalType$70581 = -12
_dwTotal$70583 = -8
_pConfig$ = -4
_dwType$ = 8
_dwPChannelCount$ = 12
_dwSampleRate$ = 16
?CreateStandardConfig@CAudioPathConfig@@SGPAV1@KKK@Z PROC NEAR ; CAudioPathConfig::CreateStandardConfig, COMDAT

; 2511 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH

; 2512 :     CAudioPathConfig *pConfig = new CAudioPathConfig;

  00009	68 6c 03 00 00	 push	 876			; 0000036cH
  0000e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00013	83 c4 04	 add	 esp, 4
  00016	89 45 80	 mov	 DWORD PTR $T71839[ebp], eax
  00019	83 7d 80 00	 cmp	 DWORD PTR $T71839[ebp], 0
  0001d	74 10		 je	 SHORT $L71840
  0001f	8b 4d 80	 mov	 ecx, DWORD PTR $T71839[ebp]
  00022	e8 00 00 00 00	 call	 ??0CAudioPathConfig@@QAE@XZ ; CAudioPathConfig::CAudioPathConfig
  00027	89 85 48 ff ff
	ff		 mov	 DWORD PTR tv69[ebp], eax
  0002d	eb 0a		 jmp	 SHORT $L71841
$L71840:
  0002f	c7 85 48 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv69[ebp], 0
$L71841:
  00039	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR tv69[ebp]
  0003f	89 45 fc	 mov	 DWORD PTR _pConfig$[ebp], eax

; 2513 :     if (pConfig)

  00042	83 7d fc 00	 cmp	 DWORD PTR _pConfig$[ebp], 0
  00046	0f 84 2f 06 00
	00		 je	 $L70580

; 2514 :     {
; 2515 :         DWORD dwGlobalType = 0;         // Global mixin buffer.

  0004c	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _dwGlobalType$70581[ebp], 0

; 2516 :         DWORD dwTypes[3];               // What types of buffers to create.
; 2517 :         DWORD dwTotal = 0;              // How many buffers.

  00053	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _dwTotal$70583[ebp], 0

; 2518 :         GUID  guidBufferIDs[3];         // IDs of buffers that should be connected to.
; 2519 :         DWORD dwConnections = 0;        // How many buffer connections.

  0005a	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _dwConnections$70585[ebp], 0

; 2520 :         BOOL fCreatePort = TRUE;

  00061	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR _fCreatePort$70586[ebp], 1

; 2521 : #ifdef XBOX
; 2522 :         DMUS_IO_BUFFER_MIXBINS_HEADER MixBinsHeader;
; 2523 :         MixBinsHeader.bControllers[0] = 0;

  00068	c6 45 a8 00	 mov	 BYTE PTR _MixBinsHeader$70587[ebp+4], 0

; 2524 :         MixBinsHeader.dwMixBins = 0;

  0006c	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR _MixBinsHeader$70587[ebp], 0

; 2525 : #endif
; 2526 :         switch (dwType)
; 2527 :         {

  00073	8b 4d 08	 mov	 ecx, DWORD PTR _dwType$[ebp]
  00076	89 8d 44 ff ff
	ff		 mov	 DWORD PTR tv71[ebp], ecx
  0007c	8b 95 44 ff ff
	ff		 mov	 edx, DWORD PTR tv71[ebp]
  00082	81 c2 ff ff 00
	00		 add	 edx, 65535		; 0000ffffH
  00088	89 95 44 ff ff
	ff		 mov	 DWORD PTR tv71[ebp], edx
  0008e	83 bd 44 ff ff
	ff 04		 cmp	 DWORD PTR tv71[ebp], 4
  00095	0f 87 90 01 00
	00		 ja	 $L70597
  0009b	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR tv71[ebp]
  000a1	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L71871[eax*4]
$L70592:

; 2528 :         case DMUS_APATH_SHARED_STEREOPLUSREVERB:
; 2529 :             dwTypes[0] = BUFFER_MUSIC; 

  000a8	c7 45 e4 08 00
	00 00		 mov	 DWORD PTR _dwTypes$70582[ebp], 8

; 2530 :             dwTypes[1] = BUFFER_REVERB;

  000af	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _dwTypes$70582[ebp+4], 1

; 2531 :             guidBufferIDs[0] = GUID_Buffer_Stereo;

  000b6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _GUID_Buffer_Stereo
  000bc	89 4d b0	 mov	 DWORD PTR _guidBufferIDs$70584[ebp], ecx
  000bf	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR _GUID_Buffer_Stereo+4
  000c5	89 55 b4	 mov	 DWORD PTR _guidBufferIDs$70584[ebp+4], edx
  000c8	a1 08 00 00 00	 mov	 eax, DWORD PTR _GUID_Buffer_Stereo+8
  000cd	89 45 b8	 mov	 DWORD PTR _guidBufferIDs$70584[ebp+8], eax
  000d0	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _GUID_Buffer_Stereo+12
  000d6	89 4d bc	 mov	 DWORD PTR _guidBufferIDs$70584[ebp+12], ecx

; 2532 :             guidBufferIDs[1] = GUID_Buffer_Reverb;

  000d9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _GUID_Buffer_Reverb
  000df	89 55 c0	 mov	 DWORD PTR _guidBufferIDs$70584[ebp+16], edx
  000e2	a1 04 00 00 00	 mov	 eax, DWORD PTR _GUID_Buffer_Reverb+4
  000e7	89 45 c4	 mov	 DWORD PTR _guidBufferIDs$70584[ebp+20], eax
  000ea	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR _GUID_Buffer_Reverb+8
  000f0	89 4d c8	 mov	 DWORD PTR _guidBufferIDs$70584[ebp+24], ecx
  000f3	8b 15 0c 00 00
	00		 mov	 edx, DWORD PTR _GUID_Buffer_Reverb+12
  000f9	89 55 cc	 mov	 DWORD PTR _guidBufferIDs$70584[ebp+28], edx

; 2533 : #ifdef DXAPI
; 2534 :             dwConnections = 2;
; 2535 :             dwTotal = 2;
; 2536 : #else
; 2537 :             dwTypes[2] = BUFFER_CHORUS;

  000fc	c7 45 ec 09 00
	00 00		 mov	 DWORD PTR _dwTypes$70582[ebp+8], 9

; 2538 :             dwConnections = 3;

  00103	c7 45 f0 03 00
	00 00		 mov	 DWORD PTR _dwConnections$70585[ebp], 3

; 2539 :             dwTotal = 3;

  0010a	c7 45 f8 03 00
	00 00		 mov	 DWORD PTR _dwTotal$70583[ebp], 3

; 2540 :             guidBufferIDs[2] = GUID_Buffer_Chorus;

  00111	a1 00 00 00 00	 mov	 eax, DWORD PTR _GUID_Buffer_Chorus
  00116	89 45 d0	 mov	 DWORD PTR _guidBufferIDs$70584[ebp+32], eax
  00119	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR _GUID_Buffer_Chorus+4
  0011f	89 4d d4	 mov	 DWORD PTR _guidBufferIDs$70584[ebp+36], ecx
  00122	8b 15 08 00 00
	00		 mov	 edx, DWORD PTR _GUID_Buffer_Chorus+8
  00128	89 55 d8	 mov	 DWORD PTR _guidBufferIDs$70584[ebp+40], edx
  0012b	a1 0c 00 00 00	 mov	 eax, DWORD PTR _GUID_Buffer_Chorus+12
  00130	89 45 dc	 mov	 DWORD PTR _guidBufferIDs$70584[ebp+44], eax

; 2541 : #endif
; 2542 :             break;

  00133	e9 c0 01 00 00	 jmp	 $L70589
$L70593:

; 2543 :         // Following removed for DX8, should be reintroduced for Whistler and DX8.1...
; 2544 : /*
; 2545 :         case DMUS_APATH_DYNAMIC_ENV3D:
; 2546 :             dwGlobalType = BUFFER_ENVREVERB;
; 2547 :             dwTypes[0] = BUFFER_3D;
; 2548 :             guidBufferIDs[0] = GUID_Buffer_3D;
; 2549 :             dwConnections = 1;
; 2550 :             dwTotal = 1;
; 2551 :             break;
; 2552 : */
; 2553 :         case DMUS_APATH_DYNAMIC_3D:
; 2554 :             dwTypes[0] = BUFFER_3D_DRY;

  00138	c7 45 e4 04 00
	00 00		 mov	 DWORD PTR _dwTypes$70582[ebp], 4

; 2555 :             guidBufferIDs[0] = GUID_Buffer_3D_Dry;

  0013f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _GUID_Buffer_3D_Dry
  00145	89 4d b0	 mov	 DWORD PTR _guidBufferIDs$70584[ebp], ecx
  00148	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR _GUID_Buffer_3D_Dry+4
  0014e	89 55 b4	 mov	 DWORD PTR _guidBufferIDs$70584[ebp+4], edx
  00151	a1 08 00 00 00	 mov	 eax, DWORD PTR _GUID_Buffer_3D_Dry+8
  00156	89 45 b8	 mov	 DWORD PTR _guidBufferIDs$70584[ebp+8], eax
  00159	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _GUID_Buffer_3D_Dry+12
  0015f	89 4d bc	 mov	 DWORD PTR _guidBufferIDs$70584[ebp+12], ecx

; 2556 :             dwConnections = 1;

  00162	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _dwConnections$70585[ebp], 1

; 2557 :             dwTotal = 1;

  00169	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _dwTotal$70583[ebp], 1

; 2558 :             break;

  00170	e9 83 01 00 00	 jmp	 $L70589
$L70594:

; 2559 :         case DMUS_APATH_DYNAMIC_MONO:
; 2560 :             dwTypes[0] = BUFFER_MONO;

  00175	c7 45 e4 06 00
	00 00		 mov	 DWORD PTR _dwTypes$70582[ebp], 6

; 2561 :             guidBufferIDs[0] = GUID_Buffer_Mono;

  0017c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _GUID_Buffer_Mono
  00182	89 55 b0	 mov	 DWORD PTR _guidBufferIDs$70584[ebp], edx
  00185	a1 04 00 00 00	 mov	 eax, DWORD PTR _GUID_Buffer_Mono+4
  0018a	89 45 b4	 mov	 DWORD PTR _guidBufferIDs$70584[ebp+4], eax
  0018d	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR _GUID_Buffer_Mono+8
  00193	89 4d b8	 mov	 DWORD PTR _guidBufferIDs$70584[ebp+8], ecx
  00196	8b 15 0c 00 00
	00		 mov	 edx, DWORD PTR _GUID_Buffer_Mono+12
  0019c	89 55 bc	 mov	 DWORD PTR _guidBufferIDs$70584[ebp+12], edx

; 2562 :             dwConnections = 1;

  0019f	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _dwConnections$70585[ebp], 1

; 2563 :             dwTotal = 1;

  001a6	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _dwTotal$70583[ebp], 1

; 2564 :             break;

  001ad	e9 46 01 00 00	 jmp	 $L70589
$L70595:

; 2565 :         case DMUS_APATH_DYNAMIC_STEREO:
; 2566 :             dwTypes[0] = BUFFER_STEREO;

  001b2	c7 45 e4 07 00
	00 00		 mov	 DWORD PTR _dwTypes$70582[ebp], 7

; 2567 :             guidBufferIDs[0] = GUID_Buffer_Stereo;

  001b9	a1 00 00 00 00	 mov	 eax, DWORD PTR _GUID_Buffer_Stereo
  001be	89 45 b0	 mov	 DWORD PTR _guidBufferIDs$70584[ebp], eax
  001c1	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR _GUID_Buffer_Stereo+4
  001c7	89 4d b4	 mov	 DWORD PTR _guidBufferIDs$70584[ebp+4], ecx
  001ca	8b 15 08 00 00
	00		 mov	 edx, DWORD PTR _GUID_Buffer_Stereo+8
  001d0	89 55 b8	 mov	 DWORD PTR _guidBufferIDs$70584[ebp+8], edx
  001d3	a1 0c 00 00 00	 mov	 eax, DWORD PTR _GUID_Buffer_Stereo+12
  001d8	89 45 bc	 mov	 DWORD PTR _guidBufferIDs$70584[ebp+12], eax

; 2568 :             dwConnections = 1;

  001db	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _dwConnections$70585[ebp], 1

; 2569 :             dwTotal = 1;

  001e2	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _dwTotal$70583[ebp], 1

; 2570 :             break;

  001e9	e9 0a 01 00 00	 jmp	 $L70589
$L70596:

; 2571 : #ifndef DXAPI
; 2572 :         case DMUS_APATH_SHARED_STEREO:
; 2573 :             dwTypes[0] = BUFFER_MUSIC; 

  001ee	c7 45 e4 08 00
	00 00		 mov	 DWORD PTR _dwTypes$70582[ebp], 8

; 2574 :             guidBufferIDs[0] = GUID_Buffer_Stereo;

  001f5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _GUID_Buffer_Stereo
  001fb	89 4d b0	 mov	 DWORD PTR _guidBufferIDs$70584[ebp], ecx
  001fe	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR _GUID_Buffer_Stereo+4
  00204	89 55 b4	 mov	 DWORD PTR _guidBufferIDs$70584[ebp+4], edx
  00207	a1 08 00 00 00	 mov	 eax, DWORD PTR _GUID_Buffer_Stereo+8
  0020c	89 45 b8	 mov	 DWORD PTR _guidBufferIDs$70584[ebp+8], eax
  0020f	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _GUID_Buffer_Stereo+12
  00215	89 4d bc	 mov	 DWORD PTR _guidBufferIDs$70584[ebp+12], ecx

; 2575 :             dwConnections = 1;

  00218	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _dwConnections$70585[ebp], 1

; 2576 :             dwTotal = 1;

  0021f	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _dwTotal$70583[ebp], 1

; 2577 :             break;

  00226	e9 cd 00 00 00	 jmp	 $L70589
$L70597:

; 2578 : #endif
; 2579 : #ifdef XBOX
; 2580 :         default:
; 2581 :             // Treat all default cases as mixbin cases.
; 2582 :             {
; 2583 :                 dwTypes[0] = BUFFER_MIXBINS;

  0022b	c7 45 e4 0a 00
	00 00		 mov	 DWORD PTR _dwTypes$70582[ebp], 10 ; 0000000aH

; 2584 :                 guidBufferIDs[0] = GUID_Buffer_MixBins;

  00232	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _GUID_Buffer_MixBins
  00238	89 55 b0	 mov	 DWORD PTR _guidBufferIDs$70584[ebp], edx
  0023b	a1 04 00 00 00	 mov	 eax, DWORD PTR _GUID_Buffer_MixBins+4
  00240	89 45 b4	 mov	 DWORD PTR _guidBufferIDs$70584[ebp+4], eax
  00243	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR _GUID_Buffer_MixBins+8
  00249	89 4d b8	 mov	 DWORD PTR _guidBufferIDs$70584[ebp+8], ecx
  0024c	8b 15 0c 00 00
	00		 mov	 edx, DWORD PTR _GUID_Buffer_MixBins+12
  00252	89 55 bc	 mov	 DWORD PTR _guidBufferIDs$70584[ebp+12], edx

; 2585 :                 dwConnections = 1;

  00255	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _dwConnections$70585[ebp], 1

; 2586 :                 dwTotal = 1;

  0025c	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _dwTotal$70583[ebp], 1

; 2587 :                 DWORD dwMixCount = 0;

  00263	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR _dwMixCount$70598[ebp], 0

; 2588 :                 DWORD dwMixBins = dwType;

  0026a	8b 45 08	 mov	 eax, DWORD PTR _dwType$[ebp]
  0026d	89 45 a0	 mov	 DWORD PTR _dwMixBins$70599[ebp], eax

; 2589 :                 // First, clear the controllers.
; 2590 :                 for (dwMixCount = 0; dwMixCount < 8; dwMixCount++)

  00270	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR _dwMixCount$70598[ebp], 0
  00277	eb 09		 jmp	 SHORT $L70600
$L70601:
  00279	8b 4d 9c	 mov	 ecx, DWORD PTR _dwMixCount$70598[ebp]
  0027c	83 c1 01	 add	 ecx, 1
  0027f	89 4d 9c	 mov	 DWORD PTR _dwMixCount$70598[ebp], ecx
$L70600:
  00282	83 7d 9c 08	 cmp	 DWORD PTR _dwMixCount$70598[ebp], 8
  00286	73 0a		 jae	 SHORT $L70602

; 2591 :                 {
; 2592 :                     MixBinsHeader.bControllers[dwMixCount] = 0;

  00288	8b 55 9c	 mov	 edx, DWORD PTR _dwMixCount$70598[ebp]
  0028b	c6 44 15 a8 00	 mov	 BYTE PTR _MixBinsHeader$70587[ebp+edx+4], 0

; 2593 :                 }

  00290	eb e7		 jmp	 SHORT $L70601
$L70602:

; 2594 :                 dwMixCount = 0;

  00292	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR _dwMixCount$70598[ebp], 0

; 2595 :                 // For each bit set, assign a controller.
; 2596 :                 for (; (dwMixBins != 0) && (dwMixCount < 8); dwMixBins >>= 1)

  00299	eb 08		 jmp	 SHORT $L70603
$L70604:
  0029b	8b 45 a0	 mov	 eax, DWORD PTR _dwMixBins$70599[ebp]
  0029e	d1 e8		 shr	 eax, 1
  002a0	89 45 a0	 mov	 DWORD PTR _dwMixBins$70599[ebp], eax
$L70603:
  002a3	83 7d a0 00	 cmp	 DWORD PTR _dwMixBins$70599[ebp], 0
  002a7	74 29		 je	 SHORT $L70605
  002a9	83 7d 9c 08	 cmp	 DWORD PTR _dwMixCount$70598[ebp], 8
  002ad	73 23		 jae	 SHORT $L70605

; 2597 :                 {
; 2598 :                     if (dwMixBins & 1) 

  002af	8b 4d a0	 mov	 ecx, DWORD PTR _dwMixBins$70599[ebp]
  002b2	83 e1 01	 and	 ecx, 1
  002b5	85 c9		 test	 ecx, ecx
  002b7	74 17		 je	 SHORT $L70606

; 2599 :                     {
; 2600 :                         MixBinsHeader.bControllers[dwMixCount] = (BYTE) dwMixCount+1;

  002b9	0f b6 55 9c	 movzx	 edx, BYTE PTR _dwMixCount$70598[ebp]
  002bd	83 c2 01	 add	 edx, 1
  002c0	8b 45 9c	 mov	 eax, DWORD PTR _dwMixCount$70598[ebp]
  002c3	88 54 05 a8	 mov	 BYTE PTR _MixBinsHeader$70587[ebp+eax+4], dl

; 2601 :                         dwMixCount++;

  002c7	8b 4d 9c	 mov	 ecx, DWORD PTR _dwMixCount$70598[ebp]
  002ca	83 c1 01	 add	 ecx, 1
  002cd	89 4d 9c	 mov	 DWORD PTR _dwMixCount$70598[ebp], ecx
$L70606:

; 2602 :                     }
; 2603 :                 }

  002d0	eb c9		 jmp	 SHORT $L70604
$L70605:

; 2604 :                 if (dwMixBins)

  002d2	83 7d a0 00	 cmp	 DWORD PTR _dwMixBins$70599[ebp], 0
  002d6	74 1a		 je	 SHORT $L70608

; 2605 :                 {
; 2606 :                     // Force a failure. Too many mixbins requested.
; 2607 :                     Trace(0,"Error: Attempt to create mixbin audiopath with more than 8 mixbins: %lx\n",dwType);

  002d8	8b 55 08	 mov	 edx, DWORD PTR _dwType$[ebp]
  002db	52		 push	 edx
  002dc	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EJ@ENIGIDFJ@Error?3?5Attempt?5to?5create?5mixbin?5@
  002e1	6a 00		 push	 0
  002e3	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  002e8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2608 :                     fCreatePort = false;

  002eb	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _fCreatePort$70586[ebp], 0
$L70608:

; 2609 :                 }
; 2610 :                 MixBinsHeader.dwMixBins = dwType;

  002f2	8b 45 08	 mov	 eax, DWORD PTR _dwType$[ebp]
  002f5	89 45 a4	 mov	 DWORD PTR _MixBinsHeader$70587[ebp], eax
$L70589:

; 2611 :             }
; 2612 :             break;
; 2613 : #endif
; 2614 :         }
; 2615 :         if (dwGlobalType)

  002f8	83 7d f4 00	 cmp	 DWORD PTR _dwGlobalType$70581[ebp], 0
  002fc	0f 84 9e 00 00
	00		 je	 $L70610

; 2616 :         {
; 2617 :             CBufferConfig *pBuffer = new CBufferConfig(dwGlobalType);

  00302	6a 30		 push	 48			; 00000030H
  00304	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00309	83 c4 04	 add	 esp, 4
  0030c	89 85 7c ff ff
	ff		 mov	 DWORD PTR $T71842[ebp], eax
  00312	83 bd 7c ff ff
	ff 00		 cmp	 DWORD PTR $T71842[ebp], 0
  00319	74 17		 je	 SHORT $L71843
  0031b	8b 4d f4	 mov	 ecx, DWORD PTR _dwGlobalType$70581[ebp]
  0031e	51		 push	 ecx
  0031f	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR $T71842[ebp]
  00325	e8 00 00 00 00	 call	 ??0CBufferConfig@@QAE@K@Z ; CBufferConfig::CBufferConfig
  0032a	89 85 40 ff ff
	ff		 mov	 DWORD PTR tv134[ebp], eax
  00330	eb 0a		 jmp	 SHORT $L71844
$L71843:
  00332	c7 85 40 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv134[ebp], 0
$L71844:
  0033c	8b 95 40 ff ff
	ff		 mov	 edx, DWORD PTR tv134[ebp]
  00342	89 55 98	 mov	 DWORD PTR _pBuffer$70611[ebp], edx

; 2618 :             if (pBuffer)

  00345	83 7d 98 00	 cmp	 DWORD PTR _pBuffer$70611[ebp], 0
  00349	74 11		 je	 SHORT $L70614

; 2619 :             {
; 2620 :                 // This buffer configuration just has an id to identify which standard
; 2621 :                 // buffer, instead of a pointer to a DSoundBufferConfig object,
; 2622 :                 // which is what you'd see in the file io case.
; 2623 :                 pConfig->m_BufferConfigList.AddHead(pBuffer);

  0034b	8b 45 98	 mov	 eax, DWORD PTR _pBuffer$70611[ebp]
  0034e	50		 push	 eax
  0034f	8b 4d fc	 mov	 ecx, DWORD PTR _pConfig$[ebp]
  00352	83 c1 18	 add	 ecx, 24			; 00000018H
  00355	e8 00 00 00 00	 call	 ?AddHead@CBufferConfigList@@QAEXPAVCBufferConfig@@@Z ; CBufferConfigList::AddHead

; 2624 :             }
; 2625 :             else

  0035a	eb 44		 jmp	 SHORT $L70610
$L70614:

; 2626 :             {
; 2627 :                 delete pConfig;

  0035c	8b 4d fc	 mov	 ecx, DWORD PTR _pConfig$[ebp]
  0035f	89 8d 74 ff ff
	ff		 mov	 DWORD PTR $T71846[ebp], ecx
  00365	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR $T71846[ebp]
  0036b	89 95 78 ff ff
	ff		 mov	 DWORD PTR $T71845[ebp], edx
  00371	83 bd 78 ff ff
	ff 00		 cmp	 DWORD PTR $T71845[ebp], 0
  00378	74 15		 je	 SHORT $L71847
  0037a	6a 01		 push	 1
  0037c	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR $T71845[ebp]
  00382	e8 00 00 00 00	 call	 ??_GCAudioPathConfig@@QAEPAXI@Z
  00387	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv143[ebp], eax
  0038d	eb 0a		 jmp	 SHORT $L71848
$L71847:
  0038f	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv143[ebp], 0
$L71848:

; 2628 :                 return NULL;

  00399	33 c0		 xor	 eax, eax
  0039b	e9 de 02 00 00	 jmp	 $L70576
$L70610:

; 2629 :             }
; 2630 :         }
; 2631 :         if (fCreatePort)

  003a0	83 7d e0 00	 cmp	 DWORD PTR _fCreatePort$70586[ebp], 0
  003a4	0f 84 d1 02 00
	00		 je	 $L70580

; 2632 :         {
; 2633 :             CPortConfig *pPort = new CPortConfig();

  003aa	6a 5c		 push	 92			; 0000005cH
  003ac	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  003b1	83 c4 04	 add	 esp, 4
  003b4	89 85 70 ff ff
	ff		 mov	 DWORD PTR $T71849[ebp], eax
  003ba	83 bd 70 ff ff
	ff 00		 cmp	 DWORD PTR $T71849[ebp], 0
  003c1	74 13		 je	 SHORT $L71850
  003c3	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR $T71849[ebp]
  003c9	e8 00 00 00 00	 call	 ??0CPortConfig@@QAE@XZ	; CPortConfig::CPortConfig
  003ce	89 85 38 ff ff
	ff		 mov	 DWORD PTR tv150[ebp], eax
  003d4	eb 0a		 jmp	 SHORT $L71851
$L71850:
  003d6	c7 85 38 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv150[ebp], 0
$L71851:
  003e0	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR tv150[ebp]
  003e6	89 45 94	 mov	 DWORD PTR _pPort$70619[ebp], eax

; 2634 :             if (pPort)

  003e9	83 7d 94 00	 cmp	 DWORD PTR _pPort$70619[ebp], 0
  003ed	0f 84 44 02 00
	00		 je	 $L70622

; 2635 :             {
; 2636 :                 pConfig->m_PortConfigList.AddHead(pPort);

  003f3	8b 4d 94	 mov	 ecx, DWORD PTR _pPort$70619[ebp]
  003f6	51		 push	 ecx
  003f7	8b 4d fc	 mov	 ecx, DWORD PTR _pConfig$[ebp]
  003fa	83 c1 14	 add	 ecx, 20			; 00000014H
  003fd	e8 00 00 00 00	 call	 ?AddHead@CPortConfigList@@QAEXPAVCPortConfig@@@Z ; CPortConfigList::AddHead

; 2637 :                 for (DWORD dwIndex = 0; dwIndex < dwTotal; dwIndex++)

  00402	c7 45 90 00 00
	00 00		 mov	 DWORD PTR _dwIndex$70623[ebp], 0
  00409	eb 09		 jmp	 SHORT $L70624
$L70625:
  0040b	8b 55 90	 mov	 edx, DWORD PTR _dwIndex$70623[ebp]
  0040e	83 c2 01	 add	 edx, 1
  00411	89 55 90	 mov	 DWORD PTR _dwIndex$70623[ebp], edx
$L70624:
  00414	8b 45 90	 mov	 eax, DWORD PTR _dwIndex$70623[ebp]
  00417	3b 45 f8	 cmp	 eax, DWORD PTR _dwTotal$70583[ebp]
  0041a	0f 83 be 00 00
	00		 jae	 $L70626

; 2638 :                 {
; 2639 :                     CBufferConfig *pBuffer = new CBufferConfig(dwTypes[dwIndex]);

  00420	6a 30		 push	 48			; 00000030H
  00422	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00427	83 c4 04	 add	 esp, 4
  0042a	89 85 6c ff ff
	ff		 mov	 DWORD PTR $T71852[ebp], eax
  00430	83 bd 6c ff ff
	ff 00		 cmp	 DWORD PTR $T71852[ebp], 0
  00437	74 1b		 je	 SHORT $L71853
  00439	8b 4d 90	 mov	 ecx, DWORD PTR _dwIndex$70623[ebp]
  0043c	8b 54 8d e4	 mov	 edx, DWORD PTR _dwTypes$70582[ebp+ecx*4]
  00440	52		 push	 edx
  00441	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR $T71852[ebp]
  00447	e8 00 00 00 00	 call	 ??0CBufferConfig@@QAE@K@Z ; CBufferConfig::CBufferConfig
  0044c	89 85 34 ff ff
	ff		 mov	 DWORD PTR tv197[ebp], eax
  00452	eb 0a		 jmp	 SHORT $L71854
$L71853:
  00454	c7 85 34 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv197[ebp], 0
$L71854:
  0045e	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR tv197[ebp]
  00464	89 45 8c	 mov	 DWORD PTR _pBuffer$70627[ebp], eax

; 2640 :                     if (pBuffer)

  00467	83 7d 8c 00	 cmp	 DWORD PTR _pBuffer$70627[ebp], 0
  0046b	74 28		 je	 SHORT $L70630

; 2641 :                     {
; 2642 :                         // This buffer configuration just has an id to identify which standard
; 2643 :                         // buffer, instead of a pointer to a DSoundBufferConfig object,
; 2644 :                         // which is what you'd see in the file io case.
; 2645 :                         pPort->m_BufferConfigList.AddHead(pBuffer);

  0046d	8b 4d 8c	 mov	 ecx, DWORD PTR _pBuffer$70627[ebp]
  00470	51		 push	 ecx
  00471	8b 4d 94	 mov	 ecx, DWORD PTR _pPort$70619[ebp]
  00474	83 c1 4c	 add	 ecx, 76			; 0000004cH
  00477	e8 00 00 00 00	 call	 ?AddHead@CBufferConfigList@@QAEXPAVCBufferConfig@@@Z ; CBufferConfigList::AddHead

; 2646 : #ifdef XBOX
; 2647 :                         pBuffer->m_MixBinsHeader = MixBinsHeader;

  0047c	8b 55 8c	 mov	 edx, DWORD PTR _pBuffer$70627[ebp]
  0047f	83 c2 24	 add	 edx, 36			; 00000024H
  00482	8b 45 a4	 mov	 eax, DWORD PTR _MixBinsHeader$70587[ebp]
  00485	89 02		 mov	 DWORD PTR [edx], eax
  00487	8b 4d a8	 mov	 ecx, DWORD PTR _MixBinsHeader$70587[ebp+4]
  0048a	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  0048d	8b 45 ac	 mov	 eax, DWORD PTR _MixBinsHeader$70587[ebp+8]
  00490	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 2648 : #endif
; 2649 :                     }
; 2650 :                     else

  00493	eb 44		 jmp	 SHORT $L70631
$L70630:

; 2651 :                     {
; 2652 :                         delete pConfig;

  00495	8b 4d fc	 mov	 ecx, DWORD PTR _pConfig$[ebp]
  00498	89 8d 64 ff ff
	ff		 mov	 DWORD PTR $T71856[ebp], ecx
  0049e	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR $T71856[ebp]
  004a4	89 95 68 ff ff
	ff		 mov	 DWORD PTR $T71855[ebp], edx
  004aa	83 bd 68 ff ff
	ff 00		 cmp	 DWORD PTR $T71855[ebp], 0
  004b1	74 15		 je	 SHORT $L71857
  004b3	6a 01		 push	 1
  004b5	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR $T71855[ebp]
  004bb	e8 00 00 00 00	 call	 ??_GCAudioPathConfig@@QAEPAXI@Z
  004c0	89 85 30 ff ff
	ff		 mov	 DWORD PTR tv207[ebp], eax
  004c6	eb 0a		 jmp	 SHORT $L71858
$L71857:
  004c8	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv207[ebp], 0
$L71858:

; 2653 :                         return NULL;

  004d2	33 c0		 xor	 eax, eax
  004d4	e9 a5 01 00 00	 jmp	 $L70576
$L70631:

; 2654 :                     }
; 2655 :                 }

  004d9	e9 2d ff ff ff	 jmp	 $L70625
$L70626:

; 2656 :                 // If there are connections to buffers, create the connection structure.
; 2657 :                 if (dwConnections)

  004de	83 7d f0 00	 cmp	 DWORD PTR _dwConnections$70585[ebp], 0
  004e2	0f 84 35 01 00
	00		 je	 $L70634

; 2658 :                 {
; 2659 :                     CBufferConnect *pConnect = new CBufferConnect;

  004e8	6a 1c		 push	 28			; 0000001cH
  004ea	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  004ef	83 c4 04	 add	 esp, 4
  004f2	89 85 60 ff ff
	ff		 mov	 DWORD PTR $T71859[ebp], eax
  004f8	83 bd 60 ff ff
	ff 00		 cmp	 DWORD PTR $T71859[ebp], 0
  004ff	74 13		 je	 SHORT $L71860
  00501	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR $T71859[ebp]
  00507	e8 00 00 00 00	 call	 ??0CBufferConnect@@QAE@XZ ; CBufferConnect::CBufferConnect
  0050c	89 85 2c ff ff
	ff		 mov	 DWORD PTR tv214[ebp], eax
  00512	eb 0a		 jmp	 SHORT $L71861
$L71860:
  00514	c7 85 2c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv214[ebp], 0
$L71861:
  0051e	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR tv214[ebp]
  00524	89 45 88	 mov	 DWORD PTR _pConnect$70635[ebp], eax

; 2660 :                     if (pConnect)

  00527	83 7d 88 00	 cmp	 DWORD PTR _pConnect$70635[ebp], 0
  0052b	0f 84 ec 00 00
	00		 je	 $L70634

; 2661 :                     {
; 2662 :                         pPort->m_BufferConnectList.AddHead(pConnect);

  00531	8b 4d 88	 mov	 ecx, DWORD PTR _pConnect$70635[ebp]
  00534	51		 push	 ecx
  00535	8b 4d 94	 mov	 ecx, DWORD PTR _pPort$70619[ebp]
  00538	83 c1 48	 add	 ecx, 72			; 00000048H
  0053b	e8 00 00 00 00	 call	 ?AddHead@CBufferConnectList@@QAEXPAVCBufferConnect@@@Z ; CBufferConnectList::AddHead

; 2663 :                         pConnect->m_ConnectHeader.dwBufferCount = dwConnections;

  00540	8b 55 88	 mov	 edx, DWORD PTR _pConnect$70635[ebp]
  00543	8b 45 f0	 mov	 eax, DWORD PTR _dwConnections$70585[ebp]
  00546	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 2664 :                         pConnect->m_ConnectHeader.dwFlags = 0;

  00549	8b 4d 88	 mov	 ecx, DWORD PTR _pConnect$70635[ebp]
  0054c	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 2665 :                         pConnect->m_ConnectHeader.dwPChannelBase = 0;

  00553	8b 55 88	 mov	 edx, DWORD PTR _pConnect$70635[ebp]
  00556	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0

; 2666 :                         pConnect->m_ConnectHeader.dwPChannelCount = dwPChannelCount;

  0055d	8b 45 88	 mov	 eax, DWORD PTR _pConnect$70635[ebp]
  00560	8b 4d 0c	 mov	 ecx, DWORD PTR _dwPChannelCount$[ebp]
  00563	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 2667 :                         pConnect->m_pguidBufferIDs = new GUID[dwConnections];

  00566	8b 55 f0	 mov	 edx, DWORD PTR _dwConnections$70585[ebp]
  00569	c1 e2 04	 shl	 edx, 4
  0056c	52		 push	 edx
  0056d	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00572	83 c4 04	 add	 esp, 4
  00575	89 85 5c ff ff
	ff		 mov	 DWORD PTR $T71862[ebp], eax
  0057b	8b 45 88	 mov	 eax, DWORD PTR _pConnect$70635[ebp]
  0057e	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR $T71862[ebp]
  00584	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 2668 :                         if (pConnect->m_pguidBufferIDs)

  00587	8b 55 88	 mov	 edx, DWORD PTR _pConnect$70635[ebp]
  0058a	83 7a 14 00	 cmp	 DWORD PTR [edx+20], 0
  0058e	74 4c		 je	 SHORT $L70641

; 2669 :                         {
; 2670 :                             for (DWORD dwIndex = 0; dwIndex < dwConnections; dwIndex++)

  00590	c7 45 84 00 00
	00 00		 mov	 DWORD PTR _dwIndex$70642[ebp], 0
  00597	eb 09		 jmp	 SHORT $L70643
$L70644:
  00599	8b 45 84	 mov	 eax, DWORD PTR _dwIndex$70642[ebp]
  0059c	83 c0 01	 add	 eax, 1
  0059f	89 45 84	 mov	 DWORD PTR _dwIndex$70642[ebp], eax
$L70643:
  005a2	8b 4d 84	 mov	 ecx, DWORD PTR _dwIndex$70642[ebp]
  005a5	3b 4d f0	 cmp	 ecx, DWORD PTR _dwConnections$70585[ebp]
  005a8	73 30		 jae	 SHORT $L70645

; 2671 :                             {
; 2672 :                                 pConnect->m_pguidBufferIDs[dwIndex] = guidBufferIDs[dwIndex];

  005aa	8b 55 84	 mov	 edx, DWORD PTR _dwIndex$70642[ebp]
  005ad	c1 e2 04	 shl	 edx, 4
  005b0	8d 44 15 b0	 lea	 eax, DWORD PTR _guidBufferIDs$70584[ebp+edx]
  005b4	8b 4d 84	 mov	 ecx, DWORD PTR _dwIndex$70642[ebp]
  005b7	c1 e1 04	 shl	 ecx, 4
  005ba	8b 55 88	 mov	 edx, DWORD PTR _pConnect$70635[ebp]
  005bd	8b 52 14	 mov	 edx, DWORD PTR [edx+20]
  005c0	03 d1		 add	 edx, ecx
  005c2	8b 08		 mov	 ecx, DWORD PTR [eax]
  005c4	89 0a		 mov	 DWORD PTR [edx], ecx
  005c6	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  005c9	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  005cc	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  005cf	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  005d2	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  005d5	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 2673 :                             }

  005d8	eb bf		 jmp	 SHORT $L70644
$L70645:

; 2674 :                         }
; 2675 :                         else

  005da	eb 41		 jmp	 SHORT $L70634
$L70641:

; 2676 :                         {
; 2677 :                             delete pConfig;

  005dc	8b 4d fc	 mov	 ecx, DWORD PTR _pConfig$[ebp]
  005df	89 8d 54 ff ff
	ff		 mov	 DWORD PTR $T71864[ebp], ecx
  005e5	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR $T71864[ebp]
  005eb	89 95 58 ff ff
	ff		 mov	 DWORD PTR $T71863[ebp], edx
  005f1	83 bd 58 ff ff
	ff 00		 cmp	 DWORD PTR $T71863[ebp], 0
  005f8	74 15		 je	 SHORT $L71865
  005fa	6a 01		 push	 1
  005fc	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR $T71863[ebp]
  00602	e8 00 00 00 00	 call	 ??_GCAudioPathConfig@@QAEPAXI@Z
  00607	89 85 28 ff ff
	ff		 mov	 DWORD PTR tv245[ebp], eax
  0060d	eb 0a		 jmp	 SHORT $L71866
$L71865:
  0060f	c7 85 28 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv245[ebp], 0
$L71866:

; 2678 :                             return NULL;

  00619	33 c0		 xor	 eax, eax
  0061b	eb 61		 jmp	 SHORT $L70576
$L70634:

; 2679 :                         }
; 2680 :                     }
; 2681 :                 }
; 2682 :                 pPort->m_PortHeader.dwPChannelCount = dwPChannelCount;

  0061d	8b 45 94	 mov	 eax, DWORD PTR _pPort$70619[ebp]
  00620	8b 4d 0c	 mov	 ecx, DWORD PTR _dwPChannelCount$[ebp]
  00623	89 48 18	 mov	 DWORD PTR [eax+24], ecx

; 2683 :                 pPort->m_PortParams.dwChannelGroups = (dwPChannelCount + 15) / 16;

  00626	8b 55 0c	 mov	 edx, DWORD PTR _dwPChannelCount$[ebp]
  00629	83 c2 0f	 add	 edx, 15			; 0000000fH
  0062c	c1 ea 04	 shr	 edx, 4
  0062f	8b 45 94	 mov	 eax, DWORD PTR _pPort$70619[ebp]
  00632	89 50 2c	 mov	 DWORD PTR [eax+44], edx

; 2684 :             }
; 2685 :             else

  00635	eb 44		 jmp	 SHORT $L70580
$L70622:

; 2686 :             {
; 2687 :                 delete pConfig;

  00637	8b 4d fc	 mov	 ecx, DWORD PTR _pConfig$[ebp]
  0063a	89 8d 4c ff ff
	ff		 mov	 DWORD PTR $T71868[ebp], ecx
  00640	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR $T71868[ebp]
  00646	89 95 50 ff ff
	ff		 mov	 DWORD PTR $T71867[ebp], edx
  0064c	83 bd 50 ff ff
	ff 00		 cmp	 DWORD PTR $T71867[ebp], 0
  00653	74 15		 je	 SHORT $L71869
  00655	6a 01		 push	 1
  00657	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR $T71867[ebp]
  0065d	e8 00 00 00 00	 call	 ??_GCAudioPathConfig@@QAEPAXI@Z
  00662	89 85 24 ff ff
	ff		 mov	 DWORD PTR tv256[ebp], eax
  00668	eb 0a		 jmp	 SHORT $L71870
$L71869:
  0066a	c7 85 24 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv256[ebp], 0
$L71870:

; 2688 :                 pConfig = NULL;

  00674	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pConfig$[ebp], 0
$L70580:

; 2689 :             }
; 2690 :         }
; 2691 :     }
; 2692 :     return pConfig;

  0067b	8b 45 fc	 mov	 eax, DWORD PTR _pConfig$[ebp]
$L70576:

; 2693 : }

  0067e	8b e5		 mov	 esp, ebp
  00680	5d		 pop	 ebp
  00681	c2 0c 00	 ret	 12			; 0000000cH
$L71871:
  00684	00 00 00 00	 DD	 $L70596
  00688	00 00 00 00	 DD	 $L70592
  0068c	00 00 00 00	 DD	 $L70594
  00690	00 00 00 00	 DD	 $L70593
  00694	00 00 00 00	 DD	 $L70595
?CreateStandardConfig@CAudioPathConfig@@SGPAV1@KKK@Z ENDP ; CAudioPathConfig::CreateStandardConfig
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??_GCAudioPathConfig@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4
___flags$ = 8
??_GCAudioPathConfig@@QAEPAXI@Z PROC NEAR		; CAudioPathConfig::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CAudioPathConfig@@QAE@XZ ; CAudioPathConfig::~CAudioPathConfig
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $L70655
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$L70655:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GCAudioPathConfig@@QAEPAXI@Z ENDP			; CAudioPathConfig::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_C@_0EH@FEDPIBJE@Warning?3?5Request?5to?5query?5unknow@ ; `string'
EXTRN	_CLSID_AutDirectMusicAudioPathConfig:BYTE
EXTRN	_IID_IDirectMusicObject:BYTE
EXTRN	_IID_IPersistStream:BYTE
;	COMDAT ?__szValidateInterfaceName@?1??QueryInterface@CAudioPathConfig@@UAGJABU_GUID@@PAPAX@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??QueryInterface@CAudioPathConfig@@UAGJABU_GUID@@PAPAX@Z@4QBDB DB 'C'
	DB	'AudioPathConfig::QueryInterface', 00H	; `CAudioPathConfig::QueryInterface'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0EH@FEDPIBJE@Warning?3?5Request?5to?5query?5unknow@
CONST	SEGMENT
??_C@_0EH@FEDPIBJE@Warning?3?5Request?5to?5query?5unknow@ DB 'Warning: Re'
	DB	'quest to query unknown interface on AudioPathConfig object', 0aH
	DB	00H						; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?QueryInterface@CAudioPathConfig@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
tv141 = -8
tv88 = -4
_this$ = 8
_iid$ = 12
_ppv$ = 16
?QueryInterface@CAudioPathConfig@@UAGJABU_GUID@@PAPAX@Z PROC NEAR ; CAudioPathConfig::QueryInterface, COMDAT

; 2700 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 2701 :     V_INAME(CAudioPathConfig::QueryInterface);
; 2702 :     V_PTRPTR_WRITE(ppv);

  00006	6a 04		 push	 4
  00008	8b 45 10	 mov	 eax, DWORD PTR _ppv$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  00011	85 c0		 test	 eax, eax
  00013	74 19		 je	 SHORT $L70664
  00015	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??QueryInterface@CAudioPathConfig@@UAGJABU_GUID@@PAPAX@Z@4QBDB
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BJ@IGMLCEHI@?$CFs?3?5Invalid?5pointer?5ppv?6?$AA@
  0001f	6a ff		 push	 -1
  00021	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH
  00029	e8 00 00 00 00	 call	 _DebugBreak@0
$L70664:

; 2703 :     V_REFGUID(iid);

  0002e	6a 10		 push	 16			; 00000010H
  00030	8b 4d 0c	 mov	 ecx, DWORD PTR _iid$[ebp]
  00033	51		 push	 ecx
  00034	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  00039	85 c0		 test	 eax, eax
  0003b	74 19		 je	 SHORT $L70667
  0003d	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??QueryInterface@CAudioPathConfig@@UAGJABU_GUID@@PAPAX@Z@4QBDB
  00042	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CB@NHMFCKLP@?$CFs?3?5Invalid?5pointer?5?$CIvoid?$CK?$CJ?$CGiid?6@
  00047	6a ff		 push	 -1
  00049	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00051	e8 00 00 00 00	 call	 _DebugBreak@0
$L70667:

; 2704 : 
; 2705 :     *ppv = NULL;

  00056	8b 55 10	 mov	 edx, DWORD PTR _ppv$[ebp]
  00059	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 2706 :     if ((iid == IID_IUnknown ) || (iid == IID_IDirectMusicObject))

  0005f	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IUnknown
  00064	8b 45 0c	 mov	 eax, DWORD PTR _iid$[ebp]
  00067	50		 push	 eax
  00068	e8 00 00 00 00	 call	 _==@8
  0006d	85 c0		 test	 eax, eax
  0006f	75 12		 jne	 SHORT $L70669
  00071	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IDirectMusicObject
  00076	8b 4d 0c	 mov	 ecx, DWORD PTR _iid$[ebp]
  00079	51		 push	 ecx
  0007a	e8 00 00 00 00	 call	 _==@8
  0007f	85 c0		 test	 eax, eax
  00081	74 25		 je	 SHORT $L70668
$L70669:

; 2707 :     {
; 2708 :         *ppv = static_cast<IDirectMusicObject*>(this);

  00083	83 7d 08 00	 cmp	 DWORD PTR _this$[ebp], 0
  00087	74 0b		 je	 SHORT $L71878
  00089	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0008c	83 c2 04	 add	 edx, 4
  0008f	89 55 fc	 mov	 DWORD PTR tv88[ebp], edx
  00092	eb 07		 jmp	 SHORT $L71879
$L71878:
  00094	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv88[ebp], 0
$L71879:
  0009b	8b 45 10	 mov	 eax, DWORD PTR _ppv$[ebp]
  0009e	8b 4d fc	 mov	 ecx, DWORD PTR tv88[ebp]
  000a1	89 08		 mov	 DWORD PTR [eax], ecx

; 2709 :     }
; 2710 :     else if (iid == IID_IPersistStream)

  000a3	e9 bf 00 00 00	 jmp	 $L70671
$L70668:
  000a8	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IPersistStream
  000ad	8b 55 0c	 mov	 edx, DWORD PTR _iid$[ebp]
  000b0	52		 push	 edx
  000b1	e8 00 00 00 00	 call	 _==@8
  000b6	85 c0		 test	 eax, eax
  000b8	74 0d		 je	 SHORT $L70672

; 2711 :     {
; 2712 :         *ppv = static_cast<IPersistStream*>(this);

  000ba	8b 45 10	 mov	 eax, DWORD PTR _ppv$[ebp]
  000bd	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000c0	89 08		 mov	 DWORD PTR [eax], ecx

; 2713 :     }
; 2714 :     else if (iid == IID_CAudioPathConfig)

  000c2	e9 a0 00 00 00	 jmp	 $L70671
$L70672:
  000c7	68 00 00 00 00	 push	 OFFSET FLAT:_IID_CAudioPathConfig
  000cc	8b 55 0c	 mov	 edx, DWORD PTR _iid$[ebp]
  000cf	52		 push	 edx
  000d0	e8 00 00 00 00	 call	 _==@8
  000d5	85 c0		 test	 eax, eax
  000d7	74 0d		 je	 SHORT $L70675

; 2715 :     {
; 2716 :         *ppv = static_cast<CAudioPathConfig*>(this);

  000d9	8b 45 10	 mov	 eax, DWORD PTR _ppv$[ebp]
  000dc	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000df	89 08		 mov	 DWORD PTR [eax], ecx

; 2717 :     }
; 2718 :     else if (iid == IID_IDispatch)

  000e1	e9 81 00 00 00	 jmp	 $L70671
$L70675:
  000e6	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IDispatch
  000eb	8b 55 0c	 mov	 edx, DWORD PTR _iid$[ebp]
  000ee	52		 push	 edx
  000ef	e8 00 00 00 00	 call	 _==@8
  000f4	85 c0		 test	 eax, eax
  000f6	74 6f		 je	 SHORT $L70671

; 2719 :     {
; 2720 :         // A helper scripting object implements IDispatch, which we expose via COM aggregation.
; 2721 :         if (!m_pUnkDispatch)

  000f8	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  000fb	83 b8 68 03 00
	00 00		 cmp	 DWORD PTR [eax+872], 0
  00102	75 35		 jne	 SHORT $L70679

; 2722 :         {
; 2723 :             // Create the helper object
; 2724 :             DirectMusicCreateInstance(
; 2725 :                 CLSID_AutDirectMusicAudioPathConfig,
; 2726 :                 static_cast<IDirectMusicObject*>(this),
; 2727 :                 IID_IUnknown,
; 2728 :                 reinterpret_cast<void**>(&m_pUnkDispatch));

  00104	83 7d 08 00	 cmp	 DWORD PTR _this$[ebp], 0
  00108	74 0b		 je	 SHORT $L71880
  0010a	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0010d	83 c1 04	 add	 ecx, 4
  00110	89 4d f8	 mov	 DWORD PTR tv141[ebp], ecx
  00113	eb 07		 jmp	 SHORT $L71881
$L71880:
  00115	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv141[ebp], 0
$L71881:
  0011c	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0011f	81 c2 68 03 00
	00		 add	 edx, 872		; 00000368H
  00125	52		 push	 edx
  00126	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IUnknown
  0012b	8b 45 f8	 mov	 eax, DWORD PTR tv141[ebp]
  0012e	50		 push	 eax
  0012f	68 00 00 00 00	 push	 OFFSET FLAT:_CLSID_AutDirectMusicAudioPathConfig
  00134	e8 00 00 00 00	 call	 _DirectMusicCreateInstance@16
$L70679:

; 2729 :         }
; 2730 :         if (m_pUnkDispatch)

  00139	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0013c	83 b9 68 03 00
	00 00		 cmp	 DWORD PTR [ecx+872], 0
  00143	74 22		 je	 SHORT $L70671

; 2731 :         {
; 2732 :             return m_pUnkDispatch->QueryInterface(IID_IDispatch, ppv);

  00145	8b 55 10	 mov	 edx, DWORD PTR _ppv$[ebp]
  00148	52		 push	 edx
  00149	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IDispatch
  0014e	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00151	8b 88 68 03 00
	00		 mov	 ecx, DWORD PTR [eax+872]
  00157	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0015a	8b 82 68 03 00
	00		 mov	 eax, DWORD PTR [edx+872]
  00160	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00162	50		 push	 eax
  00163	ff 11		 call	 DWORD PTR [ecx]
  00165	eb 2c		 jmp	 SHORT $L70660
$L70671:

; 2733 :         }
; 2734 :     }
; 2735 : 
; 2736 :     if (*ppv == NULL)

  00167	8b 55 10	 mov	 edx, DWORD PTR _ppv$[ebp]
  0016a	83 3a 00	 cmp	 DWORD PTR [edx], 0
  0016d	75 16		 jne	 SHORT $L70683

; 2737 :     {
; 2738 :         Trace(4,"Warning: Request to query unknown interface on AudioPathConfig object\n");

  0016f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EH@FEDPIBJE@Warning?3?5Request?5to?5query?5unknow@
  00174	6a 04		 push	 4
  00176	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0017b	83 c4 08	 add	 esp, 8

; 2739 :         return E_NOINTERFACE;

  0017e	b8 02 40 00 80	 mov	 eax, -2147467262	; 80004002H
  00183	eb 0e		 jmp	 SHORT $L70660
$L70683:

; 2740 :     }
; 2741 :     AddRef();

  00185	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00188	8b 08		 mov	 ecx, DWORD PTR [eax]
  0018a	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0018d	52		 push	 edx
  0018e	ff 51 04	 call	 DWORD PTR [ecx+4]

; 2742 :     return S_OK;

  00191	33 c0		 xor	 eax, eax
$L70660:

; 2743 : }

  00193	8b e5		 mov	 esp, ebp
  00195	5d		 pop	 ebp
  00196	c2 0c 00	 ret	 12			; 0000000cH
?QueryInterface@CAudioPathConfig@@UAGJABU_GUID@@PAPAX@Z ENDP ; CAudioPathConfig::QueryInterface
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?AddRef@CAudioPathConfig@@UAGKXZ
_TEXT	SEGMENT
_this$ = 8
?AddRef@CAudioPathConfig@@UAGKXZ PROC NEAR		; CAudioPathConfig::AddRef, COMDAT

; 2747 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2748 :     return InterlockedIncrement(&m_cRef);

  00003	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00006	83 c0 38	 add	 eax, 56			; 00000038H
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 __InterlockedIncrement@4

; 2749 : }

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?AddRef@CAudioPathConfig@@UAGKXZ ENDP			; CAudioPathConfig::AddRef
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?Release@CAudioPathConfig@@UAGKXZ
_TEXT	SEGMENT
tv72 = -12
$T71889 = -8
$T71888 = -4
_this$ = 8
?Release@CAudioPathConfig@@UAGKXZ PROC NEAR		; CAudioPathConfig::Release, COMDAT

; 2752 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 2753 :     if (!InterlockedDecrement(&m_cRef))

  00006	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00009	83 c0 38	 add	 eax, 56			; 00000038H
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 __InterlockedDecrement@4
  00012	85 c0		 test	 eax, eax
  00014	75 2c		 jne	 SHORT $L70693

; 2754 :     {
; 2755 :         delete this;

  00016	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	89 4d f8	 mov	 DWORD PTR $T71889[ebp], ecx
  0001c	8b 55 f8	 mov	 edx, DWORD PTR $T71889[ebp]
  0001f	89 55 fc	 mov	 DWORD PTR $T71888[ebp], edx
  00022	83 7d fc 00	 cmp	 DWORD PTR $T71888[ebp], 0
  00026	74 0f		 je	 SHORT $L71890
  00028	6a 01		 push	 1
  0002a	8b 4d fc	 mov	 ecx, DWORD PTR $T71888[ebp]
  0002d	e8 00 00 00 00	 call	 ??_GCAudioPathConfig@@QAEPAXI@Z
  00032	89 45 f4	 mov	 DWORD PTR tv72[ebp], eax
  00035	eb 07		 jmp	 SHORT $L71891
$L71890:
  00037	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv72[ebp], 0
$L71891:

; 2756 :         return 0;

  0003e	33 c0		 xor	 eax, eax
  00040	eb 06		 jmp	 SHORT $L70692
$L70693:

; 2757 :     }
; 2758 : 
; 2759 :     return m_cRef;

  00042	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00045	8b 40 38	 mov	 eax, DWORD PTR [eax+56]
$L70692:

; 2760 : }

  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c2 04 00	 ret	 4
?Release@CAudioPathConfig@@UAGKXZ ENDP			; CAudioPathConfig::Release
_TEXT	ENDS
PUBLIC	??_C@_0CH@DNOFJOKI@offsetof?$CIDMUS_OBJECTDESC?0?5dwSize@ ; `string'
PUBLIC	??_C@_0L@JDNNJMNO@?$CFs?$EA?$CFs?3?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0EH@OOGGANMB@?$CFs?3?5pDesc?5does?5not?5point?5to?5as?5m@ ; `string'
PUBLIC	??_C@_0CA@DAJLLPMH@?$CFs?3?5pDesc?9?$DOdwSize?5is?5too?5small?6?$AA@ ; `string'
EXTRN	?GetDescriptor@CInfo@@QAEJPAU_DMUS_OBJECTDESC@@ABU_GUID@@@Z:NEAR ; CInfo::GetDescriptor
EXTRN	_CLSID_DirectMusicAudioPathConfig:BYTE
;	COMDAT ??_C@_0CH@DNOFJOKI@offsetof?$CIDMUS_OBJECTDESC?0?5dwSize@
CONST	SEGMENT
??_C@_0CH@DNOFJOKI@offsetof?$CIDMUS_OBJECTDESC?0?5dwSize@ DB 'offsetof(DM'
	DB	'US_OBJECTDESC, dwSize) == 0', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JDNNJMNO@?$CFs?$EA?$CFs?3?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0L@JDNNJMNO@?$CFs?$EA?$CFs?3?5?$CFs?6?$AA@ DB '%s@%s: %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??GetDescriptor@CAudioPathConfig@@UAGJPAU_DMUS_OBJECTDESC@@@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??GetDescriptor@CAudioPathConfig@@UAGJPAU_DMUS_OBJECTDESC@@@Z@4QBDB DB 'C'
	DB	'AudioPathConfig::GetDescriptor', 00H	; `CAudioPathConfig::GetDescriptor'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0EH@OOGGANMB@?$CFs?3?5pDesc?5does?5not?5point?5to?5as?5m@
CONST	SEGMENT
??_C@_0EH@OOGGANMB@?$CFs?3?5pDesc?5does?5not?5point?5to?5as?5m@ DB '%s: p'
	DB	'Desc does not point to as much memory as pDesc->dwSize indica'
	DB	'tes', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@DAJLLPMH@?$CFs?3?5pDesc?9?$DOdwSize?5is?5too?5small?6?$AA@
CONST	SEGMENT
??_C@_0CA@DAJLLPMH@?$CFs?3?5pDesc?9?$DOdwSize?5is?5too?5small?6?$AA@ DB '%'
	DB	's: pDesc->dwSize is too small', 0aH, 00H	; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?GetDescriptor@CAudioPathConfig@@UAGJPAU_DMUS_OBJECTDESC@@@Z
_TEXT	SEGMENT
_this$ = 8
_pDesc$ = 12
?GetDescriptor@CAudioPathConfig@@UAGJPAU_DMUS_OBJECTDESC@@@Z PROC NEAR ; CAudioPathConfig::GetDescriptor, COMDAT

; 2763 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2764 :     // Argument validation
; 2765 :     V_INAME(CAudioPathConfig::GetDescriptor);
; 2766 :     V_STRUCTPTR_WRITE(pDesc, DMUS_OBJECTDESC);

  00003	33 c0		 xor	 eax, eax
  00005	85 c0		 test	 eax, eax
  00007	74 23		 je	 SHORT $L70704
  00009	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CH@DNOFJOKI@offsetof?$CIDMUS_OBJECTDESC?0?5dwSize@
  0000e	68 ce 0a 00 00	 push	 2766			; 00000aceH
  00013	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@JGOKDJAP@c?3?2xbox?2private?2windows?2directx?2@
  00018	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0L@JDNNJMNO@?$CFs?$EA?$CFs?3?5?$CFs?6?$AA@
  0001d	6a ff		 push	 -1
  0001f	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00024	83 c4 14	 add	 esp, 20			; 00000014H
  00027	e8 00 00 00 00	 call	 _DebugBreak@0
$L70704:
  0002c	6a 04		 push	 4
  0002e	8b 4d 0c	 mov	 ecx, DWORD PTR _pDesc$[ebp]
  00031	51		 push	 ecx
  00032	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  00037	85 c0		 test	 eax, eax
  00039	74 19		 je	 SHORT $L70708
  0003b	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??GetDescriptor@CAudioPathConfig@@UAGJPAU_DMUS_OBJECTDESC@@@Z@4QBDB
  00040	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EH@OOGGANMB@?$CFs?3?5pDesc?5does?5not?5point?5to?5as?5m@
  00045	6a ff		 push	 -1
  00047	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0004c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004f	e8 00 00 00 00	 call	 _DebugBreak@0
$L70708:
  00054	8b 55 0c	 mov	 edx, DWORD PTR _pDesc$[ebp]
  00057	81 3a 50 03 00
	00		 cmp	 DWORD PTR [edx], 848	; 00000350H
  0005d	73 19		 jae	 SHORT $L70711
  0005f	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??GetDescriptor@CAudioPathConfig@@UAGJPAU_DMUS_OBJECTDESC@@@Z@4QBDB
  00064	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@DAJLLPMH@?$CFs?3?5pDesc?9?$DOdwSize?5is?5too?5small?6?$AA@
  00069	6a ff		 push	 -1
  0006b	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00070	83 c4 0c	 add	 esp, 12			; 0000000cH
  00073	e8 00 00 00 00	 call	 _DebugBreak@0
$L70711:
  00078	8b 45 0c	 mov	 eax, DWORD PTR _pDesc$[ebp]
  0007b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007d	51		 push	 ecx
  0007e	8b 55 0c	 mov	 edx, DWORD PTR _pDesc$[ebp]
  00081	52		 push	 edx
  00082	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  00087	85 c0		 test	 eax, eax
  00089	74 19		 je	 SHORT $L70713
  0008b	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??GetDescriptor@CAudioPathConfig@@UAGJPAU_DMUS_OBJECTDESC@@@Z@4QBDB
  00090	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EH@OOGGANMB@?$CFs?3?5pDesc?5does?5not?5point?5to?5as?5m@
  00095	6a ff		 push	 -1
  00097	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0009c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0009f	e8 00 00 00 00	 call	 _DebugBreak@0
$L70713:

; 2767 :     return m_Info.GetDescriptor(pDesc,CLSID_DirectMusicAudioPathConfig);

  000a4	68 00 00 00 00	 push	 OFFSET FLAT:_CLSID_DirectMusicAudioPathConfig
  000a9	8b 45 0c	 mov	 eax, DWORD PTR _pDesc$[ebp]
  000ac	50		 push	 eax
  000ad	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000b0	83 c1 38	 add	 ecx, 56			; 00000038H
  000b3	e8 00 00 00 00	 call	 ?GetDescriptor@CInfo@@QAEJPAU_DMUS_OBJECTDESC@@ABU_GUID@@@Z ; CInfo::GetDescriptor

; 2768 : }

  000b8	5d		 pop	 ebp
  000b9	c2 08 00	 ret	 8
?GetDescriptor@CAudioPathConfig@@UAGJPAU_DMUS_OBJECTDESC@@@Z ENDP ; CAudioPathConfig::GetDescriptor
_TEXT	ENDS
EXTRN	?SetDescriptor@CInfo@@QAEJPAU_DMUS_OBJECTDESC@@@Z:NEAR ; CInfo::SetDescriptor
;	COMDAT ?__szValidateInterfaceName@?1??SetDescriptor@CAudioPathConfig@@UAGJPAU_DMUS_OBJECTDESC@@@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??SetDescriptor@CAudioPathConfig@@UAGJPAU_DMUS_OBJECTDESC@@@Z@4QBDB DB 'C'
	DB	'AudioPathConfig::SetDescriptor', 00H	; `CAudioPathConfig::SetDescriptor'::`2'::__szValidateInterfaceName
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?SetDescriptor@CAudioPathConfig@@UAGJPAU_DMUS_OBJECTDESC@@@Z
_TEXT	SEGMENT
_this$ = 8
_pDesc$ = 12
?SetDescriptor@CAudioPathConfig@@UAGJPAU_DMUS_OBJECTDESC@@@Z PROC NEAR ; CAudioPathConfig::SetDescriptor, COMDAT

; 2771 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2772 :     // Argument validation
; 2773 :     V_INAME(CAudioPathConfig::SetDescriptor);
; 2774 :     V_STRUCTPTR_READ(pDesc, DMUS_OBJECTDESC);

  00003	33 c0		 xor	 eax, eax
  00005	85 c0		 test	 eax, eax
  00007	74 23		 je	 SHORT $L70722
  00009	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CH@DNOFJOKI@offsetof?$CIDMUS_OBJECTDESC?0?5dwSize@
  0000e	68 d6 0a 00 00	 push	 2774			; 00000ad6H
  00013	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@JGOKDJAP@c?3?2xbox?2private?2windows?2directx?2@
  00018	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0L@JDNNJMNO@?$CFs?$EA?$CFs?3?5?$CFs?6?$AA@
  0001d	6a ff		 push	 -1
  0001f	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00024	83 c4 14	 add	 esp, 20			; 00000014H
  00027	e8 00 00 00 00	 call	 _DebugBreak@0
$L70722:
  0002c	6a 04		 push	 4
  0002e	8b 4d 0c	 mov	 ecx, DWORD PTR _pDesc$[ebp]
  00031	51		 push	 ecx
  00032	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  00037	85 c0		 test	 eax, eax
  00039	74 19		 je	 SHORT $L70724
  0003b	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??SetDescriptor@CAudioPathConfig@@UAGJPAU_DMUS_OBJECTDESC@@@Z@4QBDB
  00040	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EH@OOGGANMB@?$CFs?3?5pDesc?5does?5not?5point?5to?5as?5m@
  00045	6a ff		 push	 -1
  00047	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0004c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004f	e8 00 00 00 00	 call	 _DebugBreak@0
$L70724:
  00054	8b 55 0c	 mov	 edx, DWORD PTR _pDesc$[ebp]
  00057	81 3a 50 03 00
	00		 cmp	 DWORD PTR [edx], 848	; 00000350H
  0005d	73 19		 jae	 SHORT $L70726
  0005f	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??SetDescriptor@CAudioPathConfig@@UAGJPAU_DMUS_OBJECTDESC@@@Z@4QBDB
  00064	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@DAJLLPMH@?$CFs?3?5pDesc?9?$DOdwSize?5is?5too?5small?6?$AA@
  00069	6a ff		 push	 -1
  0006b	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00070	83 c4 0c	 add	 esp, 12			; 0000000cH
  00073	e8 00 00 00 00	 call	 _DebugBreak@0
$L70726:
  00078	8b 45 0c	 mov	 eax, DWORD PTR _pDesc$[ebp]
  0007b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007d	51		 push	 ecx
  0007e	8b 55 0c	 mov	 edx, DWORD PTR _pDesc$[ebp]
  00081	52		 push	 edx
  00082	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  00087	85 c0		 test	 eax, eax
  00089	74 19		 je	 SHORT $L70727
  0008b	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??SetDescriptor@CAudioPathConfig@@UAGJPAU_DMUS_OBJECTDESC@@@Z@4QBDB
  00090	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EH@OOGGANMB@?$CFs?3?5pDesc?5does?5not?5point?5to?5as?5m@
  00095	6a ff		 push	 -1
  00097	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0009c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0009f	e8 00 00 00 00	 call	 _DebugBreak@0
$L70727:

; 2775 : 	return m_Info.SetDescriptor(pDesc);

  000a4	8b 45 0c	 mov	 eax, DWORD PTR _pDesc$[ebp]
  000a7	50		 push	 eax
  000a8	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000ab	83 c1 38	 add	 ecx, 56			; 00000038H
  000ae	e8 00 00 00 00	 call	 ?SetDescriptor@CInfo@@QAEJPAU_DMUS_OBJECTDESC@@@Z ; CInfo::SetDescriptor

; 2776 : }

  000b3	5d		 pop	 ebp
  000b4	c2 08 00	 ret	 8
?SetDescriptor@CAudioPathConfig@@UAGJPAU_DMUS_OBJECTDESC@@@Z ENDP ; CAudioPathConfig::SetDescriptor
_TEXT	ENDS
PUBLIC	??_C@_0BO@LHMABAKO@?$CFs?3?5Invalid?5pointer?5pIStream?6?$AA@ ; `string'
EXTRN	?ParseDescriptor@CInfo@@QAEJPAUIStream@@PAU_DMUS_OBJECTDESC@@KABU_GUID@@@Z:NEAR ; CInfo::ParseDescriptor
EXTRN	_IsBadCodePtr@4:NEAR
;	COMDAT ?__szValidateInterfaceName@?1??ParseDescriptor@CAudioPathConfig@@UAGJPAUIStream@@PAU_DMUS_OBJECTDESC@@@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??ParseDescriptor@CAudioPathConfig@@UAGJPAUIStream@@PAU_DMUS_OBJECTDESC@@@Z@4QBDB DB 'C'
	DB	'AudioPathConfig::ParseDescriptor', 00H	; `CAudioPathConfig::ParseDescriptor'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0BO@LHMABAKO@?$CFs?3?5Invalid?5pointer?5pIStream?6?$AA@
CONST	SEGMENT
??_C@_0BO@LHMABAKO@?$CFs?3?5Invalid?5pointer?5pIStream?6?$AA@ DB '%s: Inv'
	DB	'alid pointer pIStream', 0aH, 00H		; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?ParseDescriptor@CAudioPathConfig@@UAGJPAUIStream@@PAU_DMUS_OBJECTDESC@@@Z
_TEXT	SEGMENT
_this$ = 8
_pIStream$ = 12
_pDesc$ = 16
?ParseDescriptor@CAudioPathConfig@@UAGJPAUIStream@@PAU_DMUS_OBJECTDESC@@@Z PROC NEAR ; CAudioPathConfig::ParseDescriptor, COMDAT

; 2780 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2781 :     V_INAME(CAudioPathConfig::ParseDescriptor);
; 2782 :     V_INTERFACE(pIStream);

  00003	6a 04		 push	 4
  00005	8b 45 0c	 mov	 eax, DWORD PTR _pIStream$[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  0000e	85 c0		 test	 eax, eax
  00010	74 19		 je	 SHORT $L70736
  00012	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??ParseDescriptor@CAudioPathConfig@@UAGJPAUIStream@@PAU_DMUS_OBJECTDESC@@@Z@4QBDB
  00017	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@LHMABAKO@?$CFs?3?5Invalid?5pointer?5pIStream?6?$AA@
  0001c	6a ff		 push	 -1
  0001e	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH
  00026	e8 00 00 00 00	 call	 _DebugBreak@0
$L70736:
  0002b	6a 04		 push	 4
  0002d	8b 4d 0c	 mov	 ecx, DWORD PTR _pIStream$[ebp]
  00030	8b 11		 mov	 edx, DWORD PTR [ecx]
  00032	52		 push	 edx
  00033	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  00038	85 c0		 test	 eax, eax
  0003a	74 19		 je	 SHORT $L70739
  0003c	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??ParseDescriptor@CAudioPathConfig@@UAGJPAUIStream@@PAU_DMUS_OBJECTDESC@@@Z@4QBDB
  00041	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@LHMABAKO@?$CFs?3?5Invalid?5pointer?5pIStream?6?$AA@
  00046	6a ff		 push	 -1
  00048	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0004d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00050	e8 00 00 00 00	 call	 _DebugBreak@0
$L70739:
  00055	8b 45 0c	 mov	 eax, DWORD PTR _pIStream$[ebp]
  00058	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005c	52		 push	 edx
  0005d	e8 00 00 00 00	 call	 _IsBadCodePtr@4
  00062	85 c0		 test	 eax, eax
  00064	74 19		 je	 SHORT $L70741
  00066	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??ParseDescriptor@CAudioPathConfig@@UAGJPAUIStream@@PAU_DMUS_OBJECTDESC@@@Z@4QBDB
  0006b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@LHMABAKO@?$CFs?3?5Invalid?5pointer?5pIStream?6?$AA@
  00070	6a ff		 push	 -1
  00072	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00077	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007a	e8 00 00 00 00	 call	 _DebugBreak@0
$L70741:

; 2783 :     V_STRUCTPTR_WRITE(pDesc, DMUS_OBJECTDESC);

  0007f	33 c0		 xor	 eax, eax
  00081	85 c0		 test	 eax, eax
  00083	74 23		 je	 SHORT $L70744
  00085	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CH@DNOFJOKI@offsetof?$CIDMUS_OBJECTDESC?0?5dwSize@
  0008a	68 df 0a 00 00	 push	 2783			; 00000adfH
  0008f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@JGOKDJAP@c?3?2xbox?2private?2windows?2directx?2@
  00094	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0L@JDNNJMNO@?$CFs?$EA?$CFs?3?5?$CFs?6?$AA@
  00099	6a ff		 push	 -1
  0009b	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  000a0	83 c4 14	 add	 esp, 20			; 00000014H
  000a3	e8 00 00 00 00	 call	 _DebugBreak@0
$L70744:
  000a8	6a 04		 push	 4
  000aa	8b 4d 10	 mov	 ecx, DWORD PTR _pDesc$[ebp]
  000ad	51		 push	 ecx
  000ae	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  000b3	85 c0		 test	 eax, eax
  000b5	74 19		 je	 SHORT $L70746
  000b7	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??ParseDescriptor@CAudioPathConfig@@UAGJPAUIStream@@PAU_DMUS_OBJECTDESC@@@Z@4QBDB
  000bc	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EH@OOGGANMB@?$CFs?3?5pDesc?5does?5not?5point?5to?5as?5m@
  000c1	6a ff		 push	 -1
  000c3	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  000c8	83 c4 0c	 add	 esp, 12			; 0000000cH
  000cb	e8 00 00 00 00	 call	 _DebugBreak@0
$L70746:
  000d0	8b 55 10	 mov	 edx, DWORD PTR _pDesc$[ebp]
  000d3	81 3a 50 03 00
	00		 cmp	 DWORD PTR [edx], 848	; 00000350H
  000d9	73 19		 jae	 SHORT $L70748
  000db	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??ParseDescriptor@CAudioPathConfig@@UAGJPAUIStream@@PAU_DMUS_OBJECTDESC@@@Z@4QBDB
  000e0	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@DAJLLPMH@?$CFs?3?5pDesc?9?$DOdwSize?5is?5too?5small?6?$AA@
  000e5	6a ff		 push	 -1
  000e7	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  000ec	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ef	e8 00 00 00 00	 call	 _DebugBreak@0
$L70748:
  000f4	8b 45 10	 mov	 eax, DWORD PTR _pDesc$[ebp]
  000f7	8b 08		 mov	 ecx, DWORD PTR [eax]
  000f9	51		 push	 ecx
  000fa	8b 55 10	 mov	 edx, DWORD PTR _pDesc$[ebp]
  000fd	52		 push	 edx
  000fe	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  00103	85 c0		 test	 eax, eax
  00105	74 19		 je	 SHORT $L70749
  00107	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??ParseDescriptor@CAudioPathConfig@@UAGJPAUIStream@@PAU_DMUS_OBJECTDESC@@@Z@4QBDB
  0010c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EH@OOGGANMB@?$CFs?3?5pDesc?5does?5not?5point?5to?5as?5m@
  00111	6a ff		 push	 -1
  00113	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00118	83 c4 0c	 add	 esp, 12			; 0000000cH
  0011b	e8 00 00 00 00	 call	 _DebugBreak@0
$L70749:

; 2784 : 
; 2785 :     return m_Info.ParseDescriptor(pIStream,pDesc,DMUS_FOURCC_AUDIOPATH_FORM,CLSID_DirectMusicAudioPathConfig);

  00120	68 00 00 00 00	 push	 OFFSET FLAT:_CLSID_DirectMusicAudioPathConfig
  00125	68 44 4d 41 50	 push	 1346456900		; 50414d44H
  0012a	8b 45 10	 mov	 eax, DWORD PTR _pDesc$[ebp]
  0012d	50		 push	 eax
  0012e	8b 4d 0c	 mov	 ecx, DWORD PTR _pIStream$[ebp]
  00131	51		 push	 ecx
  00132	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00135	83 c1 38	 add	 ecx, 56			; 00000038H
  00138	e8 00 00 00 00	 call	 ?ParseDescriptor@CInfo@@QAEJPAUIStream@@PAU_DMUS_OBJECTDESC@@KABU_GUID@@@Z ; CInfo::ParseDescriptor

; 2786 : }

  0013d	5d		 pop	 ebp
  0013e	c2 0c 00	 ret	 12			; 0000000cH
?ParseDescriptor@CAudioPathConfig@@UAGJPAUIStream@@PAU_DMUS_OBJECTDESC@@@Z ENDP ; CAudioPathConfig::ParseDescriptor
_TEXT	ENDS
PUBLIC	??_C@_0BO@DNADCDLB@?$CFs?3?5Invalid?5pointer?5pClassID?6?$AA@ ; `string'
;	COMDAT ?__szValidateInterfaceName@?1??GetClassID@CAudioPathConfig@@UAGJPAU_GUID@@@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??GetClassID@CAudioPathConfig@@UAGJPAU_GUID@@@Z@4QBDB DB 'C'
	DB	'AudioPathConfig::GetClassID', 00H		; `CAudioPathConfig::GetClassID'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0BO@DNADCDLB@?$CFs?3?5Invalid?5pointer?5pClassID?6?$AA@
CONST	SEGMENT
??_C@_0BO@DNADCDLB@?$CFs?3?5Invalid?5pointer?5pClassID?6?$AA@ DB '%s: Inv'
	DB	'alid pointer pClassID', 0aH, 00H		; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?GetClassID@CAudioPathConfig@@UAGJPAU_GUID@@@Z
_TEXT	SEGMENT
_this$ = 8
_pClassID$ = 12
?GetClassID@CAudioPathConfig@@UAGJPAU_GUID@@@Z PROC NEAR ; CAudioPathConfig::GetClassID, COMDAT

; 2792 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2793 :     V_INAME(CAudioPathConfig::GetClassID);
; 2794 :     V_PTR_WRITE(pClassID, CLSID); 

  00003	6a 10		 push	 16			; 00000010H
  00005	8b 45 0c	 mov	 eax, DWORD PTR _pClassID$[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  0000e	85 c0		 test	 eax, eax
  00010	74 19		 je	 SHORT $L70765
  00012	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??GetClassID@CAudioPathConfig@@UAGJPAU_GUID@@@Z@4QBDB
  00017	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@DNADCDLB@?$CFs?3?5Invalid?5pointer?5pClassID?6?$AA@
  0001c	6a ff		 push	 -1
  0001e	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH
  00026	e8 00 00 00 00	 call	 _DebugBreak@0
$L70765:

; 2795 :     *pClassID = CLSID_DirectMusicAudioPathConfig;

  0002b	8b 4d 0c	 mov	 ecx, DWORD PTR _pClassID$[ebp]
  0002e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _CLSID_DirectMusicAudioPathConfig
  00034	89 11		 mov	 DWORD PTR [ecx], edx
  00036	a1 04 00 00 00	 mov	 eax, DWORD PTR _CLSID_DirectMusicAudioPathConfig+4
  0003b	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0003e	8b 15 08 00 00
	00		 mov	 edx, DWORD PTR _CLSID_DirectMusicAudioPathConfig+8
  00044	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00047	a1 0c 00 00 00	 mov	 eax, DWORD PTR _CLSID_DirectMusicAudioPathConfig+12
  0004c	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 2796 :     return S_OK;

  0004f	33 c0		 xor	 eax, eax

; 2797 : }

  00051	5d		 pop	 ebp
  00052	c2 08 00	 ret	 8
?GetClassID@CAudioPathConfig@@UAGJPAU_GUID@@@Z ENDP	; CAudioPathConfig::GetClassID
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?IsDirty@CAudioPathConfig@@UAGJXZ
_TEXT	SEGMENT
_this$ = 8
?IsDirty@CAudioPathConfig@@UAGJXZ PROC NEAR		; CAudioPathConfig::IsDirty, COMDAT

; 2803 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2804 :     return S_FALSE;

  00003	b8 01 00 00 00	 mov	 eax, 1

; 2805 : }

  00008	5d		 pop	 ebp
  00009	c2 04 00	 ret	 4
?IsDirty@CAudioPathConfig@@UAGJXZ ENDP			; CAudioPathConfig::IsDirty
_TEXT	ENDS
PUBLIC	??_C@_0DN@BMALPPLF@Error?3?5Failed?5parsing?5?9?5file?5is?5@ ; `string'
PUBLIC	?Load@CAudioPathConfig@@QAEJPAVCRiffParser@@@Z	; CAudioPathConfig::Load
EXTRN	??0CRiffParser@@QAE@PAUIStream@@@Z:NEAR		; CRiffParser::CRiffParser
;	COMDAT ?__szValidateInterfaceName@?1??Load@CAudioPathConfig@@UAGJPAUIStream@@@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??Load@CAudioPathConfig@@UAGJPAUIStream@@@Z@4QBDB DB 'I'
	DB	'PersistStream::Load', 00H			; `CAudioPathConfig::Load'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0DN@BMALPPLF@Error?3?5Failed?5parsing?5?9?5file?5is?5@
CONST	SEGMENT
??_C@_0DN@BMALPPLF@Error?3?5Failed?5parsing?5?9?5file?5is?5@ DB 'Error: F'
	DB	'ailed parsing - file is not AudioPathConfig format.', 0aH, 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?Load@CAudioPathConfig@@UAGJPAUIStream@@@Z
_TEXT	SEGMENT
_hr$ = -68
_Parser$ = -64
_ckMain$ = -32
_this$ = 8
_pIStream$ = 12
?Load@CAudioPathConfig@@UAGJPAUIStream@@@Z PROC NEAR	; CAudioPathConfig::Load, COMDAT

; 2808 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H

; 2809 :     V_INAME(IPersistStream::Load);
; 2810 :     V_INTERFACE(pIStream);

  00006	6a 04		 push	 4
  00008	8b 45 0c	 mov	 eax, DWORD PTR _pIStream$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  00011	85 c0		 test	 eax, eax
  00013	74 19		 je	 SHORT $L70779
  00015	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??Load@CAudioPathConfig@@UAGJPAUIStream@@@Z@4QBDB
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@LHMABAKO@?$CFs?3?5Invalid?5pointer?5pIStream?6?$AA@
  0001f	6a ff		 push	 -1
  00021	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH
  00029	e8 00 00 00 00	 call	 _DebugBreak@0
$L70779:
  0002e	6a 04		 push	 4
  00030	8b 4d 0c	 mov	 ecx, DWORD PTR _pIStream$[ebp]
  00033	8b 11		 mov	 edx, DWORD PTR [ecx]
  00035	52		 push	 edx
  00036	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  0003b	85 c0		 test	 eax, eax
  0003d	74 19		 je	 SHORT $L70782
  0003f	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??Load@CAudioPathConfig@@UAGJPAUIStream@@@Z@4QBDB
  00044	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@LHMABAKO@?$CFs?3?5Invalid?5pointer?5pIStream?6?$AA@
  00049	6a ff		 push	 -1
  0004b	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00050	83 c4 0c	 add	 esp, 12			; 0000000cH
  00053	e8 00 00 00 00	 call	 _DebugBreak@0
$L70782:
  00058	8b 45 0c	 mov	 eax, DWORD PTR _pIStream$[ebp]
  0005b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005f	52		 push	 edx
  00060	e8 00 00 00 00	 call	 _IsBadCodePtr@4
  00065	85 c0		 test	 eax, eax
  00067	74 19		 je	 SHORT $L70784
  00069	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??Load@CAudioPathConfig@@UAGJPAUIStream@@@Z@4QBDB
  0006e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@LHMABAKO@?$CFs?3?5Invalid?5pointer?5pIStream?6?$AA@
  00073	6a ff		 push	 -1
  00075	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0007a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007d	e8 00 00 00 00	 call	 _DebugBreak@0
$L70784:

; 2811 : 
; 2812 :     CRiffParser Parser(pIStream);

  00082	8b 45 0c	 mov	 eax, DWORD PTR _pIStream$[ebp]
  00085	50		 push	 eax
  00086	8d 4d c0	 lea	 ecx, DWORD PTR _Parser$[ebp]
  00089	e8 00 00 00 00	 call	 ??0CRiffParser@@QAE@PAUIStream@@@Z ; CRiffParser::CRiffParser

; 2813 :     RIFFIO ckMain;
; 2814 :     HRESULT hr = S_OK;

  0008e	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 2815 : 
; 2816 :     Parser.EnterList(&ckMain);  

  00095	8d 4d e0	 lea	 ecx, DWORD PTR _ckMain$[ebp]
  00098	51		 push	 ecx
  00099	8d 4d c0	 lea	 ecx, DWORD PTR _Parser$[ebp]
  0009c	e8 00 00 00 00	 call	 ?EnterList@CRiffParser@@QAEXPAU_RIFFIO@@@Z ; CRiffParser::EnterList

; 2817 :     if (Parser.NextChunk(&hr) && (ckMain.fccType == DMUS_FOURCC_AUDIOPATH_FORM))

  000a1	8d 55 bc	 lea	 edx, DWORD PTR _hr$[ebp]
  000a4	52		 push	 edx
  000a5	8d 4d c0	 lea	 ecx, DWORD PTR _Parser$[ebp]
  000a8	e8 00 00 00 00	 call	 ?NextChunk@CRiffParser@@QAEHPAJ@Z ; CRiffParser::NextChunk
  000ad	85 c0		 test	 eax, eax
  000af	74 65		 je	 SHORT $L70797
  000b1	81 7d e8 44 4d
	41 50		 cmp	 DWORD PTR _ckMain$[ebp+8], 1346456900 ; 50414d44H
  000b8	75 5c		 jne	 SHORT $L70797

; 2818 :     {
; 2819 :         ENTER_CRITICAL_SECTION(&m_CriticalSection);

  000ba	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  000bd	83 c0 1c	 add	 eax, 28			; 0000001cH
  000c0	50		 push	 eax
  000c1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 2820 :         // Clear out any data that was previously loaded.
; 2821 :         if (m_pGraph)

  000c7	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000ca	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  000ce	74 12		 je	 SHORT $L70798

; 2822 :         {
; 2823 :             m_pGraph->Release();

  000d0	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  000d3	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  000d6	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000d9	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  000dc	8b 00		 mov	 eax, DWORD PTR [eax]
  000de	52		 push	 edx
  000df	ff 50 08	 call	 DWORD PTR [eax+8]
$L70798:

; 2824 :         }
; 2825 :         m_PortConfigList.Clear();

  000e2	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000e5	83 c1 14	 add	 ecx, 20			; 00000014H
  000e8	e8 00 00 00 00	 call	 ?Clear@CPortConfigList@@QAEXXZ ; CPortConfigList::Clear

; 2826 :         m_BufferConfigList.Clear();        

  000ed	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000f0	83 c1 18	 add	 ecx, 24			; 00000018H
  000f3	e8 00 00 00 00	 call	 ?Clear@CBufferConfigList@@QAEXXZ ; CBufferConfigList::Clear

; 2827 :         hr = Load(&Parser);

  000f8	8d 4d c0	 lea	 ecx, DWORD PTR _Parser$[ebp]
  000fb	51		 push	 ecx
  000fc	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000ff	e8 00 00 00 00	 call	 ?Load@CAudioPathConfig@@QAEJPAVCRiffParser@@@Z ; CAudioPathConfig::Load
  00104	89 45 bc	 mov	 DWORD PTR _hr$[ebp], eax

; 2828 :         LEAVE_CRITICAL_SECTION(&m_CriticalSection);

  00107	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0010a	83 c2 1c	 add	 edx, 28			; 0000001cH
  0010d	52		 push	 edx
  0010e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 2829 :     }
; 2830 :     else

  00114	eb 16		 jmp	 SHORT $L70799
$L70797:

; 2831 :     {
; 2832 :         Trace(1,"Error: Failed parsing - file is not AudioPathConfig format.\n");

  00116	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DN@BMALPPLF@Error?3?5Failed?5parsing?5?9?5file?5is?5@
  0011b	6a 01		 push	 1
  0011d	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00122	83 c4 08	 add	 esp, 8

; 2833 :         hr = DMUS_E_DESCEND_CHUNK_FAIL;

  00125	c7 45 bc 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
$L70799:

; 2834 :     }
; 2835 :     return hr;

  0012c	8b 45 bc	 mov	 eax, DWORD PTR _hr$[ebp]

; 2836 : }

  0012f	8b e5		 mov	 esp, ebp
  00131	5d		 pop	 ebp
  00132	c2 08 00	 ret	 8
?Load@CAudioPathConfig@@UAGJPAUIStream@@@Z ENDP		; CAudioPathConfig::Load
_TEXT	ENDS
PUBLIC	??_C@_0DG@BIDDMOBM@Error?3?5AudioPath?5Configuration?5f@ ; `string'
EXTRN	?ReadChunk@CInfo@@QAEJPAVCRiffParser@@K@Z:NEAR	; CInfo::ReadChunk
EXTRN	?Load@CGraph@@QAEJPAVCRiffParser@@@Z:NEAR	; CGraph::Load
;	COMDAT ??_C@_0DG@BIDDMOBM@Error?3?5AudioPath?5Configuration?5f@
CONST	SEGMENT
??_C@_0DG@BIDDMOBM@Error?3?5AudioPath?5Configuration?5f@ DB 'Error: Audio'
	DB	'Path Configuration failed loading buffer', 0aH, 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?Load@CAudioPathConfig@@QAEJPAVCRiffParser@@@Z
_TEXT	SEGMENT
tv222 = -160
tv216 = -156
tv197 = -152
tv187 = -148
tv154 = -144
tv146 = -140
tv129 = -136
tv90 = -132
tv78 = -128
tv72 = -124
_this$ = -120
$T71931 = -116
$T71928 = -112
$T71927 = -108
$T71924 = -104
$T71921 = -100
$T71920 = -96
$T71916 = -92
$T71913 = -88
_pGraph$71017 = -84
_pSource$70997 = -80
_pSource$70923 = -76
_pConfig$70906 = -72
_hr$ = -68
_ckNext$ = -64
_ckChild$ = -32
_pParser$ = 8
?Load@CAudioPathConfig@@QAEJPAVCRiffParser@@@Z PROC NEAR ; CAudioPathConfig::Load, COMDAT
; _this$ = ecx

; 2840 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a0 00 00
	00		 sub	 esp, 160		; 000000a0H
  00009	89 4d 88	 mov	 DWORD PTR _this$[ebp], ecx

; 2841 :     RIFFIO ckNext, ckChild;
; 2842 :     HRESULT hr = S_OK;

  0000c	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 2843 : 
; 2844 :     ENTER_CRITICAL_SECTION(&m_CriticalSection);

  00013	8b 45 88	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 c0 1c	 add	 eax, 28			; 0000001cH
  00019	50		 push	 eax
  0001a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 2845 : 
; 2846 :     pParser->EnterList(&ckNext);

  00020	8d 4d c0	 lea	 ecx, DWORD PTR _ckNext$[ebp]
  00023	51		 push	 ecx
  00024	8b 4d 08	 mov	 ecx, DWORD PTR _pParser$[ebp]
  00027	e8 00 00 00 00	 call	 ?EnterList@CRiffParser@@QAEXPAU_RIFFIO@@@Z ; CRiffParser::EnterList
$L70811:

; 2847 :     while(pParser->NextChunk(&hr))

  0002c	8d 55 bc	 lea	 edx, DWORD PTR _hr$[ebp]
  0002f	52		 push	 edx
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _pParser$[ebp]
  00033	e8 00 00 00 00	 call	 ?NextChunk@CRiffParser@@QAEHPAJ@Z ; CRiffParser::NextChunk
  00038	85 c0		 test	 eax, eax
  0003a	0f 84 45 04 00
	00		 je	 $L70812

; 2848 :     {
; 2849 :         switch(ckNext.ckid)
; 2850 :         {

  00040	8b 45 c0	 mov	 eax, DWORD PTR _ckNext$[ebp]
  00043	89 45 84	 mov	 DWORD PTR tv72[ebp], eax
  00046	81 7d 84 64 61
	74 65		 cmp	 DWORD PTR tv72[ebp], 1702125924 ; 65746164H
  0004d	77 20		 ja	 SHORT $L71935
  0004f	81 7d 84 64 61
	74 65		 cmp	 DWORD PTR tv72[ebp], 1702125924 ; 65746164H
  00056	74 2e		 je	 SHORT $L70825
  00058	81 7d 84 4c 49
	53 54		 cmp	 DWORD PTR tv72[ebp], 1414744396 ; 5453494cH
  0005f	74 40		 je	 SHORT $L70858
  00061	81 7d 84 67 75
	69 64		 cmp	 DWORD PTR tv72[ebp], 1684632935 ; 64697567H
  00068	74 1c		 je	 SHORT $L70825
  0006a	e9 11 04 00 00	 jmp	 $L70814
$L71935:
  0006f	81 7d 84 63 61
	74 67		 cmp	 DWORD PTR tv72[ebp], 1735680355 ; 67746163H
  00076	74 0e		 je	 SHORT $L70825
  00078	81 7d 84 76 65
	72 73		 cmp	 DWORD PTR tv72[ebp], 1936876918 ; 73726576H
  0007f	74 05		 je	 SHORT $L70825
  00081	e9 fa 03 00 00	 jmp	 $L70814
$L70825:

; 2851 :         case DMUS_FOURCC_GUID_CHUNK:
; 2852 :         case DMUS_FOURCC_VERSION_CHUNK:
; 2853 :         case DMUS_FOURCC_CATEGORY_CHUNK:
; 2854 :         case DMUS_FOURCC_DATE_CHUNK:
; 2855 :             hr = m_Info.ReadChunk(pParser,ckNext.ckid);

  00086	8b 4d c0	 mov	 ecx, DWORD PTR _ckNext$[ebp]
  00089	51		 push	 ecx
  0008a	8b 55 08	 mov	 edx, DWORD PTR _pParser$[ebp]
  0008d	52		 push	 edx
  0008e	8b 4d 88	 mov	 ecx, DWORD PTR _this$[ebp]
  00091	83 c1 3c	 add	 ecx, 60			; 0000003cH
  00094	e8 00 00 00 00	 call	 ?ReadChunk@CInfo@@QAEJPAVCRiffParser@@K@Z ; CInfo::ReadChunk
  00099	89 45 bc	 mov	 DWORD PTR _hr$[ebp], eax

; 2856 : 			break;

  0009c	e9 df 03 00 00	 jmp	 $L70814
$L70858:

; 2857 : 		case FOURCC_LIST:
; 2858 : 			switch(ckNext.fccType)
; 2859 : 			{

  000a1	8b 45 c8	 mov	 eax, DWORD PTR _ckNext$[ebp+8]
  000a4	89 45 80	 mov	 DWORD PTR tv78[ebp], eax
  000a7	81 7d 80 55 4e
	46 4f		 cmp	 DWORD PTR tv78[ebp], 1330007637 ; 4f464e55H
  000ae	77 28		 ja	 SHORT $L71934
  000b0	81 7d 80 55 4e
	46 4f		 cmp	 DWORD PTR tv78[ebp], 1330007637 ; 4f464e55H
  000b7	74 3a		 je	 SHORT $L70871
  000b9	81 7d 80 44 53
	42 43		 cmp	 DWORD PTR tv78[ebp], 1128420164 ; 43425344H
  000c0	0f 84 7e 02 00
	00		 je	 $L70996
  000c6	81 7d 80 44 4d
	54 47		 cmp	 DWORD PTR tv78[ebp], 1196707140 ; 47544d44H
  000cd	0f 84 32 03 00
	00		 je	 $L71016
  000d3	e9 a8 03 00 00	 jmp	 $L70814
$L71934:
  000d8	81 7d 80 64 62
	66 6c		 cmp	 DWORD PTR tv78[ebp], 1818649188 ; 6c666264H
  000df	0f 84 e4 00 00
	00		 je	 $L70922
  000e5	81 7d 80 70 63
	73 6c		 cmp	 DWORD PTR tv78[ebp], 1819501424 ; 6c736370H
  000ec	74 20		 je	 SHORT $L70880
  000ee	e9 8d 03 00 00	 jmp	 $L70814
$L70871:

; 2860 :                 case DMUS_FOURCC_UNFO_LIST:
; 2861 :                     hr = m_Info.ReadChunk(pParser,ckNext.fccType);

  000f3	8b 4d c8	 mov	 ecx, DWORD PTR _ckNext$[ebp+8]
  000f6	51		 push	 ecx
  000f7	8b 55 08	 mov	 edx, DWORD PTR _pParser$[ebp]
  000fa	52		 push	 edx
  000fb	8b 4d 88	 mov	 ecx, DWORD PTR _this$[ebp]
  000fe	83 c1 3c	 add	 ecx, 60			; 0000003cH
  00101	e8 00 00 00 00	 call	 ?ReadChunk@CInfo@@QAEJPAVCRiffParser@@K@Z ; CInfo::ReadChunk
  00106	89 45 bc	 mov	 DWORD PTR _hr$[ebp], eax

; 2862 : 					break;

  00109	e9 72 03 00 00	 jmp	 $L70814
$L70880:

; 2863 :                 case DMUS_FOURCC_PORTCONFIGS_LIST:
; 2864 :                     pParser->EnterList(&ckChild);

  0010e	8d 45 e0	 lea	 eax, DWORD PTR _ckChild$[ebp]
  00111	50		 push	 eax
  00112	8b 4d 08	 mov	 ecx, DWORD PTR _pParser$[ebp]
  00115	e8 00 00 00 00	 call	 ?EnterList@CRiffParser@@QAEXPAU_RIFFIO@@@Z ; CRiffParser::EnterList
$L70882:

; 2865 :                     while (pParser->NextChunk(&hr))

  0011a	8d 4d bc	 lea	 ecx, DWORD PTR _hr$[ebp]
  0011d	51		 push	 ecx
  0011e	8b 4d 08	 mov	 ecx, DWORD PTR _pParser$[ebp]
  00121	e8 00 00 00 00	 call	 ?NextChunk@CRiffParser@@QAEHPAJ@Z ; CRiffParser::NextChunk
  00126	85 c0		 test	 eax, eax
  00128	0f 84 8e 00 00
	00		 je	 $L70883

; 2866 :                     {
; 2867 :                         switch( ckChild.ckid )
; 2868 :                         {

  0012e	8b 55 e0	 mov	 edx, DWORD PTR _ckChild$[ebp]
  00131	89 95 7c ff ff
	ff		 mov	 DWORD PTR tv90[ebp], edx
  00137	81 bd 7c ff ff
	ff 4c 49 53 54	 cmp	 DWORD PTR tv90[ebp], 1414744396 ; 5453494cH
  00141	74 02		 je	 SHORT $L70896
  00143	eb 72		 jmp	 SHORT $L70885
$L70896:

; 2869 :                         case FOURCC_LIST:
; 2870 :                             if (ckChild.fccType == DMUS_FOURCC_PORTCONFIG_LIST)

  00145	81 7d e8 70 63
	66 6c		 cmp	 DWORD PTR _ckChild$[ebp+8], 1818649456 ; 6c666370H
  0014c	75 69		 jne	 SHORT $L70885

; 2871 :                             {
; 2872 :                                 CPortConfig *pConfig = new CPortConfig();

  0014e	6a 5c		 push	 92			; 0000005cH
  00150	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00155	83 c4 04	 add	 esp, 4
  00158	89 45 a8	 mov	 DWORD PTR $T71913[ebp], eax
  0015b	83 7d a8 00	 cmp	 DWORD PTR $T71913[ebp], 0
  0015f	74 10		 je	 SHORT $L71914
  00161	8b 4d a8	 mov	 ecx, DWORD PTR $T71913[ebp]
  00164	e8 00 00 00 00	 call	 ??0CPortConfig@@QAE@XZ	; CPortConfig::CPortConfig
  00169	89 85 78 ff ff
	ff		 mov	 DWORD PTR tv129[ebp], eax
  0016f	eb 0a		 jmp	 SHORT $L71915
$L71914:
  00171	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv129[ebp], 0
$L71915:
  0017b	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR tv129[ebp]
  00181	89 45 b8	 mov	 DWORD PTR _pConfig$70906[ebp], eax

; 2873 :                                 if (pConfig) 

  00184	83 7d b8 00	 cmp	 DWORD PTR _pConfig$70906[ebp], 0
  00188	74 26		 je	 SHORT $L70909

; 2874 :                                 {
; 2875 :                                     hr = pConfig->Load(pParser);

  0018a	8b 4d 08	 mov	 ecx, DWORD PTR _pParser$[ebp]
  0018d	51		 push	 ecx
  0018e	8b 4d b8	 mov	 ecx, DWORD PTR _pConfig$70906[ebp]
  00191	e8 00 00 00 00	 call	 ?Load@CPortConfig@@QAEJPAVCRiffParser@@@Z ; CPortConfig::Load
  00196	89 45 bc	 mov	 DWORD PTR _hr$[ebp], eax

; 2876 :                                     if (SUCCEEDED(hr))

  00199	83 7d bc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0019d	7c 0f		 jl	 SHORT $L70911

; 2877 :                                     {
; 2878 :                                         m_PortConfigList.AddTail(pConfig);

  0019f	8b 55 b8	 mov	 edx, DWORD PTR _pConfig$70906[ebp]
  001a2	52		 push	 edx
  001a3	8b 4d 88	 mov	 ecx, DWORD PTR _this$[ebp]
  001a6	83 c1 14	 add	 ecx, 20			; 00000014H
  001a9	e8 00 00 00 00	 call	 ?AddTail@CPortConfigList@@QAEXPAVCPortConfig@@@Z ; CPortConfigList::AddTail
$L70911:

; 2879 :                                     }
; 2880 :                                 }
; 2881 :                                 else

  001ae	eb 07		 jmp	 SHORT $L70885
$L70909:

; 2882 :                                 {
; 2883 :                                     hr = E_OUTOFMEMORY;

  001b0	c7 45 bc 0e 00
	07 80		 mov	 DWORD PTR _hr$[ebp], -2147024882 ; 8007000eH
$L70885:

; 2884 :                                 }
; 2885 :                             }
; 2886 :                             break;
; 2887 :                         }
; 2888 :                     }

  001b7	e9 5e ff ff ff	 jmp	 $L70882
$L70883:

; 2889 :                     pParser->LeaveList();

  001bc	8b 4d 08	 mov	 ecx, DWORD PTR _pParser$[ebp]
  001bf	e8 00 00 00 00	 call	 ?LeaveList@CRiffParser@@QAEXXZ ; CRiffParser::LeaveList

; 2890 :                     break;

  001c4	e9 b7 02 00 00	 jmp	 $L70814
$L70922:

; 2891 :                 case DMUS_FOURCC_DSBUFFER_LIST:
; 2892 :                     {
; 2893 :                         CBufferConfig *pSource = new CBufferConfig(0);

  001c9	6a 30		 push	 48			; 00000030H
  001cb	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  001d0	83 c4 04	 add	 esp, 4
  001d3	89 45 a4	 mov	 DWORD PTR $T71916[ebp], eax
  001d6	83 7d a4 00	 cmp	 DWORD PTR $T71916[ebp], 0
  001da	74 12		 je	 SHORT $L71917
  001dc	6a 00		 push	 0
  001de	8b 4d a4	 mov	 ecx, DWORD PTR $T71916[ebp]
  001e1	e8 00 00 00 00	 call	 ??0CBufferConfig@@QAE@K@Z ; CBufferConfig::CBufferConfig
  001e6	89 85 74 ff ff
	ff		 mov	 DWORD PTR tv146[ebp], eax
  001ec	eb 0a		 jmp	 SHORT $L71918
$L71917:
  001ee	c7 85 74 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv146[ebp], 0
$L71918:
  001f8	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR tv146[ebp]
  001fe	89 45 b4	 mov	 DWORD PTR _pSource$70923[ebp], eax

; 2894 :                         if (pSource)

  00201	83 7d b4 00	 cmp	 DWORD PTR _pSource$70923[ebp], 0
  00205	0f 84 2d 01 00
	00		 je	 $L70926

; 2895 :                         {
; 2896 :                             pParser->EnterList(&ckChild);

  0020b	8d 4d e0	 lea	 ecx, DWORD PTR _ckChild$[ebp]
  0020e	51		 push	 ecx
  0020f	8b 4d 08	 mov	 ecx, DWORD PTR _pParser$[ebp]
  00212	e8 00 00 00 00	 call	 ?EnterList@CRiffParser@@QAEXPAU_RIFFIO@@@Z ; CRiffParser::EnterList
$L70928:

; 2897 :                             while (pParser->NextChunk(&hr))

  00217	8d 55 bc	 lea	 edx, DWORD PTR _hr$[ebp]
  0021a	52		 push	 edx
  0021b	8b 4d 08	 mov	 ecx, DWORD PTR _pParser$[ebp]
  0021e	e8 00 00 00 00	 call	 ?NextChunk@CRiffParser@@QAEHPAJ@Z ; CRiffParser::NextChunk
  00223	85 c0		 test	 eax, eax
  00225	0f 84 af 00 00
	00		 je	 $L70929

; 2898 :                             {
; 2899 :                                 switch( ckChild.ckid )
; 2900 :                                 {

  0022b	8b 45 e0	 mov	 eax, DWORD PTR _ckChild$[ebp]
  0022e	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv154[ebp], eax
  00234	81 bd 70 ff ff
	ff 64 64 61 68	 cmp	 DWORD PTR tv154[ebp], 1751213156 ; 68616464H
  0023e	77 26		 ja	 SHORT $L71919
  00240	81 bd 70 ff ff
	ff 64 64 61 68	 cmp	 DWORD PTR tv154[ebp], 1751213156 ; 68616464H
  0024a	74 28		 je	 SHORT $L70942
  0024c	81 bd 70 ff ff
	ff 52 49 46 46	 cmp	 DWORD PTR tv154[ebp], 1179011410 ; 46464952H
  00256	74 50		 je	 SHORT $L70962
  00258	81 bd 70 ff ff
	ff 4c 49 53 54	 cmp	 DWORD PTR tv154[ebp], 1414744396 ; 5453494cH
  00262	74 44		 je	 SHORT $L70962
  00264	eb 6f		 jmp	 SHORT $L70931
$L71919:
  00266	81 bd 70 ff ff
	ff 6d 78 62 6e	 cmp	 DWORD PTR tv154[ebp], 1851947117 ; 6e62786dH
  00270	74 20		 je	 SHORT $L70952
  00272	eb 61		 jmp	 SHORT $L70931
$L70942:

; 2901 :                                 case DMUS_FOURCC_DSBUFFATTR_ITEM:
; 2902 :                                     hr = pParser->Read(&pSource->m_BufferHeader, 
; 2903 :                                         sizeof(DMUS_IO_BUFFER_ATTRIBUTES_HEADER));

  00274	6a 14		 push	 20			; 00000014H
  00276	8b 4d b4	 mov	 ecx, DWORD PTR _pSource$70923[ebp]
  00279	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0027c	51		 push	 ecx
  0027d	8b 4d 08	 mov	 ecx, DWORD PTR _pParser$[ebp]
  00280	e8 00 00 00 00	 call	 ?Read@CRiffParser@@QAEJPAXK@Z ; CRiffParser::Read
  00285	89 45 bc	 mov	 DWORD PTR _hr$[ebp], eax

; 2904 :                                     pSource->DecideType();

  00288	8b 4d b4	 mov	 ecx, DWORD PTR _pSource$70923[ebp]
  0028b	e8 00 00 00 00	 call	 ?DecideType@CBufferConfig@@QAEXXZ ; CBufferConfig::DecideType

; 2905 :                                     break;

  00290	eb 43		 jmp	 SHORT $L70931
$L70952:

; 2906 :                                 case DMUS_FOURCC_MIXBINS_ITEM:
; 2907 :                                     hr = pParser->Read(&pSource->m_MixBinsHeader, 
; 2908 :                                         sizeof(DMUS_IO_BUFFER_MIXBINS_HEADER));

  00292	6a 0c		 push	 12			; 0000000cH
  00294	8b 55 b4	 mov	 edx, DWORD PTR _pSource$70923[ebp]
  00297	83 c2 24	 add	 edx, 36			; 00000024H
  0029a	52		 push	 edx
  0029b	8b 4d 08	 mov	 ecx, DWORD PTR _pParser$[ebp]
  0029e	e8 00 00 00 00	 call	 ?Read@CRiffParser@@QAEJPAXK@Z ; CRiffParser::Read
  002a3	89 45 bc	 mov	 DWORD PTR _hr$[ebp], eax

; 2909 :                                     break;

  002a6	eb 2d		 jmp	 SHORT $L70931
$L70962:

; 2910 :                                 case FOURCC_LIST:
; 2911 :                                 case FOURCC_RIFF:
; 2912 :                                     if ( ckChild.fccType == DMUS_FOURCC_DSBC_FORM)

  002a8	81 7d e8 44 53
	42 43		 cmp	 DWORD PTR _ckChild$[ebp+8], 1128420164 ; 43425344H
  002af	75 24		 jne	 SHORT $L70931

; 2913 :                                     {
; 2914 :                                         pParser->SeekBack();

  002b1	8b 4d 08	 mov	 ecx, DWORD PTR _pParser$[ebp]
  002b4	e8 00 00 00 00	 call	 ?SeekBack@CRiffParser@@QAEJXZ ; CRiffParser::SeekBack

; 2915 :                                         hr = pSource->Load(pParser->GetStream());

  002b9	8b 4d 08	 mov	 ecx, DWORD PTR _pParser$[ebp]
  002bc	e8 00 00 00 00	 call	 ?GetStream@CRiffParser@@QAEPAUIStream@@XZ ; CRiffParser::GetStream
  002c1	50		 push	 eax
  002c2	8b 4d b4	 mov	 ecx, DWORD PTR _pSource$70923[ebp]
  002c5	e8 00 00 00 00	 call	 ?Load@CBufferConfig@@QAEJPAUIStream@@@Z ; CBufferConfig::Load
  002ca	89 45 bc	 mov	 DWORD PTR _hr$[ebp], eax

; 2916 :                                         pParser->SeekForward();

  002cd	8b 4d 08	 mov	 ecx, DWORD PTR _pParser$[ebp]
  002d0	e8 00 00 00 00	 call	 ?SeekForward@CRiffParser@@QAEJXZ ; CRiffParser::SeekForward
$L70931:

; 2917 :                                     }
; 2918 :                                 }
; 2919 :                             }

  002d5	e9 3d ff ff ff	 jmp	 $L70928
$L70929:

; 2920 :                             if (SUCCEEDED(hr))

  002da	83 7d bc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  002de	7c 11		 jl	 SHORT $L70981

; 2921 :                             {
; 2922 :                                 m_BufferConfigList.AddTail(pSource);

  002e0	8b 45 b4	 mov	 eax, DWORD PTR _pSource$70923[ebp]
  002e3	50		 push	 eax
  002e4	8b 4d 88	 mov	 ecx, DWORD PTR _this$[ebp]
  002e7	83 c1 18	 add	 ecx, 24			; 00000018H
  002ea	e8 00 00 00 00	 call	 ?AddTail@CBufferConfigList@@QAEXPAVCBufferConfig@@@Z ; CBufferConfigList::AddTail

; 2923 :                             }
; 2924 :                             else

  002ef	eb 3d		 jmp	 SHORT $L70982
$L70981:

; 2925 :                             {
; 2926 :                                 delete pSource;

  002f1	8b 4d b4	 mov	 ecx, DWORD PTR _pSource$70923[ebp]
  002f4	89 4d 9c	 mov	 DWORD PTR $T71921[ebp], ecx
  002f7	8b 55 9c	 mov	 edx, DWORD PTR $T71921[ebp]
  002fa	89 55 a0	 mov	 DWORD PTR $T71920[ebp], edx
  002fd	83 7d a0 00	 cmp	 DWORD PTR $T71920[ebp], 0
  00301	74 12		 je	 SHORT $L71922
  00303	6a 01		 push	 1
  00305	8b 4d a0	 mov	 ecx, DWORD PTR $T71920[ebp]
  00308	e8 00 00 00 00	 call	 ??_GCBufferConfig@@QAEPAXI@Z
  0030d	89 85 6c ff ff
	ff		 mov	 DWORD PTR tv187[ebp], eax
  00313	eb 0a		 jmp	 SHORT $L71923
$L71922:
  00315	c7 85 6c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv187[ebp], 0
$L71923:

; 2927 :                                 Trace(1,"Error: AudioPath Configuration failed loading buffer\n");

  0031f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DG@BIDDMOBM@Error?3?5AudioPath?5Configuration?5f@
  00324	6a 01		 push	 1
  00326	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0032b	83 c4 08	 add	 esp, 8
$L70982:

; 2928 :                             }
; 2929 :                             pParser->LeaveList();

  0032e	8b 4d 08	 mov	 ecx, DWORD PTR _pParser$[ebp]
  00331	e8 00 00 00 00	 call	 ?LeaveList@CRiffParser@@QAEXXZ ; CRiffParser::LeaveList

; 2930 :                         }
; 2931 :                         else

  00336	eb 07		 jmp	 SHORT $L70986
$L70926:

; 2932 :                         {
; 2933 :                             hr = E_OUTOFMEMORY;

  00338	c7 45 bc 0e 00
	07 80		 mov	 DWORD PTR _hr$[ebp], -2147024882 ; 8007000eH
$L70986:

; 2934 :                         }
; 2935 :                     }
; 2936 :                     break;

  0033f	e9 3c 01 00 00	 jmp	 $L70814
$L70996:

; 2937 :                 case DMUS_FOURCC_DSBC_FORM:
; 2938 :                     {
; 2939 :                         CBufferConfig *pSource = new CBufferConfig(0);

  00344	6a 30		 push	 48			; 00000030H
  00346	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0034b	83 c4 04	 add	 esp, 4
  0034e	89 45 98	 mov	 DWORD PTR $T71924[ebp], eax
  00351	83 7d 98 00	 cmp	 DWORD PTR $T71924[ebp], 0
  00355	74 12		 je	 SHORT $L71925
  00357	6a 00		 push	 0
  00359	8b 4d 98	 mov	 ecx, DWORD PTR $T71924[ebp]
  0035c	e8 00 00 00 00	 call	 ??0CBufferConfig@@QAE@K@Z ; CBufferConfig::CBufferConfig
  00361	89 85 68 ff ff
	ff		 mov	 DWORD PTR tv197[ebp], eax
  00367	eb 0a		 jmp	 SHORT $L71926
$L71925:
  00369	c7 85 68 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv197[ebp], 0
$L71926:
  00373	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR tv197[ebp]
  00379	89 45 b0	 mov	 DWORD PTR _pSource$70997[ebp], eax

; 2940 :                         if (pSource)

  0037c	83 7d b0 00	 cmp	 DWORD PTR _pSource$70997[ebp], 0
  00380	74 7a		 je	 SHORT $L71000

; 2941 :                         {
; 2942 :                             pParser->SeekBack();

  00382	8b 4d 08	 mov	 ecx, DWORD PTR _pParser$[ebp]
  00385	e8 00 00 00 00	 call	 ?SeekBack@CRiffParser@@QAEJXZ ; CRiffParser::SeekBack

; 2943 :                             hr = pSource->Load(pParser->GetStream());

  0038a	8b 4d 08	 mov	 ecx, DWORD PTR _pParser$[ebp]
  0038d	e8 00 00 00 00	 call	 ?GetStream@CRiffParser@@QAEPAUIStream@@XZ ; CRiffParser::GetStream
  00392	50		 push	 eax
  00393	8b 4d b0	 mov	 ecx, DWORD PTR _pSource$70997[ebp]
  00396	e8 00 00 00 00	 call	 ?Load@CBufferConfig@@QAEJPAUIStream@@@Z ; CBufferConfig::Load
  0039b	89 45 bc	 mov	 DWORD PTR _hr$[ebp], eax

; 2944 :                             pParser->SeekForward();

  0039e	8b 4d 08	 mov	 ecx, DWORD PTR _pParser$[ebp]
  003a1	e8 00 00 00 00	 call	 ?SeekForward@CRiffParser@@QAEJXZ ; CRiffParser::SeekForward

; 2945 :                             if (SUCCEEDED(hr))

  003a6	83 7d bc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  003aa	7c 11		 jl	 SHORT $L71002

; 2946 :                             {
; 2947 :                                 m_BufferConfigList.AddTail(pSource);

  003ac	8b 4d b0	 mov	 ecx, DWORD PTR _pSource$70997[ebp]
  003af	51		 push	 ecx
  003b0	8b 4d 88	 mov	 ecx, DWORD PTR _this$[ebp]
  003b3	83 c1 18	 add	 ecx, 24			; 00000018H
  003b6	e8 00 00 00 00	 call	 ?AddTail@CBufferConfigList@@QAEXPAVCBufferConfig@@@Z ; CBufferConfigList::AddTail

; 2948 :                             }
; 2949 :                             else

  003bb	eb 3d		 jmp	 SHORT $L71003
$L71002:

; 2950 :                             {
; 2951 :                                 Trace(1,"Error: AudioPath Configuration failed loading buffer\n");

  003bd	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DG@BIDDMOBM@Error?3?5AudioPath?5Configuration?5f@
  003c2	6a 01		 push	 1
  003c4	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  003c9	83 c4 08	 add	 esp, 8

; 2952 :                                 delete pSource;

  003cc	8b 55 b0	 mov	 edx, DWORD PTR _pSource$70997[ebp]
  003cf	89 55 90	 mov	 DWORD PTR $T71928[ebp], edx
  003d2	8b 45 90	 mov	 eax, DWORD PTR $T71928[ebp]
  003d5	89 45 94	 mov	 DWORD PTR $T71927[ebp], eax
  003d8	83 7d 94 00	 cmp	 DWORD PTR $T71927[ebp], 0
  003dc	74 12		 je	 SHORT $L71929
  003de	6a 01		 push	 1
  003e0	8b 4d 94	 mov	 ecx, DWORD PTR $T71927[ebp]
  003e3	e8 00 00 00 00	 call	 ??_GCBufferConfig@@QAEPAXI@Z
  003e8	89 85 64 ff ff
	ff		 mov	 DWORD PTR tv216[ebp], eax
  003ee	eb 0a		 jmp	 SHORT $L71003
$L71929:
  003f0	c7 85 64 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv216[ebp], 0
$L71003:

; 2953 :                             }
; 2954 :                         }
; 2955 :                         else

  003fa	eb 07		 jmp	 SHORT $L71006
$L71000:

; 2956 :                         {
; 2957 :                             hr = E_OUTOFMEMORY;

  003fc	c7 45 bc 0e 00
	07 80		 mov	 DWORD PTR _hr$[ebp], -2147024882 ; 8007000eH
$L71006:

; 2958 :                         }
; 2959 :                     }
; 2960 :                     break;               

  00403	eb 7b		 jmp	 SHORT $L70814
$L71016:

; 2961 :                 case DMUS_FOURCC_TOOLGRAPH_FORM:
; 2962 :                     {
; 2963 :                         CGraph *pGraph = new CGraph;

  00405	68 70 03 00 00	 push	 880			; 00000370H
  0040a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0040f	83 c4 04	 add	 esp, 4
  00412	89 45 8c	 mov	 DWORD PTR $T71931[ebp], eax
  00415	83 7d 8c 00	 cmp	 DWORD PTR $T71931[ebp], 0
  00419	74 10		 je	 SHORT $L71932
  0041b	8b 4d 8c	 mov	 ecx, DWORD PTR $T71931[ebp]
  0041e	e8 00 00 00 00	 call	 ??0CGraph@@QAE@XZ	; CGraph::CGraph
  00423	89 85 60 ff ff
	ff		 mov	 DWORD PTR tv222[ebp], eax
  00429	eb 0a		 jmp	 SHORT $L71933
$L71932:
  0042b	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv222[ebp], 0
$L71933:
  00435	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR tv222[ebp]
  0043b	89 4d ac	 mov	 DWORD PTR _pGraph$71017[ebp], ecx

; 2964 :                         if (pGraph)

  0043e	83 7d ac 00	 cmp	 DWORD PTR _pGraph$71017[ebp], 0
  00442	74 35		 je	 SHORT $L71020

; 2965 :                         {
; 2966 :                             hr = pGraph->Load(pParser); 

  00444	8b 55 08	 mov	 edx, DWORD PTR _pParser$[ebp]
  00447	52		 push	 edx
  00448	8b 4d ac	 mov	 ecx, DWORD PTR _pGraph$71017[ebp]
  0044b	e8 00 00 00 00	 call	 ?Load@CGraph@@QAEJPAVCRiffParser@@@Z ; CGraph::Load
  00450	89 45 bc	 mov	 DWORD PTR _hr$[ebp], eax

; 2967 :                             if(m_pGraph)

  00453	8b 45 88	 mov	 eax, DWORD PTR _this$[ebp]
  00456	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  0045a	74 12		 je	 SHORT $L71021

; 2968 :                             {
; 2969 :                                 m_pGraph->Release();

  0045c	8b 4d 88	 mov	 ecx, DWORD PTR _this$[ebp]
  0045f	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00462	8b 45 88	 mov	 eax, DWORD PTR _this$[ebp]
  00465	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00468	8b 12		 mov	 edx, DWORD PTR [edx]
  0046a	51		 push	 ecx
  0046b	ff 52 08	 call	 DWORD PTR [edx+8]
$L71021:

; 2970 :                             }
; 2971 :                             m_pGraph = pGraph;

  0046e	8b 45 88	 mov	 eax, DWORD PTR _this$[ebp]
  00471	8b 4d ac	 mov	 ecx, DWORD PTR _pGraph$71017[ebp]
  00474	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 2972 :                         }
; 2973 :                         else

  00477	eb 07		 jmp	 SHORT $L70814
$L71020:

; 2974 :                         {
; 2975 :                             hr = E_OUTOFMEMORY;

  00479	c7 45 bc 0e 00
	07 80		 mov	 DWORD PTR _hr$[ebp], -2147024882 ; 8007000eH
$L70814:

; 2976 :                         }
; 2977 :                     }
; 2978 :                     break;                       
; 2979 :             }
; 2980 :             break;
; 2981 :         }
; 2982 :     }

  00480	e9 a7 fb ff ff	 jmp	 $L70811
$L70812:

; 2983 :     pParser->LeaveList();

  00485	8b 4d 08	 mov	 ecx, DWORD PTR _pParser$[ebp]
  00488	e8 00 00 00 00	 call	 ?LeaveList@CRiffParser@@QAEXXZ ; CRiffParser::LeaveList

; 2984 :     LEAVE_CRITICAL_SECTION(&m_CriticalSection);

  0048d	8b 55 88	 mov	 edx, DWORD PTR _this$[ebp]
  00490	83 c2 1c	 add	 edx, 28			; 0000001cH
  00493	52		 push	 edx
  00494	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 2985 :     return hr;

  0049a	8b 45 bc	 mov	 eax, DWORD PTR _hr$[ebp]

; 2986 : }

  0049d	8b e5		 mov	 esp, ebp
  0049f	5d		 pop	 ebp
  004a0	c2 04 00	 ret	 4
?Load@CAudioPathConfig@@QAEJPAVCRiffParser@@@Z ENDP	; CAudioPathConfig::Load
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?Save@CAudioPathConfig@@UAGJPAUIStream@@H@Z
_TEXT	SEGMENT
_this$ = 8
_pIStream$ = 12
_fClearDirty$ = 16
?Save@CAudioPathConfig@@UAGJPAUIStream@@H@Z PROC NEAR	; CAudioPathConfig::Save, COMDAT

; 2989 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2990 :     return E_NOTIMPL;

  00003	b8 01 40 00 80	 mov	 eax, -2147467263	; 80004001H

; 2991 : }

  00008	5d		 pop	 ebp
  00009	c2 0c 00	 ret	 12			; 0000000cH
?Save@CAudioPathConfig@@UAGJPAUIStream@@H@Z ENDP	; CAudioPathConfig::Save
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetSizeMax@CAudioPathConfig@@UAGJPAT_ULARGE_INTEGER@@@Z
_TEXT	SEGMENT
_this$ = 8
_pcbSize$ = 12
?GetSizeMax@CAudioPathConfig@@UAGJPAT_ULARGE_INTEGER@@@Z PROC NEAR ; CAudioPathConfig::GetSizeMax, COMDAT

; 2994 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2995 :     return E_NOTIMPL;

  00003	b8 01 40 00 80	 mov	 eax, -2147467263	; 80004001H

; 2996 : }

  00008	5d		 pop	 ebp
  00009	c2 08 00	 ret	 8
?GetSizeMax@CAudioPathConfig@@UAGJPAT_ULARGE_INTEGER@@@Z ENDP ; CAudioPathConfig::GetSizeMax
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?QueryInterface@CAudioPathConfig@@W3AGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
?QueryInterface@CAudioPathConfig@@W3AGJABU_GUID@@PAPAX@Z PROC NEAR ; CAudioPathConfig::QueryInterface, COMDAT
  00000	83 6c 24 04 04	 sub	 DWORD PTR [esp+4], 4
  00005	e9 00 00 00 00	 jmp	 ?QueryInterface@CAudioPathConfig@@UAGJABU_GUID@@PAPAX@Z ; CAudioPathConfig::QueryInterface
?QueryInterface@CAudioPathConfig@@W3AGJABU_GUID@@PAPAX@Z ENDP ; CAudioPathConfig::QueryInterface
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?AddRef@CAudioPathConfig@@W3AGKXZ
_TEXT	SEGMENT
?AddRef@CAudioPathConfig@@W3AGKXZ PROC NEAR		; CAudioPathConfig::AddRef, COMDAT
  00000	83 6c 24 04 04	 sub	 DWORD PTR [esp+4], 4
  00005	e9 00 00 00 00	 jmp	 ?AddRef@CAudioPathConfig@@UAGKXZ ; CAudioPathConfig::AddRef
?AddRef@CAudioPathConfig@@W3AGKXZ ENDP			; CAudioPathConfig::AddRef
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?Release@CAudioPathConfig@@W3AGKXZ
_TEXT	SEGMENT
?Release@CAudioPathConfig@@W3AGKXZ PROC NEAR		; CAudioPathConfig::Release, COMDAT
  00000	83 6c 24 04 04	 sub	 DWORD PTR [esp+4], 4
  00005	e9 00 00 00 00	 jmp	 ?Release@CAudioPathConfig@@UAGKXZ ; CAudioPathConfig::Release
?Release@CAudioPathConfig@@W3AGKXZ ENDP			; CAudioPathConfig::Release
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?QueryInterface@CAudioPath@@W3AGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
?QueryInterface@CAudioPath@@W3AGJABU_GUID@@PAPAX@Z PROC NEAR ; CAudioPath::QueryInterface, COMDAT
  00000	83 6c 24 04 04	 sub	 DWORD PTR [esp+4], 4
  00005	e9 00 00 00 00	 jmp	 ?QueryInterface@CAudioPath@@UAGJABU_GUID@@PAPAX@Z ; CAudioPath::QueryInterface
?QueryInterface@CAudioPath@@W3AGJABU_GUID@@PAPAX@Z ENDP	; CAudioPath::QueryInterface
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?AddRef@CAudioPath@@W3AGKXZ
_TEXT	SEGMENT
?AddRef@CAudioPath@@W3AGKXZ PROC NEAR			; CAudioPath::AddRef, COMDAT
  00000	83 6c 24 04 04	 sub	 DWORD PTR [esp+4], 4
  00005	e9 00 00 00 00	 jmp	 ?AddRef@CAudioPath@@UAGKXZ ; CAudioPath::AddRef
?AddRef@CAudioPath@@W3AGKXZ ENDP			; CAudioPath::AddRef
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?Release@CAudioPath@@W3AGKXZ
_TEXT	SEGMENT
?Release@CAudioPath@@W3AGKXZ PROC NEAR			; CAudioPath::Release, COMDAT
  00000	83 6c 24 04 04	 sub	 DWORD PTR [esp+4], 4
  00005	e9 00 00 00 00	 jmp	 ?Release@CAudioPath@@UAGKXZ ; CAudioPath::Release
?Release@CAudioPath@@W3AGKXZ ENDP			; CAudioPath::Release
_TEXT	ENDS
EXTRN	_IDirectSound_CreateSoundBuffer@16:NEAR
; Function compile flags: /Odt
; File c:\xbox\public\sdk\inc\dsound.h
;	COMDAT ?CreateSoundBuffer@IDirectSound@@QAGJPBU_DSBUFFERDESC@@PAPAUIDirectSoundBuffer@@PAUIUnknown@@@Z
_TEXT	SEGMENT
_this$ = 8
_pdsbd$ = 12
_ppBuffer$ = 16
_pUnkOuter$ = 20
?CreateSoundBuffer@IDirectSound@@QAGJPBU_DSBUFFERDESC@@PAPAUIDirectSoundBuffer@@PAUIUnknown@@@Z PROC NEAR ; IDirectSound::CreateSoundBuffer, COMDAT

; 1461 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1462 :         return IDirectSound_CreateSoundBuffer(this, pdsbd, ppBuffer, pUnkOuter);

  00003	8b 45 14	 mov	 eax, DWORD PTR _pUnkOuter$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 10	 mov	 ecx, DWORD PTR _ppBuffer$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 0c	 mov	 edx, DWORD PTR _pdsbd$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 _IDirectSound_CreateSoundBuffer@16

; 1463 :     }

  00018	5d		 pop	 ebp
  00019	c2 10 00	 ret	 16			; 00000010H
?CreateSoundBuffer@IDirectSound@@QAGJPBU_DSBUFFERDESC@@PAPAUIDirectSoundBuffer@@PAUIUnknown@@@Z ENDP ; IDirectSound::CreateSoundBuffer
_TEXT	ENDS
EXTRN	_IDirectSound_SetMixBinHeadroom@12:NEAR
; Function compile flags: /Odt
;	COMDAT ?SetMixBinHeadroom@IDirectSound@@QAGJKK@Z
_TEXT	SEGMENT
_this$ = 8
_dwMixBin$ = 12
_dwHeadroom$ = 16
?SetMixBinHeadroom@IDirectSound@@QAGJKK@Z PROC NEAR	; IDirectSound::SetMixBinHeadroom, COMDAT

; 1511 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1512 :         return IDirectSound_SetMixBinHeadroom(this, dwMixBin, dwHeadroom);

  00003	8b 45 10	 mov	 eax, DWORD PTR _dwHeadroom$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 0c	 mov	 ecx, DWORD PTR _dwMixBin$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0000e	52		 push	 edx
  0000f	e8 00 00 00 00	 call	 _IDirectSound_SetMixBinHeadroom@12

; 1513 :     }

  00014	5d		 pop	 ebp
  00015	c2 0c 00	 ret	 12			; 0000000cH
?SetMixBinHeadroom@IDirectSound@@QAGJKK@Z ENDP		; IDirectSound::SetMixBinHeadroom
_TEXT	ENDS
EXTRN	_IDirectSoundBuffer_QueryInterface@12:NEAR
; Function compile flags: /Odt
;	COMDAT ?QueryInterface@IDirectSoundBuffer@@QAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
_this$ = 8
_iid$ = 12
_ppvInterface$ = 16
?QueryInterface@IDirectSoundBuffer@@QAGJABU_GUID@@PAPAX@Z PROC NEAR ; IDirectSoundBuffer::QueryInterface, COMDAT

; 1662 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1663 :         return IDirectSoundBuffer_QueryInterface(this, iid, ppvInterface);

  00003	8b 45 10	 mov	 eax, DWORD PTR _ppvInterface$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 0c	 mov	 ecx, DWORD PTR _iid$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0000e	52		 push	 edx
  0000f	e8 00 00 00 00	 call	 _IDirectSoundBuffer_QueryInterface@12

; 1664 :     }

  00014	5d		 pop	 ebp
  00015	c2 0c 00	 ret	 12			; 0000000cH
?QueryInterface@IDirectSoundBuffer@@QAGJABU_GUID@@PAPAX@Z ENDP ; IDirectSoundBuffer::QueryInterface
_TEXT	ENDS
EXTRN	_IDirectSoundBuffer_AddRef@4:NEAR
; Function compile flags: /Odt
;	COMDAT ?AddRef@IDirectSoundBuffer@@QAGKXZ
_TEXT	SEGMENT
_this$ = 8
?AddRef@IDirectSoundBuffer@@QAGKXZ PROC NEAR		; IDirectSoundBuffer::AddRef, COMDAT

; 1667 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1668 :         return IDirectSoundBuffer_AddRef(this);

  00003	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 _IDirectSoundBuffer_AddRef@4

; 1669 :     }

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?AddRef@IDirectSoundBuffer@@QAGKXZ ENDP			; IDirectSoundBuffer::AddRef
_TEXT	ENDS
EXTRN	_IDirectSoundBuffer_Release@4:NEAR
; Function compile flags: /Odt
;	COMDAT ?Release@IDirectSoundBuffer@@QAGKXZ
_TEXT	SEGMENT
_this$ = 8
?Release@IDirectSoundBuffer@@QAGKXZ PROC NEAR		; IDirectSoundBuffer::Release, COMDAT

; 1672 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1673 :         return IDirectSoundBuffer_Release(this);

  00003	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 _IDirectSoundBuffer_Release@4

; 1674 :     }

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?Release@IDirectSoundBuffer@@QAGKXZ ENDP		; IDirectSoundBuffer::Release
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\alist.h
_TEXT	ENDS
;	COMDAT ??0AListItem@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0AListItem@@QAE@XZ PROC NEAR				; AListItem::AListItem, COMDAT
; _this$ = ecx

; 17   :     AListItem() { m_pNext=NULL; };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??0AListItem@@QAE@XZ ENDP				; AListItem::AListItem
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0AList@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0AList@@QAE@XZ PROC NEAR				; AList::AList, COMDAT
; _this$ = ecx

; 34   :     AList() {m_pHead=NULL;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??0AList@@QAE@XZ ENDP					; AList::AList
_TEXT	ENDS
EXTRN	?DirectMusicAllocI@@YGPAXI@Z:NEAR		; DirectMusicAllocI
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\xalloc.h
;	COMDAT ??2@YAPAXI@Z
_TEXT	SEGMENT
_cb$ = 8
??2@YAPAXI@Z PROC NEAR					; operator new, COMDAT

; 12   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 13   :     return DirectMusicAllocI(cb);

  00003	8b 45 08	 mov	 eax, DWORD PTR _cb$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ?DirectMusicAllocI@@YGPAXI@Z ; DirectMusicAllocI

; 14   : }

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??2@YAPAXI@Z ENDP					; operator new
_TEXT	ENDS
EXTRN	?DirectMusicFreeI@@YGXPAX@Z:NEAR		; DirectMusicFreeI
; Function compile flags: /Odt
;	COMDAT ??3@YAXPAX@Z
_TEXT	SEGMENT
_pv$ = 8
??3@YAXPAX@Z PROC NEAR					; operator delete, COMDAT

; 17   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 18   :     DirectMusicFreeI(pv);

  00003	8b 45 08	 mov	 eax, DWORD PTR _pv$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ?DirectMusicFreeI@@YGXPAX@Z ; DirectMusicFreeI

; 19   : }

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??3@YAXPAX@Z ENDP					; operator delete
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??_U@YAPAXI@Z
_TEXT	SEGMENT
_cb$ = 8
??_U@YAPAXI@Z PROC NEAR					; operator new[], COMDAT

; 22   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 23   :     return DirectMusicAllocI(cb);

  00003	8b 45 08	 mov	 eax, DWORD PTR _cb$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ?DirectMusicAllocI@@YGPAXI@Z ; DirectMusicAllocI

; 24   : }

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??_U@YAPAXI@Z ENDP					; operator new[]
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??_V@YAXPAX@Z
_TEXT	SEGMENT
_pv$ = 8
??_V@YAXPAX@Z PROC NEAR					; operator delete[], COMDAT

; 27   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 28   :     DirectMusicFreeI(pv);

  00003	8b 45 08	 mov	 eax, DWORD PTR _pv$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ?DirectMusicFreeI@@YGXPAX@Z ; DirectMusicFreeI

; 29   : }

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??_V@YAXPAX@Z ENDP					; operator delete[]
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\dmstrm.h
_TEXT	ENDS
;	COMDAT ?GetStream@CRiffParser@@QAEPAUIStream@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetStream@CRiffParser@@QAEPAUIStream@@XZ PROC NEAR	; CRiffParser::GetStream, COMDAT
; _this$ = ecx

; 96   :     IStream *   GetStream() { return m_pStream; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?GetStream@CRiffParser@@QAEPAUIStream@@XZ ENDP		; CRiffParser::GetStream
_TEXT	ENDS
EXTRN	?Init@CInfo@@QAEXXZ:NEAR			; CInfo::Init
; Function compile flags: /Odt
;	COMDAT ??0CInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CInfo@@QAE@XZ PROC NEAR				; CInfo::CInfo, COMDAT
; _this$ = ecx

; 111  :     CInfo() { Init(); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?Init@CInfo@@QAEXXZ	; CInfo::Init
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0CInfo@@QAE@XZ ENDP					; CInfo::CInfo
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\dmime\audpath.h
_TEXT	ENDS
;	COMDAT ?GetBuffer@CBufferNode@@QAEPAUIDirectSoundBuffer@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetBuffer@CBufferNode@@QAEPAUIDirectSoundBuffer@@XZ PROC NEAR ; CBufferNode::GetBuffer, COMDAT
; _this$ = ecx

; 32   :     IDirectSoundBuffer *GetBuffer() { if (m_pBuffer) m_pBuffer->AddRef(); return m_pBuffer;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0000e	74 0c		 je	 SHORT $L41065
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00016	52		 push	 edx
  00017	e8 00 00 00 00	 call	 ?AddRef@IDirectSoundBuffer@@QAGKXZ ; IDirectSoundBuffer::AddRef
$L41065:
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
?GetBuffer@CBufferNode@@QAEPAUIDirectSoundBuffer@@XZ ENDP ; CBufferNode::GetBuffer
_TEXT	ENDS
PUBLIC	?GetNext@AListItem@@QBEPAV1@XZ			; AListItem::GetNext
; Function compile flags: /Odt
;	COMDAT ?GetNext@CBufferNode@@AAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4
?GetNext@CBufferNode@@AAEPAV1@XZ PROC NEAR		; CBufferNode::GetNext, COMDAT
; _this$ = ecx

; 36   :     CBufferNode* GetNext() { return (CBufferNode*)AListItem::GetNext();}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?GetNext@AListItem@@QBEPAV1@XZ ; AListItem::GetNext
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?GetNext@CBufferNode@@AAEPAV1@XZ ENDP			; CBufferNode::GetNext
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\alist.h
_TEXT	ENDS
;	COMDAT ?GetNext@AListItem@@QBEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4
?GetNext@AListItem@@QBEPAV1@XZ PROC NEAR		; AListItem::GetNext, COMDAT
; _this$ = ecx

; 18   :     AListItem *GetNext() const {return m_pNext;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?GetNext@AListItem@@QBEPAV1@XZ ENDP			; AListItem::GetNext
_TEXT	ENDS
PUBLIC	?AddHead@AList@@QAEXPAVAListItem@@@Z		; AList::AddHead
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\dmime\audpath.h
;	COMDAT ?AddHead@CBufferManager@@QAEXPAVCBufferNode@@@Z
_TEXT	SEGMENT
_this$ = -4
_pBufferNode$ = 8
?AddHead@CBufferManager@@QAEXPAVCBufferNode@@@Z PROC NEAR ; CBufferManager::AddHead, COMDAT
; _this$ = ecx

; 58   :     void AddHead(CBufferNode* pBufferNode) { AList::AddHead((AListItem*)pBufferNode);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _pBufferNode$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ?AddHead@AList@@QAEXPAVAListItem@@@Z ; AList::AddHead
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
?AddHead@CBufferManager@@QAEXPAVCBufferNode@@@Z ENDP	; CBufferManager::AddHead
_TEXT	ENDS
PUBLIC	?SetNext@AListItem@@QAEXPAV1@@Z			; AListItem::SetNext
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\alist.h
;	COMDAT ?AddHead@AList@@QAEXPAVAListItem@@@Z
_TEXT	SEGMENT
_this$ = -4
_pItem$ = 8
?AddHead@AList@@QAEXPAVAListItem@@@Z PROC NEAR		; AList::AddHead, COMDAT
; _this$ = ecx

; 51   :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 52   :             if (pItem!=NULL)

  00007	83 7d 08 00	 cmp	 DWORD PTR _pItem$[ebp], 0
  0000b	74 16		 je	 SHORT $L32730

; 53   :             {
; 54   :                 pItem->SetNext(m_pHead);

  0000d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00010	8b 08		 mov	 ecx, DWORD PTR [eax]
  00012	51		 push	 ecx
  00013	8b 4d 08	 mov	 ecx, DWORD PTR _pItem$[ebp]
  00016	e8 00 00 00 00	 call	 ?SetNext@AListItem@@QAEXPAV1@@Z ; AListItem::SetNext

; 55   :                 m_pHead=pItem;

  0001b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001e	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  00021	89 02		 mov	 DWORD PTR [edx], eax
$L32730:

; 56   :             }
; 57   :         };

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
?AddHead@AList@@QAEXPAVAListItem@@@Z ENDP		; AList::AddHead
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?SetNext@AListItem@@QAEXPAV1@@Z
_TEXT	SEGMENT
_this$ = -4
_pNext$ = 8
?SetNext@AListItem@@QAEXPAV1@@Z PROC NEAR		; AListItem::SetNext, COMDAT
; _this$ = ecx

; 19   :     void SetNext(AListItem *pNext) {m_pNext=pNext;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _pNext$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?SetNext@AListItem@@QAEXPAV1@@Z ENDP			; AListItem::SetNext
_TEXT	ENDS
PUBLIC	?GetHead@AList@@QBEPAVAListItem@@XZ		; AList::GetHead
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\dmime\audpath.h
;	COMDAT ?GetHead@CBufferManager@@QAEPAVCBufferNode@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetHead@CBufferManager@@QAEPAVCBufferNode@@XZ PROC NEAR ; CBufferManager::GetHead, COMDAT
; _this$ = ecx

; 59   :     CBufferNode* GetHead(){return (CBufferNode*)AList::GetHead();}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?GetHead@AList@@QBEPAVAListItem@@XZ ; AList::GetHead
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?GetHead@CBufferManager@@QAEPAVCBufferNode@@XZ ENDP	; CBufferManager::GetHead
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\alist.h
_TEXT	ENDS
;	COMDAT ?GetHead@AList@@QBEPAVAListItem@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetHead@AList@@QBEPAVAListItem@@XZ PROC NEAR		; AList::GetHead, COMDAT
; _this$ = ecx

; 35   :     AListItem *GetHead() const { return m_pHead;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?GetHead@AList@@QBEPAVAListItem@@XZ ENDP		; AList::GetHead
_TEXT	ENDS
PUBLIC	?Remove@AList@@QAEXPAVAListItem@@@Z		; AList::Remove
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\dmime\audpath.h
;	COMDAT ?Remove@CBufferManager@@QAEXPAVCBufferNode@@@Z
_TEXT	SEGMENT
_this$ = -4
_pBufferNode$ = 8
?Remove@CBufferManager@@QAEXPAVCBufferNode@@@Z PROC NEAR ; CBufferManager::Remove, COMDAT
; _this$ = ecx

; 61   :     void Remove(CBufferNode* pBufferNode){AList::Remove((AListItem*)pBufferNode);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _pBufferNode$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ?Remove@AList@@QAEXPAVAListItem@@@Z ; AList::Remove
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
?Remove@CBufferManager@@QAEXPAVCBufferNode@@@Z ENDP	; CBufferManager::Remove
_TEXT	ENDS
EXTRN	?Remove@AListItem@@QAEPAV1@PAV1@@Z:NEAR		; AListItem::Remove
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\alist.h
;	COMDAT ?Remove@AList@@QAEXPAVAListItem@@@Z
_TEXT	SEGMENT
_this$ = -4
_pItem$ = 8
?Remove@AList@@QAEXPAVAListItem@@@Z PROC NEAR		; AList::Remove, COMDAT
; _this$ = ecx

; 60   :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 61   :             if (pItem != NULL)

  00007	83 7d 08 00	 cmp	 DWORD PTR _pItem$[ebp], 0
  0000b	74 13		 je	 SHORT $L32733

; 62   :             {
; 63   :                 m_pHead=m_pHead->Remove(pItem);

  0000d	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  00010	50		 push	 eax
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00016	e8 00 00 00 00	 call	 ?Remove@AListItem@@QAEPAV1@PAV1@@Z ; AListItem::Remove
  0001b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001e	89 02		 mov	 DWORD PTR [edx], eax
$L32733:

; 64   :             }
; 65   :         };

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
?Remove@AList@@QAEXPAVAListItem@@@Z ENDP		; AList::Remove
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\dmime\audpath.h
_TEXT	ENDS
;	COMDAT ?GetNext@CBufferConfig@@QAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4
?GetNext@CBufferConfig@@QAEPAV1@XZ PROC NEAR		; CBufferConfig::GetNext, COMDAT
; _this$ = ecx

; 146  :     CBufferConfig* GetNext() { return (CBufferConfig*)AListItem::GetNext();}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?GetNext@AListItem@@QBEPAV1@XZ ; AListItem::GetNext
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?GetNext@CBufferConfig@@QAEPAV1@XZ ENDP			; CBufferConfig::GetNext
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?AddHead@CBufferConfigList@@QAEXPAVCBufferConfig@@@Z
_TEXT	SEGMENT
_this$ = -4
_pBufferConfig$ = 8
?AddHead@CBufferConfigList@@QAEXPAVCBufferConfig@@@Z PROC NEAR ; CBufferConfigList::AddHead, COMDAT
; _this$ = ecx

; 160  :     void AddHead(CBufferConfig* pBufferConfig) { AList::AddHead((AListItem*)pBufferConfig);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _pBufferConfig$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ?AddHead@AList@@QAEXPAVAListItem@@@Z ; AList::AddHead
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
?AddHead@CBufferConfigList@@QAEXPAVCBufferConfig@@@Z ENDP ; CBufferConfigList::AddHead
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetHead@CBufferConfigList@@QAEPAVCBufferConfig@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetHead@CBufferConfigList@@QAEPAVCBufferConfig@@XZ PROC NEAR ; CBufferConfigList::GetHead, COMDAT
; _this$ = ecx

; 161  :     CBufferConfig* GetHead(){return (CBufferConfig*)AList::GetHead();}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?GetHead@AList@@QBEPAVAListItem@@XZ ; AList::GetHead
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?GetHead@CBufferConfigList@@QAEPAVCBufferConfig@@XZ ENDP ; CBufferConfigList::GetHead
_TEXT	ENDS
PUBLIC	?RemoveHead@AList@@QAEPAVAListItem@@XZ		; AList::RemoveHead
; Function compile flags: /Odt
;	COMDAT ?RemoveHead@CBufferConfigList@@QAEPAVCBufferConfig@@XZ
_TEXT	SEGMENT
_this$ = -4
?RemoveHead@CBufferConfigList@@QAEPAVCBufferConfig@@XZ PROC NEAR ; CBufferConfigList::RemoveHead, COMDAT
; _this$ = ecx

; 162  :     CBufferConfig* RemoveHead() {return (CBufferConfig *) AList::RemoveHead();}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?RemoveHead@AList@@QAEPAVAListItem@@XZ ; AList::RemoveHead
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?RemoveHead@CBufferConfigList@@QAEPAVCBufferConfig@@XZ ENDP ; CBufferConfigList::RemoveHead
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\alist.h
_TEXT	ENDS
;	COMDAT ?RemoveHead@AList@@QAEPAVAListItem@@XZ
_TEXT	SEGMENT
_this$ = -8
_li$ = -4
?RemoveHead@AList@@QAEPAVAListItem@@XZ PROC NEAR	; AList::RemoveHead, COMDAT
; _this$ = ecx

; 71   :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 72   :             AListItem *li;
; 73   :             li = m_pHead;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 4d fc	 mov	 DWORD PTR _li$[ebp], ecx

; 74   :             if(m_pHead)

  00011	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00014	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00017	74 19		 je	 SHORT $L32744

; 75   :             {
; 76   :                 m_pHead = m_pHead->GetNext();

  00019	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001e	e8 00 00 00 00	 call	 ?GetNext@AListItem@@QBEPAV1@XZ ; AListItem::GetNext
  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	89 01		 mov	 DWORD PTR [ecx], eax

; 77   :                 li->SetNext(NULL);

  00028	6a 00		 push	 0
  0002a	8b 4d fc	 mov	 ecx, DWORD PTR _li$[ebp]
  0002d	e8 00 00 00 00	 call	 ?SetNext@AListItem@@QAEXPAV1@@Z ; AListItem::SetNext
$L32744:

; 78   :             }
; 79   :             return li;

  00032	8b 45 fc	 mov	 eax, DWORD PTR _li$[ebp]

; 80   :         }

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?RemoveHead@AList@@QAEPAVAListItem@@XZ ENDP		; AList::RemoveHead
_TEXT	ENDS
EXTRN	?AddTail@AList@@QAEXPAVAListItem@@@Z:NEAR	; AList::AddTail
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\dmime\audpath.h
;	COMDAT ?AddTail@CBufferConfigList@@QAEXPAVCBufferConfig@@@Z
_TEXT	SEGMENT
_this$ = -4
_pBufferConfig$ = 8
?AddTail@CBufferConfigList@@QAEXPAVCBufferConfig@@@Z PROC NEAR ; CBufferConfigList::AddTail, COMDAT
; _this$ = ecx

; 164  :     void AddTail(CBufferConfig* pBufferConfig){AList::AddTail((AListItem*)pBufferConfig);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _pBufferConfig$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ?AddTail@AList@@QAEXPAVAListItem@@@Z ; AList::AddTail
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
?AddTail@CBufferConfigList@@QAEXPAVCBufferConfig@@@Z ENDP ; CBufferConfigList::AddTail
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetNext@CBufferConnect@@QAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4
?GetNext@CBufferConnect@@QAEPAV1@XZ PROC NEAR		; CBufferConnect::GetNext, COMDAT
; _this$ = ecx

; 180  :     CBufferConnect* GetNext() { return (CBufferConnect*)AListItem::GetNext();}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?GetNext@AListItem@@QBEPAV1@XZ ; AListItem::GetNext
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?GetNext@CBufferConnect@@QAEPAV1@XZ ENDP		; CBufferConnect::GetNext
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?AddHead@CBufferConnectList@@QAEXPAVCBufferConnect@@@Z
_TEXT	SEGMENT
_this$ = -4
_pBufferConnect$ = 8
?AddHead@CBufferConnectList@@QAEXPAVCBufferConnect@@@Z PROC NEAR ; CBufferConnectList::AddHead, COMDAT
; _this$ = ecx

; 189  :     void AddHead(CBufferConnect* pBufferConnect) { AList::AddHead((AListItem*)pBufferConnect);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _pBufferConnect$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ?AddHead@AList@@QAEXPAVAListItem@@@Z ; AList::AddHead
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
?AddHead@CBufferConnectList@@QAEXPAVCBufferConnect@@@Z ENDP ; CBufferConnectList::AddHead
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetHead@CBufferConnectList@@QAEPAVCBufferConnect@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetHead@CBufferConnectList@@QAEPAVCBufferConnect@@XZ PROC NEAR ; CBufferConnectList::GetHead, COMDAT
; _this$ = ecx

; 190  :     CBufferConnect* GetHead(){return (CBufferConnect*)AList::GetHead();}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?GetHead@AList@@QBEPAVAListItem@@XZ ; AList::GetHead
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?GetHead@CBufferConnectList@@QAEPAVCBufferConnect@@XZ ENDP ; CBufferConnectList::GetHead
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?RemoveHead@CBufferConnectList@@QAEPAVCBufferConnect@@XZ
_TEXT	SEGMENT
_this$ = -4
?RemoveHead@CBufferConnectList@@QAEPAVCBufferConnect@@XZ PROC NEAR ; CBufferConnectList::RemoveHead, COMDAT
; _this$ = ecx

; 191  :     CBufferConnect* RemoveHead() {return (CBufferConnect *) AList::RemoveHead();}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?RemoveHead@AList@@QAEPAVAListItem@@XZ ; AList::RemoveHead
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?RemoveHead@CBufferConnectList@@QAEPAVCBufferConnect@@XZ ENDP ; CBufferConnectList::RemoveHead
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?AddTail@CBufferConnectList@@QAEXPAVCBufferConnect@@@Z
_TEXT	SEGMENT
_this$ = -4
_pBufferConnect$ = 8
?AddTail@CBufferConnectList@@QAEXPAVCBufferConnect@@@Z PROC NEAR ; CBufferConnectList::AddTail, COMDAT
; _this$ = ecx

; 193  :     void AddTail(CBufferConnect* pBufferConnect){AList::AddTail((AListItem*)pBufferConnect);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _pBufferConnect$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ?AddTail@AList@@QAEXPAVAListItem@@@Z ; AList::AddTail
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
?AddTail@CBufferConnectList@@QAEXPAVCBufferConnect@@@Z ENDP ; CBufferConnectList::AddTail
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetNext@CPortConfig@@QAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4
?GetNext@CPortConfig@@QAEPAV1@XZ PROC NEAR		; CPortConfig::GetNext, COMDAT
; _this$ = ecx

; 206  :     CPortConfig* GetNext() { return (CPortConfig*)AListItem::GetNext();}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?GetNext@AListItem@@QBEPAV1@XZ ; AListItem::GetNext
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?GetNext@CPortConfig@@QAEPAV1@XZ ENDP			; CPortConfig::GetNext
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?AddHead@CPortConfigList@@QAEXPAVCPortConfig@@@Z
_TEXT	SEGMENT
_this$ = -4
_pPortConfig$ = 8
?AddHead@CPortConfigList@@QAEXPAVCPortConfig@@@Z PROC NEAR ; CPortConfigList::AddHead, COMDAT
; _this$ = ecx

; 223  :     void AddHead(CPortConfig* pPortConfig) { AList::AddHead((AListItem*)pPortConfig);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _pPortConfig$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ?AddHead@AList@@QAEXPAVAListItem@@@Z ; AList::AddHead
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
?AddHead@CPortConfigList@@QAEXPAVCPortConfig@@@Z ENDP	; CPortConfigList::AddHead
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetHead@CPortConfigList@@QAEPAVCPortConfig@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetHead@CPortConfigList@@QAEPAVCPortConfig@@XZ PROC NEAR ; CPortConfigList::GetHead, COMDAT
; _this$ = ecx

; 224  :     CPortConfig* GetHead(){return (CPortConfig*)AList::GetHead();}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?GetHead@AList@@QBEPAVAListItem@@XZ ; AList::GetHead
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?GetHead@CPortConfigList@@QAEPAVCPortConfig@@XZ ENDP	; CPortConfigList::GetHead
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?RemoveHead@CPortConfigList@@QAEPAVCPortConfig@@XZ
_TEXT	SEGMENT
_this$ = -4
?RemoveHead@CPortConfigList@@QAEPAVCPortConfig@@XZ PROC NEAR ; CPortConfigList::RemoveHead, COMDAT
; _this$ = ecx

; 225  :     CPortConfig* RemoveHead() {return (CPortConfig *) AList::RemoveHead();}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?RemoveHead@AList@@QAEPAVAListItem@@XZ ; AList::RemoveHead
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?RemoveHead@CPortConfigList@@QAEPAVCPortConfig@@XZ ENDP	; CPortConfigList::RemoveHead
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?AddTail@CPortConfigList@@QAEXPAVCPortConfig@@@Z
_TEXT	SEGMENT
_this$ = -4
_pPortConfig$ = 8
?AddTail@CPortConfigList@@QAEXPAVCPortConfig@@@Z PROC NEAR ; CPortConfigList::AddTail, COMDAT
; _this$ = ecx

; 227  :     void AddTail(CPortConfig* pPortConfig){AList::AddTail((AListItem*)pPortConfig);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _pPortConfig$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ?AddTail@AList@@QAEXPAVAListItem@@@Z ; AList::AddTail
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
?AddTail@CPortConfigList@@QAEXPAVCPortConfig@@@Z ENDP	; CPortConfigList::AddTail
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetNext@CAudioPath@@QAEPAV1@XZ
_TEXT	SEGMENT
tv71 = -12
tv68 = -8
_this$ = -4
?GetNext@CAudioPath@@QAEPAV1@XZ PROC NEAR		; CAudioPath::GetNext, COMDAT
; _this$ = ecx

; 252  :     CAudioPath* GetNext() { return (CAudioPath*)AListItem::GetNext();}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	83 c1 08	 add	 ecx, 8
  0000f	e8 00 00 00 00	 call	 ?GetNext@AListItem@@QBEPAV1@XZ ; AListItem::GetNext
  00014	89 45 f8	 mov	 DWORD PTR tv68[ebp], eax
  00017	83 7d f8 00	 cmp	 DWORD PTR tv68[ebp], 0
  0001b	74 0b		 je	 SHORT $L72080
  0001d	8b 45 f8	 mov	 eax, DWORD PTR tv68[ebp]
  00020	83 e8 08	 sub	 eax, 8
  00023	89 45 f4	 mov	 DWORD PTR tv71[ebp], eax
  00026	eb 07		 jmp	 SHORT $L72081
$L72080:
  00028	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
$L72081:
  0002f	8b 45 f4	 mov	 eax, DWORD PTR tv71[ebp]
  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
?GetNext@CAudioPath@@QAEPAV1@XZ ENDP			; CAudioPath::GetNext
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?UsesPort@CAudioPath@@QAEHPAUIDirectMusicPort@@@Z
_TEXT	SEGMENT
_this$ = -4
_pPort$ = 8
?UsesPort@CAudioPath@@QAEHPAUIDirectMusicPort@@@Z PROC NEAR ; CAudioPath::UsesPort, COMDAT
; _this$ = ecx

; 283  :     BOOL UsesPort(IDirectMusicPort *pPort) { return m_PortConfigList.UsesPort(pPort); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _pPort$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	83 c1 68	 add	 ecx, 104		; 00000068H
  00011	e8 00 00 00 00	 call	 ?UsesPort@CPortConfigList@@QAEHPAUIDirectMusicPort@@@Z ; CPortConfigList::UsesPort
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
?UsesPort@CAudioPath@@QAEHPAUIDirectMusicPort@@@Z ENDP	; CAudioPath::UsesPort
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?AddHead@CAudioPathList@@QAEXPAVCAudioPath@@@Z
_TEXT	SEGMENT
tv67 = -8
_this$ = -4
_pAudioPath$ = 8
?AddHead@CAudioPathList@@QAEXPAVCAudioPath@@@Z PROC NEAR ; CAudioPathList::AddHead, COMDAT
; _this$ = ecx

; 309  :     void AddHead(CAudioPath* pAudioPath) { AList::AddHead((AListItem*)pAudioPath);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	83 7d 08 00	 cmp	 DWORD PTR _pAudioPath$[ebp], 0
  0000d	74 0b		 je	 SHORT $L72088
  0000f	8b 45 08	 mov	 eax, DWORD PTR _pAudioPath$[ebp]
  00012	83 c0 08	 add	 eax, 8
  00015	89 45 f8	 mov	 DWORD PTR tv67[ebp], eax
  00018	eb 07		 jmp	 SHORT $L72089
$L72088:
  0001a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
$L72089:
  00021	8b 4d f8	 mov	 ecx, DWORD PTR tv67[ebp]
  00024	51		 push	 ecx
  00025	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	e8 00 00 00 00	 call	 ?AddHead@AList@@QAEXPAVAListItem@@@Z ; AList::AddHead
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
?AddHead@CAudioPathList@@QAEXPAVCAudioPath@@@Z ENDP	; CAudioPathList::AddHead
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetHead@CAudioPathList@@QAEPAVCAudioPath@@XZ
_TEXT	SEGMENT
tv69 = -12
tv66 = -8
_this$ = -4
?GetHead@CAudioPathList@@QAEPAVCAudioPath@@XZ PROC NEAR	; CAudioPathList::GetHead, COMDAT
; _this$ = ecx

; 310  :     CAudioPath* GetHead(){return (CAudioPath*)AList::GetHead();}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?GetHead@AList@@QBEPAVAListItem@@XZ ; AList::GetHead
  00011	89 45 f8	 mov	 DWORD PTR tv66[ebp], eax
  00014	83 7d f8 00	 cmp	 DWORD PTR tv66[ebp], 0
  00018	74 0b		 je	 SHORT $L72093
  0001a	8b 45 f8	 mov	 eax, DWORD PTR tv66[ebp]
  0001d	83 e8 08	 sub	 eax, 8
  00020	89 45 f4	 mov	 DWORD PTR tv69[ebp], eax
  00023	eb 07		 jmp	 SHORT $L72094
$L72093:
  00025	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$L72094:
  0002c	8b 45 f4	 mov	 eax, DWORD PTR tv69[ebp]
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
?GetHead@CAudioPathList@@QAEPAVCAudioPath@@XZ ENDP	; CAudioPathList::GetHead
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?Remove@CAudioPathList@@QAEXPAVCAudioPath@@@Z
_TEXT	SEGMENT
tv67 = -8
_this$ = -4
_pAudioPath$ = 8
?Remove@CAudioPathList@@QAEXPAVCAudioPath@@@Z PROC NEAR	; CAudioPathList::Remove, COMDAT
; _this$ = ecx

; 312  :     void Remove(CAudioPath* pAudioPath){AList::Remove((AListItem*)pAudioPath);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	83 7d 08 00	 cmp	 DWORD PTR _pAudioPath$[ebp], 0
  0000d	74 0b		 je	 SHORT $L72098
  0000f	8b 45 08	 mov	 eax, DWORD PTR _pAudioPath$[ebp]
  00012	83 c0 08	 add	 eax, 8
  00015	89 45 f8	 mov	 DWORD PTR tv67[ebp], eax
  00018	eb 07		 jmp	 SHORT $L72099
$L72098:
  0001a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
$L72099:
  00021	8b 4d f8	 mov	 ecx, DWORD PTR tv67[ebp]
  00024	51		 push	 ecx
  00025	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	e8 00 00 00 00	 call	 ?Remove@AList@@QAEXPAVAListItem@@@Z ; AList::Remove
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
?Remove@CAudioPathList@@QAEXPAVCAudioPath@@@Z ENDP	; CAudioPathList::Remove
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\xboxutil.h
_TEXT	ENDS
;	COMDAT ?DeleteCriticalSection@@YGXPAX@Z
_TEXT	SEGMENT
___formal$ = 8
?DeleteCriticalSection@@YGXPAX@Z PROC NEAR		; DeleteCriticalSection, COMDAT

; 16   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 17   : }

  00003	5d		 pop	 ebp
  00004	c2 04 00	 ret	 4
?DeleteCriticalSection@@YGXPAX@Z ENDP			; DeleteCriticalSection
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0IUnknown@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0IUnknown@@QAE@XZ PROC NEAR				; IUnknown::IUnknown, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??0IUnknown@@QAE@XZ ENDP				; IUnknown::IUnknown
_TEXT	ENDS
END
