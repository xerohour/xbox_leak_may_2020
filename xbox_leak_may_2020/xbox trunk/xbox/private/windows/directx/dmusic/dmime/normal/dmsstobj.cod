; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9254.1 

	TITLE	..\dmsstobj.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0BK@EEFOGCF@SegmentState?5?$CFlx?5created?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DK@MLGOPCLM@SegmentState?5?$CFlx?5destroyed?5with?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BJ@IGMLCEHI@?$CFs?3?5Invalid?5pointer?5ppv?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CB@NHMFCKLP@?$CFs?3?5Invalid?5pointer?5?$CIvoid?$CK?$CJ?$CGiid?6@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EE@BJNBMMKH@Warning?3?5Request?5to?5query?5unknow@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DK@NBCHJFPK@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@CCBLCLGJ@pParentSegment?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@GBKEFDMD@pPerformance?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FI@KPFANMHN@Warning?$CB?5SegmentState?5?$CFlx?5still?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CL@MHOICLE@Attempting?5to?5delete?5a?5NULL?5Segm@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07JPGHMFOH@pmtTime?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09GJFDDKPJ@pmtOffset?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09FGDJMGFM@pdwRepeat?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BN@IFHAGJPO@Send?5Dirty?5PMsg?5?$FL4?$FN?5?$CFd?5?$CI?$CFd?$CJ?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CA@ONCHGBPA@?$CFs?3?5Invalid?5pointer?5pdwRepeats?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BP@IPCOEDEC@?$CFs?3?5Invalid?5pointer?5ppSegment?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DJ@JJNELLME@Error?3?5Segmentstate?5doesn?8t?5have@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BN@BNNDBOOO@Send?5Dirty?5PMsg?5?$FL1?$FN?5?$CFd?5?$CI?$CFd?$CJ?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DG@MNLICCBK@SegState?5?$CFld?5Play?5from?5?$CFld?5to?5?$CFl@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@LLLGOMEJ@pCTrack?9?$DOm_pTrack?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BN@GKENMMBO@Send?5Dirty?5PMsg?5?$FL2?$FN?5?$CFd?5?$CI?$CFd?$CJ?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0GD@LBIELNMC@Warning?3?5Segmentstate?3?3GetParam?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BO@IBOJFPEI@?$CFs?3?5Invalid?5argument?5lVolume?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BN@MDFJNLGO@?$CFs?3?5Invalid?5argument?5lPitch?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CP@FDCAMJIJ@?$CFs?3?5Invalid?5pointer?5?$CIvoid?$CK?$CJ?$CGrgui@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FB@JJEDPCIN@Error?3?5Segmentstate?3?3SetTrackCon@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09GLHEMJPI@pmtResult?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@GHKMBHCB@m_mtLength?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BO@ODPGIKAP@?$CFs?3?5Invalid?5pointer?5pmtStart?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BN@FPNBBHE@?$CFs?3?5Invalid?5pointer?5pmtSeek?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BL@KLPIMHHM@?$CFs?3?5Invalid?5pointer?5pPMsg?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FN@BKJJAELJ@Error?3?5Segmentstate?3?3StampPMsg?5f@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BO@EMDDDLDF@?$CFs?3?5Invalid?5pointer?5ppObject?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DP@IFALCKJM@Error?3?5Unable?5to?5access?5audiopat@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02BGAOHDMM@?$CBp?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
XBLD$V	SEGMENT DWORD USE32 PUBLIC ''
XBLD$V	ENDS
;	COMDAT ??0CSegState@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IDirectMusicSegmentState@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IDirectMusicGraph@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CTrackList@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CSegState@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?QueryInterface@CSegState@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@CSegState@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@CSegState@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCSegState@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PrivateInit@CSegState@@QAEJPAVCSegment@@PAVCPerformance@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitRoute@CSegState@@QAEJPAUIDirectMusicAudioPath@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ShutDown@CSegState@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEndTime@CSegState@@QAEJJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ConvertToSegTime@CSegState@@QAEJPAJ0PAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GenerateNotification@CSegState@@AAEXKJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SendDirtyPMsg@CSegState@@AAEXJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AbortPlay@CSegState@@QAEJJH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetRepeats@CSegState@@UAGJPAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSegment@CSegState@@UAGJPAPAUIDirectMusicSegment@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Play@CSegState@@QAGJJPAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Play@CSegState@@QAEJJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTrackByParam@CSegState@@AAEPAVCTrack@@PAV2@ABU_GUID@@KK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetParam@CSegState@@QAEJPAVCPerformance@@ABU_GUID@@KKJPAJPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTrack@CSegState@@AAEPAVCTrack@@ABU_GUID@@KK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetVolume@CSegState@@UAGJJK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetPitch@CSegState@@UAGJJK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetTrackConfig@CSegState@@QAGJABU_GUID@@KKKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckPlay@CSegState@@QAEJJPAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStartTime@CSegState@@UAGJPAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStartPoint@CSegState@@UAGJPAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetSeek@CSegState@@QAEJJK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetInvalidate@CSegState@@QAEJJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSeek@CSegState@@UAGJPAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Flush@CSegState@@QAGJJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Shutdown@CSegState@@QAGJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InsertTool@CSegState@@UAGJPAUIDirectMusicTool@@PAKKJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTool@CSegState@@UAGJKPAPAUIDirectMusicTool@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveTool@CSegState@@UAGJPAUIDirectMusicTool@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StampPMsg@CSegState@@UAGJPAU_DMUS_PMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetObjectInPath@CSegState@@UAGJKKKABU_GUID@@K0PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TList@UTriggerInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetHead@?$TList@UTriggerInfo@@@@QBEPAV?$TListItem@UTriggerInfo@@@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CleanUp@?$TList@UTriggerInfo@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddHead@?$TList@UTriggerInfo@@@@QAEXPAV?$TListItem@UTriggerInfo@@@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TList@ULyricInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetHead@?$TList@ULyricInfo@@@@QBEPAV?$TListItem@ULyricInfo@@@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CleanUp@?$TList@ULyricInfo@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddHead@?$TList@ULyricInfo@@@@QAEXPAV?$TListItem@ULyricInfo@@@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TListItem@UTriggerInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNext@?$TListItem@UTriggerInfo@@@@QBEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetItemValue@?$TListItem@UTriggerInfo@@@@QAEAAUTriggerInfo@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TListItem@ULyricInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNext@?$TListItem@ULyricInfo@@@@QBEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetItemValue@?$TListItem@ULyricInfo@@@@QAEAAULyricInfo@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$ComPtr@UIDirectMusicLoader@@@SmartRef@@QAE@PAUIDirectMusicLoader@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$ComPtr@UIDirectMusicLoader@@@SmartRef@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$ComPtr@UIDirectMusicLoader@@@SmartRef@@QAEPAUIDirectMusicLoader@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??I?$ComPtr@UIDirectMusicLoader@@@SmartRef@@QAEPAPAUIDirectMusicLoader@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EventCompare@?$CmpStruct@UTriggerInfo@@@@SGHAAUTriggerInfo@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EventCompare@?$CmpStruct@ULyricInfo@@@@SGHAAULyricInfo@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CStandardStateData@ULyricInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1LyricInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetNext@?$TListItem@UTriggerInfo@@@@QAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetNext@?$TListItem@ULyricInfo@@@@QAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$ComPtr@UIDirectMusicLoader@@@SmartRef@@QAEAAV01@PAUIDirectMusicLoader@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MergeSort@?$TList@UTriggerInfo@@@@QAEXP6GHAAUTriggerInfo@@0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reverse@?$TList@UTriggerInfo@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@UTriggerInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MergeSort@?$TList@ULyricInfo@@@@QAEXP6GHAAULyricInfo@@0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reverse@?$TList@ULyricInfo@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@ULyricInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@UWaveItem@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@U_DMUS_IO_SEQ_ITEM@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@U_DMUS_IO_CURVE_ITEM@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@UParamInfo@CParamControlTrack@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@_J@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TListItem@UObjectInfo@CParamControlTrack@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1ObjectInfo@CParamControlTrack@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MergeSort@?$TListItem@UTriggerInfo@@@@QAEPAV1@P6GHAAUTriggerInfo@@0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MergeSort@?$TListItem@ULyricInfo@@@@QAEPAV1@P6GHAAULyricInfo@@0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Divide@?$TListItem@UTriggerInfo@@@@AAEXAAPAV1@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Merge@?$TListItem@UTriggerInfo@@@@AAEPAV1@PAV1@P6GHAAUTriggerInfo@@1@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Divide@?$TListItem@ULyricInfo@@@@AAEXAAPAV1@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Merge@?$TListItem@ULyricInfo@@@@AAEPAV1@PAV1@P6GHAAULyricInfo@@1@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?QueryInterface@CSegState@@W3AGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@CSegState@@W3AGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@CSegState@@W3AGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TList@UParamInfo@CParamControlTrack@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Delete@?$TListItem@UParamInfo@CParamControlTrack@@@@SGXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$TListItem@UParamInfo@CParamControlTrack@@@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1ParamInfo@CParamControlTrack@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_V@YAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1WaveItem@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1WString@SmartRef@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0DJ@BKGKOLMN@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0LyricInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0WString@SmartRef@@QAE@PBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1TriggerInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0TriggerInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Delete@?$TListItem@ULyricInfo@@@@SGXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$TListItem@ULyricInfo@@@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Delete@?$TListItem@UTriggerInfo@@@@SGXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$TListItem@UTriggerInfo@@@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??GetObjectInPath@CSegState@@UAGJKKKABU_GUID@@K0PAPAX@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??StampPMsg@CSegState@@UAGJPAU_DMUS_PMSG@@@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??GetSeek@CSegState@@UAGJPAJ@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??GetStartPoint@CSegState@@UAGJPAJ@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??GetStartTime@CSegState@@UAGJPAJ@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??SetTrackConfig@CSegState@@QAGJABU_GUID@@KKKK@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??SetPitch@CSegState@@UAGJJK@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??SetVolume@CSegState@@UAGJJK@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_00000000_0000_0000_0000_000000000000
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??GetSegment@CSegState@@UAGJPAPAUIDirectMusicSegment@@@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??GetRepeats@CSegState@@UAGJPAK@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?GetNext@CTrack@@QAEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNext@AListItem@@QBEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetHead@CTrackList@@QAEPAVCTrack@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetHead@AList@@QBEPAVAListItem@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clear@CTrackList@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveHead@CTrackList@@QAEPAVCTrack@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveHead@AList@@QAEPAVAListItem@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetNext@AListItem@@QAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCTrack@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3@YAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _==@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _IsEqualGUID@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??QueryInterface@CSegState@@UAGJABU_GUID@@PAPAX@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?DeleteCriticalSection@@YGXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0AList@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IUnknown@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CSegState@@6BIDirectMusicGraph@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CSegState@@6BIDirectMusicSegmentState@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0AListItem@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
FLAT	GROUP _DATA, CONST, _BSS, XBLD$V
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	??0IDirectMusicSegmentState@@QAE@XZ		; IDirectMusicSegmentState::IDirectMusicSegmentState
PUBLIC	??0IDirectMusicGraph@@QAE@XZ			; IDirectMusicGraph::IDirectMusicGraph
PUBLIC	??0CSegState@@QAE@XZ				; CSegState::CSegState
PUBLIC	?QueryInterface@CSegState@@UAGJABU_GUID@@PAPAX@Z ; CSegState::QueryInterface
PUBLIC	?AddRef@CSegState@@UAGKXZ			; CSegState::AddRef
PUBLIC	?Release@CSegState@@UAGKXZ			; CSegState::Release
PUBLIC	?GetRepeats@CSegState@@UAGJPAK@Z		; CSegState::GetRepeats
PUBLIC	?GetSegment@CSegState@@UAGJPAPAUIDirectMusicSegment@@@Z ; CSegState::GetSegment
PUBLIC	?GetStartTime@CSegState@@UAGJPAJ@Z		; CSegState::GetStartTime
PUBLIC	?GetSeek@CSegState@@UAGJPAJ@Z			; CSegState::GetSeek
PUBLIC	?GetStartPoint@CSegState@@UAGJPAJ@Z		; CSegState::GetStartPoint
PUBLIC	?GetObjectInPath@CSegState@@UAGJKKKABU_GUID@@K0PAPAX@Z ; CSegState::GetObjectInPath
PUBLIC	?SetVolume@CSegState@@UAGJJK@Z			; CSegState::SetVolume
PUBLIC	?SetPitch@CSegState@@UAGJJK@Z			; CSegState::SetPitch
PUBLIC	?InsertTool@CSegState@@UAGJPAUIDirectMusicTool@@PAKKJ@Z ; CSegState::InsertTool
PUBLIC	?GetTool@CSegState@@UAGJKPAPAUIDirectMusicTool@@@Z ; CSegState::GetTool
PUBLIC	?RemoveTool@CSegState@@UAGJPAUIDirectMusicTool@@@Z ; CSegState::RemoveTool
PUBLIC	?StampPMsg@CSegState@@UAGJPAU_DMUS_PMSG@@@Z	; CSegState::StampPMsg
PUBLIC	??_7CSegState@@6BIDirectMusicSegmentState@@@	; CSegState::`vftable'
PUBLIC	??_7CSegState@@6BIDirectMusicGraph@@@		; CSegState::`vftable'
PUBLIC	?QueryInterface@CSegState@@W3AGJABU_GUID@@PAPAX@Z ; CSegState::QueryInterface
PUBLIC	?AddRef@CSegState@@W3AGKXZ			; CSegState::AddRef
PUBLIC	?Release@CSegState@@W3AGKXZ			; CSegState::Release
PUBLIC	??0CTrackList@@QAE@XZ				; CTrackList::CTrackList
PUBLIC	??0AListItem@@QAE@XZ				; AListItem::AListItem
EXTRN	??0CMemTrack@@QAE@K@Z:NEAR			; CMemTrack::CMemTrack
EXTRN	__imp__RtlInitializeCriticalSection@4:NEAR
;	COMDAT ??_7CSegState@@6BIDirectMusicSegmentState@@@
; File c:\xbox\private\windows\directx\dmusic\dmime\dmsstobj.cpp
CONST	SEGMENT
??_7CSegState@@6BIDirectMusicSegmentState@@@ DD FLAT:?QueryInterface@CSegState@@UAGJABU_GUID@@PAPAX@Z ; CSegState::`vftable'
	DD	FLAT:?AddRef@CSegState@@UAGKXZ
	DD	FLAT:?Release@CSegState@@UAGKXZ
	DD	FLAT:?GetObjectInPath@CSegState@@UAGJKKKABU_GUID@@K0PAPAX@Z
	DD	FLAT:?SetVolume@CSegState@@UAGJJK@Z
	DD	FLAT:?SetPitch@CSegState@@UAGJJK@Z
	DD	FLAT:?GetSegment@CSegState@@UAGJPAPAUIDirectMusicSegment@@@Z
	DD	FLAT:?GetStartTime@CSegState@@UAGJPAJ@Z
	DD	FLAT:?GetRepeats@CSegState@@UAGJPAK@Z
	DD	FLAT:?GetSeek@CSegState@@UAGJPAJ@Z
	DD	FLAT:?GetStartPoint@CSegState@@UAGJPAJ@Z
CONST	ENDS
;	COMDAT ??_7CSegState@@6BIDirectMusicGraph@@@
CONST	SEGMENT
??_7CSegState@@6BIDirectMusicGraph@@@ DD FLAT:?QueryInterface@CSegState@@W3AGJABU_GUID@@PAPAX@Z ; CSegState::`vftable'
	DD	FLAT:?AddRef@CSegState@@W3AGKXZ
	DD	FLAT:?Release@CSegState@@W3AGKXZ
	DD	FLAT:?StampPMsg@CSegState@@UAGJPAU_DMUS_PMSG@@@Z
	DD	FLAT:?InsertTool@CSegState@@UAGJPAUIDirectMusicTool@@PAKKJ@Z
	DD	FLAT:?GetTool@CSegState@@UAGJKPAPAUIDirectMusicTool@@@Z
	DD	FLAT:?RemoveTool@CSegState@@UAGJPAUIDirectMusicTool@@@Z
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ??0CSegState@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CSegState@@QAE@XZ PROC NEAR				; CSegState::CSegState, COMDAT
; _this$ = ecx

; 24   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0IDirectMusicSegmentState@@QAE@XZ
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	83 c1 04	 add	 ecx, 4
  00015	e8 00 00 00 00	 call	 ??0IDirectMusicGraph@@QAE@XZ
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	83 c1 08	 add	 ecx, 8
  00020	e8 00 00 00 00	 call	 ??0AListItem@@QAE@XZ	; AListItem::AListItem
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CSegState@@6BIDirectMusicSegmentState@@@
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET FLAT:??_7CSegState@@6BIDirectMusicGraph@@@
  00038	6a 04		 push	 4
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00040	e8 00 00 00 00	 call	 ??0CMemTrack@@QAE@K@Z	; CMemTrack::CMemTrack
  00045	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	83 c1 44	 add	 ecx, 68			; 00000044H
  0004b	e8 00 00 00 00	 call	 ??0CTrackList@@QAE@XZ

; 25   :     INITIALIZE_CRITICAL_SECTION(&m_CriticalSection);

  00050	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00053	83 c2 14	 add	 edx, 20			; 00000014H
  00056	52		 push	 edx
  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitializeCriticalSection@4

; 26   :     IncrementDLLCount();
; 27   :     m_fDelayShutDown = false;

  0005d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00060	c7 80 24 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+292], 0

; 28   :     m_fInPlay = false;

  0006a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006d	c7 81 20 01 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+288], 0

; 29   : 	m_cRef = 1;

  00077	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0007a	c7 82 2c 01 00
	00 01 00 00 00	 mov	 DWORD PTR [edx+300], 1

; 30   : 	m_dwPlayTrackFlags = DMUS_TRACKF_START | DMUS_TRACKF_SEEK;

  00084	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00087	c7 40 58 05 00
	00 00		 mov	 DWORD PTR [eax+88], 5

; 31   :     m_dwFirstTrackID = 0;

  0008e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00091	c7 81 0c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+268], 0

; 32   :     m_dwLastTrackID = 0;

  0009b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0009e	c7 82 10 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+272], 0

; 33   :     m_mtEndTime = 0;

  000a8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ab	c7 40 68 00 00
	00 00		 mov	 DWORD PTR [eax+104], 0

; 34   :     m_mtAbortTime = 0;

  000b2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b5	c7 81 80 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+128], 0

; 35   : 	m_mtOffset = 0;

  000bf	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000c2	c7 42 6c 00 00
	00 00		 mov	 DWORD PTR [edx+108], 0

; 36   :     m_rtOffset = 0;

  000c9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000cc	c7 80 b8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+184], 0
  000d6	c7 80 bc 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+188], 0

; 37   :     m_rtEndTime = 0;

  000e0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000e3	c7 81 c0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+192], 0
  000ed	c7 81 c4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+196], 0

; 38   : 	m_mtStartPoint = 0;

  000f7	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000fa	c7 42 7c 00 00
	00 00		 mov	 DWORD PTR [edx+124], 0

; 39   :     m_rtStartPoint = 0;

  00101	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00104	c7 80 b0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+176], 0
  0010e	c7 80 b4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+180], 0

; 40   : 	m_mtSeek = 0;

  00118	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0011b	c7 41 78 00 00
	00 00		 mov	 DWORD PTR [ecx+120], 0

; 41   :     m_rtSeek = 0;

  00122	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00125	c7 82 c8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+200], 0
  0012f	c7 82 cc 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+204], 0

; 42   :     m_rtFirstLoopStart = 0;

  00139	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0013c	c7 80 d8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+216], 0
  00146	c7 80 dc 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+220], 0

; 43   :     m_rtCurLoopStart = 0;

  00150	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00153	c7 81 e0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+224], 0
  0015d	c7 81 e4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+228], 0

; 44   :     m_rtCurLoopEnd = 0;

  00167	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0016a	c7 82 e8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+232], 0
  00174	c7 82 ec 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+236], 0

; 45   :     m_mtFirstLoopStart = 0;

  0017e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00181	c7 80 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+132], 0

; 46   : 	m_mtLength = 0;

  0018b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0018e	c7 41 54 00 00
	00 00		 mov	 DWORD PTR [ecx+84], 0

; 47   :     m_rtLength = 0;

  00195	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00198	c7 82 d0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+208], 0
  001a2	c7 82 d4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+212], 0

; 48   : 	m_mtLoopStart = 0;

  001ac	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001af	c7 40 48 00 00
	00 00		 mov	 DWORD PTR [eax+72], 0

; 49   : 	m_mtLoopEnd = 0;

  001b6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001b9	c7 41 4c 00 00
	00 00		 mov	 DWORD PTR [ecx+76], 0

; 50   :     m_mtCurLoopStart = 0;

  001c0	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  001c3	c7 82 88 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+136], 0

; 51   :     m_mtCurLoopEnd = 0;

  001cd	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001d0	c7 80 8c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+140], 0

; 52   :     m_rtLoopStart = 0;

  001da	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001dd	c7 81 90 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+144], 0
  001e7	c7 81 94 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+148], 0

; 53   :     m_rtLoopEnd = 0;

  001f1	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  001f4	c7 82 98 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+152], 0
  001fe	c7 82 9c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+156], 0

; 54   :     m_dwRepeatsLeft = 0;

  00208	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0020b	c7 80 00 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+256], 0

; 55   : 	m_dwRepeats = 0;

  00215	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00218	c7 41 50 00 00
	00 00		 mov	 DWORD PTR [ecx+80], 0

; 56   :     m_dwVersion = 0; // Init to 6.1 behavior.

  0021f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00222	c7 82 08 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+264], 0

; 57   :     m_fPrepped = FALSE;

  0022c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0022f	c7 80 14 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+276], 0

; 58   : 	m_fCanStop = TRUE;

  00239	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0023c	c7 81 1c 01 00
	00 01 00 00 00	 mov	 DWORD PTR [ecx+284], 1

; 59   : 	m_rtGivenStart = -1;

  00246	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00249	c7 82 a0 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [edx+160], -1
  00253	c7 82 a4 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [edx+164], -1

; 60   : 	m_mtResolvedStart = -1;

  0025d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00260	c7 40 64 ff ff
	ff ff		 mov	 DWORD PTR [eax+100], -1

; 61   : 	m_mtLastPlayed = 0;

  00267	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0026a	c7 41 70 00 00
	00 00		 mov	 DWORD PTR [ecx+112], 0

; 62   :     m_rtLastPlayed = 0;

  00271	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00274	c7 82 a8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+168], 0
  0027e	c7 82 ac 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+172], 0

; 63   :     m_rtLastVolChange = 0;

  00288	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0028b	c7 80 f0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+240], 0
  00295	c7 80 f4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+244], 0

; 64   :     m_rtLastPitchChange = 0;

  0029f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002a2	c7 81 f8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+248], 0
  002ac	c7 81 fc 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+252], 0

; 65   : 	m_mtStopTime = 0;

  002b6	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  002b9	c7 42 74 00 00
	00 00		 mov	 DWORD PTR [edx+116], 0

; 66   : 	m_dwPlaySegFlags = 0;

  002c0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  002c3	c7 40 5c 00 00
	00 00		 mov	 DWORD PTR [eax+92], 0

; 67   :     m_dwSegFlags = 0;

  002ca	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002cd	c7 41 60 00 00
	00 00		 mov	 DWORD PTR [ecx+96], 0

; 68   : 	m_fStartedPlay = FALSE;

  002d4	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  002d7	c7 82 04 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+260], 0

; 69   : 	m_pUnkDispatch = NULL;

  002e1	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  002e4	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [eax+48], 0

; 70   : 	m_pSegment = NULL;

  002eb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002ee	c7 41 38 00 00
	00 00		 mov	 DWORD PTR [ecx+56], 0

; 71   : 	m_pPerformance = NULL;

  002f5	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  002f8	c7 42 34 00 00
	00 00		 mov	 DWORD PTR [edx+52], 0

; 72   :     m_pAudioPath = NULL;

  002ff	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00302	c7 40 3c 00 00
	00 00		 mov	 DWORD PTR [eax+60], 0

; 73   :     m_pGraph = NULL;

  00309	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0030c	c7 41 40 00 00
	00 00		 mov	 DWORD PTR [ecx+64], 0

; 74   :     m_fSongMode = FALSE;

  00313	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00316	c7 82 18 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+280], 0

; 75   :     m_pSongSegState = NULL;

  00320	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00323	c7 80 28 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+296], 0

; 76   : 	TraceI(2, "SegmentState %lx created\n", this );
; 77   : }

  0032d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00330	8b e5		 mov	 esp, ebp
  00332	5d		 pop	 ebp
  00333	c3		 ret	 0
??0CSegState@@QAE@XZ ENDP				; CSegState::CSegState
_TEXT	ENDS
PUBLIC	??0IUnknown@@QAE@XZ				; IUnknown::IUnknown
; Function compile flags: /Odt
;	COMDAT ??0IDirectMusicSegmentState@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0IDirectMusicSegmentState@@QAE@XZ PROC NEAR		; IDirectMusicSegmentState::IDirectMusicSegmentState, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0IUnknown@@QAE@XZ
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0IDirectMusicSegmentState@@QAE@XZ ENDP		; IDirectMusicSegmentState::IDirectMusicSegmentState
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0IDirectMusicGraph@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0IDirectMusicGraph@@QAE@XZ PROC NEAR			; IDirectMusicGraph::IDirectMusicGraph, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0IUnknown@@QAE@XZ
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0IDirectMusicGraph@@QAE@XZ ENDP			; IDirectMusicGraph::IDirectMusicGraph
_TEXT	ENDS
PUBLIC	??0AList@@QAE@XZ				; AList::AList
; Function compile flags: /Odt
;	COMDAT ??0CTrackList@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CTrackList@@QAE@XZ PROC NEAR				; CTrackList::CTrackList, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0AList@@QAE@XZ	; AList::AList
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0CTrackList@@QAE@XZ ENDP				; CTrackList::CTrackList
_TEXT	ENDS
PUBLIC	??1CSegState@@QAE@XZ				; CSegState::~CSegState
PUBLIC	?DeleteCriticalSection@@YGXPAX@Z		; DeleteCriticalSection
EXTRN	??1CMemTrack@@QAE@XZ:NEAR			; CMemTrack::~CMemTrack
; Function compile flags: /Odt
;	COMDAT ??1CSegState@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1CSegState@@QAE@XZ PROC NEAR				; CSegState::~CSegState, COMDAT
; _this$ = ecx

; 80   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CSegState@@6BIDirectMusicSegmentState@@@
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET FLAT:??_7CSegState@@6BIDirectMusicGraph@@@

; 81   : 	if (m_pUnkDispatch)

  0001a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	83 7a 30 00	 cmp	 DWORD PTR [edx+48], 0
  00021	74 12		 je	 SHORT $L69429

; 82   : 		m_pUnkDispatch->Release(); // free IDispatch implementation we may have borrowed

  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00029	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0002c	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  0002f	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00031	50		 push	 eax
  00032	ff 51 08	 call	 DWORD PTR [ecx+8]
$L69429:

; 83   :     if (m_pAudioPath) m_pAudioPath->Release();

  00035	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00038	83 7a 3c 00	 cmp	 DWORD PTR [edx+60], 0
  0003c	74 12		 je	 SHORT $L69430
  0003e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00041	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  00044	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00047	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  0004a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0004c	50		 push	 eax
  0004d	ff 51 08	 call	 DWORD PTR [ecx+8]
$L69430:

; 84   :     if (m_pGraph) m_pGraph->Release();

  00050	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00053	83 7a 40 00	 cmp	 DWORD PTR [edx+64], 0
  00057	74 12		 je	 SHORT $L69431
  00059	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  0005f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00062	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  00065	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00067	50		 push	 eax
  00068	ff 51 08	 call	 DWORD PTR [ecx+8]
$L69431:

; 85   :     if (m_pSongSegState) m_pSongSegState->Release();

  0006b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0006e	83 ba 28 01 00
	00 00		 cmp	 DWORD PTR [edx+296], 0
  00075	74 18		 je	 SHORT $L69432
  00077	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0007a	8b 88 28 01 00
	00		 mov	 ecx, DWORD PTR [eax+296]
  00080	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00083	8b 82 28 01 00
	00		 mov	 eax, DWORD PTR [edx+296]
  00089	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0008b	50		 push	 eax
  0008c	ff 51 08	 call	 DWORD PTR [ecx+8]
$L69432:

; 86   :     DecrementDLLCount();
; 87   :     DELETE_CRITICAL_SECTION(&m_CriticalSection);

  0008f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00092	83 c2 14	 add	 edx, 20			; 00000014H
  00095	52		 push	 edx
  00096	e8 00 00 00 00	 call	 ?DeleteCriticalSection@@YGXPAX@Z ; DeleteCriticalSection

; 88   : 	TraceI(2, "SegmentState %lx destroyed with %ld releases outstanding\n", this, m_cRef );
; 89   : }

  0009b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0009e	83 c1 0c	 add	 ecx, 12			; 0000000cH
  000a1	e8 00 00 00 00	 call	 ??1CMemTrack@@QAE@XZ	; CMemTrack::~CMemTrack
  000a6	8b e5		 mov	 esp, ebp
  000a8	5d		 pop	 ebp
  000a9	c3		 ret	 0
??1CSegState@@QAE@XZ ENDP				; CSegState::~CSegState
_TEXT	ENDS
PUBLIC	??_C@_0BJ@IGMLCEHI@?$CFs?3?5Invalid?5pointer?5ppv?6?$AA@ ; `string'
PUBLIC	??_C@_0CB@NHMFCKLP@?$CFs?3?5Invalid?5pointer?5?$CIvoid?$CK?$CJ?$CGiid?6@ ; `string'
PUBLIC	??_C@_0EE@BJNBMMKH@Warning?3?5Request?5to?5query?5unknow@ ; `string'
PUBLIC	_==@8
EXTRN	_CLSID_AutDirectMusicSegmentState:BYTE
EXTRN	_IID_IDispatch:BYTE
EXTRN	?DebugTrace@@YAXHPADZZ:NEAR			; DebugTrace
EXTRN	_DebugBreak@0:NEAR
EXTRN	_IID_CSegState:BYTE
EXTRN	_IID_IUnknown:BYTE
EXTRN	_IID_IDirectMusicSegmentState:BYTE
EXTRN	_IID_IDirectMusicGraph:BYTE
EXTRN	_DirectMusicCreateInstance@16:NEAR
EXTRN	_IsBadReadPtr@8:NEAR
EXTRN	_IsBadWritePtr@8:NEAR
;	COMDAT ?__szValidateInterfaceName@?1??QueryInterface@CSegState@@UAGJABU_GUID@@PAPAX@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??QueryInterface@CSegState@@UAGJABU_GUID@@PAPAX@Z@4QBDB DB 'C'
	DB	'SegState::QueryInterface', 00H		; `CSegState::QueryInterface'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0BJ@IGMLCEHI@?$CFs?3?5Invalid?5pointer?5ppv?6?$AA@
CONST	SEGMENT
??_C@_0BJ@IGMLCEHI@?$CFs?3?5Invalid?5pointer?5ppv?6?$AA@ DB '%s: Invalid '
	DB	'pointer ppv', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@NHMFCKLP@?$CFs?3?5Invalid?5pointer?5?$CIvoid?$CK?$CJ?$CGiid?6@
CONST	SEGMENT
??_C@_0CB@NHMFCKLP@?$CFs?3?5Invalid?5pointer?5?$CIvoid?$CK?$CJ?$CGiid?6@ DB '%'
	DB	's: Invalid pointer (void*)&iid', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@BJNBMMKH@Warning?3?5Request?5to?5query?5unknow@
CONST	SEGMENT
??_C@_0EE@BJNBMMKH@Warning?3?5Request?5to?5query?5unknow@ DB 'Warning: Re'
	DB	'quest to query unknown interface on SegmentState object', 0aH
	DB	00H						; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?QueryInterface@CSegState@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
tv132 = -4
_this$ = 8
_iid$ = 12
_ppv$ = 16
?QueryInterface@CSegState@@UAGJABU_GUID@@PAPAX@Z PROC NEAR ; CSegState::QueryInterface, COMDAT

; 95   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 96   : 	V_INAME(CSegState::QueryInterface);
; 97   : 	V_PTRPTR_WRITE(ppv);

  00004	6a 04		 push	 4
  00006	8b 45 10	 mov	 eax, DWORD PTR _ppv$[ebp]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  0000f	85 c0		 test	 eax, eax
  00011	74 19		 je	 SHORT $L69442
  00013	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??QueryInterface@CSegState@@UAGJABU_GUID@@PAPAX@Z@4QBDB
  00018	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BJ@IGMLCEHI@?$CFs?3?5Invalid?5pointer?5ppv?6?$AA@
  0001d	6a ff		 push	 -1
  0001f	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00024	83 c4 0c	 add	 esp, 12			; 0000000cH
  00027	e8 00 00 00 00	 call	 _DebugBreak@0
$L69442:

; 98   : 	V_REFGUID(iid);

  0002c	6a 10		 push	 16			; 00000010H
  0002e	8b 4d 0c	 mov	 ecx, DWORD PTR _iid$[ebp]
  00031	51		 push	 ecx
  00032	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  00037	85 c0		 test	 eax, eax
  00039	74 19		 je	 SHORT $L69446
  0003b	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??QueryInterface@CSegState@@UAGJABU_GUID@@PAPAX@Z@4QBDB
  00040	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CB@NHMFCKLP@?$CFs?3?5Invalid?5pointer?5?$CIvoid?$CK?$CJ?$CGiid?6@
  00045	6a ff		 push	 -1
  00047	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0004c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004f	e8 00 00 00 00	 call	 _DebugBreak@0
$L69446:

; 99   : 
; 100  :     *ppv = NULL;

  00054	8b 55 10	 mov	 edx, DWORD PTR _ppv$[ebp]
  00057	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 101  : 
; 102  : 	if (iid == IID_IUnknown || iid == IID_IDirectMusicSegmentState || 
; 103  :         iid == IID_IDirectMusicSegmentState8)

  0005d	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IUnknown
  00062	8b 45 0c	 mov	 eax, DWORD PTR _iid$[ebp]
  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 _==@8
  0006b	85 c0		 test	 eax, eax
  0006d	75 24		 jne	 SHORT $L69449
  0006f	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IDirectMusicSegmentState
  00074	8b 4d 0c	 mov	 ecx, DWORD PTR _iid$[ebp]
  00077	51		 push	 ecx
  00078	e8 00 00 00 00	 call	 _==@8
  0007d	85 c0		 test	 eax, eax
  0007f	75 12		 jne	 SHORT $L69449
  00081	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IDirectMusicSegmentState
  00086	8b 55 0c	 mov	 edx, DWORD PTR _iid$[ebp]
  00089	52		 push	 edx
  0008a	e8 00 00 00 00	 call	 _==@8
  0008f	85 c0		 test	 eax, eax
  00091	74 0d		 je	 SHORT $L69448
$L69449:

; 104  : 	{
; 105  : 		*ppv = static_cast<IDirectMusicSegmentState*>(this);

  00093	8b 45 10	 mov	 eax, DWORD PTR _ppv$[ebp]
  00096	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00099	89 08		 mov	 DWORD PTR [eax], ecx

; 106  : 	} else

  0009b	e9 ad 00 00 00	 jmp	 $L69451
$L69448:

; 107  :     if (iid == IID_CSegState)

  000a0	68 00 00 00 00	 push	 OFFSET FLAT:_IID_CSegState
  000a5	8b 55 0c	 mov	 edx, DWORD PTR _iid$[ebp]
  000a8	52		 push	 edx
  000a9	e8 00 00 00 00	 call	 _==@8
  000ae	85 c0		 test	 eax, eax
  000b0	74 0d		 je	 SHORT $L69452

; 108  : 	{
; 109  :         *ppv = static_cast<CSegState*>(this);

  000b2	8b 45 10	 mov	 eax, DWORD PTR _ppv$[ebp]
  000b5	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000b8	89 08		 mov	 DWORD PTR [eax], ecx

; 110  : 	} else 

  000ba	e9 8e 00 00 00	 jmp	 $L69451
$L69452:

; 111  : 	if (iid == IID_IDirectMusicGraph)

  000bf	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IDirectMusicGraph
  000c4	8b 55 0c	 mov	 edx, DWORD PTR _iid$[ebp]
  000c7	52		 push	 edx
  000c8	e8 00 00 00 00	 call	 _==@8
  000cd	85 c0		 test	 eax, eax
  000cf	74 22		 je	 SHORT $L69455

; 112  : 	{
; 113  : 		*ppv = static_cast<IDirectMusicGraph*>(this);

  000d1	83 7d 08 00	 cmp	 DWORD PTR _this$[ebp], 0
  000d5	74 0b		 je	 SHORT $L70627
  000d7	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  000da	83 c0 04	 add	 eax, 4
  000dd	89 45 fc	 mov	 DWORD PTR tv132[ebp], eax
  000e0	eb 07		 jmp	 SHORT $L70628
$L70627:
  000e2	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv132[ebp], 0
$L70628:
  000e9	8b 4d 10	 mov	 ecx, DWORD PTR _ppv$[ebp]
  000ec	8b 55 fc	 mov	 edx, DWORD PTR tv132[ebp]
  000ef	89 11		 mov	 DWORD PTR [ecx], edx

; 114  : 	} else

  000f1	eb 5a		 jmp	 SHORT $L69451
$L69455:

; 115  : 	if (iid == IID_IDispatch)

  000f3	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IDispatch
  000f8	8b 45 0c	 mov	 eax, DWORD PTR _iid$[ebp]
  000fb	50		 push	 eax
  000fc	e8 00 00 00 00	 call	 _==@8
  00101	85 c0		 test	 eax, eax
  00103	74 48		 je	 SHORT $L69451

; 116  : 	{
; 117  : 		// A helper scripting object implements IDispatch, which we expose from the
; 118  : 		// Performance object via COM aggregation.
; 119  : 		if (!m_pUnkDispatch)

  00105	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00108	83 79 30 00	 cmp	 DWORD PTR [ecx+48], 0
  0010c	75 1a		 jne	 SHORT $L69459

; 120  : 		{
; 121  : 			// Create the helper object
; 122  : 			DirectMusicCreateInstance(
; 123  : 				CLSID_AutDirectMusicSegmentState,
; 124  : 				static_cast<IDirectMusicSegmentState*>(this),
; 125  : 				IID_IUnknown,
; 126  : 				reinterpret_cast<void**>(&m_pUnkDispatch));

  0010e	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00111	83 c2 30	 add	 edx, 48			; 00000030H
  00114	52		 push	 edx
  00115	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IUnknown
  0011a	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0011d	50		 push	 eax
  0011e	68 00 00 00 00	 push	 OFFSET FLAT:_CLSID_AutDirectMusicSegmentState
  00123	e8 00 00 00 00	 call	 _DirectMusicCreateInstance@16
$L69459:

; 127  : 		}
; 128  : 		if (m_pUnkDispatch)

  00128	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0012b	83 79 30 00	 cmp	 DWORD PTR [ecx+48], 0
  0012f	74 1c		 je	 SHORT $L69451

; 129  : 		{
; 130  : 			return m_pUnkDispatch->QueryInterface(IID_IDispatch, ppv);

  00131	8b 55 10	 mov	 edx, DWORD PTR _ppv$[ebp]
  00134	52		 push	 edx
  00135	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IDispatch
  0013a	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0013d	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00140	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00143	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  00146	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00148	50		 push	 eax
  00149	ff 11		 call	 DWORD PTR [ecx]
  0014b	eb 2c		 jmp	 SHORT $L69438
$L69451:

; 131  : 		}
; 132  : 	}
; 133  : 
; 134  : 	if (*ppv == NULL)

  0014d	8b 55 10	 mov	 edx, DWORD PTR _ppv$[ebp]
  00150	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00153	75 16		 jne	 SHORT $L69463

; 135  :     {
; 136  :         Trace(4,"Warning: Request to query unknown interface on SegmentState object\n");

  00155	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EE@BJNBMMKH@Warning?3?5Request?5to?5query?5unknow@
  0015a	6a 04		 push	 4
  0015c	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00161	83 c4 08	 add	 esp, 8

; 137  : 		return E_NOINTERFACE;

  00164	b8 02 40 00 80	 mov	 eax, -2147467262	; 80004002H
  00169	eb 0e		 jmp	 SHORT $L69438
$L69463:

; 138  :     }
; 139  : 	reinterpret_cast<IUnknown*>(this)->AddRef();

  0016b	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0016e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00170	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00173	52		 push	 edx
  00174	ff 51 04	 call	 DWORD PTR [ecx+4]

; 140  : 	return S_OK;

  00177	33 c0		 xor	 eax, eax
$L69438:

; 141  : }

  00179	8b e5		 mov	 esp, ebp
  0017b	5d		 pop	 ebp
  0017c	c2 0c 00	 ret	 12			; 0000000cH
?QueryInterface@CSegState@@UAGJABU_GUID@@PAPAX@Z ENDP	; CSegState::QueryInterface
_TEXT	ENDS
PUBLIC	_IsEqualGUID@8
; Function compile flags: /Odt
; File c:\xbox\public\sdk\inc\guiddef.h
;	COMDAT _==@8
_TEXT	SEGMENT
_guidOne$ = 8
_guidOther$ = 12
_==@8	PROC NEAR					; COMDAT

; 188  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 189  :     return IsEqualGUID(guidOne,guidOther);

  00003	8b 45 0c	 mov	 eax, DWORD PTR _guidOther$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR _guidOne$[ebp]
  0000a	51		 push	 ecx
  0000b	e8 00 00 00 00	 call	 _IsEqualGUID@8

; 190  : }

  00010	5d		 pop	 ebp
  00011	c2 08 00	 ret	 8
_==@8	ENDP
_TEXT	ENDS
EXTRN	_memcmp:NEAR
; Function compile flags: /Odt
;	COMDAT _IsEqualGUID@8
_TEXT	SEGMENT
_rguid1$ = 8
_rguid2$ = 12
_IsEqualGUID@8 PROC NEAR				; COMDAT

; 155  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 156  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

  00003	6a 10		 push	 16			; 00000010H
  00005	8b 45 0c	 mov	 eax, DWORD PTR _rguid2$[ebp]
  00008	50		 push	 eax
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _rguid1$[ebp]
  0000c	51		 push	 ecx
  0000d	e8 00 00 00 00	 call	 _memcmp
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	f7 d8		 neg	 eax
  00017	1b c0		 sbb	 eax, eax
  00019	40		 inc	 eax

; 157  : }

  0001a	5d		 pop	 ebp
  0001b	c2 08 00	 ret	 8
_IsEqualGUID@8 ENDP
_TEXT	ENDS
EXTRN	__InterlockedIncrement@4:NEAR
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\dmime\dmsstobj.cpp
;	COMDAT ?AddRef@CSegState@@UAGKXZ
_TEXT	SEGMENT
_this$ = 8
?AddRef@CSegState@@UAGKXZ PROC NEAR			; CSegState::AddRef, COMDAT

; 144  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 145  :     return InterlockedIncrement(&m_cRef);

  00003	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00006	05 2c 01 00 00	 add	 eax, 300		; 0000012cH
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 __InterlockedIncrement@4

; 146  : }

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?AddRef@CSegState@@UAGKXZ ENDP				; CSegState::AddRef
_TEXT	ENDS
PUBLIC	??_GCSegState@@QAEPAXI@Z			; CSegState::`scalar deleting destructor'
EXTRN	__InterlockedDecrement@4:NEAR
; Function compile flags: /Odt
;	COMDAT ?Release@CSegState@@UAGKXZ
_TEXT	SEGMENT
tv73 = -12
$T70642 = -8
$T70641 = -4
_this$ = 8
?Release@CSegState@@UAGKXZ PROC NEAR			; CSegState::Release, COMDAT

; 149  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 150  :     if (!InterlockedDecrement(&m_cRef))

  00006	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00009	05 2c 01 00 00	 add	 eax, 300		; 0000012cH
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 __InterlockedDecrement@4
  00014	85 c0		 test	 eax, eax
  00016	75 39		 jne	 SHORT $L69474

; 151  :     {
; 152  : 		m_cRef = 100; // artificial reference count to prevent reentrency due to COM aggregation

  00018	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	c7 81 2c 01 00
	00 64 00 00 00	 mov	 DWORD PTR [ecx+300], 100 ; 00000064H

; 153  :         delete this;

  00025	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00028	89 55 f8	 mov	 DWORD PTR $T70642[ebp], edx
  0002b	8b 45 f8	 mov	 eax, DWORD PTR $T70642[ebp]
  0002e	89 45 fc	 mov	 DWORD PTR $T70641[ebp], eax
  00031	83 7d fc 00	 cmp	 DWORD PTR $T70641[ebp], 0
  00035	74 0f		 je	 SHORT $L70643
  00037	6a 01		 push	 1
  00039	8b 4d fc	 mov	 ecx, DWORD PTR $T70641[ebp]
  0003c	e8 00 00 00 00	 call	 ??_GCSegState@@QAEPAXI@Z
  00041	89 45 f4	 mov	 DWORD PTR tv73[ebp], eax
  00044	eb 07		 jmp	 SHORT $L70644
$L70643:
  00046	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
$L70644:

; 154  :         return 0;

  0004d	33 c0		 xor	 eax, eax
  0004f	eb 09		 jmp	 SHORT $L69473
$L69474:

; 155  :     }
; 156  : 
; 157  :     return m_cRef;

  00051	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	8b 81 2c 01 00
	00		 mov	 eax, DWORD PTR [ecx+300]
$L69473:

; 158  : }

  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c2 04 00	 ret	 4
?Release@CSegState@@UAGKXZ ENDP				; CSegState::Release
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??_GCSegState@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4
___flags$ = 8
??_GCSegState@@QAEPAXI@Z PROC NEAR			; CSegState::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CSegState@@QAE@XZ	; CSegState::~CSegState
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $L69480
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$L69480:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GCSegState@@QAEPAXI@Z ENDP				; CSegState::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?PrivateInit@CSegState@@QAEJPAVCSegment@@PAVCPerformance@@@Z ; CSegState::PrivateInit
PUBLIC	??_C@_0DK@NBCHJFPK@c?3?2xbox?2private?2windows?2directx?2@ ; `string'
PUBLIC	??_C@_0P@CCBLCLGJ@pParentSegment?$AA@		; `string'
PUBLIC	??_C@_0N@GBKEFDMD@pPerformance?$AA@		; `string'
EXTRN	__imp__RtlAssert@16:NEAR
EXTRN	?MusicToReferenceTime@CSegment@@QAEJJPA_J@Z:NEAR ; CSegment::MusicToReferenceTime
EXTRN	?ReferenceToMusicTime@CSegment@@QAEJ_JPAJ@Z:NEAR ; CSegment::ReferenceToMusicTime
EXTRN	?g_lNewTrackID@@3JA:DWORD			; g_lNewTrackID
;	COMDAT ??_C@_0DK@NBCHJFPK@c?3?2xbox?2private?2windows?2directx?2@
CONST	SEGMENT
??_C@_0DK@NBCHJFPK@c?3?2xbox?2private?2windows?2directx?2@ DB 'c:\xbox\pr'
	DB	'ivate\windows\directx\dmusic\dmime\dmsstobj.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@CCBLCLGJ@pParentSegment?$AA@
CONST	SEGMENT
??_C@_0P@CCBLCLGJ@pParentSegment?$AA@ DB 'pParentSegment', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GBKEFDMD@pPerformance?$AA@
CONST	SEGMENT
??_C@_0N@GBKEFDMD@pPerformance?$AA@ DB 'pPerformance', 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?PrivateInit@CSegState@@QAEJPAVCSegment@@PAVCPerformance@@@Z
_TEXT	SEGMENT
tv294 = -36
tv293 = -32
tv267 = -28
tv249 = -24
tv248 = -20
tv239 = -16
_this$ = -12
_dwMax$69503 = -8
_hr$ = -4
_pParentSegment$ = 8
_pPerformance$ = 12
?PrivateInit@CSegState@@QAEJPAVCSegment@@PAVCPerformance@@@Z PROC NEAR ; CSegState::PrivateInit, COMDAT
; _this$ = ecx

; 170  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 171  : 	HRESULT hr = S_OK;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 172  : 	ASSERT(pParentSegment);

  00010	83 7d 08 00	 cmp	 DWORD PTR _pParentSegment$[ebp], 0
  00014	75 17		 jne	 SHORT $L69489
  00016	6a 00		 push	 0
  00018	68 ac 00 00 00	 push	 172			; 000000acH
  0001d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NBCHJFPK@c?3?2xbox?2private?2windows?2directx?2@
  00022	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0P@CCBLCLGJ@pParentSegment?$AA@
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
$L69489:

; 173  : 	ASSERT(pPerformance);

  0002d	83 7d 0c 00	 cmp	 DWORD PTR _pPerformance$[ebp], 0
  00031	75 17		 jne	 SHORT $L69492
  00033	6a 00		 push	 0
  00035	68 ad 00 00 00	 push	 173			; 000000adH
  0003a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NBCHJFPK@c?3?2xbox?2private?2windows?2directx?2@
  0003f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0N@GBKEFDMD@pPerformance?$AA@
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
$L69492:

; 174  : 
; 175  :    	InterlockedIncrement(&g_lNewTrackID);   // Every segstate gets a unique "track ID."

  0004a	68 00 00 00 00	 push	 OFFSET FLAT:?g_lNewTrackID@@3JA ; g_lNewTrackID
  0004f	e8 00 00 00 00	 call	 __InterlockedIncrement@4

; 176  : 	m_dwTrackID = g_lNewTrackID;

  00054	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00057	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_lNewTrackID@@3JA ; g_lNewTrackID
  0005d	89 88 30 01 00
	00		 mov	 DWORD PTR [eax+304], ecx

; 177  :     m_pSegment = pParentSegment;

  00063	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00066	8b 45 08	 mov	 eax, DWORD PTR _pParentSegment$[ebp]
  00069	89 42 38	 mov	 DWORD PTR [edx+56], eax

; 178  :     pParentSegment->AddRef();

  0006c	8b 4d 08	 mov	 ecx, DWORD PTR _pParentSegment$[ebp]
  0006f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00071	8b 45 08	 mov	 eax, DWORD PTR _pParentSegment$[ebp]
  00074	50		 push	 eax
  00075	ff 52 04	 call	 DWORD PTR [edx+4]

; 179  :     m_pPerformance = pPerformance; // retain only a weak reference

  00078	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0007b	8b 55 0c	 mov	 edx, DWORD PTR _pPerformance$[ebp]
  0007e	89 51 34	 mov	 DWORD PTR [ecx+52], edx

; 180  :     m_rtLength = pParentSegment->m_rtLength;

  00081	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00084	8b 4d 08	 mov	 ecx, DWORD PTR _pParentSegment$[ebp]
  00087	8b 51 58	 mov	 edx, DWORD PTR [ecx+88]
  0008a	89 90 d0 00 00
	00		 mov	 DWORD PTR [eax+208], edx
  00090	8b 49 5c	 mov	 ecx, DWORD PTR [ecx+92]
  00093	89 88 d4 00 00
	00		 mov	 DWORD PTR [eax+212], ecx

; 181  :     m_mtStartPoint = pParentSegment->m_mtStart;

  00099	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0009c	8b 45 08	 mov	 eax, DWORD PTR _pParentSegment$[ebp]
  0009f	8b 48 74	 mov	 ecx, DWORD PTR [eax+116]
  000a2	89 4a 7c	 mov	 DWORD PTR [edx+124], ecx

; 182  :     pParentSegment->MusicToReferenceTime(m_mtStartPoint, &m_rtStartPoint);

  000a5	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  000a8	81 c2 b0 00 00
	00		 add	 edx, 176		; 000000b0H
  000ae	52		 push	 edx
  000af	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  000b2	8b 48 7c	 mov	 ecx, DWORD PTR [eax+124]
  000b5	51		 push	 ecx
  000b6	8b 4d 08	 mov	 ecx, DWORD PTR _pParentSegment$[ebp]
  000b9	e8 00 00 00 00	 call	 ?MusicToReferenceTime@CSegment@@QAEJJPA_J@Z ; CSegment::MusicToReferenceTime

; 183  :     m_mtLoopStart = pParentSegment->m_mtLoopStart;

  000be	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  000c1	8b 45 08	 mov	 eax, DWORD PTR _pParentSegment$[ebp]
  000c4	8b 48 78	 mov	 ecx, DWORD PTR [eax+120]
  000c7	89 4a 48	 mov	 DWORD PTR [edx+72], ecx

; 184  :     m_mtLoopEnd = pParentSegment->m_mtLoopEnd;

  000ca	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  000cd	8b 45 08	 mov	 eax, DWORD PTR _pParentSegment$[ebp]
  000d0	8b 48 7c	 mov	 ecx, DWORD PTR [eax+124]
  000d3	89 4a 4c	 mov	 DWORD PTR [edx+76], ecx

; 185  :     m_dwSegFlags = pParentSegment->m_dwSegFlags;

  000d6	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  000d9	8b 45 08	 mov	 eax, DWORD PTR _pParentSegment$[ebp]
  000dc	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  000df	89 4a 60	 mov	 DWORD PTR [edx+96], ecx

; 186  :     m_dwRepeats = pParentSegment->m_dwRepeats;

  000e2	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  000e5	8b 45 08	 mov	 eax, DWORD PTR _pParentSegment$[ebp]
  000e8	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  000eb	89 4a 50	 mov	 DWORD PTR [edx+80], ecx

; 187  :     m_rtLoopStart = pParentSegment->m_rtLoopStart;

  000ee	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  000f1	8b 45 08	 mov	 eax, DWORD PTR _pParentSegment$[ebp]
  000f4	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  000f7	89 8a 90 00 00
	00		 mov	 DWORD PTR [edx+144], ecx
  000fd	8b 40 64	 mov	 eax, DWORD PTR [eax+100]
  00100	89 82 94 00 00
	00		 mov	 DWORD PTR [edx+148], eax

; 188  :     m_rtLoopEnd = pParentSegment->m_rtLoopEnd;

  00106	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00109	8b 55 08	 mov	 edx, DWORD PTR _pParentSegment$[ebp]
  0010c	8b 42 68	 mov	 eax, DWORD PTR [edx+104]
  0010f	89 81 98 00 00
	00		 mov	 DWORD PTR [ecx+152], eax
  00115	8b 52 6c	 mov	 edx, DWORD PTR [edx+108]
  00118	89 91 9c 00 00
	00		 mov	 DWORD PTR [ecx+156], edx

; 189  :     if (m_rtLoopEnd)

  0011e	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00121	89 45 f0	 mov	 DWORD PTR tv239[ebp], eax
  00124	8b 4d f0	 mov	 ecx, DWORD PTR tv239[ebp]
  00127	8b 55 f0	 mov	 edx, DWORD PTR tv239[ebp]
  0012a	8b 81 98 00 00
	00		 mov	 eax, DWORD PTR [ecx+152]
  00130	0b 82 9c 00 00
	00		 or	 eax, DWORD PTR [edx+156]
  00136	85 c0		 test	 eax, eax
  00138	74 6d		 je	 SHORT $L69494

; 190  :     {
; 191  :         // Don't allow a music time start point on a clock time looping segment.
; 192  :         m_mtStartPoint = 0;

  0013a	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0013d	c7 41 7c 00 00
	00 00		 mov	 DWORD PTR [ecx+124], 0

; 193  :         // Don't allow the clock time loop length to be shorter than the length of the segment.
; 194  :         if (m_rtLoopEnd > m_rtLength)

  00144	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00147	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0014a	89 55 ec	 mov	 DWORD PTR tv248[ebp], edx
  0014d	89 45 e8	 mov	 DWORD PTR tv249[ebp], eax
  00150	8b 4d ec	 mov	 ecx, DWORD PTR tv248[ebp]
  00153	8b 55 e8	 mov	 edx, DWORD PTR tv249[ebp]
  00156	8b 81 9c 00 00
	00		 mov	 eax, DWORD PTR [ecx+156]
  0015c	3b 82 d4 00 00
	00		 cmp	 eax, DWORD PTR [edx+212]
  00162	7c 34		 jl	 SHORT $L69495
  00164	7f 14		 jg	 SHORT $L70651
  00166	8b 4d ec	 mov	 ecx, DWORD PTR tv248[ebp]
  00169	8b 55 e8	 mov	 edx, DWORD PTR tv249[ebp]
  0016c	8b 81 98 00 00
	00		 mov	 eax, DWORD PTR [ecx+152]
  00172	3b 82 d0 00 00
	00		 cmp	 eax, DWORD PTR [edx+208]
  00178	76 1e		 jbe	 SHORT $L69495
$L70651:

; 195  :         {
; 196  :             m_rtLength = m_rtLoopEnd;

  0017a	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0017d	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00180	8b 82 98 00 00
	00		 mov	 eax, DWORD PTR [edx+152]
  00186	89 81 d0 00 00
	00		 mov	 DWORD PTR [ecx+208], eax
  0018c	8b 92 9c 00 00
	00		 mov	 edx, DWORD PTR [edx+156]
  00192	89 91 d4 00 00
	00		 mov	 DWORD PTR [ecx+212], edx
$L69495:

; 197  :         }
; 198  : 
; 199  :         // 
; 200  :         // clock time looping code mis-uses m_dwRepeats since with dwRepeats=1
; 201  :         // it will not repeat at all
; 202  :         // adding one to repeats fixes this.
; 203  :         // this is much smaller chance of regression than fixing the Play code
; 204  :         //
; 205  : 
; 206  :         m_dwRepeats += 1;

  00198	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0019b	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  0019e	83 c1 01	 add	 ecx, 1
  001a1	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  001a4	89 4a 50	 mov	 DWORD PTR [edx+80], ecx
$L69494:

; 207  : 
; 208  :     }
; 209  :     if (m_rtLength) // It's a ref time segment, so convert the length to music time

  001a7	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  001aa	89 45 e4	 mov	 DWORD PTR tv267[ebp], eax
  001ad	8b 4d e4	 mov	 ecx, DWORD PTR tv267[ebp]
  001b0	8b 55 e4	 mov	 edx, DWORD PTR tv267[ebp]
  001b3	8b 81 d0 00 00
	00		 mov	 eax, DWORD PTR [ecx+208]
  001b9	0b 82 d4 00 00
	00		 or	 eax, DWORD PTR [edx+212]
  001bf	85 c0		 test	 eax, eax
  001c1	74 22		 je	 SHORT $L69496

; 210  :     {
; 211  :         pParentSegment->ReferenceToMusicTime(m_rtLength, &m_mtLength);

  001c3	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  001c6	83 c1 54	 add	 ecx, 84			; 00000054H
  001c9	51		 push	 ecx
  001ca	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  001cd	8b 82 d4 00 00
	00		 mov	 eax, DWORD PTR [edx+212]
  001d3	50		 push	 eax
  001d4	8b 8a d0 00 00
	00		 mov	 ecx, DWORD PTR [edx+208]
  001da	51		 push	 ecx
  001db	8b 4d 08	 mov	 ecx, DWORD PTR _pParentSegment$[ebp]
  001de	e8 00 00 00 00	 call	 ?ReferenceToMusicTime@CSegment@@QAEJ_JPAJ@Z ; CSegment::ReferenceToMusicTime

; 212  :     }
; 213  :     else

  001e3	eb 0c		 jmp	 SHORT $L69497
$L69496:

; 214  :     {
; 215  :         m_mtLength = pParentSegment->m_mtLength;

  001e5	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  001e8	8b 45 08	 mov	 eax, DWORD PTR _pParentSegment$[ebp]
  001eb	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  001ee	89 4a 54	 mov	 DWORD PTR [edx+84], ecx
$L69497:

; 216  :     }
; 217  :     // Don't allow repeat count to overflow and cause mathematical errors. 
; 218  :     // Make it so it can't create a segment length larger than 0x3FFFFFFF, 
; 219  :     // which would last for 8 days at 120 bpm!
; 220  :     if (m_dwRepeats)

  001f1	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  001f4	83 7a 50 00	 cmp	 DWORD PTR [edx+80], 0
  001f8	0f 84 b8 00 00
	00		 je	 $L69498

; 221  :     {
; 222  :         if ((m_mtLoopEnd == 0) && (m_mtLoopStart == 0))

  001fe	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00201	83 78 4c 00	 cmp	 DWORD PTR [eax+76], 0
  00205	75 2c		 jne	 SHORT $L69499
  00207	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0020a	83 79 48 00	 cmp	 DWORD PTR [ecx+72], 0
  0020e	75 23		 jne	 SHORT $L69499

; 223  :         {
; 224  :             // This happens when loading waves and MIDI files. 
; 225  :             m_mtLoopEnd = m_mtLength;

  00210	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00213	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00216	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  00219	89 4a 4c	 mov	 DWORD PTR [edx+76], ecx

; 226  : 
; 227  :             // zero rtLoopEnd so we dont try to do clock time looping on a wave
; 228  :             m_rtLoopEnd = 0;

  0021c	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0021f	c7 82 98 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+152], 0
  00229	c7 82 9c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+156], 0
$L69499:

; 229  :         }
; 230  :         // Make sure the loop is real.
; 231  :         if (m_rtLoopEnd > m_rtLoopStart)

  00233	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00236	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00239	89 45 e0	 mov	 DWORD PTR tv293[ebp], eax
  0023c	89 4d dc	 mov	 DWORD PTR tv294[ebp], ecx
  0023f	8b 55 e0	 mov	 edx, DWORD PTR tv293[ebp]
  00242	8b 45 dc	 mov	 eax, DWORD PTR tv294[ebp]
  00245	8b 8a 9c 00 00
	00		 mov	 ecx, DWORD PTR [edx+156]
  0024b	3b 88 94 00 00
	00		 cmp	 ecx, DWORD PTR [eax+148]
  00251	7c 18		 jl	 SHORT $L69500
  00253	7f 14		 jg	 SHORT $L70652
  00255	8b 55 e0	 mov	 edx, DWORD PTR tv293[ebp]
  00258	8b 45 dc	 mov	 eax, DWORD PTR tv294[ebp]
  0025b	8b 8a 98 00 00
	00		 mov	 ecx, DWORD PTR [edx+152]
  00261	3b 88 90 00 00
	00		 cmp	 ecx, DWORD PTR [eax+144]
  00267	76 02		 jbe	 SHORT $L69500
$L70652:

; 232  :         {
; 233  :             // probably need some test code for now, but at least this enables clock time looping...
; 234  :         }
; 235  :         else if (m_mtLoopEnd > m_mtLoopStart)

  00269	eb 4b		 jmp	 SHORT $L69498
$L69500:
  0026b	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0026e	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00271	8b 4a 4c	 mov	 ecx, DWORD PTR [edx+76]
  00274	3b 48 48	 cmp	 ecx, DWORD PTR [eax+72]
  00277	7e 33		 jle	 SHORT $L69502

; 236  :         {
; 237  :             // Take the maximum length, subtract out the full length, then divide by the loop size.
; 238  :             DWORD dwMax = (0x3FFFFFFF - m_mtLength) / (m_mtLoopEnd - m_mtLoopStart);

  00279	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0027c	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH
  00281	2b 42 54	 sub	 eax, DWORD PTR [edx+84]
  00284	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00287	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0028a	8b 49 4c	 mov	 ecx, DWORD PTR [ecx+76]
  0028d	2b 4a 48	 sub	 ecx, DWORD PTR [edx+72]
  00290	99		 cdq
  00291	f7 f9		 idiv	 ecx
  00293	89 45 f8	 mov	 DWORD PTR _dwMax$69503[ebp], eax

; 239  :             // dwMax is the maximum number of loops that can be done without overflowing the time.
; 240  :             if (m_dwRepeats > dwMax)

  00296	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00299	8b 42 50	 mov	 eax, DWORD PTR [edx+80]
  0029c	3b 45 f8	 cmp	 eax, DWORD PTR _dwMax$69503[ebp]
  0029f	76 09		 jbe	 SHORT $L69504

; 241  :             {
; 242  :                 m_dwRepeats = dwMax;

  002a1	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  002a4	8b 55 f8	 mov	 edx, DWORD PTR _dwMax$69503[ebp]
  002a7	89 51 50	 mov	 DWORD PTR [ecx+80], edx
$L69504:

; 243  :             }
; 244  :         }
; 245  :         else

  002aa	eb 0a		 jmp	 SHORT $L69498
$L69502:

; 246  :         {
; 247  :             m_dwRepeats = 0;

  002ac	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  002af	c7 40 50 00 00
	00 00		 mov	 DWORD PTR [eax+80], 0
$L69498:

; 248  :         }
; 249  :     }
; 250  : 	m_dwRepeatsLeft = m_dwRepeats;

  002b6	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  002b9	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  002bc	8b 42 50	 mov	 eax, DWORD PTR [edx+80]
  002bf	89 81 00 01 00
	00		 mov	 DWORD PTR [ecx+256], eax

; 251  : 	if( m_mtLoopEnd == 0 )

  002c5	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  002c8	83 79 4c 00	 cmp	 DWORD PTR [ecx+76], 0
  002cc	75 0c		 jne	 SHORT $L69506

; 252  : 	{
; 253  : 		m_mtLoopEnd = m_mtLength;

  002ce	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  002d1	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  002d4	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  002d7	89 4a 4c	 mov	 DWORD PTR [edx+76], ecx
$L69506:

; 254  : 	}
; 255  : 	if( m_mtStartPoint >= m_mtLoopEnd )

  002da	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  002dd	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  002e0	8b 4a 7c	 mov	 ecx, DWORD PTR [edx+124]
  002e3	3b 48 4c	 cmp	 ecx, DWORD PTR [eax+76]
  002e6	7c 2b		 jl	 SHORT $L69507

; 256  : 	{
; 257  : 		// in this case, we're not doing any looping.
; 258  : 		m_mtLoopEnd = m_mtLoopStart = 0;

  002e8	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  002eb	c7 42 48 00 00
	00 00		 mov	 DWORD PTR [edx+72], 0
  002f2	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  002f5	c7 40 4c 00 00
	00 00		 mov	 DWORD PTR [eax+76], 0

; 259  : 		m_dwRepeats = m_dwRepeatsLeft = 0;

  002fc	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  002ff	c7 81 00 01 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+256], 0
  00309	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0030c	c7 42 50 00 00
	00 00		 mov	 DWORD PTR [edx+80], 0
$L69507:

; 260  : 	}
; 261  : 	return hr;

  00313	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]

; 262  : }

  00316	8b e5		 mov	 esp, ebp
  00318	5d		 pop	 ebp
  00319	c2 08 00	 ret	 8
?PrivateInit@CSegState@@QAEJPAVCSegment@@PAVCPerformance@@@Z ENDP ; CSegState::PrivateInit
_TEXT	ENDS
PUBLIC	?InitRoute@CSegState@@QAEJPAUIDirectMusicAudioPath@@@Z ; CSegState::InitRoute
EXTRN	__imp__RtlEnterCriticalSection@4:NEAR
EXTRN	__imp__RtlLeaveCriticalSection@4:NEAR
; Function compile flags: /Odt
;	COMDAT ?InitRoute@CSegState@@QAEJPAUIDirectMusicAudioPath@@@Z
_TEXT	SEGMENT
_this$ = -8
_hr$ = -4
_pAudioPath$ = 8
?InitRoute@CSegState@@QAEJPAUIDirectMusicAudioPath@@@Z PROC NEAR ; CSegState::InitRoute, COMDAT
; _this$ = ecx

; 266  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 267  :     HRESULT hr = E_INVALIDARG;

  00009	c7 45 fc 57 00
	07 80		 mov	 DWORD PTR _hr$[ebp], -2147024809 ; 80070057H

; 268  :     ENTER_CRITICAL_SECTION(&m_CriticalSection);

  00010	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 14	 add	 eax, 20			; 00000014H
  00016	50		 push	 eax
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 269  :     if (pAudioPath)

  0001d	83 7d 08 00	 cmp	 DWORD PTR _pAudioPath$[ebp], 0
  00021	74 35		 je	 SHORT $L69514

; 270  :     {
; 271  :         if (m_dwVersion < 8) m_dwVersion = 8;

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	83 b9 08 01 00
	00 08		 cmp	 DWORD PTR [ecx+264], 8
  0002d	73 0d		 jae	 SHORT $L69515
  0002f	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00032	c7 82 08 01 00
	00 08 00 00 00	 mov	 DWORD PTR [edx+264], 8
$L69515:

; 272  :         m_pAudioPath = (CAudioPath *) pAudioPath;

  0003c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003f	8b 4d 08	 mov	 ecx, DWORD PTR _pAudioPath$[ebp]
  00042	89 48 3c	 mov	 DWORD PTR [eax+60], ecx

; 273  :         pAudioPath->AddRef();

  00045	8b 55 08	 mov	 edx, DWORD PTR _pAudioPath$[ebp]
  00048	8b 02		 mov	 eax, DWORD PTR [edx]
  0004a	8b 4d 08	 mov	 ecx, DWORD PTR _pAudioPath$[ebp]
  0004d	51		 push	 ecx
  0004e	ff 50 04	 call	 DWORD PTR [eax+4]

; 274  :         hr = S_OK;

  00051	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0
$L69514:

; 275  :     }
; 276  :     LEAVE_CRITICAL_SECTION(&m_CriticalSection);

  00058	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0005b	83 c2 14	 add	 edx, 20			; 00000014H
  0005e	52		 push	 edx
  0005f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 277  :     return hr;

  00065	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]

; 278  : }

  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c2 04 00	 ret	 4
?InitRoute@CSegState@@QAEJPAUIDirectMusicAudioPath@@@Z ENDP ; CSegState::InitRoute
_TEXT	ENDS
PUBLIC	?ShutDown@CSegState@@QAEJXZ			; CSegState::ShutDown
PUBLIC	?Clear@CTrackList@@QAEXXZ			; CTrackList::Clear
; Function compile flags: /Odt
;	COMDAT ?ShutDown@CSegState@@QAEJXZ
_TEXT	SEGMENT
_this$ = -8
_nCount$69528 = -4
?ShutDown@CSegState@@QAEJXZ PROC NEAR			; CSegState::ShutDown, COMDAT
; _this$ = ecx

; 286  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 287  :     if (this)

  00009	83 7d f8 00	 cmp	 DWORD PTR _this$[ebp], 0
  0000d	0f 84 dd 00 00
	00		 je	 $L69522

; 288  :     {
; 289  :         if (m_fInPlay)

  00013	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 b8 20 01 00
	00 00		 cmp	 DWORD PTR [eax+288], 0
  0001d	74 14		 je	 SHORT $L69523

; 290  :         {
; 291  :             m_fDelayShutDown = true;

  0001f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	c7 81 24 01 00
	00 01 00 00 00	 mov	 DWORD PTR [ecx+292], 1

; 292  :             return S_OK;

  0002c	33 c0		 xor	 eax, eax
  0002e	e9 c2 00 00 00	 jmp	 $L69521
$L69523:

; 293  :         }
; 294  :         ENTER_CRITICAL_SECTION(&m_CriticalSection);

  00033	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00036	83 c2 14	 add	 edx, 20			; 00000014H
  00039	52		 push	 edx
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 295  :         m_TrackList.Clear();

  00040	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	83 c1 44	 add	 ecx, 68			; 00000044H
  00046	e8 00 00 00 00	 call	 ?Clear@CTrackList@@QAEXXZ ; CTrackList::Clear

; 296  :         if( m_pSegment )

  0004b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004e	83 78 38 00	 cmp	 DWORD PTR [eax+56], 0
  00052	74 1c		 je	 SHORT $L69525

; 297  :         {
; 298  :             m_pSegment->Release();

  00054	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00057	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  0005a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005d	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00060	8b 12		 mov	 edx, DWORD PTR [edx]
  00062	51		 push	 ecx
  00063	ff 52 08	 call	 DWORD PTR [edx+8]

; 299  :             m_pSegment = NULL;

  00066	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00069	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [eax+56], 0
$L69525:

; 300  :         }
; 301  :         if( m_pAudioPath)

  00070	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00073	83 79 3c 00	 cmp	 DWORD PTR [ecx+60], 0
  00077	74 1c		 je	 SHORT $L69526

; 302  :         {
; 303  :             m_pAudioPath->Release();

  00079	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0007c	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  0007f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00082	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  00085	8b 00		 mov	 eax, DWORD PTR [eax]
  00087	52		 push	 edx
  00088	ff 50 08	 call	 DWORD PTR [eax+8]

; 304  :             m_pAudioPath = NULL;

  0008b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0008e	c7 41 3c 00 00
	00 00		 mov	 DWORD PTR [ecx+60], 0
$L69526:

; 305  :         }
; 306  :         if (m_pSongSegState)

  00095	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00098	83 ba 28 01 00
	00 00		 cmp	 DWORD PTR [edx+296], 0
  0009f	74 25		 je	 SHORT $L69527

; 307  :         {
; 308  :             m_pSongSegState->Release();

  000a1	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000a4	8b 88 28 01 00
	00		 mov	 ecx, DWORD PTR [eax+296]
  000aa	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000ad	8b 82 28 01 00
	00		 mov	 eax, DWORD PTR [edx+296]
  000b3	8b 09		 mov	 ecx, DWORD PTR [ecx]
  000b5	50		 push	 eax
  000b6	ff 51 08	 call	 DWORD PTR [ecx+8]

; 309  :             m_pSongSegState = NULL;

  000b9	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000bc	c7 82 28 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+296], 0
$L69527:

; 310  :         }
; 311  :         m_pPerformance = NULL;

  000c6	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000c9	c7 40 34 00 00
	00 00		 mov	 DWORD PTR [eax+52], 0

; 312  :         LEAVE_CRITICAL_SECTION(&m_CriticalSection);

  000d0	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000d3	83 c1 14	 add	 ecx, 20			; 00000014H
  000d6	51		 push	 ecx
  000d7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 313  :         if( int nCount = Release() )

  000dd	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000e0	8b 02		 mov	 eax, DWORD PTR [edx]
  000e2	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000e5	51		 push	 ecx
  000e6	ff 50 08	 call	 DWORD PTR [eax+8]
  000e9	89 45 fc	 mov	 DWORD PTR _nCount$69528[ebp], eax

; 314  : 	    {
; 315  : 		    TraceI( 2, "Warning! SegmentState %lx still referenced %d times after Performance has released it.\n", this, nCount );
; 316  : 	    }
; 317  : 
; 318  :         return S_OK;

  000ec	33 c0		 xor	 eax, eax
  000ee	eb 05		 jmp	 SHORT $L69521
$L69522:

; 319  :     }
; 320  :     TraceI(0,"Attempting to delete a NULL SegmentState!\n");
; 321  :     return E_FAIL;

  000f0	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
$L69521:

; 322  : }

  000f5	8b e5		 mov	 esp, ebp
  000f7	5d		 pop	 ebp
  000f8	c3		 ret	 0
?ShutDown@CSegState@@QAEJXZ ENDP			; CSegState::ShutDown
_TEXT	ENDS
PUBLIC	?GetEndTime@CSegState@@QAEJJ@Z			; CSegState::GetEndTime
; Function compile flags: /Odt
;	COMDAT ?GetEndTime@CSegState@@QAEJJ@Z
_TEXT	SEGMENT
tv171 = -48
_this$ = -44
_rtOffset$69540 = -40
_mtOldLength$69542 = -28
_rtEndTime$69541 = -24
_mtOffset$69539 = -12
_length$ = -8
_mtStartTime$ = 8
?GetEndTime@CSegState@@QAEJJ@Z PROC NEAR		; CSegState::GetEndTime, COMDAT
; _this$ = ecx

; 330  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	89 4d d4	 mov	 DWORD PTR _this$[ebp], ecx

; 331  :     ENTER_CRITICAL_SECTION(&m_CriticalSection);

  00009	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 14	 add	 eax, 20			; 00000014H
  0000f	50		 push	 eax
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 332  :     if (m_rtLength && m_pPerformance)

  00016	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	89 4d d0	 mov	 DWORD PTR tv171[ebp], ecx
  0001c	8b 55 d0	 mov	 edx, DWORD PTR tv171[ebp]
  0001f	8b 45 d0	 mov	 eax, DWORD PTR tv171[ebp]
  00022	8b 8a d0 00 00
	00		 mov	 ecx, DWORD PTR [edx+208]
  00028	0b 88 d4 00 00
	00		 or	 ecx, DWORD PTR [eax+212]
  0002e	85 c9		 test	 ecx, ecx
  00030	0f 84 11 01 00
	00		 je	 $L69538
  00036	8b 55 d4	 mov	 edx, DWORD PTR _this$[ebp]
  00039	83 7a 34 00	 cmp	 DWORD PTR [edx+52], 0
  0003d	0f 84 04 01 00
	00		 je	 $L69538

; 333  :     {
; 334  :         // If there is a reference time length, convert it into Music Time.
; 335  :         // ALSO: convert m_mtLength and re-adjust loop points.
; 336  :         MUSIC_TIME mtOffset = m_mtResolvedStart;

  00043	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  00046	8b 48 64	 mov	 ecx, DWORD PTR [eax+100]
  00049	89 4d f4	 mov	 DWORD PTR _mtOffset$69539[ebp], ecx

; 337  :         REFERENCE_TIME rtOffset = 0;

  0004c	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _rtOffset$69540[ebp], 0
  00053	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _rtOffset$69540[ebp+4], 0

; 338  :         m_pPerformance->MusicToReferenceTime(mtOffset, &rtOffset);

  0005a	8d 55 d8	 lea	 edx, DWORD PTR _rtOffset$69540[ebp]
  0005d	52		 push	 edx
  0005e	8b 45 f4	 mov	 eax, DWORD PTR _mtOffset$69539[ebp]
  00061	50		 push	 eax
  00062	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  00065	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00068	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  0006b	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0006e	8b 12		 mov	 edx, DWORD PTR [edx]
  00070	51		 push	 ecx
  00071	ff 52 14	 call	 DWORD PTR [edx+20]

; 339  :         REFERENCE_TIME rtEndTime = (m_rtLength - m_rtStartPoint) + rtOffset; // Convert from length to actual end time.

  00074	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  00077	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  0007a	8b 90 d0 00 00
	00		 mov	 edx, DWORD PTR [eax+208]
  00080	2b 91 b0 00 00
	00		 sub	 edx, DWORD PTR [ecx+176]
  00086	8b 80 d4 00 00
	00		 mov	 eax, DWORD PTR [eax+212]
  0008c	1b 81 b4 00 00
	00		 sbb	 eax, DWORD PTR [ecx+180]
  00092	03 55 d8	 add	 edx, DWORD PTR _rtOffset$69540[ebp]
  00095	13 45 dc	 adc	 eax, DWORD PTR _rtOffset$69540[ebp+4]
  00098	89 55 e8	 mov	 DWORD PTR _rtEndTime$69541[ebp], edx
  0009b	89 45 ec	 mov	 DWORD PTR _rtEndTime$69541[ebp+4], eax

; 340  :         m_pPerformance->ReferenceToMusicTime(rtEndTime, &m_mtEndTime);

  0009e	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  000a1	83 c1 68	 add	 ecx, 104		; 00000068H
  000a4	51		 push	 ecx
  000a5	8b 55 ec	 mov	 edx, DWORD PTR _rtEndTime$69541[ebp+4]
  000a8	52		 push	 edx
  000a9	8b 45 e8	 mov	 eax, DWORD PTR _rtEndTime$69541[ebp]
  000ac	50		 push	 eax
  000ad	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  000b0	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  000b3	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  000b6	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  000b9	8b 12		 mov	 edx, DWORD PTR [edx]
  000bb	51		 push	 ecx
  000bc	ff 52 18	 call	 DWORD PTR [edx+24]

; 341  :         MUSIC_TIME mtOldLength = m_mtLength;

  000bf	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  000c2	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  000c5	89 4d e4	 mov	 DWORD PTR _mtOldLength$69542[ebp], ecx

; 342  :         m_mtLength = m_mtEndTime - mtOffset + m_mtStartPoint;

  000c8	8b 55 d4	 mov	 edx, DWORD PTR _this$[ebp]
  000cb	8b 42 68	 mov	 eax, DWORD PTR [edx+104]
  000ce	2b 45 f4	 sub	 eax, DWORD PTR _mtOffset$69539[ebp]
  000d1	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  000d4	03 41 7c	 add	 eax, DWORD PTR [ecx+124]
  000d7	8b 55 d4	 mov	 edx, DWORD PTR _this$[ebp]
  000da	89 42 54	 mov	 DWORD PTR [edx+84], eax

; 343  :         if (m_mtLoopEnd >= mtOldLength) // keep loop end equal to length

  000dd	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  000e0	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  000e3	3b 4d e4	 cmp	 ecx, DWORD PTR _mtOldLength$69542[ebp]
  000e6	7c 0c		 jl	 SHORT $L69543

; 344  :         {
; 345  :             m_mtLoopEnd = m_mtLength;

  000e8	8b 55 d4	 mov	 edx, DWORD PTR _this$[ebp]
  000eb	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  000ee	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  000f1	89 4a 4c	 mov	 DWORD PTR [edx+76], ecx
$L69543:

; 346  :         }
; 347  :         if( m_mtLoopEnd > m_mtLength ) // shrink loop end to equal length

  000f4	8b 55 d4	 mov	 edx, DWORD PTR _this$[ebp]
  000f7	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  000fa	8b 4a 4c	 mov	 ecx, DWORD PTR [edx+76]
  000fd	3b 48 54	 cmp	 ecx, DWORD PTR [eax+84]
  00100	7e 45		 jle	 SHORT $L69538

; 348  :         {
; 349  :             m_mtLoopEnd = m_mtLength;

  00102	8b 55 d4	 mov	 edx, DWORD PTR _this$[ebp]
  00105	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  00108	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  0010b	89 4a 4c	 mov	 DWORD PTR [edx+76], ecx

; 350  :             if( m_mtStartPoint >= m_mtLoopEnd )

  0010e	8b 55 d4	 mov	 edx, DWORD PTR _this$[ebp]
  00111	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  00114	8b 4a 7c	 mov	 ecx, DWORD PTR [edx+124]
  00117	3b 48 4c	 cmp	 ecx, DWORD PTR [eax+76]
  0011a	7c 2b		 jl	 SHORT $L69538

; 351  :             {
; 352  :                 // in this case, we're not doing any looping.
; 353  :                 m_mtLoopEnd = m_mtLoopStart = 0;

  0011c	8b 55 d4	 mov	 edx, DWORD PTR _this$[ebp]
  0011f	c7 42 48 00 00
	00 00		 mov	 DWORD PTR [edx+72], 0
  00126	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  00129	c7 40 4c 00 00
	00 00		 mov	 DWORD PTR [eax+76], 0

; 354  :                 m_dwRepeats = m_dwRepeatsLeft = 0;

  00130	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  00133	c7 81 00 01 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+256], 0
  0013d	8b 55 d4	 mov	 edx, DWORD PTR _this$[ebp]
  00140	c7 42 50 00 00
	00 00		 mov	 DWORD PTR [edx+80], 0
$L69538:

; 355  :             }
; 356  :         }
; 357  :     }
; 358  :     LEAVE_CRITICAL_SECTION(&m_CriticalSection);

  00147	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  0014a	83 c0 14	 add	 eax, 20			; 00000014H
  0014d	50		 push	 eax
  0014e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 359  : 	LONGLONG length;
; 360  : 	length = m_mtLength + ((m_mtLoopEnd - m_mtLoopStart) * m_dwRepeats);

  00154	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  00157	8b 55 d4	 mov	 edx, DWORD PTR _this$[ebp]
  0015a	8b 41 4c	 mov	 eax, DWORD PTR [ecx+76]
  0015d	2b 42 48	 sub	 eax, DWORD PTR [edx+72]
  00160	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  00163	0f af 41 50	 imul	 eax, DWORD PTR [ecx+80]
  00167	8b 55 d4	 mov	 edx, DWORD PTR _this$[ebp]
  0016a	8b 4a 54	 mov	 ecx, DWORD PTR [edx+84]
  0016d	03 c8		 add	 ecx, eax
  0016f	33 d2		 xor	 edx, edx
  00171	89 4d f8	 mov	 DWORD PTR _length$[ebp], ecx
  00174	89 55 fc	 mov	 DWORD PTR _length$[ebp+4], edx

; 361  : 	length -= m_mtStartPoint;

  00177	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  0017a	8b 40 7c	 mov	 eax, DWORD PTR [eax+124]
  0017d	99		 cdq
  0017e	8b 4d f8	 mov	 ecx, DWORD PTR _length$[ebp]
  00181	2b c8		 sub	 ecx, eax
  00183	8b 45 fc	 mov	 eax, DWORD PTR _length$[ebp+4]
  00186	1b c2		 sbb	 eax, edx
  00188	89 4d f8	 mov	 DWORD PTR _length$[ebp], ecx
  0018b	89 45 fc	 mov	 DWORD PTR _length$[ebp+4], eax

; 362  :     length += mtStartTime;

  0018e	8b 45 08	 mov	 eax, DWORD PTR _mtStartTime$[ebp]
  00191	99		 cdq
  00192	8b 4d f8	 mov	 ecx, DWORD PTR _length$[ebp]
  00195	03 c8		 add	 ecx, eax
  00197	8b 45 fc	 mov	 eax, DWORD PTR _length$[ebp+4]
  0019a	13 c2		 adc	 eax, edx
  0019c	89 4d f8	 mov	 DWORD PTR _length$[ebp], ecx
  0019f	89 45 fc	 mov	 DWORD PTR _length$[ebp+4], eax

; 363  : 	if(length > 0x7fffffff) length = 0x7fffffff;

  001a2	83 7d fc 00	 cmp	 DWORD PTR _length$[ebp+4], 0
  001a6	7c 19		 jl	 SHORT $L69547
  001a8	7f 09		 jg	 SHORT $L70662
  001aa	81 7d f8 ff ff
	ff 7f		 cmp	 DWORD PTR _length$[ebp], 2147483647 ; 7fffffffH
  001b1	76 0e		 jbe	 SHORT $L69547
$L70662:
  001b3	c7 45 f8 ff ff
	ff 7f		 mov	 DWORD PTR _length$[ebp], 2147483647 ; 7fffffffH
  001ba	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _length$[ebp+4], 0
$L69547:

; 364  : 	return (MUSIC_TIME)length;

  001c1	8b 45 f8	 mov	 eax, DWORD PTR _length$[ebp]

; 365  : }

  001c4	8b e5		 mov	 esp, ebp
  001c6	5d		 pop	 ebp
  001c7	c2 04 00	 ret	 4
?GetEndTime@CSegState@@QAEJJ@Z ENDP			; CSegState::GetEndTime
_TEXT	ENDS
PUBLIC	?ConvertToSegTime@CSegState@@QAEJPAJ0PAK@Z	; CSegState::ConvertToSegTime
PUBLIC	??_C@_07JPGHMFOH@pmtTime?$AA@			; `string'
PUBLIC	??_C@_09GJFDDKPJ@pmtOffset?$AA@			; `string'
PUBLIC	??_C@_09FGDJMGFM@pdwRepeat?$AA@			; `string'
;	COMDAT ??_C@_07JPGHMFOH@pmtTime?$AA@
CONST	SEGMENT
??_C@_07JPGHMFOH@pmtTime?$AA@ DB 'pmtTime', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09GJFDDKPJ@pmtOffset?$AA@
CONST	SEGMENT
??_C@_09GJFDDKPJ@pmtOffset?$AA@ DB 'pmtOffset', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09FGDJMGFM@pdwRepeat?$AA@
CONST	SEGMENT
??_C@_09FGDJMGFM@pdwRepeat?$AA@ DB 'pdwRepeat', 00H	; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?ConvertToSegTime@CSegState@@QAEJPAJ0PAK@Z
_TEXT	SEGMENT
_this$ = -20
_mtLoopLength$ = -16
_dwRepeat$ = -12
_mtPos$ = -8
_mtOffset$ = -4
_pmtTime$ = 8
_pmtOffset$ = 12
_pdwRepeat$ = 16
?ConvertToSegTime@CSegState@@QAEJPAJ0PAK@Z PROC NEAR	; CSegState::ConvertToSegTime, COMDAT
; _this$ = ecx

; 374  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 375  : 	ASSERT( pmtTime );

  00009	83 7d 08 00	 cmp	 DWORD PTR _pmtTime$[ebp], 0
  0000d	75 17		 jne	 SHORT $L69555
  0000f	6a 00		 push	 0
  00011	68 77 01 00 00	 push	 375			; 00000177H
  00016	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NBCHJFPK@c?3?2xbox?2private?2windows?2directx?2@
  0001b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07JPGHMFOH@pmtTime?$AA@
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
$L69555:

; 376  : 	ASSERT( pmtOffset );

  00026	83 7d 0c 00	 cmp	 DWORD PTR _pmtOffset$[ebp], 0
  0002a	75 17		 jne	 SHORT $L69557
  0002c	6a 00		 push	 0
  0002e	68 78 01 00 00	 push	 376			; 00000178H
  00033	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NBCHJFPK@c?3?2xbox?2private?2windows?2directx?2@
  00038	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_09GJFDDKPJ@pmtOffset?$AA@
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
$L69557:

; 377  : 	ASSERT( pdwRepeat );

  00043	83 7d 10 00	 cmp	 DWORD PTR _pdwRepeat$[ebp], 0
  00047	75 17		 jne	 SHORT $L69559
  00049	6a 00		 push	 0
  0004b	68 79 01 00 00	 push	 377			; 00000179H
  00050	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NBCHJFPK@c?3?2xbox?2private?2windows?2directx?2@
  00055	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_09FGDJMGFM@pdwRepeat?$AA@
  0005a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
$L69559:

; 378  : 
; 379  : 	MUSIC_TIME mtPos = *pmtTime - m_mtResolvedStart + m_mtStartPoint;

  00060	8b 45 08	 mov	 eax, DWORD PTR _pmtTime$[ebp]
  00063	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00066	8b 10		 mov	 edx, DWORD PTR [eax]
  00068	2b 51 64	 sub	 edx, DWORD PTR [ecx+100]
  0006b	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	03 50 7c	 add	 edx, DWORD PTR [eax+124]
  00071	89 55 f8	 mov	 DWORD PTR _mtPos$[ebp], edx

; 380  : 	MUSIC_TIME mtLoopLength = m_mtLoopEnd - m_mtLoopStart;

  00074	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00077	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0007a	8b 41 4c	 mov	 eax, DWORD PTR [ecx+76]
  0007d	2b 42 48	 sub	 eax, DWORD PTR [edx+72]
  00080	89 45 f0	 mov	 DWORD PTR _mtLoopLength$[ebp], eax

; 381  : 	DWORD dwRepeat = 0;

  00083	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _dwRepeat$[ebp], 0

; 382  : 	DWORD mtOffset = m_mtResolvedStart - m_mtStartPoint;

  0008a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0008d	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00090	8b 41 64	 mov	 eax, DWORD PTR [ecx+100]
  00093	2b 42 7c	 sub	 eax, DWORD PTR [edx+124]
  00096	89 45 fc	 mov	 DWORD PTR _mtOffset$[ebp], eax
$L69566:

; 383  : 
; 384  : 	while( mtPos >= m_mtLoopEnd )

  00099	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0009c	8b 55 f8	 mov	 edx, DWORD PTR _mtPos$[ebp]
  0009f	3b 51 4c	 cmp	 edx, DWORD PTR [ecx+76]
  000a2	7c 2a		 jl	 SHORT $L69567

; 385  : 	{
; 386  : 		if( dwRepeat >= m_dwRepeats ) break;

  000a4	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000a7	8b 4d f4	 mov	 ecx, DWORD PTR _dwRepeat$[ebp]
  000aa	3b 48 50	 cmp	 ecx, DWORD PTR [eax+80]
  000ad	72 02		 jb	 SHORT $L69568
  000af	eb 1d		 jmp	 SHORT $L69567
$L69568:

; 387  : 		mtPos -= mtLoopLength;

  000b1	8b 55 f8	 mov	 edx, DWORD PTR _mtPos$[ebp]
  000b4	2b 55 f0	 sub	 edx, DWORD PTR _mtLoopLength$[ebp]
  000b7	89 55 f8	 mov	 DWORD PTR _mtPos$[ebp], edx

; 388  : 		mtOffset += mtLoopLength;

  000ba	8b 45 fc	 mov	 eax, DWORD PTR _mtOffset$[ebp]
  000bd	03 45 f0	 add	 eax, DWORD PTR _mtLoopLength$[ebp]
  000c0	89 45 fc	 mov	 DWORD PTR _mtOffset$[ebp], eax

; 389  : 		dwRepeat++;

  000c3	8b 4d f4	 mov	 ecx, DWORD PTR _dwRepeat$[ebp]
  000c6	83 c1 01	 add	 ecx, 1
  000c9	89 4d f4	 mov	 DWORD PTR _dwRepeat$[ebp], ecx

; 390  : 	}

  000cc	eb cb		 jmp	 SHORT $L69566
$L69567:

; 391  : 	*pmtTime = mtPos;

  000ce	8b 55 08	 mov	 edx, DWORD PTR _pmtTime$[ebp]
  000d1	8b 45 f8	 mov	 eax, DWORD PTR _mtPos$[ebp]
  000d4	89 02		 mov	 DWORD PTR [edx], eax

; 392  : 	*pmtOffset = mtOffset;

  000d6	8b 4d 0c	 mov	 ecx, DWORD PTR _pmtOffset$[ebp]
  000d9	8b 55 fc	 mov	 edx, DWORD PTR _mtOffset$[ebp]
  000dc	89 11		 mov	 DWORD PTR [ecx], edx

; 393  : 	*pdwRepeat = dwRepeat;

  000de	8b 45 10	 mov	 eax, DWORD PTR _pdwRepeat$[ebp]
  000e1	8b 4d f4	 mov	 ecx, DWORD PTR _dwRepeat$[ebp]
  000e4	89 08		 mov	 DWORD PTR [eax], ecx

; 394  : 	if( (mtPos >= 0) && (mtPos < m_mtLength) )

  000e6	83 7d f8 00	 cmp	 DWORD PTR _mtPos$[ebp], 0
  000ea	7c 0f		 jl	 SHORT $L69569
  000ec	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000ef	8b 45 f8	 mov	 eax, DWORD PTR _mtPos$[ebp]
  000f2	3b 42 54	 cmp	 eax, DWORD PTR [edx+84]
  000f5	7d 04		 jge	 SHORT $L69569

; 395  : 	{
; 396  : 		return S_OK;	// time is in range of the Segment

  000f7	33 c0		 xor	 eax, eax
  000f9	eb 05		 jmp	 SHORT $L69554
$L69569:

; 397  : 	}
; 398  : 	else
; 399  : 	{
; 400  : 		return S_FALSE; // time is out of range of the Segment

  000fb	b8 01 00 00 00	 mov	 eax, 1
$L69554:

; 401  : 	}
; 402  : }

  00100	8b e5		 mov	 esp, ebp
  00102	5d		 pop	 ebp
  00103	c2 0c 00	 ret	 12			; 0000000cH
?ConvertToSegTime@CSegState@@QAEJPAJ0PAK@Z ENDP		; CSegState::ConvertToSegTime
_TEXT	ENDS
PUBLIC	?GenerateNotification@CSegState@@AAEXKJ@Z	; CSegState::GenerateNotification
EXTRN	?CheckNotification@CSegment@@QAEJABU_GUID@@@Z:NEAR ; CSegment::CheckNotification
EXTRN	_GUID_NOTIFICATION_SEGMENT:BYTE
; Function compile flags: /Odt
;	COMDAT ?GenerateNotification@CSegState@@AAEXKJ@Z
_TEXT	SEGMENT
_this$ = -28
_pEvent$69582 = -24
_hr$ = -20
_guid$ = -16
_dwNotification$ = 8
_mtTime$ = 12
?GenerateNotification@CSegState@@AAEXKJ@Z PROC NEAR	; CSegState::GenerateNotification, COMDAT
; _this$ = ecx

; 405  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 406  : 	GUID guid;
; 407  : 	HRESULT hr;
; 408  : 	guid = GUID_NOTIFICATION_SEGMENT;

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _GUID_NOTIFICATION_SEGMENT
  0000e	89 45 f0	 mov	 DWORD PTR _guid$[ebp], eax
  00011	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR _GUID_NOTIFICATION_SEGMENT+4
  00017	89 4d f4	 mov	 DWORD PTR _guid$[ebp+4], ecx
  0001a	8b 15 08 00 00
	00		 mov	 edx, DWORD PTR _GUID_NOTIFICATION_SEGMENT+8
  00020	89 55 f8	 mov	 DWORD PTR _guid$[ebp+8], edx
  00023	a1 0c 00 00 00	 mov	 eax, DWORD PTR _GUID_NOTIFICATION_SEGMENT+12
  00028	89 45 fc	 mov	 DWORD PTR _guid$[ebp+12], eax

; 409  : 
; 410  : 	hr = m_pSegment->CheckNotification( guid );

  0002b	8d 4d f0	 lea	 ecx, DWORD PTR _guid$[ebp]
  0002e	51		 push	 ecx
  0002f	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  00032	8b 4a 38	 mov	 ecx, DWORD PTR [edx+56]
  00035	e8 00 00 00 00	 call	 ?CheckNotification@CSegment@@QAEJABU_GUID@@@Z ; CSegment::CheckNotification
  0003a	89 45 ec	 mov	 DWORD PTR _hr$[ebp], eax

; 411  : 
; 412  : 	if( S_FALSE != hr )

  0003d	83 7d ec 01	 cmp	 DWORD PTR _hr$[ebp], 1
  00041	0f 84 f5 00 00
	00		 je	 $L69577

; 413  :     {
; 414  : 	    DMUS_NOTIFICATION_PMSG* pEvent = NULL;

  00047	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _pEvent$69582[ebp], 0

; 415  : 	    if( SUCCEEDED( m_pPerformance->AllocPMsg( sizeof(DMUS_NOTIFICATION_PMSG), 
; 416  : 		    (DMUS_PMSG**)&pEvent )))

  0004e	8d 45 e8	 lea	 eax, DWORD PTR _pEvent$69582[ebp]
  00051	50		 push	 eax
  00052	6a 58		 push	 88			; 00000058H
  00054	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00057	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  0005a	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0005d	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00060	8b 12		 mov	 edx, DWORD PTR [edx]
  00062	51		 push	 ecx
  00063	ff 52 24	 call	 DWORD PTR [edx+36]
  00066	85 c0		 test	 eax, eax
  00068	0f 8c ce 00 00
	00		 jl	 $L69577

; 417  : 	    {
; 418  : 		    pEvent->dwField1 = 0;

  0006e	8b 45 e8	 mov	 eax, DWORD PTR _pEvent$69582[ebp]
  00071	c7 40 4c 00 00
	00 00		 mov	 DWORD PTR [eax+76], 0

; 419  : 		    pEvent->dwField2 = 0;

  00078	8b 4d e8	 mov	 ecx, DWORD PTR _pEvent$69582[ebp]
  0007b	c7 41 50 00 00
	00 00		 mov	 DWORD PTR [ecx+80], 0

; 420  : 		    pEvent->guidNotificationType = GUID_NOTIFICATION_SEGMENT;

  00082	8b 55 e8	 mov	 edx, DWORD PTR _pEvent$69582[ebp]
  00085	83 c2 38	 add	 edx, 56			; 00000038H
  00088	a1 00 00 00 00	 mov	 eax, DWORD PTR _GUID_NOTIFICATION_SEGMENT
  0008d	89 02		 mov	 DWORD PTR [edx], eax
  0008f	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR _GUID_NOTIFICATION_SEGMENT+4
  00095	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00098	a1 08 00 00 00	 mov	 eax, DWORD PTR _GUID_NOTIFICATION_SEGMENT+8
  0009d	89 42 08	 mov	 DWORD PTR [edx+8], eax
  000a0	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _GUID_NOTIFICATION_SEGMENT+12
  000a6	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 421  : 		    pEvent->dwType = DMUS_PMSGT_NOTIFICATION;

  000a9	8b 55 e8	 mov	 edx, DWORD PTR _pEvent$69582[ebp]
  000ac	c7 42 28 03 00
	00 00		 mov	 DWORD PTR [edx+40], 3

; 422  : 		    pEvent->mtTime = mtTime;

  000b3	8b 45 e8	 mov	 eax, DWORD PTR _pEvent$69582[ebp]
  000b6	8b 4d 0c	 mov	 ecx, DWORD PTR _mtTime$[ebp]
  000b9	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 423  : 		    pEvent->dwFlags = DMUS_PMSGF_MUSICTIME | DMUS_PMSGF_TOOL_ATTIME;

  000bc	8b 55 e8	 mov	 edx, DWORD PTR _pEvent$69582[ebp]
  000bf	c7 42 14 12 00
	00 00		 mov	 DWORD PTR [edx+20], 18	; 00000012H

; 424  :             pEvent->dwPChannel = 0;

  000c6	8b 45 e8	 mov	 eax, DWORD PTR _pEvent$69582[ebp]
  000c9	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 425  : 		    pEvent->dwNotificationOption = dwNotification;

  000d0	8b 4d e8	 mov	 ecx, DWORD PTR _pEvent$69582[ebp]
  000d3	8b 55 08	 mov	 edx, DWORD PTR _dwNotification$[ebp]
  000d6	89 51 48	 mov	 DWORD PTR [ecx+72], edx

; 426  : 		    pEvent->dwGroupID = 0xffffffff;

  000d9	8b 45 e8	 mov	 eax, DWORD PTR _pEvent$69582[ebp]
  000dc	c7 40 30 ff ff
	ff ff		 mov	 DWORD PTR [eax+48], -1

; 427  : 		    pEvent->punkUser = (IUnknown*)(IDirectMusicSegmentState*)this;

  000e3	8b 4d e8	 mov	 ecx, DWORD PTR _pEvent$69582[ebp]
  000e6	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  000e9	89 51 34	 mov	 DWORD PTR [ecx+52], edx

; 428  : 		    AddRef();

  000ec	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  000ef	8b 08		 mov	 ecx, DWORD PTR [eax]
  000f1	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  000f4	52		 push	 edx
  000f5	ff 51 04	 call	 DWORD PTR [ecx+4]

; 429  : 		    StampPMsg((DMUS_PMSG*)pEvent);

  000f8	8b 45 e8	 mov	 eax, DWORD PTR _pEvent$69582[ebp]
  000fb	50		 push	 eax
  000fc	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  000ff	83 c1 04	 add	 ecx, 4
  00102	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  00105	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00108	51		 push	 ecx
  00109	ff 50 0c	 call	 DWORD PTR [eax+12]

; 430  : 			if(FAILED(m_pPerformance->SendPMsg( (DMUS_PMSG*)pEvent )))

  0010c	8b 4d e8	 mov	 ecx, DWORD PTR _pEvent$69582[ebp]
  0010f	51		 push	 ecx
  00110	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  00113	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  00116	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00119	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  0011c	8b 00		 mov	 eax, DWORD PTR [eax]
  0011e	52		 push	 edx
  0011f	ff 50 10	 call	 DWORD PTR [eax+16]
  00122	85 c0		 test	 eax, eax
  00124	7d 16		 jge	 SHORT $L69577

; 431  : 			{
; 432  : 				m_pPerformance->FreePMsg((DMUS_PMSG*) pEvent );

  00126	8b 4d e8	 mov	 ecx, DWORD PTR _pEvent$69582[ebp]
  00129	51		 push	 ecx
  0012a	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  0012d	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  00130	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00133	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00136	8b 00		 mov	 eax, DWORD PTR [eax]
  00138	52		 push	 edx
  00139	ff 50 28	 call	 DWORD PTR [eax+40]
$L69577:

; 433  : 			}
; 434  : 		}
; 435  : 	}
; 436  : }

  0013c	8b e5		 mov	 esp, ebp
  0013e	5d		 pop	 ebp
  0013f	c2 08 00	 ret	 8
?GenerateNotification@CSegState@@AAEXKJ@Z ENDP		; CSegState::GenerateNotification
_TEXT	ENDS
PUBLIC	?SendDirtyPMsg@CSegState@@AAEXJ@Z		; CSegState::SendDirtyPMsg
; Function compile flags: /Odt
;	COMDAT ?SendDirtyPMsg@CSegState@@AAEXJ@Z
_TEXT	SEGMENT
_this$ = -8
_pEvent$ = -4
_mtTime$ = 8
?SendDirtyPMsg@CSegState@@AAEXJ@Z PROC NEAR		; CSegState::SendDirtyPMsg, COMDAT
; _this$ = ecx

; 443  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 444  : 	DMUS_PMSG* pEvent = NULL;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pEvent$[ebp], 0

; 445  :     if (m_pPerformance)

  00010	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 78 34 00	 cmp	 DWORD PTR [eax+52], 0
  00017	0f 84 87 00 00
	00		 je	 $L69597

; 446  :     {
; 447  : 	    if( SUCCEEDED( m_pPerformance->AllocPMsg( sizeof(DMUS_PMSG), 
; 448  : 		    (DMUS_PMSG**)&pEvent )))

  0001d	8d 4d fc	 lea	 ecx, DWORD PTR _pEvent$[ebp]
  00020	51		 push	 ecx
  00021	6a 38		 push	 56			; 00000038H
  00023	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00026	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  00029	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  0002f	8b 00		 mov	 eax, DWORD PTR [eax]
  00031	52		 push	 edx
  00032	ff 50 24	 call	 DWORD PTR [eax+36]
  00035	85 c0		 test	 eax, eax
  00037	7c 6b		 jl	 SHORT $L69597

; 449  : 	    {
; 450  : 		    pEvent->mtTime = mtTime;

  00039	8b 4d fc	 mov	 ecx, DWORD PTR _pEvent$[ebp]
  0003c	8b 55 08	 mov	 edx, DWORD PTR _mtTime$[ebp]
  0003f	89 51 10	 mov	 DWORD PTR [ecx+16], edx

; 451  : 		    pEvent->dwFlags = DMUS_PMSGF_MUSICTIME | DMUS_PMSGF_TOOL_IMMEDIATE;

  00042	8b 45 fc	 mov	 eax, DWORD PTR _pEvent$[ebp]
  00045	c7 40 14 06 00
	00 00		 mov	 DWORD PTR [eax+20], 6

; 452  : 		    pEvent->dwGroupID = 0xffffffff;

  0004c	8b 4d fc	 mov	 ecx, DWORD PTR _pEvent$[ebp]
  0004f	c7 41 30 ff ff
	ff ff		 mov	 DWORD PTR [ecx+48], -1

; 453  : 		    pEvent->dwType = DMUS_PMSGT_DIRTY;

  00056	8b 55 fc	 mov	 edx, DWORD PTR _pEvent$[ebp]
  00059	c7 42 28 0b 00
	00 00		 mov	 DWORD PTR [edx+40], 11	; 0000000bH

; 454  : 		    StampPMsg((DMUS_PMSG*)pEvent);

  00060	8b 45 fc	 mov	 eax, DWORD PTR _pEvent$[ebp]
  00063	50		 push	 eax
  00064	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00067	83 c1 04	 add	 ecx, 4
  0006a	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0006d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00070	51		 push	 ecx
  00071	ff 50 0c	 call	 DWORD PTR [eax+12]

; 455  : 		    if( FAILED( m_pPerformance->SendPMsg( pEvent )))

  00074	8b 4d fc	 mov	 ecx, DWORD PTR _pEvent$[ebp]
  00077	51		 push	 ecx
  00078	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0007b	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  0007e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00081	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00084	8b 00		 mov	 eax, DWORD PTR [eax]
  00086	52		 push	 edx
  00087	ff 50 10	 call	 DWORD PTR [eax+16]
  0008a	85 c0		 test	 eax, eax
  0008c	7d 16		 jge	 SHORT $L69597

; 456  : 		    {
; 457  : 			    m_pPerformance->FreePMsg( pEvent );

  0008e	8b 4d fc	 mov	 ecx, DWORD PTR _pEvent$[ebp]
  00091	51		 push	 ecx
  00092	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00095	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  00098	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0009b	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  0009e	8b 00		 mov	 eax, DWORD PTR [eax]
  000a0	52		 push	 edx
  000a1	ff 50 28	 call	 DWORD PTR [eax+40]
$L69597:

; 458  : 		    }
; 459  : 	    }
; 460  :     }
; 461  : }

  000a4	8b e5		 mov	 esp, ebp
  000a6	5d		 pop	 ebp
  000a7	c2 04 00	 ret	 4
?SendDirtyPMsg@CSegState@@AAEXJ@Z ENDP			; CSegState::SendDirtyPMsg
_TEXT	ENDS
PUBLIC	?AbortPlay@CSegState@@QAEJJH@Z			; CSegState::AbortPlay
PUBLIC	?GetNext@CTrack@@QAEPAV1@XZ			; CTrack::GetNext
PUBLIC	?GetHead@CTrackList@@QAEPAVCTrack@@XZ		; CTrackList::GetHead
EXTRN	_CLSID_DirectMusicParamControlTrack:BYTE
EXTRN	_IID_CParamControlTrack:BYTE
EXTRN	?FlushVirtualTrack@CPerformance@@QAEJKJK@Z:NEAR	; CPerformance::FlushVirtualTrack
; Function compile flags: /Odt
;	COMDAT ?AbortPlay@CSegState@@QAEJJH@Z
_TEXT	SEGMENT
_this$ = -16
_pParamTrack$69628 = -12
_pTrack$69614 = -8
_pTrack$ = -4
_mtTime$ = 8
_fLeaveNotesOn$ = 12
?AbortPlay@CSegState@@QAEJJH@Z PROC NEAR		; CSegState::AbortPlay, COMDAT
; _this$ = ecx

; 469  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 470  :     ENTER_CRITICAL_SECTION(&m_CriticalSection);

  00009	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 14	 add	 eax, 20			; 00000014H
  0000f	50		 push	 eax
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 471  :     if (m_pPerformance)

  00016	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	83 79 34 00	 cmp	 DWORD PTR [ecx+52], 0
  0001d	74 6d		 je	 SHORT $L69612

; 472  :     {
; 473  :         if( m_mtLastPlayed > mtTime )

  0001f	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00022	8b 42 70	 mov	 eax, DWORD PTR [edx+112]
  00025	3b 45 08	 cmp	 eax, DWORD PTR _mtTime$[ebp]
  00028	7e 42		 jle	 SHORT $L69613

; 474  :         {
; 475  :             // If we've played past the abort time, we need to flush messages. 
; 476  :             // Note that if we were aborted by playing another segment that had
; 477  :             // the DMUS_SEGF_NOINVALIDATE flag set, don't truncate notes
; 478  :             // that are currently on.
; 479  :             CTrack*	pTrack;
; 480  : 	        pTrack = m_TrackList.GetHead();

  0002a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	83 c1 44	 add	 ecx, 68			; 00000044H
  00030	e8 00 00 00 00	 call	 ?GetHead@CTrackList@@QAEPAVCTrack@@XZ ; CTrackList::GetHead
  00035	89 45 f8	 mov	 DWORD PTR _pTrack$69614[ebp], eax
$L69616:

; 481  : 	        while( pTrack )

  00038	83 7d f8 00	 cmp	 DWORD PTR _pTrack$69614[ebp], 0
  0003c	74 25		 je	 SHORT $L69617

; 482  : 	        {
; 483  : 		        m_pPerformance->FlushVirtualTrack( pTrack->m_dwVirtualID, mtTime, FLUSH_LEAVE_ON );

  0003e	6a 01		 push	 1
  00040	8b 4d 08	 mov	 ecx, DWORD PTR _mtTime$[ebp]
  00043	51		 push	 ecx
  00044	8b 55 f8	 mov	 edx, DWORD PTR _pTrack$69614[ebp]
  00047	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  0004a	50		 push	 eax
  0004b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0004e	8b 49 34	 mov	 ecx, DWORD PTR [ecx+52]
  00051	e8 00 00 00 00	 call	 ?FlushVirtualTrack@CPerformance@@QAEJKJK@Z ; CPerformance::FlushVirtualTrack

; 484  : 		        pTrack = pTrack->GetNext();

  00056	8b 4d f8	 mov	 ecx, DWORD PTR _pTrack$69614[ebp]
  00059	e8 00 00 00 00	 call	 ?GetNext@CTrack@@QAEPAV1@XZ ; CTrack::GetNext
  0005e	89 45 f8	 mov	 DWORD PTR _pTrack$69614[ebp], eax

; 485  : 	        }

  00061	eb d5		 jmp	 SHORT $L69616
$L69617:

; 486  :             m_mtLastPlayed = mtTime;

  00063	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00066	8b 45 08	 mov	 eax, DWORD PTR _mtTime$[ebp]
  00069	89 42 70	 mov	 DWORD PTR [edx+112], eax
$L69613:

; 487  :         }
; 488  :         // Always fill in the updated value for lastplayed so the ShutDown or Done queue will flush this
; 489  :         // at the right time.
; 490  :         m_pPerformance->MusicToReferenceTime(mtTime,&m_rtLastPlayed);

  0006c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0006f	81 c1 a8 00 00
	00		 add	 ecx, 168		; 000000a8H
  00075	51		 push	 ecx
  00076	8b 55 08	 mov	 edx, DWORD PTR _mtTime$[ebp]
  00079	52		 push	 edx
  0007a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0007d	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00080	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00083	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  00086	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00088	50		 push	 eax
  00089	ff 51 14	 call	 DWORD PTR [ecx+20]
$L69612:

; 491  :     }
; 492  :     LEAVE_CRITICAL_SECTION(&m_CriticalSection);

  0008c	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0008f	83 c2 14	 add	 edx, 20			; 00000014H
  00092	52		 push	 edx
  00093	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 493  :     // Always generate an abort for a segment that has not started playing yet. 
; 494  :     if (m_fStartedPlay && (m_mtEndTime <= mtTime))

  00099	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0009c	83 b8 04 01 00
	00 00		 cmp	 DWORD PTR [eax+260], 0
  000a3	74 15		 je	 SHORT $L69618
  000a5	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000a8	8b 51 68	 mov	 edx, DWORD PTR [ecx+104]
  000ab	3b 55 08	 cmp	 edx, DWORD PTR _mtTime$[ebp]
  000ae	7f 0a		 jg	 SHORT $L69618

; 495  :     {
; 496  :         return S_FALSE; // Abort was too late to matter.

  000b0	b8 01 00 00 00	 mov	 eax, 1
  000b5	e9 0f 01 00 00	 jmp	 $L69611
$L69618:

; 497  :     }
; 498  :     if (m_mtAbortTime)  // Previous abort.

  000ba	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000bd	83 b8 80 00 00
	00 00		 cmp	 DWORD PTR [eax+128], 0
  000c4	74 18		 je	 SHORT $L69620

; 499  :     {
; 500  :         if (m_mtAbortTime <= mtTime) // Is this earlier?

  000c6	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000c9	8b 91 80 00 00
	00		 mov	 edx, DWORD PTR [ecx+128]
  000cf	3b 55 08	 cmp	 edx, DWORD PTR _mtTime$[ebp]
  000d2	7f 0a		 jg	 SHORT $L69620

; 501  :         {
; 502  :             return S_FALSE;     // No, don't send abort message.

  000d4	b8 01 00 00 00	 mov	 eax, 1
  000d9	e9 eb 00 00 00	 jmp	 $L69611
$L69620:

; 503  :         }
; 504  :     }
; 505  :     m_mtAbortTime = mtTime;

  000de	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000e1	8b 4d 08	 mov	 ecx, DWORD PTR _mtTime$[ebp]
  000e4	89 88 80 00 00
	00		 mov	 DWORD PTR [eax+128], ecx

; 506  :     // Find all the parameter control tracks and invalidate any parameter envelopes
; 507  :     // that need invalidation.
; 508  : 	CTrack* pTrack = m_TrackList.GetHead();

  000ea	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000ed	83 c1 44	 add	 ecx, 68			; 00000044H
  000f0	e8 00 00 00 00	 call	 ?GetHead@CTrackList@@QAEPAVCTrack@@XZ ; CTrackList::GetHead
  000f5	89 45 fc	 mov	 DWORD PTR _pTrack$[ebp], eax
$L69625:

; 509  : 	while( pTrack )

  000f8	83 7d fc 00	 cmp	 DWORD PTR _pTrack$[ebp], 0
  000fc	0f 84 82 00 00
	00		 je	 $L69626

; 510  : 	{
; 511  :         if (pTrack->m_guidClassID == CLSID_DirectMusicParamControlTrack)

  00102	68 00 00 00 00	 push	 OFFSET FLAT:_CLSID_DirectMusicParamControlTrack
  00107	8b 55 fc	 mov	 edx, DWORD PTR _pTrack$[ebp]
  0010a	83 c2 04	 add	 edx, 4
  0010d	52		 push	 edx
  0010e	e8 00 00 00 00	 call	 _==@8
  00113	85 c0		 test	 eax, eax
  00115	74 5d		 je	 SHORT $L69627

; 512  :         {
; 513  :             CParamControlTrack* pParamTrack = NULL;

  00117	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _pParamTrack$69628[ebp], 0

; 514  :             if (pTrack->m_pTrack &&
; 515  :                 SUCCEEDED(pTrack->m_pTrack->QueryInterface(IID_CParamControlTrack, (void**)&pParamTrack)))

  0011e	8b 45 fc	 mov	 eax, DWORD PTR _pTrack$[ebp]
  00121	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  00125	74 4d		 je	 SHORT $L69627
  00127	8d 4d f4	 lea	 ecx, DWORD PTR _pParamTrack$69628[ebp]
  0012a	51		 push	 ecx
  0012b	68 00 00 00 00	 push	 OFFSET FLAT:_IID_CParamControlTrack
  00130	8b 55 fc	 mov	 edx, DWORD PTR _pTrack$[ebp]
  00133	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00136	8b 4d fc	 mov	 ecx, DWORD PTR _pTrack$[ebp]
  00139	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0013c	8b 00		 mov	 eax, DWORD PTR [eax]
  0013e	52		 push	 edx
  0013f	ff 10		 call	 DWORD PTR [eax]
  00141	85 c0		 test	 eax, eax
  00143	7c 2f		 jl	 SHORT $L69627

; 516  :             {
; 517  :                 pParamTrack->OnSegmentEnd(m_rtLastPlayed, pTrack->m_pTrackState);

  00145	8b 4d fc	 mov	 ecx, DWORD PTR _pTrack$[ebp]
  00148	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0014b	52		 push	 edx
  0014c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0014f	8b 88 ac 00 00
	00		 mov	 ecx, DWORD PTR [eax+172]
  00155	51		 push	 ecx
  00156	8b 90 a8 00 00
	00		 mov	 edx, DWORD PTR [eax+168]
  0015c	52		 push	 edx
  0015d	8b 45 f4	 mov	 eax, DWORD PTR _pParamTrack$69628[ebp]
  00160	8b 10		 mov	 edx, DWORD PTR [eax]
  00162	8b 4d f4	 mov	 ecx, DWORD PTR _pParamTrack$69628[ebp]
  00165	ff 52 28	 call	 DWORD PTR [edx+40]

; 518  :                 pParamTrack->Release();

  00168	8b 45 f4	 mov	 eax, DWORD PTR _pParamTrack$69628[ebp]
  0016b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0016d	8b 55 f4	 mov	 edx, DWORD PTR _pParamTrack$69628[ebp]
  00170	52		 push	 edx
  00171	ff 51 08	 call	 DWORD PTR [ecx+8]
$L69627:

; 519  :             }
; 520  :         }
; 521  : 		pTrack = pTrack->GetNext();

  00174	8b 4d fc	 mov	 ecx, DWORD PTR _pTrack$[ebp]
  00177	e8 00 00 00 00	 call	 ?GetNext@CTrack@@QAEPAV1@XZ ; CTrack::GetNext
  0017c	89 45 fc	 mov	 DWORD PTR _pTrack$[ebp], eax

; 522  : 	}

  0017f	e9 74 ff ff ff	 jmp	 $L69625
$L69626:

; 523  :     GenerateNotification( DMUS_NOTIFICATION_SEGABORT, mtTime );

  00184	8b 45 08	 mov	 eax, DWORD PTR _mtTime$[ebp]
  00187	50		 push	 eax
  00188	6a 04		 push	 4
  0018a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0018d	e8 00 00 00 00	 call	 ?GenerateNotification@CSegState@@AAEXKJ@Z ; CSegState::GenerateNotification

; 524  :     // if this is a primary or controlling segment, send a DMUS_PMSGT_DIRTY message
; 525  :     if( !(m_dwPlaySegFlags & DMUS_SEGF_SECONDARY) || (m_dwPlaySegFlags & DMUS_SEGF_CONTROL) )

  00192	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00195	8b 51 5c	 mov	 edx, DWORD PTR [ecx+92]
  00198	81 e2 80 00 00
	00		 and	 edx, 128		; 00000080H
  0019e	85 d2		 test	 edx, edx
  001a0	74 10		 je	 SHORT $L69633
  001a2	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  001a5	8b 48 5c	 mov	 ecx, DWORD PTR [eax+92]
  001a8	81 e1 00 02 00
	00		 and	 ecx, 512		; 00000200H
  001ae	85 c9		 test	 ecx, ecx
  001b0	74 15		 je	 SHORT $L69632
$L69633:

; 526  :     {
; 527  :         TraceI(4, "Send Dirty PMsg [4] %d (%d)\n", m_mtSeek, m_mtOffset + m_mtSeek);
; 528  :         SendDirtyPMsg( m_mtOffset + m_mtSeek );

  001b2	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  001b5	8b 42 6c	 mov	 eax, DWORD PTR [edx+108]
  001b8	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  001bb	03 41 78	 add	 eax, DWORD PTR [ecx+120]
  001be	50		 push	 eax
  001bf	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  001c2	e8 00 00 00 00	 call	 ?SendDirtyPMsg@CSegState@@AAEXJ@Z ; CSegState::SendDirtyPMsg
$L69632:

; 529  :     }
; 530  : 	return S_OK;

  001c7	33 c0		 xor	 eax, eax
$L69611:

; 531  : }

  001c9	8b e5		 mov	 esp, ebp
  001cb	5d		 pop	 ebp
  001cc	c2 08 00	 ret	 8
?AbortPlay@CSegState@@QAEJJH@Z ENDP			; CSegState::AbortPlay
_TEXT	ENDS
PUBLIC	??_C@_0CA@ONCHGBPA@?$CFs?3?5Invalid?5pointer?5pdwRepeats?6?$AA@ ; `string'
;	COMDAT ?__szValidateInterfaceName@?1??GetRepeats@CSegState@@UAGJPAK@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??GetRepeats@CSegState@@UAGJPAK@Z@4QBDB DB 'I'
	DB	'DirectMusicSegmentState::GetRepeats', 00H	; `CSegState::GetRepeats'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0CA@ONCHGBPA@?$CFs?3?5Invalid?5pointer?5pdwRepeats?6?$AA@
CONST	SEGMENT
??_C@_0CA@ONCHGBPA@?$CFs?3?5Invalid?5pointer?5pdwRepeats?6?$AA@ DB '%s: I'
	DB	'nvalid pointer pdwRepeats', 0aH, 00H	; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?GetRepeats@CSegState@@UAGJPAK@Z
_TEXT	SEGMENT
_this$ = 8
_pdwRepeats$ = 12
?GetRepeats@CSegState@@UAGJPAK@Z PROC NEAR		; CSegState::GetRepeats, COMDAT

; 549  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 550  : 	V_INAME(IDirectMusicSegmentState::GetRepeats);
; 551  : 	V_PTR_WRITE(pdwRepeats,DWORD);

  00003	6a 04		 push	 4
  00005	8b 45 0c	 mov	 eax, DWORD PTR _pdwRepeats$[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  0000e	85 c0		 test	 eax, eax
  00010	74 19		 je	 SHORT $L69643
  00012	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??GetRepeats@CSegState@@UAGJPAK@Z@4QBDB
  00017	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@ONCHGBPA@?$CFs?3?5Invalid?5pointer?5pdwRepeats?6?$AA@
  0001c	6a ff		 push	 -1
  0001e	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH
  00026	e8 00 00 00 00	 call	 _DebugBreak@0
$L69643:

; 552  : 
; 553  : 	*pdwRepeats = m_dwRepeats;

  0002b	8b 4d 0c	 mov	 ecx, DWORD PTR _pdwRepeats$[ebp]
  0002e	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00031	8b 42 50	 mov	 eax, DWORD PTR [edx+80]
  00034	89 01		 mov	 DWORD PTR [ecx], eax

; 554  : 	return S_OK;

  00036	33 c0		 xor	 eax, eax

; 555  : }

  00038	5d		 pop	 ebp
  00039	c2 08 00	 ret	 8
?GetRepeats@CSegState@@UAGJPAK@Z ENDP			; CSegState::GetRepeats
_TEXT	ENDS
PUBLIC	??_C@_0BP@IPCOEDEC@?$CFs?3?5Invalid?5pointer?5ppSegment?6?$AA@ ; `string'
PUBLIC	??_C@_0DJ@JJNELLME@Error?3?5Segmentstate?5doesn?8t?5have@ ; `string'
;	COMDAT ?__szValidateInterfaceName@?1??GetSegment@CSegState@@UAGJPAPAUIDirectMusicSegment@@@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??GetSegment@CSegState@@UAGJPAPAUIDirectMusicSegment@@@Z@4QBDB DB 'I'
	DB	'DirectMusicSegmentState::GetSegment', 00H	; `CSegState::GetSegment'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0BP@IPCOEDEC@?$CFs?3?5Invalid?5pointer?5ppSegment?6?$AA@
CONST	SEGMENT
??_C@_0BP@IPCOEDEC@?$CFs?3?5Invalid?5pointer?5ppSegment?6?$AA@ DB '%s: In'
	DB	'valid pointer ppSegment', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@JJNELLME@Error?3?5Segmentstate?5doesn?8t?5have@
CONST	SEGMENT
??_C@_0DJ@JJNELLME@Error?3?5Segmentstate?5doesn?8t?5have@ DB 'Error: Segm'
	DB	'entstate doesn''t have an associated segment.', 0aH, 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?GetSegment@CSegState@@UAGJPAPAUIDirectMusicSegment@@@Z
_TEXT	SEGMENT
_this$ = 8
_ppSegment$ = 12
?GetSegment@CSegState@@UAGJPAPAUIDirectMusicSegment@@@Z PROC NEAR ; CSegState::GetSegment, COMDAT

; 570  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 571  : 	V_INAME(IDirectMusicSegmentState::GetSegment);
; 572  : 	V_PTRPTR_WRITE(ppSegment);

  00003	6a 04		 push	 4
  00005	8b 45 0c	 mov	 eax, DWORD PTR _ppSegment$[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  0000e	85 c0		 test	 eax, eax
  00010	74 19		 je	 SHORT $L69653
  00012	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??GetSegment@CSegState@@UAGJPAPAUIDirectMusicSegment@@@Z@4QBDB
  00017	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@IPCOEDEC@?$CFs?3?5Invalid?5pointer?5ppSegment?6?$AA@
  0001c	6a ff		 push	 -1
  0001e	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH
  00026	e8 00 00 00 00	 call	 _DebugBreak@0
$L69653:

; 573  : 
; 574  : 	*ppSegment = (IDirectMusicSegment *) m_pSegment;

  0002b	8b 4d 0c	 mov	 ecx, DWORD PTR _ppSegment$[ebp]
  0002e	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00031	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  00034	89 01		 mov	 DWORD PTR [ecx], eax

; 575  : 	if( m_pSegment )

  00036	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	83 79 38 00	 cmp	 DWORD PTR [ecx+56], 0
  0003d	74 14		 je	 SHORT $L69656

; 576  : 	{
; 577  : 		m_pSegment->AddRef();

  0003f	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00042	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  00045	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  0004b	8b 00		 mov	 eax, DWORD PTR [eax]
  0004d	52		 push	 edx
  0004e	ff 50 04	 call	 DWORD PTR [eax+4]

; 578  : 	}
; 579  : 	else

  00051	eb 16		 jmp	 SHORT $L69657
$L69656:

; 580  : 	{
; 581  :         Trace(1,"Error: Segmentstate doesn't have an associated segment.\n");

  00053	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@JJNELLME@Error?3?5Segmentstate?5doesn?8t?5have@
  00058	6a 01		 push	 1
  0005a	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0005f	83 c4 08	 add	 esp, 8

; 582  : 		return DMUS_E_NOT_FOUND;

  00062	b8 61 11 78 88	 mov	 eax, -2005397151	; 88781161H
  00067	eb 02		 jmp	 SHORT $L69649
$L69657:

; 583  : 	}
; 584  : 	return S_OK;

  00069	33 c0		 xor	 eax, eax
$L69649:

; 585  : }

  0006b	5d		 pop	 ebp
  0006c	c2 08 00	 ret	 8
?GetSegment@CSegState@@UAGJPAPAUIDirectMusicSegment@@@Z ENDP ; CSegState::GetSegment
_TEXT	ENDS
PUBLIC	?Play@CSegState@@QAGJJPAJ@Z			; CSegState::Play
; Function compile flags: /Odt
;	COMDAT ?Play@CSegState@@QAGJJPAJ@Z
_TEXT	SEGMENT
_this$ = 8
_mtAmount$ = 12
_pmtPlayed$ = 16
?Play@CSegState@@QAGJJPAJ@Z PROC NEAR			; CSegState::Play, COMDAT

; 615  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 616  :     return E_FAIL;      // We don't want to support this publicly!

  00003	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H

; 617  : }

  00008	5d		 pop	 ebp
  00009	c2 0c 00	 ret	 12			; 0000000cH
?Play@CSegState@@QAGJJPAJ@Z ENDP			; CSegState::Play
_TEXT	ENDS
PUBLIC	??_C@_0BC@LLLGOMEJ@pCTrack?9?$DOm_pTrack?$AA@	; `string'
PUBLIC	?Shutdown@CSegState@@QAGJXZ			; CSegState::Shutdown
PUBLIC	?Play@CSegState@@QAEJJ@Z			; CSegState::Play
EXTRN	_IID_CAudioPath:BYTE
EXTRN	?GetControlSegTime@CPerformance@@QAEJJPAJ@Z:NEAR ; CPerformance::GetControlSegTime
EXTRN	?GetPriSegTime@CPerformance@@QAEJJPAJ@Z:NEAR	; CPerformance::GetPriSegTime
EXTRN	?PlayOneSegment@CPerformance@@AAEJPAVCSegment@@K_JPAPAVCSegState@@PAVCAudioPath@@@Z:NEAR ; CPerformance::PlayOneSegment
EXTRN	?GetPlaySegment@CSong@@QAEJKPAPAVCSegment@@@Z:NEAR ; CSong::GetPlaySegment
;	COMDAT ??_C@_0BC@LLLGOMEJ@pCTrack?9?$DOm_pTrack?$AA@
CONST	SEGMENT
??_C@_0BC@LLLGOMEJ@pCTrack?9?$DOm_pTrack?$AA@ DB 'pCTrack->m_pTrack', 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?Play@CSegState@@QAEJJ@Z
_TEXT	SEGMENT
tv1755 = -196
tv1754 = -192
tv1722 = -188
tv1696 = -180
tv1558 = -176
tv1510 = -172
tv1500 = -168
tv1499 = -164
tv1491 = -160
tv1455 = -156
tv1422 = -152
tv1412 = -148
tv1411 = -144
tv1403 = -140
tv1180 = -136
tv1179 = -132
tv1147 = -128
tv1121 = -120
tv1075 = -116
_this$ = -112
_pNewPath$69825 = -108
_pConfig$69822 = -104
_pPath$69818 = -100
_pCSegState$69817 = -96
_dwFlags$69820 = -92
_pInternalPath$69819 = -88
_pSegment$69814 = -84
_pSong$69812 = -80
_mtNow$69806 = -76
_rtCalcAmount$69780 = -72
_dwAdditionalFlags$69735 = -60
_mtNextPri$69717 = -56
_mtControlSeg$69722 = -52
_rtCalcAmount$69701 = -48
_mtOldLength$69694 = -36
_mtOldEndTime$69693 = -32
_hr$ = -28
_pCTrack$ = -24
_mtMyAmount$ = -20
_rtMyAmount$ = -16
_fUseClockTime$ = -4
_mtAmount$ = 8
?Play@CSegState@@QAEJJ@Z PROC NEAR			; CSegState::Play, COMDAT
; _this$ = ecx

; 620  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	56		 push	 esi
  0000a	89 4d 90	 mov	 DWORD PTR _this$[ebp], ecx

; 621  :     CTrack* pCTrack;
; 622  :     MUSIC_TIME mtMyAmount = mtAmount;

  0000d	8b 45 08	 mov	 eax, DWORD PTR _mtAmount$[ebp]
  00010	89 45 ec	 mov	 DWORD PTR _mtMyAmount$[ebp], eax

; 623  :     REFERENCE_TIME rtMyAmount;
; 624  :     HRESULT hr = DMUS_S_END;

  00013	c7 45 e4 02 12
	78 08		 mov	 DWORD PTR _hr$[ebp], 142086658 ; 08781202H

; 625  :     BOOL fUseClockTime = FALSE;

  0001a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fUseClockTime$[ebp], 0

; 626  : 
; 627  :     if( mtAmount <= 0 )

  00021	83 7d 08 00	 cmp	 DWORD PTR _mtAmount$[ebp], 0
  00025	7f 0a		 jg	 SHORT $L69683

; 628  :         return E_INVALIDARG;

  00027	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  0002c	e9 0d 14 00 00	 jmp	 $L69673
$L69683:

; 629  : 
; 630  :     ENTER_CRITICAL_SECTION(&m_CriticalSection);

  00031	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	83 c1 14	 add	 ecx, 20			; 00000014H
  00037	51		 push	 ecx
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 631  :     if (m_fInPlay)

  0003e	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  00041	83 ba 20 01 00
	00 00		 cmp	 DWORD PTR [edx+288], 0
  00048	74 14		 je	 SHORT $L69685

; 632  :     {
; 633  :         LEAVE_CRITICAL_SECTION(&m_CriticalSection);

  0004a	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	83 c0 14	 add	 eax, 20			; 00000014H
  00050	50		 push	 eax
  00051	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 634  :         return S_OK;

  00057	33 c0		 xor	 eax, eax
  00059	e9 e0 13 00 00	 jmp	 $L69673
$L69685:

; 635  :     }
; 636  :     m_fInPlay = true;

  0005e	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	c7 81 20 01 00
	00 01 00 00 00	 mov	 DWORD PTR [ecx+288], 1

; 637  :     m_pPerformance->m_pGetParamSegmentState = (IDirectMusicSegmentState *) this;

  0006b	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  0006e	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  00071	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00074	89 88 d4 03 00
	00		 mov	 DWORD PTR [eax+980], ecx

; 638  :     // if this is the first call to play, we need to send a SegStart notification.
; 639  :     // We also need to check to see if we are supposed to start at the beginning,
; 640  :     // or at an offset.
; 641  :     if( m_dwPlayTrackFlags & DMUS_TRACKF_START )

  0007a	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  0007d	8b 42 58	 mov	 eax, DWORD PTR [edx+88]
  00080	83 e0 04	 and	 eax, 4
  00083	85 c0		 test	 eax, eax
  00085	0f 84 51 01 00
	00		 je	 $L69688

; 642  :     {
; 643  :         // send a segment start notification
; 644  :         GenerateNotification( DMUS_NOTIFICATION_SEGSTART, m_mtOffset );

  0008b	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  0008e	8b 51 6c	 mov	 edx, DWORD PTR [ecx+108]
  00091	52		 push	 edx
  00092	6a 00		 push	 0
  00094	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00097	e8 00 00 00 00	 call	 ?GenerateNotification@CSegState@@AAEXKJ@Z ; CSegState::GenerateNotification

; 645  :         // if this is a primary or controlling segment, send a DMUS_PMSGT_DIRTY message
; 646  :         if( !(m_dwPlaySegFlags & DMUS_SEGF_SECONDARY) || (m_dwPlaySegFlags & DMUS_SEGF_CONTROL) )

  0009c	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  0009f	8b 48 5c	 mov	 ecx, DWORD PTR [eax+92]
  000a2	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  000a8	85 c9		 test	 ecx, ecx
  000aa	74 0f		 je	 SHORT $L69690
  000ac	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  000af	8b 42 5c	 mov	 eax, DWORD PTR [edx+92]
  000b2	25 00 02 00 00	 and	 eax, 512		; 00000200H
  000b7	85 c0		 test	 eax, eax
  000b9	74 15		 je	 SHORT $L69689
$L69690:

; 647  :         {
; 648  :             TraceI(4, "Send Dirty PMsg [1] %d (%d)\n", m_mtSeek, m_mtOffset + m_mtSeek);
; 649  :             SendDirtyPMsg( m_mtOffset + m_mtSeek );

  000bb	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  000be	8b 51 6c	 mov	 edx, DWORD PTR [ecx+108]
  000c1	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  000c4	03 50 78	 add	 edx, DWORD PTR [eax+120]
  000c7	52		 push	 edx
  000c8	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  000cb	e8 00 00 00 00	 call	 ?SendDirtyPMsg@CSegState@@AAEXJ@Z ; CSegState::SendDirtyPMsg
$L69689:

; 650  :         }
; 651  :         // set the current seek to the start point
; 652  :         m_mtSeek = m_mtStartPoint;

  000d0	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  000d3	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  000d6	8b 42 7c	 mov	 eax, DWORD PTR [edx+124]
  000d9	89 41 78	 mov	 DWORD PTR [ecx+120], eax

; 653  :         // convert current offset to ref time
; 654  :         m_pPerformance->MusicToReferenceTime(m_mtOffset,&m_rtOffset);

  000dc	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  000df	81 c1 b8 00 00
	00		 add	 ecx, 184		; 000000b8H
  000e5	51		 push	 ecx
  000e6	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  000e9	8b 42 6c	 mov	 eax, DWORD PTR [edx+108]
  000ec	50		 push	 eax
  000ed	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  000f0	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  000f3	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  000f6	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  000f9	8b 12		 mov	 edx, DWORD PTR [edx]
  000fb	51		 push	 ecx
  000fc	ff 52 14	 call	 DWORD PTR [edx+20]

; 655  :         m_rtEndTime = m_rtOffset + m_rtLength;

  000ff	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  00102	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00105	8b 90 b8 00 00
	00		 mov	 edx, DWORD PTR [eax+184]
  0010b	03 91 d0 00 00
	00		 add	 edx, DWORD PTR [ecx+208]
  00111	8b 80 bc 00 00
	00		 mov	 eax, DWORD PTR [eax+188]
  00117	13 81 d4 00 00
	00		 adc	 eax, DWORD PTR [ecx+212]
  0011d	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00120	89 91 c0 00 00
	00		 mov	 DWORD PTR [ecx+192], edx
  00126	89 81 c4 00 00
	00		 mov	 DWORD PTR [ecx+196], eax

; 656  :         // subtract the start points from the offsets
; 657  :         m_mtOffset -= m_mtStartPoint;

  0012c	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  0012f	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  00132	8b 4a 6c	 mov	 ecx, DWORD PTR [edx+108]
  00135	2b 48 7c	 sub	 ecx, DWORD PTR [eax+124]
  00138	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  0013b	89 4a 6c	 mov	 DWORD PTR [edx+108], ecx

; 658  :         m_rtOffset -= m_rtStartPoint;

  0013e	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  00141	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00144	8b 90 b8 00 00
	00		 mov	 edx, DWORD PTR [eax+184]
  0014a	2b 91 b0 00 00
	00		 sub	 edx, DWORD PTR [ecx+176]
  00150	8b 80 bc 00 00
	00		 mov	 eax, DWORD PTR [eax+188]
  00156	1b 81 b4 00 00
	00		 sbb	 eax, DWORD PTR [ecx+180]
  0015c	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  0015f	89 91 b8 00 00
	00		 mov	 DWORD PTR [ecx+184], edx
  00165	89 81 bc 00 00
	00		 mov	 DWORD PTR [ecx+188], eax

; 659  :         m_rtEndTime -= m_rtStartPoint;

  0016b	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  0016e	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  00171	8b 8a c0 00 00
	00		 mov	 ecx, DWORD PTR [edx+192]
  00177	2b 88 b0 00 00
	00		 sub	 ecx, DWORD PTR [eax+176]
  0017d	8b 92 c4 00 00
	00		 mov	 edx, DWORD PTR [edx+196]
  00183	1b 90 b4 00 00
	00		 sbb	 edx, DWORD PTR [eax+180]
  00189	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  0018c	89 88 c0 00 00
	00		 mov	 DWORD PTR [eax+192], ecx
  00192	89 90 c4 00 00
	00		 mov	 DWORD PTR [eax+196], edx

; 660  :         m_rtSeek = m_rtLastPlayed - m_rtOffset;

  00198	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  0019b	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  0019e	8b 81 a8 00 00
	00		 mov	 eax, DWORD PTR [ecx+168]
  001a4	2b 82 b8 00 00
	00		 sub	 eax, DWORD PTR [edx+184]
  001aa	8b 89 ac 00 00
	00		 mov	 ecx, DWORD PTR [ecx+172]
  001b0	1b 8a bc 00 00
	00		 sbb	 ecx, DWORD PTR [edx+188]
  001b6	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  001b9	89 82 c8 00 00
	00		 mov	 DWORD PTR [edx+200], eax
  001bf	89 8a cc 00 00
	00		 mov	 DWORD PTR [edx+204], ecx

; 661  : 
; 662  :         m_rtFirstLoopStart = 0;

  001c5	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  001c8	c7 80 d8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+216], 0
  001d2	c7 80 dc 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+220], 0
$L69688:

; 663  :     }
; 664  :     if (m_rtLength)

  001dc	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  001df	89 4d 8c	 mov	 DWORD PTR tv1075[ebp], ecx
  001e2	8b 55 8c	 mov	 edx, DWORD PTR tv1075[ebp]
  001e5	8b 45 8c	 mov	 eax, DWORD PTR tv1075[ebp]
  001e8	8b 8a d0 00 00
	00		 mov	 ecx, DWORD PTR [edx+208]
  001ee	0b 88 d4 00 00
	00		 or	 ecx, DWORD PTR [eax+212]
  001f4	85 c9		 test	 ecx, ecx
  001f6	0f 84 d1 00 00
	00		 je	 $L69692

; 665  :     {
; 666  :         // If there is a reference time length, convert it into mtTime.
; 667  :         // Because there's always the danger of a tempo change, we do this every
; 668  :         // time. It doesn't require the tight precision that song time
; 669  :         // requires, so that's okay.
; 670  :         // ALSO: convert m_mtLength and re-adjust loop points. (RSW)
; 671  :         MUSIC_TIME mtOldEndTime = m_mtEndTime;

  001fc	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  001ff	8b 42 68	 mov	 eax, DWORD PTR [edx+104]
  00202	89 45 e0	 mov	 DWORD PTR _mtOldEndTime$69693[ebp], eax

; 672  : 
; 673  :         m_pPerformance->ReferenceToMusicTime(m_rtEndTime, &m_mtEndTime);

  00205	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00208	83 c1 68	 add	 ecx, 104		; 00000068H
  0020b	51		 push	 ecx
  0020c	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  0020f	8b 82 c4 00 00
	00		 mov	 eax, DWORD PTR [edx+196]
  00215	50		 push	 eax
  00216	8b 8a c0 00 00
	00		 mov	 ecx, DWORD PTR [edx+192]
  0021c	51		 push	 ecx
  0021d	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  00220	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  00223	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00226	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00229	8b 00		 mov	 eax, DWORD PTR [eax]
  0022b	52		 push	 edx
  0022c	ff 50 18	 call	 DWORD PTR [eax+24]

; 674  :         MUSIC_TIME mtOldLength = m_mtLength;

  0022f	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00232	8b 51 54	 mov	 edx, DWORD PTR [ecx+84]
  00235	89 55 dc	 mov	 DWORD PTR _mtOldLength$69694[ebp], edx

; 675  :         m_mtLength = m_mtEndTime - m_mtOffset; 

  00238	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  0023b	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  0023e	8b 50 68	 mov	 edx, DWORD PTR [eax+104]
  00241	2b 51 6c	 sub	 edx, DWORD PTR [ecx+108]
  00244	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  00247	89 50 54	 mov	 DWORD PTR [eax+84], edx

; 676  :         if (m_mtLength <= 0) {

  0024a	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  0024d	83 79 54 00	 cmp	 DWORD PTR [ecx+84], 0
  00251	7f 09		 jg	 SHORT $L69695

; 677  :             m_mtLength = mtOldLength;

  00253	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  00256	8b 45 dc	 mov	 eax, DWORD PTR _mtOldLength$69694[ebp]
  00259	89 42 54	 mov	 DWORD PTR [edx+84], eax
$L69695:

; 678  :         }
; 679  : 
; 680  :         if (m_mtLoopEnd >= mtOldLength) // keep loop end equal to length

  0025c	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  0025f	8b 51 4c	 mov	 edx, DWORD PTR [ecx+76]
  00262	3b 55 dc	 cmp	 edx, DWORD PTR _mtOldLength$69694[ebp]
  00265	7c 0c		 jl	 SHORT $L69696

; 681  :         {
; 682  :             m_mtLoopEnd = m_mtLength;

  00267	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  0026a	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  0026d	8b 51 54	 mov	 edx, DWORD PTR [ecx+84]
  00270	89 50 4c	 mov	 DWORD PTR [eax+76], edx
$L69696:

; 683  :         }
; 684  :         if( m_mtLoopEnd > m_mtLength )

  00273	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  00276	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00279	8b 50 4c	 mov	 edx, DWORD PTR [eax+76]
  0027c	3b 51 54	 cmp	 edx, DWORD PTR [ecx+84]
  0027f	7e 45		 jle	 SHORT $L69697

; 685  :         {
; 686  :             m_mtLoopEnd = m_mtLength;

  00281	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  00284	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00287	8b 51 54	 mov	 edx, DWORD PTR [ecx+84]
  0028a	89 50 4c	 mov	 DWORD PTR [eax+76], edx

; 687  :             if( m_mtStartPoint >= m_mtLoopEnd )

  0028d	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  00290	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00293	8b 50 7c	 mov	 edx, DWORD PTR [eax+124]
  00296	3b 51 4c	 cmp	 edx, DWORD PTR [ecx+76]
  00299	7c 2b		 jl	 SHORT $L69697

; 688  :             {
; 689  :                 // in this case, we're not doing any looping.
; 690  :                 m_mtLoopEnd = m_mtLoopStart = 0;

  0029b	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  0029e	c7 40 48 00 00
	00 00		 mov	 DWORD PTR [eax+72], 0
  002a5	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  002a8	c7 41 4c 00 00
	00 00		 mov	 DWORD PTR [ecx+76], 0

; 691  :                 m_dwRepeats = m_dwRepeatsLeft = 0;

  002af	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  002b2	c7 82 00 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+256], 0
  002bc	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  002bf	c7 40 50 00 00
	00 00		 mov	 DWORD PTR [eax+80], 0
$L69697:

; 692  :             }
; 693  :         }
; 694  :         
; 695  :         //m_mtEndTime += (m_mtLoopEnd - m_mtLoopStart) * m_dwRepeats;
; 696  : 
; 697  :         fUseClockTime = TRUE;

  002c6	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _fUseClockTime$[ebp], 1
$L69692:

; 698  :     }
; 699  :     // if we need to do a loop or the end is near, restrict mtMyAmount
; 700  : //  ASSERT( m_mtLength ); // length is 0, this segment won't do anything
; 701  :     if( m_dwRepeatsLeft )

  002cd	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  002d0	83 b9 00 01 00
	00 00		 cmp	 DWORD PTR [ecx+256], 0
  002d7	0f 84 6f 01 00
	00		 je	 $L69699

; 702  :     {
; 703  :         if (m_rtLoopEnd)    // Is this a clock time looped segment?

  002dd	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  002e0	89 55 88	 mov	 DWORD PTR tv1121[ebp], edx
  002e3	8b 45 88	 mov	 eax, DWORD PTR tv1121[ebp]
  002e6	8b 4d 88	 mov	 ecx, DWORD PTR tv1121[ebp]
  002e9	8b 90 98 00 00
	00		 mov	 edx, DWORD PTR [eax+152]
  002ef	0b 91 9c 00 00
	00		 or	 edx, DWORD PTR [ecx+156]
  002f5	85 d2		 test	 edx, edx
  002f7	0f 84 2d 01 00
	00		 je	 $L69700

; 704  :         {
; 705  :             REFERENCE_TIME rtCalcAmount;
; 706  :             m_pPerformance->MusicToReferenceTime(m_mtLastPlayed + mtMyAmount,&rtCalcAmount);

  002fd	8d 45 d0	 lea	 eax, DWORD PTR _rtCalcAmount$69701[ebp]
  00300	50		 push	 eax
  00301	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00304	8b 51 70	 mov	 edx, DWORD PTR [ecx+112]
  00307	03 55 ec	 add	 edx, DWORD PTR _mtMyAmount$[ebp]
  0030a	52		 push	 edx
  0030b	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  0030e	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00311	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  00314	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  00317	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00319	50		 push	 eax
  0031a	ff 51 14	 call	 DWORD PTR [ecx+20]

; 707  :             rtCalcAmount -= m_rtLastPlayed;

  0031d	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  00320	8b 45 d0	 mov	 eax, DWORD PTR _rtCalcAmount$69701[ebp]
  00323	2b 82 a8 00 00
	00		 sub	 eax, DWORD PTR [edx+168]
  00329	8b 4d d4	 mov	 ecx, DWORD PTR _rtCalcAmount$69701[ebp+4]
  0032c	1b 8a ac 00 00
	00		 sbb	 ecx, DWORD PTR [edx+172]
  00332	89 45 d0	 mov	 DWORD PTR _rtCalcAmount$69701[ebp], eax
  00335	89 4d d4	 mov	 DWORD PTR _rtCalcAmount$69701[ebp+4], ecx

; 708  :             if (rtCalcAmount > m_rtLoopEnd - m_rtSeek)

  00338	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  0033b	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  0033e	8b 8a 98 00 00
	00		 mov	 ecx, DWORD PTR [edx+152]
  00344	2b 88 c8 00 00
	00		 sub	 ecx, DWORD PTR [eax+200]
  0034a	8b 92 9c 00 00
	00		 mov	 edx, DWORD PTR [edx+156]
  00350	1b 90 cc 00 00
	00		 sbb	 edx, DWORD PTR [eax+204]
  00356	89 4d 80	 mov	 DWORD PTR tv1147[ebp], ecx
  00359	89 55 84	 mov	 DWORD PTR tv1147[ebp+4], edx
  0035c	8b 45 d4	 mov	 eax, DWORD PTR _rtCalcAmount$69701[ebp+4]
  0035f	3b 45 84	 cmp	 eax, DWORD PTR tv1147[ebp+4]
  00362	0f 8c c0 00 00
	00		 jl	 $L69702
  00368	7f 0c		 jg	 SHORT $L70687
  0036a	8b 4d d0	 mov	 ecx, DWORD PTR _rtCalcAmount$69701[ebp]
  0036d	3b 4d 80	 cmp	 ecx, DWORD PTR tv1147[ebp]
  00370	0f 86 b2 00 00
	00		 jbe	 $L69702
$L70687:

; 709  :             {
; 710  :                 rtCalcAmount = m_rtLoopEnd - m_rtSeek;

  00376	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  00379	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  0037c	8b 8a 98 00 00
	00		 mov	 ecx, DWORD PTR [edx+152]
  00382	2b 88 c8 00 00
	00		 sub	 ecx, DWORD PTR [eax+200]
  00388	8b 92 9c 00 00
	00		 mov	 edx, DWORD PTR [edx+156]
  0038e	1b 90 cc 00 00
	00		 sbb	 edx, DWORD PTR [eax+204]
  00394	89 4d d0	 mov	 DWORD PTR _rtCalcAmount$69701[ebp], ecx
  00397	89 55 d4	 mov	 DWORD PTR _rtCalcAmount$69701[ebp+4], edx

; 711  :                 m_pPerformance->ReferenceToMusicTime(m_rtLastPlayed + rtCalcAmount,&mtMyAmount);

  0039a	8d 45 ec	 lea	 eax, DWORD PTR _mtMyAmount$[ebp]
  0039d	50		 push	 eax
  0039e	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  003a1	8b 91 a8 00 00
	00		 mov	 edx, DWORD PTR [ecx+168]
  003a7	03 55 d0	 add	 edx, DWORD PTR _rtCalcAmount$69701[ebp]
  003aa	8b 81 ac 00 00
	00		 mov	 eax, DWORD PTR [ecx+172]
  003b0	13 45 d4	 adc	 eax, DWORD PTR _rtCalcAmount$69701[ebp+4]
  003b3	50		 push	 eax
  003b4	52		 push	 edx
  003b5	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  003b8	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  003bb	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  003be	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  003c1	8b 12		 mov	 edx, DWORD PTR [edx]
  003c3	51		 push	 ecx
  003c4	ff 52 18	 call	 DWORD PTR [edx+24]

; 712  :                 mtMyAmount -= m_mtLastPlayed;

  003c7	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  003ca	8b 4d ec	 mov	 ecx, DWORD PTR _mtMyAmount$[ebp]
  003cd	2b 48 70	 sub	 ecx, DWORD PTR [eax+112]
  003d0	89 4d ec	 mov	 DWORD PTR _mtMyAmount$[ebp], ecx

; 713  :                 if (!mtMyAmount && (m_rtLoopEnd > m_rtSeek))

  003d3	83 7d ec 00	 cmp	 DWORD PTR _mtMyAmount$[ebp], 0
  003d7	75 4f		 jne	 SHORT $L69702
  003d9	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  003dc	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  003df	89 95 7c ff ff
	ff		 mov	 DWORD PTR tv1179[ebp], edx
  003e5	89 85 78 ff ff
	ff		 mov	 DWORD PTR tv1180[ebp], eax
  003eb	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR tv1179[ebp]
  003f1	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR tv1180[ebp]
  003f7	8b 81 9c 00 00
	00		 mov	 eax, DWORD PTR [ecx+156]
  003fd	3b 82 cc 00 00
	00		 cmp	 eax, DWORD PTR [edx+204]
  00403	7c 23		 jl	 SHORT $L69702
  00405	7f 1a		 jg	 SHORT $L70688
  00407	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR tv1179[ebp]
  0040d	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR tv1180[ebp]
  00413	8b 81 98 00 00
	00		 mov	 eax, DWORD PTR [ecx+152]
  00419	3b 82 c8 00 00
	00		 cmp	 eax, DWORD PTR [edx+200]
  0041f	76 07		 jbe	 SHORT $L69702
$L70688:

; 714  :                 {
; 715  :                     mtMyAmount = 1;

  00421	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _mtMyAmount$[ebp], 1
$L69702:

; 716  :                 }
; 717  :             }
; 718  :         }
; 719  :         else if( mtMyAmount > m_mtLoopEnd - m_mtSeek )

  00428	eb 20		 jmp	 SHORT $L69704
$L69700:
  0042a	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  0042d	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  00430	8b 41 4c	 mov	 eax, DWORD PTR [ecx+76]
  00433	2b 42 78	 sub	 eax, DWORD PTR [edx+120]
  00436	39 45 ec	 cmp	 DWORD PTR _mtMyAmount$[ebp], eax
  00439	7e 0f		 jle	 SHORT $L69704

; 720  :         {
; 721  :             mtMyAmount = m_mtLoopEnd - m_mtSeek;

  0043b	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  0043e	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  00441	8b 41 4c	 mov	 eax, DWORD PTR [ecx+76]
  00444	2b 42 78	 sub	 eax, DWORD PTR [edx+120]
  00447	89 45 ec	 mov	 DWORD PTR _mtMyAmount$[ebp], eax
$L69704:

; 722  :         }
; 723  :     }
; 724  :     else 

  0044a	eb 58		 jmp	 SHORT $L69706
$L69699:

; 725  :     {
; 726  :         if (fUseClockTime)

  0044c	83 7d fc 00	 cmp	 DWORD PTR _fUseClockTime$[ebp], 0
  00450	74 32		 je	 SHORT $L69707

; 727  :         {
; 728  :             if (mtMyAmount > (m_mtEndTime - (m_mtOffset + m_mtSeek)))

  00452	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00455	8b 51 6c	 mov	 edx, DWORD PTR [ecx+108]
  00458	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  0045b	03 50 78	 add	 edx, DWORD PTR [eax+120]
  0045e	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00461	8b 41 68	 mov	 eax, DWORD PTR [ecx+104]
  00464	2b c2		 sub	 eax, edx
  00466	39 45 ec	 cmp	 DWORD PTR _mtMyAmount$[ebp], eax
  00469	7e 17		 jle	 SHORT $L69708

; 729  :             {
; 730  :                 mtMyAmount = m_mtEndTime - (m_mtOffset + m_mtSeek);

  0046b	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  0046e	8b 51 6c	 mov	 edx, DWORD PTR [ecx+108]
  00471	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  00474	03 50 78	 add	 edx, DWORD PTR [eax+120]
  00477	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  0047a	8b 41 68	 mov	 eax, DWORD PTR [ecx+104]
  0047d	2b c2		 sub	 eax, edx
  0047f	89 45 ec	 mov	 DWORD PTR _mtMyAmount$[ebp], eax
$L69708:

; 731  :             }
; 732  :         }
; 733  :         else if( mtMyAmount > m_mtLength - m_mtSeek )

  00482	eb 20		 jmp	 SHORT $L69706
$L69707:
  00484	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00487	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  0048a	8b 41 54	 mov	 eax, DWORD PTR [ecx+84]
  0048d	2b 42 78	 sub	 eax, DWORD PTR [edx+120]
  00490	39 45 ec	 cmp	 DWORD PTR _mtMyAmount$[ebp], eax
  00493	7e 0f		 jle	 SHORT $L69706

; 734  :         {
; 735  :             mtMyAmount = m_mtLength - m_mtSeek;

  00495	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00498	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  0049b	8b 41 54	 mov	 eax, DWORD PTR [ecx+84]
  0049e	2b 42 78	 sub	 eax, DWORD PTR [edx+120]
  004a1	89 45 ec	 mov	 DWORD PTR _mtMyAmount$[ebp], eax
$L69706:

; 736  :         }
; 737  :     }
; 738  :     if (mtMyAmount <= 0)

  004a4	83 7d ec 00	 cmp	 DWORD PTR _mtMyAmount$[ebp], 0
  004a8	7f 0c		 jg	 SHORT $L69711

; 739  :     {
; 740  :         hr = DMUS_S_END;

  004aa	c7 45 e4 02 12
	78 08		 mov	 DWORD PTR _hr$[ebp], 142086658 ; 08781202H

; 741  :     }
; 742  :     else

  004b1	e9 0c 0d 00 00	 jmp	 $L69716
$L69711:

; 743  :     {
; 744  :         // check the primary segment queue for a segment that might begin 
; 745  :         // before mtMyAmount is up
; 746  :         MUSIC_TIME mtNextPri;
; 747  :         if (S_OK == m_pPerformance->GetPriSegTime( m_mtOffset + m_mtSeek, &mtNextPri ))

  004b6	8d 4d c8	 lea	 ecx, DWORD PTR _mtNextPri$69717[ebp]
  004b9	51		 push	 ecx
  004ba	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  004bd	8b 42 6c	 mov	 eax, DWORD PTR [edx+108]
  004c0	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  004c3	03 41 78	 add	 eax, DWORD PTR [ecx+120]
  004c6	50		 push	 eax
  004c7	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  004ca	8b 4a 34	 mov	 ecx, DWORD PTR [edx+52]
  004cd	e8 00 00 00 00	 call	 ?GetPriSegTime@CPerformance@@QAEJJPAJ@Z ; CPerformance::GetPriSegTime
  004d2	85 c0		 test	 eax, eax
  004d4	75 26		 jne	 SHORT $L69719

; 748  :         {
; 749  :             if( m_mtOffset + m_mtSeek + mtMyAmount > mtNextPri )

  004d6	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  004d9	8b 48 6c	 mov	 ecx, DWORD PTR [eax+108]
  004dc	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  004df	03 4a 78	 add	 ecx, DWORD PTR [edx+120]
  004e2	03 4d ec	 add	 ecx, DWORD PTR _mtMyAmount$[ebp]
  004e5	3b 4d c8	 cmp	 ecx, DWORD PTR _mtNextPri$69717[ebp]
  004e8	7e 12		 jle	 SHORT $L69719

; 750  :             {
; 751  :                 mtMyAmount = mtNextPri - m_mtOffset - m_mtSeek;

  004ea	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  004ed	8b 4d c8	 mov	 ecx, DWORD PTR _mtNextPri$69717[ebp]
  004f0	2b 48 6c	 sub	 ecx, DWORD PTR [eax+108]
  004f3	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  004f6	2b 4a 78	 sub	 ecx, DWORD PTR [edx+120]
  004f9	89 4d ec	 mov	 DWORD PTR _mtMyAmount$[ebp], ecx
$L69719:

; 752  :             }
; 753  :         }
; 754  :         TraceI(3, "SegState %ld Play from %ld to %ld at %ld = %ld - %ld\n", this, m_mtSeek, m_mtSeek + mtMyAmount, m_mtOffset, m_mtSeek + m_mtOffset, m_mtSeek + mtMyAmount + m_mtOffset );
; 755  :         
; 756  :         // find out if there's a control segment interrupting this period of time.
; 757  :         MUSIC_TIME mtControlSeg;
; 758  :         if( S_OK == m_pPerformance->GetControlSegTime( m_mtOffset + m_mtSeek, &mtControlSeg ))

  004fc	8d 45 cc	 lea	 eax, DWORD PTR _mtControlSeg$69722[ebp]
  004ff	50		 push	 eax
  00500	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00503	8b 51 6c	 mov	 edx, DWORD PTR [ecx+108]
  00506	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  00509	03 50 78	 add	 edx, DWORD PTR [eax+120]
  0050c	52		 push	 edx
  0050d	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00510	8b 49 34	 mov	 ecx, DWORD PTR [ecx+52]
  00513	e8 00 00 00 00	 call	 ?GetControlSegTime@CPerformance@@QAEJJPAJ@Z ; CPerformance::GetControlSegTime
  00518	85 c0		 test	 eax, eax
  0051a	75 48		 jne	 SHORT $L69724

; 759  :         {
; 760  :             if( m_mtOffset + m_mtSeek == mtControlSeg )

  0051c	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  0051f	8b 42 6c	 mov	 eax, DWORD PTR [edx+108]
  00522	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00525	03 41 78	 add	 eax, DWORD PTR [ecx+120]
  00528	3b 45 cc	 cmp	 eax, DWORD PTR _mtControlSeg$69722[ebp]
  0052b	75 11		 jne	 SHORT $L69725

; 761  :             {
; 762  :                 // we're at the beginning of a new control seg, so tell the tracks
; 763  :                 m_dwPlayTrackFlags |= DMUS_TRACKF_DIRTY;

  0052d	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  00530	8b 42 58	 mov	 eax, DWORD PTR [edx+88]
  00533	83 c8 10	 or	 eax, 16			; 00000010H
  00536	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00539	89 41 58	 mov	 DWORD PTR [ecx+88], eax

; 764  :             }
; 765  :             else if( m_mtOffset + m_mtSeek + mtMyAmount > mtControlSeg )

  0053c	eb 26		 jmp	 SHORT $L69724
$L69725:
  0053e	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  00541	8b 42 6c	 mov	 eax, DWORD PTR [edx+108]
  00544	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00547	03 41 78	 add	 eax, DWORD PTR [ecx+120]
  0054a	03 45 ec	 add	 eax, DWORD PTR _mtMyAmount$[ebp]
  0054d	3b 45 cc	 cmp	 eax, DWORD PTR _mtControlSeg$69722[ebp]
  00550	7e 12		 jle	 SHORT $L69724

; 766  :             {
; 767  :                 mtMyAmount = mtControlSeg - m_mtOffset - m_mtSeek;

  00552	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  00555	8b 45 cc	 mov	 eax, DWORD PTR _mtControlSeg$69722[ebp]
  00558	2b 42 6c	 sub	 eax, DWORD PTR [edx+108]
  0055b	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  0055e	2b 41 78	 sub	 eax, DWORD PTR [ecx+120]
  00561	89 45 ec	 mov	 DWORD PTR _mtMyAmount$[ebp], eax
$L69724:

; 768  :             }
; 769  :         }
; 770  :         // Now that mtMyAmount is calculated for how far to play in music time,
; 771  :         // create the equivalent value in reference time.
; 772  :         m_pPerformance->MusicToReferenceTime(m_mtLastPlayed + mtMyAmount,&rtMyAmount);

  00564	8d 55 f0	 lea	 edx, DWORD PTR _rtMyAmount$[ebp]
  00567	52		 push	 edx
  00568	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  0056b	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  0056e	03 4d ec	 add	 ecx, DWORD PTR _mtMyAmount$[ebp]
  00571	51		 push	 ecx
  00572	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  00575	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  00578	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  0057b	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  0057e	8b 00		 mov	 eax, DWORD PTR [eax]
  00580	52		 push	 edx
  00581	ff 50 14	 call	 DWORD PTR [eax+20]

; 773  :         rtMyAmount -= m_rtLastPlayed;

  00584	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00587	8b 55 f0	 mov	 edx, DWORD PTR _rtMyAmount$[ebp]
  0058a	2b 91 a8 00 00
	00		 sub	 edx, DWORD PTR [ecx+168]
  00590	8b 45 f4	 mov	 eax, DWORD PTR _rtMyAmount$[ebp+4]
  00593	1b 81 ac 00 00
	00		 sbb	 eax, DWORD PTR [ecx+172]
  00599	89 55 f0	 mov	 DWORD PTR _rtMyAmount$[ebp], edx
  0059c	89 45 f4	 mov	 DWORD PTR _rtMyAmount$[ebp+4], eax

; 774  :         pCTrack = m_TrackList.GetHead();

  0059f	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  005a2	83 c1 44	 add	 ecx, 68			; 00000044H
  005a5	e8 00 00 00 00	 call	 ?GetHead@CTrackList@@QAEPAVCTrack@@XZ ; CTrackList::GetHead
  005aa	89 45 e8	 mov	 DWORD PTR _pCTrack$[ebp], eax
$L69729:

; 775  :         while( pCTrack )

  005ad	83 7d e8 00	 cmp	 DWORD PTR _pCTrack$[ebp], 0
  005b1	0f 84 0b 0c 00
	00		 je	 $L69716

; 776  :         {
; 777  :             if( mtMyAmount )

  005b7	83 7d ec 00	 cmp	 DWORD PTR _mtMyAmount$[ebp], 0
  005bb	0f 84 aa 02 00
	00		 je	 $L69731

; 778  :             {
; 779  :                 m_pPerformance->m_fInTrackPlay = TRUE; // This causes the Pmsgs to be stamped with PRIV_FLAG_TRACK.

  005c1	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  005c4	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  005c7	c7 82 10 01 00
	00 01 00 00 00	 mov	 DWORD PTR [edx+272], 1

; 780  :                 ASSERT( pCTrack->m_pTrack );

  005d1	8b 45 e8	 mov	 eax, DWORD PTR _pCTrack$[ebp]
  005d4	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  005d8	75 17		 jne	 SHORT $L69732
  005da	6a 00		 push	 0
  005dc	68 0c 03 00 00	 push	 780			; 0000030cH
  005e1	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NBCHJFPK@c?3?2xbox?2private?2windows?2directx?2@
  005e6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BC@LLLGOMEJ@pCTrack?9?$DOm_pTrack?$AA@
  005eb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
$L69732:

; 781  :                 // If either notification or play are enabled, we need to call the play method and set the behavior
; 782  :                 // with the DMUS_TRACKF_NOTIFY_OFF and DMUS_TRACKF_PLAY_OFF flags. 
; 783  :                 if (pCTrack->m_dwFlags & (DMUS_TRACKCONFIG_PLAY_ENABLED | DMUS_TRACKCONFIG_NOTIFICATION_ENABLED))

  005f1	8b 4d e8	 mov	 ecx, DWORD PTR _pCTrack$[ebp]
  005f4	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  005f7	83 e2 30	 and	 edx, 48			; 00000030H
  005fa	85 d2		 test	 edx, edx
  005fc	0f 84 59 02 00
	00		 je	 $L69734

; 784  :                 {
; 785  :                     DWORD dwAdditionalFlags = 0;

  00602	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _dwAdditionalFlags$69735[ebp], 0

; 786  :                     if (!(pCTrack->m_dwFlags & DMUS_TRACKCONFIG_NOTIFICATION_ENABLED))

  00609	8b 45 e8	 mov	 eax, DWORD PTR _pCTrack$[ebp]
  0060c	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0060f	83 e1 20	 and	 ecx, 32			; 00000020H
  00612	85 c9		 test	 ecx, ecx
  00614	75 07		 jne	 SHORT $L69736

; 787  :                     {
; 788  :                         dwAdditionalFlags = DMUS_TRACKF_NOTIFY_OFF;

  00616	c7 45 c4 20 00
	00 00		 mov	 DWORD PTR _dwAdditionalFlags$69735[ebp], 32 ; 00000020H
$L69736:

; 789  :                     }
; 790  :                     if (!(pCTrack->m_dwFlags & DMUS_TRACKCONFIG_PLAY_ENABLED))

  0061d	8b 55 e8	 mov	 edx, DWORD PTR _pCTrack$[ebp]
  00620	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  00623	83 e0 10	 and	 eax, 16			; 00000010H
  00626	85 c0		 test	 eax, eax
  00628	75 09		 jne	 SHORT $L69737

; 791  :                     {
; 792  :                         dwAdditionalFlags |= DMUS_TRACKF_PLAY_OFF;

  0062a	8b 4d c4	 mov	 ecx, DWORD PTR _dwAdditionalFlags$69735[ebp]
  0062d	83 c9 40	 or	 ecx, 64			; 00000040H
  00630	89 4d c4	 mov	 DWORD PTR _dwAdditionalFlags$69735[ebp], ecx
$L69737:

; 793  :                     }
; 794  :                     // If the track was authored to generate new data on start or loop, let it know.
; 795  :                     if ( ((m_dwPlayTrackFlags & DMUS_TRACKF_START) && (pCTrack->m_dwFlags & DMUS_TRACKCONFIG_PLAY_COMPOSE)) ||
; 796  :                         ((m_dwPlayTrackFlags & DMUS_TRACKF_LOOP) && (pCTrack->m_dwFlags & DMUS_TRACKCONFIG_LOOP_COMPOSE)) )

  00633	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  00636	8b 42 58	 mov	 eax, DWORD PTR [edx+88]
  00639	83 e0 04	 and	 eax, 4
  0063c	85 c0		 test	 eax, eax
  0063e	74 10		 je	 SHORT $L69740
  00640	8b 4d e8	 mov	 ecx, DWORD PTR _pCTrack$[ebp]
  00643	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00646	81 e2 80 00 00
	00		 and	 edx, 128		; 00000080H
  0064c	85 d2		 test	 edx, edx
  0064e	75 1c		 jne	 SHORT $L69739
$L69740:
  00650	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  00653	8b 48 58	 mov	 ecx, DWORD PTR [eax+88]
  00656	83 e1 02	 and	 ecx, 2
  00659	85 c9		 test	 ecx, ecx
  0065b	74 1b		 je	 SHORT $L69738
  0065d	8b 55 e8	 mov	 edx, DWORD PTR _pCTrack$[ebp]
  00660	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  00663	25 00 01 00 00	 and	 eax, 256		; 00000100H
  00668	85 c0		 test	 eax, eax
  0066a	74 0c		 je	 SHORT $L69738
$L69739:

; 797  :                     {
; 798  :                         dwAdditionalFlags |= DMUS_TRACKF_RECOMPOSE;

  0066c	8b 4d c4	 mov	 ecx, DWORD PTR _dwAdditionalFlags$69735[ebp]
  0066f	81 c9 00 02 00
	00		 or	 ecx, 512		; 00000200H
  00675	89 4d c4	 mov	 DWORD PTR _dwAdditionalFlags$69735[ebp], ecx
$L69738:

; 799  :                     }
; 800  :                     if (pCTrack->m_dwInternalFlags & CONTROL_PLAY_REFRESH)

  00678	8b 55 e8	 mov	 edx, DWORD PTR _pCTrack$[ebp]
  0067b	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  0067e	83 e0 04	 and	 eax, 4
  00681	85 c0		 test	 eax, eax
  00683	74 18		 je	 SHORT $L69741

; 801  :                     {
; 802  :                         dwAdditionalFlags |= DMUS_TRACKF_START;

  00685	8b 4d c4	 mov	 ecx, DWORD PTR _dwAdditionalFlags$69735[ebp]
  00688	83 c9 04	 or	 ecx, 4
  0068b	89 4d c4	 mov	 DWORD PTR _dwAdditionalFlags$69735[ebp], ecx

; 803  :                         pCTrack->m_dwInternalFlags &= ~CONTROL_PLAY_REFRESH;

  0068e	8b 55 e8	 mov	 edx, DWORD PTR _pCTrack$[ebp]
  00691	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  00694	83 e0 fb	 and	 eax, -5			; fffffffbH
  00697	8b 4d e8	 mov	 ecx, DWORD PTR _pCTrack$[ebp]
  0069a	89 41 38	 mov	 DWORD PTR [ecx+56], eax
$L69741:

; 804  :                     }
; 805  :                     // Let performance know what the priority should be in ensuing GetParam() calls from the track.
; 806  :                     m_pPerformance->m_dwGetParamFlags = pCTrack->m_dwFlags;

  0069d	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  006a0	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  006a3	8b 4d e8	 mov	 ecx, DWORD PTR _pCTrack$[ebp]
  006a6	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  006a9	89 90 d8 03 00
	00		 mov	 DWORD PTR [eax+984], edx

; 807  :                     // If track has DX8 interface, use it.
; 808  :                     if (pCTrack->m_pTrack8)

  006af	8b 45 e8	 mov	 eax, DWORD PTR _pCTrack$[ebp]
  006b2	83 78 18 00	 cmp	 DWORD PTR [eax+24], 0
  006b6	0f 84 3b 01 00
	00		 je	 $L69742

; 809  :                     {
; 810  :                         //  The track can call GetParam on the segment which locks the segment so
; 811  :                         //  we have to lock the segment before calling PlayEx or we'll deadlock
; 812  :                         //  with a thread that's calling PlayOneSegment which locks the segment
; 813  :                         //  before playing the tracks.
; 814  :                         if (m_pSegment) 

  006bc	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  006bf	83 79 38 00	 cmp	 DWORD PTR [ecx+56], 0
  006c3	74 10		 je	 SHORT $L69743

; 815  :                         {
; 816  :                             ENTER_CRITICAL_SECTION(&m_pSegment->m_CriticalSection);

  006c5	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  006c8	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  006cb	83 c0 1c	 add	 eax, 28			; 0000001cH
  006ce	50		 push	 eax
  006cf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4
$L69743:

; 817  :                         }
; 818  :                         // If track plays in clock time, set time variables appropriately.
; 819  :                         if (pCTrack->m_dwFlags & DMUS_TRACKCONFIG_PLAY_CLOCKTIME)

  006d5	8b 4d e8	 mov	 ecx, DWORD PTR _pCTrack$[ebp]
  006d8	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  006db	83 e2 40	 and	 edx, 64			; 00000040H
  006de	85 d2		 test	 edx, edx
  006e0	0f 84 8c 00 00
	00		 je	 $L69744

; 820  :                         {
; 821  :                             if( ( S_OK == (pCTrack->m_pTrack8->PlayEx(pCTrack->m_pTrackState,
; 822  :                                 m_rtSeek,m_rtSeek + rtMyAmount, m_rtOffset, m_dwPlayTrackFlags | dwAdditionalFlags | DMUS_TRACKF_CLOCK,
; 823  :                                 m_pPerformance, this, pCTrack->m_dwVirtualID ))))

  006e6	8b 45 e8	 mov	 eax, DWORD PTR _pCTrack$[ebp]
  006e9	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  006ec	51		 push	 ecx
  006ed	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  006f0	52		 push	 edx
  006f1	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  006f4	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  006f7	51		 push	 ecx
  006f8	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  006fb	8b 42 58	 mov	 eax, DWORD PTR [edx+88]
  006fe	0b 45 c4	 or	 eax, DWORD PTR _dwAdditionalFlags$69735[ebp]
  00701	0d 00 04 00 00	 or	 eax, 1024		; 00000400H
  00706	50		 push	 eax
  00707	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  0070a	8b 91 bc 00 00
	00		 mov	 edx, DWORD PTR [ecx+188]
  00710	52		 push	 edx
  00711	8b 81 b8 00 00
	00		 mov	 eax, DWORD PTR [ecx+184]
  00717	50		 push	 eax
  00718	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  0071b	8b 91 c8 00 00
	00		 mov	 edx, DWORD PTR [ecx+200]
  00721	03 55 f0	 add	 edx, DWORD PTR _rtMyAmount$[ebp]
  00724	8b 81 cc 00 00
	00		 mov	 eax, DWORD PTR [ecx+204]
  0072a	13 45 f4	 adc	 eax, DWORD PTR _rtMyAmount$[ebp+4]
  0072d	50		 push	 eax
  0072e	52		 push	 edx
  0072f	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00732	8b 91 cc 00 00
	00		 mov	 edx, DWORD PTR [ecx+204]
  00738	52		 push	 edx
  00739	8b 81 c8 00 00
	00		 mov	 eax, DWORD PTR [ecx+200]
  0073f	50		 push	 eax
  00740	8b 4d e8	 mov	 ecx, DWORD PTR _pCTrack$[ebp]
  00743	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00746	52		 push	 edx
  00747	8b 45 e8	 mov	 eax, DWORD PTR _pCTrack$[ebp]
  0074a	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0074d	8b 55 e8	 mov	 edx, DWORD PTR _pCTrack$[ebp]
  00750	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00753	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00755	50		 push	 eax
  00756	ff 51 34	 call	 DWORD PTR [ecx+52]
  00759	85 c0		 test	 eax, eax
  0075b	75 09		 jne	 SHORT $L69746

; 824  :                             {
; 825  :                                 hr = S_OK; // if even one track isn't done playing,

  0075d	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 826  :                                 // keep going
; 827  :                             }
; 828  :                             else 

  00764	eb 0a		 jmp	 SHORT $L69748
$L69746:

; 829  :                             {
; 830  :                                 pCTrack->m_bDone = TRUE;

  00766	8b 55 e8	 mov	 edx, DWORD PTR _pCTrack$[ebp]
  00769	c7 42 20 01 00
	00 00		 mov	 DWORD PTR [edx+32], 1
$L69748:

; 831  :                             }
; 832  :                         }
; 833  :                         else

  00770	eb 6a		 jmp	 SHORT $L69749
$L69744:

; 834  :                         {
; 835  :                             if( ( S_OK == (pCTrack->m_pTrack8->PlayEx(pCTrack->m_pTrackState,
; 836  :                                 m_mtSeek,m_mtSeek + mtMyAmount, m_mtOffset, m_dwPlayTrackFlags | dwAdditionalFlags,
; 837  :                                 m_pPerformance, this, pCTrack->m_dwVirtualID ))))

  00772	8b 45 e8	 mov	 eax, DWORD PTR _pCTrack$[ebp]
  00775	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00778	51		 push	 ecx
  00779	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  0077c	52		 push	 edx
  0077d	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  00780	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00783	51		 push	 ecx
  00784	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  00787	8b 42 58	 mov	 eax, DWORD PTR [edx+88]
  0078a	0b 45 c4	 or	 eax, DWORD PTR _dwAdditionalFlags$69735[ebp]
  0078d	50		 push	 eax
  0078e	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00791	8b 41 6c	 mov	 eax, DWORD PTR [ecx+108]
  00794	99		 cdq
  00795	52		 push	 edx
  00796	50		 push	 eax
  00797	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  0079a	8b 42 78	 mov	 eax, DWORD PTR [edx+120]
  0079d	03 45 ec	 add	 eax, DWORD PTR _mtMyAmount$[ebp]
  007a0	99		 cdq
  007a1	52		 push	 edx
  007a2	50		 push	 eax
  007a3	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  007a6	8b 40 78	 mov	 eax, DWORD PTR [eax+120]
  007a9	99		 cdq
  007aa	52		 push	 edx
  007ab	50		 push	 eax
  007ac	8b 4d e8	 mov	 ecx, DWORD PTR _pCTrack$[ebp]
  007af	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  007b2	52		 push	 edx
  007b3	8b 45 e8	 mov	 eax, DWORD PTR _pCTrack$[ebp]
  007b6	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  007b9	8b 55 e8	 mov	 edx, DWORD PTR _pCTrack$[ebp]
  007bc	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  007bf	8b 09		 mov	 ecx, DWORD PTR [ecx]
  007c1	50		 push	 eax
  007c2	ff 51 34	 call	 DWORD PTR [ecx+52]
  007c5	85 c0		 test	 eax, eax
  007c7	75 09		 jne	 SHORT $L69751

; 838  :                             {
; 839  :                                 hr = S_OK; // if even one track isn't done playing,

  007c9	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 840  :                                 // keep going
; 841  :                             }
; 842  :                             else 

  007d0	eb 0a		 jmp	 SHORT $L69749
$L69751:

; 843  :                             {
; 844  :                                 pCTrack->m_bDone = TRUE;

  007d2	8b 55 e8	 mov	 edx, DWORD PTR _pCTrack$[ebp]
  007d5	c7 42 20 01 00
	00 00		 mov	 DWORD PTR [edx+32], 1
$L69749:

; 845  :                             }
; 846  :                         }
; 847  : 
; 848  :                         if (m_pSegment) 

  007dc	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  007df	83 78 38 00	 cmp	 DWORD PTR [eax+56], 0
  007e3	74 10		 je	 SHORT $L69754

; 849  :                         {
; 850  :                             LEAVE_CRITICAL_SECTION(&m_pSegment->m_CriticalSection);

  007e5	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  007e8	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  007eb	83 c2 1c	 add	 edx, 28			; 0000001cH
  007ee	52		 push	 edx
  007ef	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4
$L69754:

; 851  :                         }
; 852  :                     }
; 853  :                     else

  007f5	eb 64		 jmp	 SHORT $L69734
$L69742:

; 854  :                     {
; 855  :                         if( ( S_OK == ( pCTrack->m_pTrack->Play( pCTrack->m_pTrackState, 
; 856  :                             m_mtSeek, m_mtSeek + mtMyAmount, m_mtOffset, m_dwPlayTrackFlags | dwAdditionalFlags,
; 857  :                             m_pPerformance, this, pCTrack->m_dwVirtualID ))))

  007f7	8b 45 e8	 mov	 eax, DWORD PTR _pCTrack$[ebp]
  007fa	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  007fd	51		 push	 ecx
  007fe	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  00801	52		 push	 edx
  00802	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  00805	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00808	51		 push	 ecx
  00809	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  0080c	8b 42 58	 mov	 eax, DWORD PTR [edx+88]
  0080f	0b 45 c4	 or	 eax, DWORD PTR _dwAdditionalFlags$69735[ebp]
  00812	50		 push	 eax
  00813	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00816	8b 51 6c	 mov	 edx, DWORD PTR [ecx+108]
  00819	52		 push	 edx
  0081a	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  0081d	8b 48 78	 mov	 ecx, DWORD PTR [eax+120]
  00820	03 4d ec	 add	 ecx, DWORD PTR _mtMyAmount$[ebp]
  00823	51		 push	 ecx
  00824	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  00827	8b 42 78	 mov	 eax, DWORD PTR [edx+120]
  0082a	50		 push	 eax
  0082b	8b 4d e8	 mov	 ecx, DWORD PTR _pCTrack$[ebp]
  0082e	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00831	52		 push	 edx
  00832	8b 45 e8	 mov	 eax, DWORD PTR _pCTrack$[ebp]
  00835	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00838	8b 55 e8	 mov	 edx, DWORD PTR _pCTrack$[ebp]
  0083b	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0083e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00840	50		 push	 eax
  00841	ff 51 18	 call	 DWORD PTR [ecx+24]
  00844	85 c0		 test	 eax, eax
  00846	75 09		 jne	 SHORT $L69757

; 858  :                         {
; 859  :                             hr = S_OK; // if even one track isn't done playing,

  00848	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 860  :                             // keep going
; 861  :                         }
; 862  :                         else

  0084f	eb 0a		 jmp	 SHORT $L69734
$L69757:

; 863  :                         {
; 864  :                             pCTrack->m_bDone = TRUE;

  00851	8b 55 e8	 mov	 edx, DWORD PTR _pCTrack$[ebp]
  00854	c7 42 20 01 00
	00 00		 mov	 DWORD PTR [edx+32], 1
$L69734:

; 865  :                         }
; 866  :                     }
; 867  :                 }
; 868  :                 m_pPerformance->m_fInTrackPlay = FALSE;

  0085b	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  0085e	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00861	c7 81 10 01 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+272], 0
$L69731:

; 869  :             }
; 870  :             pCTrack = pCTrack->GetNext();

  0086b	8b 4d e8	 mov	 ecx, DWORD PTR _pCTrack$[ebp]
  0086e	e8 00 00 00 00	 call	 ?GetNext@CTrack@@QAEPAV1@XZ ; CTrack::GetNext
  00873	89 45 e8	 mov	 DWORD PTR _pCTrack$[ebp], eax

; 871  :             if( pCTrack == NULL )

  00876	83 7d e8 00	 cmp	 DWORD PTR _pCTrack$[ebp], 0
  0087a	0f 85 3d 09 00
	00		 jne	 $L69760

; 872  :             {
; 873  :                 // none of the play flags are persistent
; 874  :                 m_dwPlayTrackFlags = 0;

  00880	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  00883	c7 42 58 00 00
	00 00		 mov	 DWORD PTR [edx+88], 0

; 875  :                 m_mtLastPlayed += mtMyAmount;   // increment play pointer

  0088a	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  0088d	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  00890	03 4d ec	 add	 ecx, DWORD PTR _mtMyAmount$[ebp]
  00893	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  00896	89 4a 70	 mov	 DWORD PTR [edx+112], ecx

; 876  :                 m_rtLastPlayed += rtMyAmount;   // same in ref time

  00899	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  0089c	8b 88 a8 00 00
	00		 mov	 ecx, DWORD PTR [eax+168]
  008a2	03 4d f0	 add	 ecx, DWORD PTR _rtMyAmount$[ebp]
  008a5	8b 90 ac 00 00
	00		 mov	 edx, DWORD PTR [eax+172]
  008ab	13 55 f4	 adc	 edx, DWORD PTR _rtMyAmount$[ebp+4]
  008ae	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  008b1	89 88 a8 00 00
	00		 mov	 DWORD PTR [eax+168], ecx
  008b7	89 90 ac 00 00
	00		 mov	 DWORD PTR [eax+172], edx

; 877  :                 m_mtSeek += mtMyAmount;         // increment seek pointer

  008bd	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  008c0	8b 51 78	 mov	 edx, DWORD PTR [ecx+120]
  008c3	03 55 ec	 add	 edx, DWORD PTR _mtMyAmount$[ebp]
  008c6	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  008c9	89 50 78	 mov	 DWORD PTR [eax+120], edx

; 878  :                 m_rtSeek += rtMyAmount;

  008cc	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  008cf	8b 91 c8 00 00
	00		 mov	 edx, DWORD PTR [ecx+200]
  008d5	03 55 f0	 add	 edx, DWORD PTR _rtMyAmount$[ebp]
  008d8	8b 81 cc 00 00
	00		 mov	 eax, DWORD PTR [ecx+204]
  008de	13 45 f4	 adc	 eax, DWORD PTR _rtMyAmount$[ebp+4]
  008e1	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  008e4	89 91 c8 00 00
	00		 mov	 DWORD PTR [ecx+200], edx
  008ea	89 81 cc 00 00
	00		 mov	 DWORD PTR [ecx+204], eax

; 879  :                 hr = S_OK;

  008f0	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 880  : 
; 881  :                 // If we're looping....
; 882  :                 // And if this is the first repeat
; 883  :                 if(m_dwRepeats > 0 && m_dwRepeats == m_dwRepeatsLeft)

  008f7	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  008fa	83 7a 50 00	 cmp	 DWORD PTR [edx+80], 0
  008fe	0f 86 ed 01 00
	00		 jbe	 $L69762
  00904	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  00907	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  0090a	8b 50 50	 mov	 edx, DWORD PTR [eax+80]
  0090d	3b 91 00 01 00
	00		 cmp	 edx, DWORD PTR [ecx+256]
  00913	0f 85 d8 01 00
	00		 jne	 $L69762

; 884  :                 {
; 885  :                     if (m_rtLoopEnd)

  00919	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  0091c	89 85 74 ff ff
	ff		 mov	 DWORD PTR tv1403[ebp], eax
  00922	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR tv1403[ebp]
  00928	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR tv1403[ebp]
  0092e	8b 81 98 00 00
	00		 mov	 eax, DWORD PTR [ecx+152]
  00934	0b 82 9c 00 00
	00		 or	 eax, DWORD PTR [edx+156]
  0093a	85 c0		 test	 eax, eax
  0093c	0f 84 e5 00 00
	00		 je	 $L69763

; 886  :                     {
; 887  :                         // If we're playing the loop start, remember it's musictime value
; 888  :                         if(m_rtSeek >= m_rtLoopStart && m_rtFirstLoopStart == 0)

  00942	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00945	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  00948	89 8d 70 ff ff
	ff		 mov	 DWORD PTR tv1411[ebp], ecx
  0094e	89 95 6c ff ff
	ff		 mov	 DWORD PTR tv1412[ebp], edx
  00954	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR tv1411[ebp]
  0095a	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR tv1412[ebp]
  00960	8b 90 cc 00 00
	00		 mov	 edx, DWORD PTR [eax+204]
  00966	3b 91 94 00 00
	00		 cmp	 edx, DWORD PTR [ecx+148]
  0096c	0f 8c b0 00 00
	00		 jl	 $L69764
  00972	7f 1e		 jg	 SHORT $L70689
  00974	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR tv1411[ebp]
  0097a	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR tv1412[ebp]
  00980	8b 90 c8 00 00
	00		 mov	 edx, DWORD PTR [eax+200]
  00986	3b 91 90 00 00
	00		 cmp	 edx, DWORD PTR [ecx+144]
  0098c	0f 82 90 00 00
	00		 jb	 $L69764
$L70689:
  00992	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  00995	89 85 68 ff ff
	ff		 mov	 DWORD PTR tv1422[ebp], eax
  0099b	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR tv1422[ebp]
  009a1	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR tv1422[ebp]
  009a7	8b 81 d8 00 00
	00		 mov	 eax, DWORD PTR [ecx+216]
  009ad	0b 82 dc 00 00
	00		 or	 eax, DWORD PTR [edx+220]
  009b3	85 c0		 test	 eax, eax
  009b5	75 6b		 jne	 SHORT $L69764

; 889  :                         {
; 890  :                             m_rtFirstLoopStart = m_rtLoopStart + m_rtOffset;

  009b7	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  009ba	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  009bd	8b 81 90 00 00
	00		 mov	 eax, DWORD PTR [ecx+144]
  009c3	03 82 b8 00 00
	00		 add	 eax, DWORD PTR [edx+184]
  009c9	8b 89 94 00 00
	00		 mov	 ecx, DWORD PTR [ecx+148]
  009cf	13 8a bc 00 00
	00		 adc	 ecx, DWORD PTR [edx+188]
  009d5	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  009d8	89 82 d8 00 00
	00		 mov	 DWORD PTR [edx+216], eax
  009de	89 8a dc 00 00
	00		 mov	 DWORD PTR [edx+220], ecx

; 891  :                             m_pPerformance->ReferenceToMusicTime(m_rtFirstLoopStart,&m_mtFirstLoopStart);

  009e4	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  009e7	05 84 00 00 00	 add	 eax, 132		; 00000084H
  009ec	50		 push	 eax
  009ed	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  009f0	8b 91 dc 00 00
	00		 mov	 edx, DWORD PTR [ecx+220]
  009f6	52		 push	 edx
  009f7	8b 81 d8 00 00
	00		 mov	 eax, DWORD PTR [ecx+216]
  009fd	50		 push	 eax
  009fe	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00a01	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00a04	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  00a07	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00a0a	8b 12		 mov	 edx, DWORD PTR [edx]
  00a0c	51		 push	 ecx
  00a0d	ff 52 18	 call	 DWORD PTR [edx+24]

; 892  :                             m_mtCurLoopStart = m_mtFirstLoopStart;

  00a10	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  00a13	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00a16	8b 91 84 00 00
	00		 mov	 edx, DWORD PTR [ecx+132]
  00a1c	89 90 88 00 00
	00		 mov	 DWORD PTR [eax+136], edx
$L69764:

; 893  :                         }
; 894  :                     }
; 895  :                     else

  00a22	e9 ca 00 00 00	 jmp	 $L69762
$L69763:

; 896  :                     {
; 897  :                         // If we're playing the loop start, remember it's reftime value
; 898  :                         if(m_mtSeek >= m_mtLoopStart && m_rtFirstLoopStart == 0)

  00a27	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  00a2a	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00a2d	8b 50 78	 mov	 edx, DWORD PTR [eax+120]
  00a30	3b 51 48	 cmp	 edx, DWORD PTR [ecx+72]
  00a33	0f 8c b8 00 00
	00		 jl	 $L69762
  00a39	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  00a3c	89 85 64 ff ff
	ff		 mov	 DWORD PTR tv1455[ebp], eax
  00a42	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR tv1455[ebp]
  00a48	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR tv1455[ebp]
  00a4e	8b 81 d8 00 00
	00		 mov	 eax, DWORD PTR [ecx+216]
  00a54	0b 82 dc 00 00
	00		 or	 eax, DWORD PTR [edx+220]
  00a5a	85 c0		 test	 eax, eax
  00a5c	0f 85 8f 00 00
	00		 jne	 $L69762

; 899  :                         {
; 900  :                             m_mtFirstLoopStart = m_mtLoopStart + m_mtOffset;

  00a62	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00a65	8b 51 48	 mov	 edx, DWORD PTR [ecx+72]
  00a68	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  00a6b	03 50 6c	 add	 edx, DWORD PTR [eax+108]
  00a6e	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00a71	89 91 84 00 00
	00		 mov	 DWORD PTR [ecx+132], edx

; 901  :                             // Huh? Why are we including the startpoint in this calculation? I talked with Bob and it's
; 902  :                             // to work around a problem with a tempo map in a clock time segment. 
; 903  :                             // But, even this solution can cause flawed results. 
; 904  :                             // Truth is, you should never have a tempo map in a clock time segment, but we'll need to 
; 905  :                             // keep this for regression reasons. 
; 906  :                             m_pPerformance->MusicToReferenceTime(m_mtLoopStart + m_mtOffset + m_mtStartPoint, &m_rtFirstLoopStart);

  00a77	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  00a7a	81 c2 d8 00 00
	00		 add	 edx, 216		; 000000d8H
  00a80	52		 push	 edx
  00a81	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  00a84	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  00a87	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  00a8a	03 4a 6c	 add	 ecx, DWORD PTR [edx+108]
  00a8d	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  00a90	03 48 7c	 add	 ecx, DWORD PTR [eax+124]
  00a93	51		 push	 ecx
  00a94	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00a97	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00a9a	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  00a9d	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00aa0	8b 12		 mov	 edx, DWORD PTR [edx]
  00aa2	51		 push	 ecx
  00aa3	ff 52 14	 call	 DWORD PTR [edx+20]

; 907  :                             m_rtFirstLoopStart -= m_rtStartPoint;

  00aa6	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  00aa9	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00aac	8b 90 d8 00 00
	00		 mov	 edx, DWORD PTR [eax+216]
  00ab2	2b 91 b0 00 00
	00		 sub	 edx, DWORD PTR [ecx+176]
  00ab8	8b 80 dc 00 00
	00		 mov	 eax, DWORD PTR [eax+220]
  00abe	1b 81 b4 00 00
	00		 sbb	 eax, DWORD PTR [ecx+180]
  00ac4	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00ac7	89 91 d8 00 00
	00		 mov	 DWORD PTR [ecx+216], edx
  00acd	89 81 dc 00 00
	00		 mov	 DWORD PTR [ecx+220], eax

; 908  :                             m_rtCurLoopStart = m_rtFirstLoopStart;

  00ad3	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  00ad6	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  00ad9	8b 88 d8 00 00
	00		 mov	 ecx, DWORD PTR [eax+216]
  00adf	89 8a e0 00 00
	00		 mov	 DWORD PTR [edx+224], ecx
  00ae5	8b 80 dc 00 00
	00		 mov	 eax, DWORD PTR [eax+220]
  00aeb	89 82 e4 00 00
	00		 mov	 DWORD PTR [edx+228], eax
$L69762:

; 909  :                         }
; 910  :                     }
; 911  :                 }
; 912  : 
; 913  :                 // take into account repeats if necessary
; 914  :                 if((m_mtSeek >= m_mtLoopEnd ) || (m_rtLoopEnd && (m_rtSeek >= m_rtLoopEnd)))

  00af1	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00af4	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  00af7	8b 41 78	 mov	 eax, DWORD PTR [ecx+120]
  00afa	3b 42 4c	 cmp	 eax, DWORD PTR [edx+76]
  00afd	7d 79		 jge	 SHORT $L69768
  00aff	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00b02	89 8d 60 ff ff
	ff		 mov	 DWORD PTR tv1491[ebp], ecx
  00b08	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR tv1491[ebp]
  00b0e	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR tv1491[ebp]
  00b14	8b 8a 98 00 00
	00		 mov	 ecx, DWORD PTR [edx+152]
  00b1a	0b 88 9c 00 00
	00		 or	 ecx, DWORD PTR [eax+156]
  00b20	85 c9		 test	 ecx, ecx
  00b22	0f 84 95 06 00
	00		 je	 $L69760
  00b28	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  00b2b	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  00b2e	89 95 5c ff ff
	ff		 mov	 DWORD PTR tv1499[ebp], edx
  00b34	89 85 58 ff ff
	ff		 mov	 DWORD PTR tv1500[ebp], eax
  00b3a	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR tv1499[ebp]
  00b40	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR tv1500[ebp]
  00b46	8b 81 cc 00 00
	00		 mov	 eax, DWORD PTR [ecx+204]
  00b4c	3b 82 9c 00 00
	00		 cmp	 eax, DWORD PTR [edx+156]
  00b52	0f 8c 65 06 00
	00		 jl	 $L69760
  00b58	7f 1e		 jg	 SHORT $L69768
  00b5a	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR tv1499[ebp]
  00b60	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR tv1500[ebp]
  00b66	8b 81 c8 00 00
	00		 mov	 eax, DWORD PTR [ecx+200]
  00b6c	3b 82 98 00 00
	00		 cmp	 eax, DWORD PTR [edx+152]
  00b72	0f 82 45 06 00
	00		 jb	 $L69760
$L69768:

; 915  :                 {
; 916  :                     // Remember the current loop end
; 917  :                     if (m_rtLoopEnd)

  00b78	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00b7b	89 8d 54 ff ff
	ff		 mov	 DWORD PTR tv1510[ebp], ecx
  00b81	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR tv1510[ebp]
  00b87	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR tv1510[ebp]
  00b8d	8b 8a 98 00 00
	00		 mov	 ecx, DWORD PTR [edx+152]
  00b93	0b 88 9c 00 00
	00		 or	 ecx, DWORD PTR [eax+156]
  00b99	85 c9		 test	 ecx, ecx
  00b9b	74 3e		 je	 SHORT $L69769

; 918  :                     {
; 919  :                         m_pPerformance->ReferenceToMusicTime(m_rtLoopEnd + m_rtOffset,&m_mtCurLoopEnd);

  00b9d	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  00ba0	81 c2 8c 00 00
	00		 add	 edx, 140		; 0000008cH
  00ba6	52		 push	 edx
  00ba7	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  00baa	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00bad	8b 90 98 00 00
	00		 mov	 edx, DWORD PTR [eax+152]
  00bb3	03 91 b8 00 00
	00		 add	 edx, DWORD PTR [ecx+184]
  00bb9	8b 80 9c 00 00
	00		 mov	 eax, DWORD PTR [eax+156]
  00bbf	13 81 bc 00 00
	00		 adc	 eax, DWORD PTR [ecx+188]
  00bc5	50		 push	 eax
  00bc6	52		 push	 edx
  00bc7	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00bca	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00bcd	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  00bd0	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00bd3	8b 12		 mov	 edx, DWORD PTR [edx]
  00bd5	51		 push	 ecx
  00bd6	ff 52 18	 call	 DWORD PTR [edx+24]

; 920  :                     }
; 921  :                     else

  00bd9	eb 5b		 jmp	 SHORT $L69770
$L69769:

; 922  :                     {
; 923  :                         // Again, we have this weirdness with startpoint that should not be...
; 924  :                         m_pPerformance->MusicToReferenceTime(m_mtLoopEnd + m_mtOffset + m_mtStartPoint, &m_rtCurLoopEnd);

  00bdb	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  00bde	05 e8 00 00 00	 add	 eax, 232		; 000000e8H
  00be3	50		 push	 eax
  00be4	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00be7	8b 51 4c	 mov	 edx, DWORD PTR [ecx+76]
  00bea	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  00bed	03 50 6c	 add	 edx, DWORD PTR [eax+108]
  00bf0	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00bf3	03 51 7c	 add	 edx, DWORD PTR [ecx+124]
  00bf6	52		 push	 edx
  00bf7	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  00bfa	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  00bfd	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00c00	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00c03	8b 00		 mov	 eax, DWORD PTR [eax]
  00c05	52		 push	 edx
  00c06	ff 50 14	 call	 DWORD PTR [eax+20]

; 925  :                         m_rtCurLoopEnd -= m_rtStartPoint;

  00c09	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00c0c	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  00c0f	8b 81 e8 00 00
	00		 mov	 eax, DWORD PTR [ecx+232]
  00c15	2b 82 b0 00 00
	00		 sub	 eax, DWORD PTR [edx+176]
  00c1b	8b 89 ec 00 00
	00		 mov	 ecx, DWORD PTR [ecx+236]
  00c21	1b 8a b4 00 00
	00		 sbb	 ecx, DWORD PTR [edx+180]
  00c27	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  00c2a	89 82 e8 00 00
	00		 mov	 DWORD PTR [edx+232], eax
  00c30	89 8a ec 00 00
	00		 mov	 DWORD PTR [edx+236], ecx
$L69770:

; 926  :                     }
; 927  : 
; 928  :                     if(m_dwRepeatsLeft)

  00c36	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  00c39	83 b8 00 01 00
	00 00		 cmp	 DWORD PTR [eax+256], 0
  00c40	0f 84 62 05 00
	00		 je	 $L69771

; 929  :                     {
; 930  :                         m_dwPlayTrackFlags |= DMUS_TRACKF_LOOP | DMUS_TRACKF_SEEK;

  00c46	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00c49	8b 51 58	 mov	 edx, DWORD PTR [ecx+88]
  00c4c	83 ca 03	 or	 edx, 3
  00c4f	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  00c52	89 50 58	 mov	 DWORD PTR [eax+88], edx

; 931  :                         m_dwRepeatsLeft--;

  00c55	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00c58	8b 91 00 01 00
	00		 mov	 edx, DWORD PTR [ecx+256]
  00c5e	83 ea 01	 sub	 edx, 1
  00c61	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  00c64	89 90 00 01 00
	00		 mov	 DWORD PTR [eax+256], edx

; 932  :                         pCTrack = m_TrackList.GetHead();

  00c6a	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00c6d	83 c1 44	 add	 ecx, 68			; 00000044H
  00c70	e8 00 00 00 00	 call	 ?GetHead@CTrackList@@QAEPAVCTrack@@XZ ; CTrackList::GetHead
  00c75	89 45 e8	 mov	 DWORD PTR _pCTrack$[ebp], eax
$L69773:

; 933  :                         while( pCTrack )

  00c78	83 7d e8 00	 cmp	 DWORD PTR _pCTrack$[ebp], 0
  00c7c	74 17		 je	 SHORT $L69774

; 934  :                         {
; 935  :                             pCTrack->m_bDone = FALSE;

  00c7e	8b 4d e8	 mov	 ecx, DWORD PTR _pCTrack$[ebp]
  00c81	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0

; 936  :                             pCTrack = pCTrack->GetNext();

  00c88	8b 4d e8	 mov	 ecx, DWORD PTR _pCTrack$[ebp]
  00c8b	e8 00 00 00 00	 call	 ?GetNext@CTrack@@QAEPAV1@XZ ; CTrack::GetNext
  00c90	89 45 e8	 mov	 DWORD PTR _pCTrack$[ebp], eax

; 937  :                         }

  00c93	eb e3		 jmp	 SHORT $L69773
$L69774:

; 938  :                         
; 939  :                         if (m_rtLoopEnd)

  00c95	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  00c98	89 95 50 ff ff
	ff		 mov	 DWORD PTR tv1558[ebp], edx
  00c9e	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR tv1558[ebp]
  00ca4	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR tv1558[ebp]
  00caa	8b 90 98 00 00
	00		 mov	 edx, DWORD PTR [eax+152]
  00cb0	0b 91 9c 00 00
	00		 or	 edx, DWORD PTR [ecx+156]
  00cb6	85 d2		 test	 edx, edx
  00cb8	0f 84 ea 00 00
	00		 je	 $L69775

; 940  :                         {
; 941  :                             m_rtSeek = m_rtLoopStart;

  00cbe	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  00cc1	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00cc4	8b 91 90 00 00
	00		 mov	 edx, DWORD PTR [ecx+144]
  00cca	89 90 c8 00 00
	00		 mov	 DWORD PTR [eax+200], edx
  00cd0	8b 89 94 00 00
	00		 mov	 ecx, DWORD PTR [ecx+148]
  00cd6	89 88 cc 00 00
	00		 mov	 DWORD PTR [eax+204], ecx

; 942  :                             m_rtOffset += ( m_rtLoopEnd - m_rtLoopStart);

  00cdc	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  00cdf	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  00ce2	8b 8a 98 00 00
	00		 mov	 ecx, DWORD PTR [edx+152]
  00ce8	2b 88 90 00 00
	00		 sub	 ecx, DWORD PTR [eax+144]
  00cee	8b 92 9c 00 00
	00		 mov	 edx, DWORD PTR [edx+156]
  00cf4	1b 90 94 00 00
	00		 sbb	 edx, DWORD PTR [eax+148]
  00cfa	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  00cfd	8b b0 b8 00 00
	00		 mov	 esi, DWORD PTR [eax+184]
  00d03	03 f1		 add	 esi, ecx
  00d05	8b 88 bc 00 00
	00		 mov	 ecx, DWORD PTR [eax+188]
  00d0b	13 ca		 adc	 ecx, edx
  00d0d	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  00d10	89 b2 b8 00 00
	00		 mov	 DWORD PTR [edx+184], esi
  00d16	89 8a bc 00 00
	00		 mov	 DWORD PTR [edx+188], ecx

; 943  :                         
; 944  :                             m_mtOffset += (m_mtCurLoopEnd - m_mtCurLoopStart);

  00d1c	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  00d1f	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00d22	8b 90 8c 00 00
	00		 mov	 edx, DWORD PTR [eax+140]
  00d28	2b 91 88 00 00
	00		 sub	 edx, DWORD PTR [ecx+136]
  00d2e	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  00d31	03 50 6c	 add	 edx, DWORD PTR [eax+108]
  00d34	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00d37	89 51 6c	 mov	 DWORD PTR [ecx+108], edx

; 945  :                             m_mtFirstLoopStart += (m_mtCurLoopEnd - m_mtCurLoopStart);

  00d3a	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  00d3d	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  00d40	8b 8a 8c 00 00
	00		 mov	 ecx, DWORD PTR [edx+140]
  00d46	2b 88 88 00 00
	00		 sub	 ecx, DWORD PTR [eax+136]
  00d4c	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  00d4f	03 8a 84 00 00
	00		 add	 ecx, DWORD PTR [edx+132]
  00d55	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  00d58	89 88 84 00 00
	00		 mov	 DWORD PTR [eax+132], ecx

; 946  :                             m_mtSeek = m_mtFirstLoopStart - m_mtOffset;

  00d5e	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00d61	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  00d64	8b 81 84 00 00
	00		 mov	 eax, DWORD PTR [ecx+132]
  00d6a	2b 42 6c	 sub	 eax, DWORD PTR [edx+108]
  00d6d	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00d70	89 41 78	 mov	 DWORD PTR [ecx+120], eax

; 947  : 
; 948  :                             m_mtEndTime += (m_mtCurLoopEnd - m_mtCurLoopStart);

  00d73	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  00d76	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  00d79	8b 8a 8c 00 00
	00		 mov	 ecx, DWORD PTR [edx+140]
  00d7f	2b 88 88 00 00
	00		 sub	 ecx, DWORD PTR [eax+136]
  00d85	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  00d88	03 4a 68	 add	 ecx, DWORD PTR [edx+104]
  00d8b	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  00d8e	89 48 68	 mov	 DWORD PTR [eax+104], ecx

; 949  :                    
; 950  :                             m_mtCurLoopStart = m_mtCurLoopEnd;

  00d91	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00d94	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  00d97	8b 82 8c 00 00
	00		 mov	 eax, DWORD PTR [edx+140]
  00d9d	89 81 88 00 00
	00		 mov	 DWORD PTR [ecx+136], eax

; 951  :                         }
; 952  :                         else

  00da3	e9 2f 01 00 00	 jmp	 $L69776
$L69775:

; 953  :                         {    
; 954  :                             m_mtSeek = m_mtLoopStart;

  00da8	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00dab	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  00dae	8b 42 48	 mov	 eax, DWORD PTR [edx+72]
  00db1	89 41 78	 mov	 DWORD PTR [ecx+120], eax

; 955  :                             m_mtOffset += ( m_mtLoopEnd - m_mtLoopStart);

  00db4	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00db7	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  00dba	8b 41 4c	 mov	 eax, DWORD PTR [ecx+76]
  00dbd	2b 42 48	 sub	 eax, DWORD PTR [edx+72]
  00dc0	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00dc3	03 41 6c	 add	 eax, DWORD PTR [ecx+108]
  00dc6	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  00dc9	89 42 6c	 mov	 DWORD PTR [edx+108], eax

; 956  :                         
; 957  :                         
; 958  :                             m_rtOffset += (m_rtCurLoopEnd - m_rtCurLoopStart);

  00dcc	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  00dcf	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00dd2	8b 90 e8 00 00
	00		 mov	 edx, DWORD PTR [eax+232]
  00dd8	2b 91 e0 00 00
	00		 sub	 edx, DWORD PTR [ecx+224]
  00dde	8b 80 ec 00 00
	00		 mov	 eax, DWORD PTR [eax+236]
  00de4	1b 81 e4 00 00
	00		 sbb	 eax, DWORD PTR [ecx+228]
  00dea	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00ded	8b b1 b8 00 00
	00		 mov	 esi, DWORD PTR [ecx+184]
  00df3	03 f2		 add	 esi, edx
  00df5	8b 91 bc 00 00
	00		 mov	 edx, DWORD PTR [ecx+188]
  00dfb	13 d0		 adc	 edx, eax
  00dfd	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  00e00	89 b0 b8 00 00
	00		 mov	 DWORD PTR [eax+184], esi
  00e06	89 90 bc 00 00
	00		 mov	 DWORD PTR [eax+188], edx

; 959  :                             m_rtFirstLoopStart += (m_rtCurLoopEnd - m_rtCurLoopStart);

  00e0c	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00e0f	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  00e12	8b 81 e8 00 00
	00		 mov	 eax, DWORD PTR [ecx+232]
  00e18	2b 82 e0 00 00
	00		 sub	 eax, DWORD PTR [edx+224]
  00e1e	8b 89 ec 00 00
	00		 mov	 ecx, DWORD PTR [ecx+236]
  00e24	1b 8a e4 00 00
	00		 sbb	 ecx, DWORD PTR [edx+228]
  00e2a	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  00e2d	8b b2 d8 00 00
	00		 mov	 esi, DWORD PTR [edx+216]
  00e33	03 f0		 add	 esi, eax
  00e35	8b 82 dc 00 00
	00		 mov	 eax, DWORD PTR [edx+220]
  00e3b	13 c1		 adc	 eax, ecx
  00e3d	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00e40	89 b1 d8 00 00
	00		 mov	 DWORD PTR [ecx+216], esi
  00e46	89 81 dc 00 00
	00		 mov	 DWORD PTR [ecx+220], eax

; 960  :                             m_rtSeek = m_rtFirstLoopStart - m_rtOffset;

  00e4c	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  00e4f	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  00e52	8b 8a d8 00 00
	00		 mov	 ecx, DWORD PTR [edx+216]
  00e58	2b 88 b8 00 00
	00		 sub	 ecx, DWORD PTR [eax+184]
  00e5e	8b 92 dc 00 00
	00		 mov	 edx, DWORD PTR [edx+220]
  00e64	1b 90 bc 00 00
	00		 sbb	 edx, DWORD PTR [eax+188]
  00e6a	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  00e6d	89 88 c8 00 00
	00		 mov	 DWORD PTR [eax+200], ecx
  00e73	89 90 cc 00 00
	00		 mov	 DWORD PTR [eax+204], edx

; 961  : 
; 962  :                             m_rtEndTime += (m_rtCurLoopEnd - m_rtCurLoopStart);

  00e79	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00e7c	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  00e7f	8b 81 e8 00 00
	00		 mov	 eax, DWORD PTR [ecx+232]
  00e85	2b 82 e0 00 00
	00		 sub	 eax, DWORD PTR [edx+224]
  00e8b	8b 89 ec 00 00
	00		 mov	 ecx, DWORD PTR [ecx+236]
  00e91	1b 8a e4 00 00
	00		 sbb	 ecx, DWORD PTR [edx+228]
  00e97	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  00e9a	8b b2 c0 00 00
	00		 mov	 esi, DWORD PTR [edx+192]
  00ea0	03 f0		 add	 esi, eax
  00ea2	8b 82 c4 00 00
	00		 mov	 eax, DWORD PTR [edx+196]
  00ea8	13 c1		 adc	 eax, ecx
  00eaa	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00ead	89 b1 c0 00 00
	00		 mov	 DWORD PTR [ecx+192], esi
  00eb3	89 81 c4 00 00
	00		 mov	 DWORD PTR [ecx+196], eax

; 963  :                    
; 964  :                             m_rtCurLoopStart = m_rtCurLoopEnd;

  00eb9	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  00ebc	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  00ebf	8b 88 e8 00 00
	00		 mov	 ecx, DWORD PTR [eax+232]
  00ec5	89 8a e0 00 00
	00		 mov	 DWORD PTR [edx+224], ecx
  00ecb	8b 80 ec 00 00
	00		 mov	 eax, DWORD PTR [eax+236]
  00ed1	89 82 e4 00 00
	00		 mov	 DWORD PTR [edx+228], eax
$L69776:

; 965  :                         }
; 966  : 
; 967  : 
; 968  :                         if( mtMyAmount < mtAmount )

  00ed7	8b 4d ec	 mov	 ecx, DWORD PTR _mtMyAmount$[ebp]
  00eda	3b 4d 08	 cmp	 ecx, DWORD PTR _mtAmount$[ebp]
  00edd	0f 8d 09 02 00
	00		 jge	 $L69777

; 969  :                         {
; 970  :                             pCTrack = m_TrackList.GetHead(); // cause outer while loop to start over

  00ee3	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00ee6	83 c1 44	 add	 ecx, 68			; 00000044H
  00ee9	e8 00 00 00 00	 call	 ?GetHead@CTrackList@@QAEPAVCTrack@@XZ ; CTrackList::GetHead
  00eee	89 45 e8	 mov	 DWORD PTR _pCTrack$[ebp], eax

; 971  :                             mtMyAmount = mtAmount - mtMyAmount;

  00ef1	8b 55 08	 mov	 edx, DWORD PTR _mtAmount$[ebp]
  00ef4	2b 55 ec	 sub	 edx, DWORD PTR _mtMyAmount$[ebp]
  00ef7	89 55 ec	 mov	 DWORD PTR _mtMyAmount$[ebp], edx

; 972  :                             mtAmount = mtMyAmount;

  00efa	8b 45 ec	 mov	 eax, DWORD PTR _mtMyAmount$[ebp]
  00efd	89 45 08	 mov	 DWORD PTR _mtAmount$[ebp], eax

; 973  :                             // if we need to do a loop or the end is near, restrict mtMyAmount
; 974  :                             if( m_dwRepeatsLeft )

  00f00	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00f03	83 b9 00 01 00
	00 00		 cmp	 DWORD PTR [ecx+256], 0
  00f0a	0f 84 84 01 00
	00		 je	 $L69778

; 975  :                             {
; 976  :                                 if (m_rtLoopEnd)    // Is this a clock time looped segment?

  00f10	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  00f13	89 95 4c ff ff
	ff		 mov	 DWORD PTR tv1696[ebp], edx
  00f19	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR tv1696[ebp]
  00f1f	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR tv1696[ebp]
  00f25	8b 90 98 00 00
	00		 mov	 edx, DWORD PTR [eax+152]
  00f2b	0b 91 9c 00 00
	00		 or	 edx, DWORD PTR [ecx+156]
  00f31	85 d2		 test	 edx, edx
  00f33	0f 84 39 01 00
	00		 je	 $L69779

; 977  :                                 {
; 978  :                                     // If so, convert from clock time to music time.
; 979  :                                     REFERENCE_TIME rtCalcAmount;
; 980  :                                     m_pPerformance->MusicToReferenceTime(m_mtLastPlayed + mtMyAmount,&rtCalcAmount);

  00f39	8d 45 b8	 lea	 eax, DWORD PTR _rtCalcAmount$69780[ebp]
  00f3c	50		 push	 eax
  00f3d	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00f40	8b 51 70	 mov	 edx, DWORD PTR [ecx+112]
  00f43	03 55 ec	 add	 edx, DWORD PTR _mtMyAmount$[ebp]
  00f46	52		 push	 edx
  00f47	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  00f4a	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00f4d	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  00f50	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  00f53	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00f55	50		 push	 eax
  00f56	ff 51 14	 call	 DWORD PTR [ecx+20]

; 981  :                                     rtCalcAmount -= m_rtLastPlayed;

  00f59	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  00f5c	8b 45 b8	 mov	 eax, DWORD PTR _rtCalcAmount$69780[ebp]
  00f5f	2b 82 a8 00 00
	00		 sub	 eax, DWORD PTR [edx+168]
  00f65	8b 4d bc	 mov	 ecx, DWORD PTR _rtCalcAmount$69780[ebp+4]
  00f68	1b 8a ac 00 00
	00		 sbb	 ecx, DWORD PTR [edx+172]
  00f6e	89 45 b8	 mov	 DWORD PTR _rtCalcAmount$69780[ebp], eax
  00f71	89 4d bc	 mov	 DWORD PTR _rtCalcAmount$69780[ebp+4], ecx

; 982  :                                     if (rtCalcAmount > m_rtLoopEnd - m_rtSeek)

  00f74	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  00f77	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  00f7a	8b 8a 98 00 00
	00		 mov	 ecx, DWORD PTR [edx+152]
  00f80	2b 88 c8 00 00
	00		 sub	 ecx, DWORD PTR [eax+200]
  00f86	8b 92 9c 00 00
	00		 mov	 edx, DWORD PTR [edx+156]
  00f8c	1b 90 cc 00 00
	00		 sbb	 edx, DWORD PTR [eax+204]
  00f92	89 8d 44 ff ff
	ff		 mov	 DWORD PTR tv1722[ebp], ecx
  00f98	89 95 48 ff ff
	ff		 mov	 DWORD PTR tv1722[ebp+4], edx
  00f9e	8b 45 bc	 mov	 eax, DWORD PTR _rtCalcAmount$69780[ebp+4]
  00fa1	3b 85 48 ff ff
	ff		 cmp	 eax, DWORD PTR tv1722[ebp+4]
  00fa7	0f 8c c3 00 00
	00		 jl	 $L69781
  00fad	7f 0f		 jg	 SHORT $L70691
  00faf	8b 4d b8	 mov	 ecx, DWORD PTR _rtCalcAmount$69780[ebp]
  00fb2	3b 8d 44 ff ff
	ff		 cmp	 ecx, DWORD PTR tv1722[ebp]
  00fb8	0f 86 b2 00 00
	00		 jbe	 $L69781
$L70691:

; 983  :                                     {
; 984  :                                         rtCalcAmount = m_rtLoopEnd - m_rtSeek;

  00fbe	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  00fc1	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  00fc4	8b 8a 98 00 00
	00		 mov	 ecx, DWORD PTR [edx+152]
  00fca	2b 88 c8 00 00
	00		 sub	 ecx, DWORD PTR [eax+200]
  00fd0	8b 92 9c 00 00
	00		 mov	 edx, DWORD PTR [edx+156]
  00fd6	1b 90 cc 00 00
	00		 sbb	 edx, DWORD PTR [eax+204]
  00fdc	89 4d b8	 mov	 DWORD PTR _rtCalcAmount$69780[ebp], ecx
  00fdf	89 55 bc	 mov	 DWORD PTR _rtCalcAmount$69780[ebp+4], edx

; 985  :                                         m_pPerformance->ReferenceToMusicTime(m_rtLastPlayed + rtCalcAmount,&mtMyAmount);

  00fe2	8d 45 ec	 lea	 eax, DWORD PTR _mtMyAmount$[ebp]
  00fe5	50		 push	 eax
  00fe6	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  00fe9	8b 91 a8 00 00
	00		 mov	 edx, DWORD PTR [ecx+168]
  00fef	03 55 b8	 add	 edx, DWORD PTR _rtCalcAmount$69780[ebp]
  00ff2	8b 81 ac 00 00
	00		 mov	 eax, DWORD PTR [ecx+172]
  00ff8	13 45 bc	 adc	 eax, DWORD PTR _rtCalcAmount$69780[ebp+4]
  00ffb	50		 push	 eax
  00ffc	52		 push	 edx
  00ffd	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  01000	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  01003	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  01006	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  01009	8b 12		 mov	 edx, DWORD PTR [edx]
  0100b	51		 push	 ecx
  0100c	ff 52 18	 call	 DWORD PTR [edx+24]

; 986  :                                         mtMyAmount -= m_mtLastPlayed;

  0100f	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  01012	8b 4d ec	 mov	 ecx, DWORD PTR _mtMyAmount$[ebp]
  01015	2b 48 70	 sub	 ecx, DWORD PTR [eax+112]
  01018	89 4d ec	 mov	 DWORD PTR _mtMyAmount$[ebp], ecx

; 987  :                                         // It's possible to have a rounding error because reference time is so mcuh
; 988  :                                         // higher than music time. If so, a value of 0 is not appropriate if loopend
; 989  :                                         // is greater than seek, so fudge by providing one clock to get us there.
; 990  :                                         if (!mtMyAmount && (m_rtLoopEnd > m_rtSeek))

  0101b	83 7d ec 00	 cmp	 DWORD PTR _mtMyAmount$[ebp], 0
  0101f	75 4f		 jne	 SHORT $L69781
  01021	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  01024	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  01027	89 95 40 ff ff
	ff		 mov	 DWORD PTR tv1754[ebp], edx
  0102d	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv1755[ebp], eax
  01033	8b 8d 40 ff ff
	ff		 mov	 ecx, DWORD PTR tv1754[ebp]
  01039	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR tv1755[ebp]
  0103f	8b 81 9c 00 00
	00		 mov	 eax, DWORD PTR [ecx+156]
  01045	3b 82 cc 00 00
	00		 cmp	 eax, DWORD PTR [edx+204]
  0104b	7c 23		 jl	 SHORT $L69781
  0104d	7f 1a		 jg	 SHORT $L70692
  0104f	8b 8d 40 ff ff
	ff		 mov	 ecx, DWORD PTR tv1754[ebp]
  01055	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR tv1755[ebp]
  0105b	8b 81 98 00 00
	00		 mov	 eax, DWORD PTR [ecx+152]
  01061	3b 82 c8 00 00
	00		 cmp	 eax, DWORD PTR [edx+200]
  01067	76 07		 jbe	 SHORT $L69781
$L70692:

; 991  :                                         {
; 992  :                                             mtMyAmount = 1;

  01069	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _mtMyAmount$[ebp], 1
$L69781:

; 993  :                                         }
; 994  :                                     }
; 995  :                                 }
; 996  :                                 else if( mtMyAmount > m_mtLoopEnd - m_mtSeek )

  01070	eb 20		 jmp	 SHORT $L69783
$L69779:
  01072	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  01075	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  01078	8b 41 4c	 mov	 eax, DWORD PTR [ecx+76]
  0107b	2b 42 78	 sub	 eax, DWORD PTR [edx+120]
  0107e	39 45 ec	 cmp	 DWORD PTR _mtMyAmount$[ebp], eax
  01081	7e 0f		 jle	 SHORT $L69783

; 997  :                                 {
; 998  :                                     mtMyAmount = m_mtLoopEnd - m_mtSeek;

  01083	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  01086	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  01089	8b 41 4c	 mov	 eax, DWORD PTR [ecx+76]
  0108c	2b 42 78	 sub	 eax, DWORD PTR [edx+120]
  0108f	89 45 ec	 mov	 DWORD PTR _mtMyAmount$[ebp], eax
$L69783:

; 999  :                                 }
; 1000 :                             }
; 1001 :                             else 

  01092	eb 58		 jmp	 SHORT $L69777
$L69778:

; 1002 :                             {
; 1003 :                                 if (fUseClockTime)

  01094	83 7d fc 00	 cmp	 DWORD PTR _fUseClockTime$[ebp], 0
  01098	74 32		 je	 SHORT $L69786

; 1004 :                                 {
; 1005 :                                     if (mtMyAmount > (m_mtEndTime - (m_mtOffset + m_mtSeek)))

  0109a	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  0109d	8b 51 6c	 mov	 edx, DWORD PTR [ecx+108]
  010a0	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  010a3	03 50 78	 add	 edx, DWORD PTR [eax+120]
  010a6	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  010a9	8b 41 68	 mov	 eax, DWORD PTR [ecx+104]
  010ac	2b c2		 sub	 eax, edx
  010ae	39 45 ec	 cmp	 DWORD PTR _mtMyAmount$[ebp], eax
  010b1	7e 17		 jle	 SHORT $L69787

; 1006 :                                     {
; 1007 :                                         mtMyAmount = m_mtEndTime - (m_mtOffset + m_mtSeek);

  010b3	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  010b6	8b 51 6c	 mov	 edx, DWORD PTR [ecx+108]
  010b9	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  010bc	03 50 78	 add	 edx, DWORD PTR [eax+120]
  010bf	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  010c2	8b 41 68	 mov	 eax, DWORD PTR [ecx+104]
  010c5	2b c2		 sub	 eax, edx
  010c7	89 45 ec	 mov	 DWORD PTR _mtMyAmount$[ebp], eax
$L69787:

; 1008 :                                     }
; 1009 :                                 }
; 1010 :                                 else if( mtMyAmount > m_mtLength - m_mtSeek )

  010ca	eb 20		 jmp	 SHORT $L69777
$L69786:
  010cc	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  010cf	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  010d2	8b 41 54	 mov	 eax, DWORD PTR [ecx+84]
  010d5	2b 42 78	 sub	 eax, DWORD PTR [edx+120]
  010d8	39 45 ec	 cmp	 DWORD PTR _mtMyAmount$[ebp], eax
  010db	7e 0f		 jle	 SHORT $L69777

; 1011 :                                 {
; 1012 :                                     mtMyAmount = m_mtLength - m_mtSeek;

  010dd	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  010e0	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  010e3	8b 41 54	 mov	 eax, DWORD PTR [ecx+84]
  010e6	2b 42 78	 sub	 eax, DWORD PTR [edx+120]
  010e9	89 45 ec	 mov	 DWORD PTR _mtMyAmount$[ebp], eax
$L69777:

; 1013 :                                 }
; 1014 :                             }
; 1015 :                         }
; 1016 :                         // send a segment looped notification
; 1017 :                         GenerateNotification( DMUS_NOTIFICATION_SEGLOOP, m_mtOffset + m_mtSeek );

  010ec	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  010ef	8b 51 6c	 mov	 edx, DWORD PTR [ecx+108]
  010f2	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  010f5	03 50 78	 add	 edx, DWORD PTR [eax+120]
  010f8	52		 push	 edx
  010f9	6a 03		 push	 3
  010fb	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  010fe	e8 00 00 00 00	 call	 ?GenerateNotification@CSegState@@AAEXKJ@Z ; CSegState::GenerateNotification

; 1018 :                         // find out if there's a control segment interrupting this period of time
; 1019 :                         if( S_OK == m_pPerformance->GetControlSegTime( m_mtOffset + m_mtSeek, &mtControlSeg ))

  01103	8d 4d cc	 lea	 ecx, DWORD PTR _mtControlSeg$69722[ebp]
  01106	51		 push	 ecx
  01107	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  0110a	8b 42 6c	 mov	 eax, DWORD PTR [edx+108]
  0110d	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  01110	03 41 78	 add	 eax, DWORD PTR [ecx+120]
  01113	50		 push	 eax
  01114	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  01117	8b 4a 34	 mov	 ecx, DWORD PTR [edx+52]
  0111a	e8 00 00 00 00	 call	 ?GetControlSegTime@CPerformance@@QAEJJPAJ@Z ; CPerformance::GetControlSegTime
  0111f	85 c0		 test	 eax, eax
  01121	75 48		 jne	 SHORT $L69791

; 1020 :                         {
; 1021 :                             if( m_mtOffset + m_mtSeek == mtControlSeg ) 

  01123	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  01126	8b 48 6c	 mov	 ecx, DWORD PTR [eax+108]
  01129	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  0112c	03 4a 78	 add	 ecx, DWORD PTR [edx+120]
  0112f	3b 4d cc	 cmp	 ecx, DWORD PTR _mtControlSeg$69722[ebp]
  01132	75 11		 jne	 SHORT $L69792

; 1022 :                             {
; 1023 :                                 // we're at the beginning of a new control seg, so tell the tracks
; 1024 :                                 m_dwPlayTrackFlags |= DMUS_TRACKF_DIRTY; 

  01134	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  01137	8b 48 58	 mov	 ecx, DWORD PTR [eax+88]
  0113a	83 c9 10	 or	 ecx, 16			; 00000010H
  0113d	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  01140	89 4a 58	 mov	 DWORD PTR [edx+88], ecx

; 1025 :                             }
; 1026 :                             else if( m_mtOffset + m_mtSeek + mtMyAmount < mtControlSeg )

  01143	eb 26		 jmp	 SHORT $L69791
$L69792:
  01145	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  01148	8b 48 6c	 mov	 ecx, DWORD PTR [eax+108]
  0114b	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  0114e	03 4a 78	 add	 ecx, DWORD PTR [edx+120]
  01151	03 4d ec	 add	 ecx, DWORD PTR _mtMyAmount$[ebp]
  01154	3b 4d cc	 cmp	 ecx, DWORD PTR _mtControlSeg$69722[ebp]
  01157	7d 12		 jge	 SHORT $L69791

; 1027 :                             {
; 1028 :                                 mtMyAmount = mtControlSeg - m_mtOffset - m_mtSeek;

  01159	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  0115c	8b 4d cc	 mov	 ecx, DWORD PTR _mtControlSeg$69722[ebp]
  0115f	2b 48 6c	 sub	 ecx, DWORD PTR [eax+108]
  01162	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  01165	2b 4a 78	 sub	 ecx, DWORD PTR [edx+120]
  01168	89 4d ec	 mov	 DWORD PTR _mtMyAmount$[ebp], ecx
$L69791:

; 1029 :                             }
; 1030 :                         }
; 1031 :                         m_pPerformance->MusicToReferenceTime(m_mtLastPlayed + mtMyAmount,&rtMyAmount);

  0116b	8d 45 f0	 lea	 eax, DWORD PTR _rtMyAmount$[ebp]
  0116e	50		 push	 eax
  0116f	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  01172	8b 51 70	 mov	 edx, DWORD PTR [ecx+112]
  01175	03 55 ec	 add	 edx, DWORD PTR _mtMyAmount$[ebp]
  01178	52		 push	 edx
  01179	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  0117c	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0117f	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  01182	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  01185	8b 09		 mov	 ecx, DWORD PTR [ecx]
  01187	50		 push	 eax
  01188	ff 51 14	 call	 DWORD PTR [ecx+20]

; 1032 :                         rtMyAmount -= m_rtLastPlayed;

  0118b	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  0118e	8b 45 f0	 mov	 eax, DWORD PTR _rtMyAmount$[ebp]
  01191	2b 82 a8 00 00
	00		 sub	 eax, DWORD PTR [edx+168]
  01197	8b 4d f4	 mov	 ecx, DWORD PTR _rtMyAmount$[ebp+4]
  0119a	1b 8a ac 00 00
	00		 sbb	 ecx, DWORD PTR [edx+172]
  011a0	89 45 f0	 mov	 DWORD PTR _rtMyAmount$[ebp], eax
  011a3	89 4d f4	 mov	 DWORD PTR _rtMyAmount$[ebp+4], ecx

; 1033 :                     }
; 1034 :                     else if( m_mtSeek == m_mtLength )

  011a6	eb 15		 jmp	 SHORT $L69760
$L69771:
  011a8	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  011ab	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  011ae	8b 4a 78	 mov	 ecx, DWORD PTR [edx+120]
  011b1	3b 48 54	 cmp	 ecx, DWORD PTR [eax+84]
  011b4	75 07		 jne	 SHORT $L69760

; 1035 :                     {
; 1036 :                         // no more repeats.
; 1037 :                         hr = DMUS_S_END;

  011b6	c7 45 e4 02 12
	78 08		 mov	 DWORD PTR _hr$[ebp], 142086658 ; 08781202H
$L69760:

; 1038 :                     }
; 1039 :                 }
; 1040 :             }
; 1041 :         }

  011bd	e9 eb f3 ff ff	 jmp	 $L69729
$L69716:

; 1042 :     }
; 1043 :     if (hr == DMUS_S_END)

  011c2	81 7d e4 02 12
	78 08		 cmp	 DWORD PTR _hr$[ebp], 142086658 ; 08781202H
  011c9	0f 85 01 02 00
	00		 jne	 $L69805

; 1044 :     {
; 1045 :         // send a segment end notification
; 1046 :         GenerateNotification( DMUS_NOTIFICATION_SEGEND, m_mtOffset + m_mtSeek );

  011cf	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  011d2	8b 42 6c	 mov	 eax, DWORD PTR [edx+108]
  011d5	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  011d8	03 41 78	 add	 eax, DWORD PTR [ecx+120]
  011db	50		 push	 eax
  011dc	6a 01		 push	 1
  011de	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  011e1	e8 00 00 00 00	 call	 ?GenerateNotification@CSegState@@AAEXKJ@Z ; CSegState::GenerateNotification

; 1047 :         // also queue the almost ended for now
; 1048 :         MUSIC_TIME mtNow;
; 1049 :         m_pPerformance->GetTime( NULL, &mtNow );

  011e6	8d 55 b4	 lea	 edx, DWORD PTR _mtNow$69806[ebp]
  011e9	52		 push	 edx
  011ea	6a 00		 push	 0
  011ec	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  011ef	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  011f2	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  011f5	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  011f8	8b 09		 mov	 ecx, DWORD PTR [ecx]
  011fa	50		 push	 eax
  011fb	ff 51 20	 call	 DWORD PTR [ecx+32]

; 1050 :         GenerateNotification( DMUS_NOTIFICATION_SEGALMOSTEND, mtNow );

  011fe	8b 55 b4	 mov	 edx, DWORD PTR _mtNow$69806[ebp]
  01201	52		 push	 edx
  01202	6a 02		 push	 2
  01204	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  01207	e8 00 00 00 00	 call	 ?GenerateNotification@CSegState@@AAEXKJ@Z ; CSegState::GenerateNotification

; 1051 :         // if this is a primary or controlling segment, send a DMUS_PMSGT_DIRTY message
; 1052 :         if( !(m_dwPlaySegFlags & DMUS_SEGF_SECONDARY) || (m_dwPlaySegFlags & DMUS_SEGF_CONTROL) )

  0120c	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  0120f	8b 48 5c	 mov	 ecx, DWORD PTR [eax+92]
  01212	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  01218	85 c9		 test	 ecx, ecx
  0121a	74 0f		 je	 SHORT $L69808
  0121c	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  0121f	8b 42 5c	 mov	 eax, DWORD PTR [edx+92]
  01222	25 00 02 00 00	 and	 eax, 512		; 00000200H
  01227	85 c0		 test	 eax, eax
  01229	74 15		 je	 SHORT $L69807
$L69808:

; 1053 :         {
; 1054 :             TraceI(4, "Send Dirty PMsg [2] %d (%d)\n", m_mtSeek, m_mtOffset + m_mtSeek);
; 1055 :             SendDirtyPMsg( m_mtOffset + m_mtSeek );

  0122b	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  0122e	8b 51 6c	 mov	 edx, DWORD PTR [ecx+108]
  01231	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  01234	03 50 78	 add	 edx, DWORD PTR [eax+120]
  01237	52		 push	 edx
  01238	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  0123b	e8 00 00 00 00	 call	 ?SendDirtyPMsg@CSegState@@AAEXJ@Z ; CSegState::SendDirtyPMsg
$L69807:

; 1056 :         }
; 1057 :         // If this is part of a song, we need to queue the next segment.
; 1058 :         if (m_fSongMode)

  01240	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  01243	83 b9 18 01 00
	00 00		 cmp	 DWORD PTR [ecx+280], 0
  0124a	0f 84 80 01 00
	00		 je	 $L69805

; 1059 :         {
; 1060 :             if (m_pSegment)

  01250	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  01253	83 7a 38 00	 cmp	 DWORD PTR [edx+56], 0
  01257	0f 84 73 01 00
	00		 je	 $L69805

; 1061 :             {
; 1062 :                 CSong *pSong = m_pSegment->m_pSong;

  0125d	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  01260	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  01263	8b 91 c8 03 00
	00		 mov	 edx, DWORD PTR [ecx+968]
  01269	89 55 b0	 mov	 DWORD PTR _pSong$69812[ebp], edx

; 1063 :                 if (pSong)

  0126c	83 7d b0 00	 cmp	 DWORD PTR _pSong$69812[ebp], 0
  01270	0f 84 5a 01 00
	00		 je	 $L69805

; 1064 :                 {
; 1065 :                     // Get the next segment from the song.
; 1066 :                     CSegment *pSegment;
; 1067 :                     if (S_OK == pSong->GetPlaySegment(m_pSegment->m_dwNextPlayID,&pSegment))

  01276	8d 45 ac	 lea	 eax, DWORD PTR _pSegment$69814[ebp]
  01279	50		 push	 eax
  0127a	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  0127d	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  01280	8b 82 d0 03 00
	00		 mov	 eax, DWORD PTR [edx+976]
  01286	50		 push	 eax
  01287	8b 4d b0	 mov	 ecx, DWORD PTR _pSong$69812[ebp]
  0128a	e8 00 00 00 00	 call	 ?GetPlaySegment@CSong@@QAEJKPAPAVCSegment@@@Z ; CSong::GetPlaySegment
  0128f	85 c0		 test	 eax, eax
  01291	0f 85 39 01 00
	00		 jne	 $L69805

; 1068 :                     {
; 1069 :                         // Now, play it.
; 1070 :                         // Unless DMUS_SEGF_USE_AUDIOPATH is set, play it on the same audiopath. 
; 1071 :                         // And, make sure that it plays at the same level (control, secondary, or primary.)
; 1072 :                         CSegState *pCSegState = NULL;

  01297	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR _pCSegState$69817[ebp], 0

; 1073 :                         CAudioPath *pPath = m_pAudioPath;

  0129e	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  012a1	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  012a4	89 55 9c	 mov	 DWORD PTR _pPath$69818[ebp], edx

; 1074 :                         CAudioPath *pInternalPath = NULL;

  012a7	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR _pInternalPath$69819[ebp], 0

; 1075 :                         DWORD dwFlags = m_dwPlaySegFlags & (DMUS_SEGF_CONTROL | DMUS_SEGF_SECONDARY);

  012ae	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  012b1	8b 48 5c	 mov	 ecx, DWORD PTR [eax+92]
  012b4	81 e1 80 02 00
	00		 and	 ecx, 640		; 00000280H
  012ba	89 4d a4	 mov	 DWORD PTR _dwFlags$69820[ebp], ecx

; 1076 :                         dwFlags &= ~DMUS_SEGF_REFTIME;

  012bd	8b 55 a4	 mov	 edx, DWORD PTR _dwFlags$69820[ebp]
  012c0	83 e2 bf	 and	 edx, -65		; ffffffbfH
  012c3	89 55 a4	 mov	 DWORD PTR _dwFlags$69820[ebp], edx

; 1077 :                         if (dwFlags & DMUS_SEGF_USE_AUDIOPATH)

  012c6	8b 45 a4	 mov	 eax, DWORD PTR _dwFlags$69820[ebp]
  012c9	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  012ce	85 c0		 test	 eax, eax
  012d0	74 5a		 je	 SHORT $L69821

; 1078 :                         {
; 1079 :                             IUnknown *pConfig;
; 1080 :                             if (SUCCEEDED(pSegment->GetAudioPathConfig(&pConfig)))

  012d2	8d 4d 98	 lea	 ecx, DWORD PTR _pConfig$69822[ebp]
  012d5	51		 push	 ecx
  012d6	8b 55 ac	 mov	 edx, DWORD PTR _pSegment$69814[ebp]
  012d9	8b 02		 mov	 eax, DWORD PTR [edx]
  012db	8b 4d ac	 mov	 ecx, DWORD PTR _pSegment$69814[ebp]
  012de	51		 push	 ecx
  012df	ff 50 7c	 call	 DWORD PTR [eax+124]
  012e2	85 c0		 test	 eax, eax
  012e4	7c 46		 jl	 SHORT $L69821

; 1081 :                             {
; 1082 :                                 IDirectMusicAudioPath *pNewPath;
; 1083 :                                 if (SUCCEEDED(m_pPerformance->CreateAudioPath(pConfig,TRUE,&pNewPath)))

  012e6	8d 55 94	 lea	 edx, DWORD PTR _pNewPath$69825[ebp]
  012e9	52		 push	 edx
  012ea	6a 01		 push	 1
  012ec	8b 45 98	 mov	 eax, DWORD PTR _pConfig$69822[ebp]
  012ef	50		 push	 eax
  012f0	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  012f3	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  012f6	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  012f9	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  012fc	8b 12		 mov	 edx, DWORD PTR [edx]
  012fe	51		 push	 ecx
  012ff	ff 52 4c	 call	 DWORD PTR [edx+76]
  01302	85 c0		 test	 eax, eax
  01304	7c 1a		 jl	 SHORT $L69827

; 1084 :                                 {
; 1085 :                                     // Now, get the CAudioPath structure.
; 1086 :                                     pConfig->QueryInterface(IID_CAudioPath,(void **) &pInternalPath);

  01306	8d 45 a8	 lea	 eax, DWORD PTR _pInternalPath$69819[ebp]
  01309	50		 push	 eax
  0130a	68 00 00 00 00	 push	 OFFSET FLAT:_IID_CAudioPath
  0130f	8b 4d 98	 mov	 ecx, DWORD PTR _pConfig$69822[ebp]
  01312	8b 11		 mov	 edx, DWORD PTR [ecx]
  01314	8b 45 98	 mov	 eax, DWORD PTR _pConfig$69822[ebp]
  01317	50		 push	 eax
  01318	ff 12		 call	 DWORD PTR [edx]

; 1087 :                                     pPath = pInternalPath;

  0131a	8b 4d a8	 mov	 ecx, DWORD PTR _pInternalPath$69819[ebp]
  0131d	89 4d 9c	 mov	 DWORD PTR _pPath$69818[ebp], ecx
$L69827:

; 1088 :                                 }
; 1089 :                                 pConfig->Release();

  01320	8b 55 98	 mov	 edx, DWORD PTR _pConfig$69822[ebp]
  01323	8b 02		 mov	 eax, DWORD PTR [edx]
  01325	8b 4d 98	 mov	 ecx, DWORD PTR _pConfig$69822[ebp]
  01328	51		 push	 ecx
  01329	ff 50 08	 call	 DWORD PTR [eax+8]
$L69821:

; 1090 :                             }
; 1091 :                         }
; 1092 :                         if (SUCCEEDED(m_pPerformance->PlayOneSegment((CSegment *)pSegment,dwFlags,m_mtEndTime,&pCSegState,pPath)))

  0132c	8b 55 9c	 mov	 edx, DWORD PTR _pPath$69818[ebp]
  0132f	52		 push	 edx
  01330	8d 45 a0	 lea	 eax, DWORD PTR _pCSegState$69817[ebp]
  01333	50		 push	 eax
  01334	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  01337	8b 41 68	 mov	 eax, DWORD PTR [ecx+104]
  0133a	99		 cdq
  0133b	52		 push	 edx
  0133c	50		 push	 eax
  0133d	8b 55 a4	 mov	 edx, DWORD PTR _dwFlags$69820[ebp]
  01340	52		 push	 edx
  01341	8b 45 ac	 mov	 eax, DWORD PTR _pSegment$69814[ebp]
  01344	50		 push	 eax
  01345	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  01348	8b 49 34	 mov	 ecx, DWORD PTR [ecx+52]
  0134b	e8 00 00 00 00	 call	 ?PlayOneSegment@CPerformance@@AAEJPAVCSegment@@K_JPAPAVCSegState@@PAVCAudioPath@@@Z ; CPerformance::PlayOneSegment
  01350	85 c0		 test	 eax, eax
  01352	7c 5e		 jl	 SHORT $L69831

; 1093 :                         {
; 1094 :                             if (m_pSongSegState)

  01354	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  01357	83 ba 28 01 00
	00 00		 cmp	 DWORD PTR [edx+296], 0
  0135e	74 21		 je	 SHORT $L69832

; 1095 :                             {
; 1096 :                                 // This is not the first, so transfer the segstate pointer.
; 1097 :                                 pCSegState->m_pSongSegState = m_pSongSegState;

  01360	8b 45 a0	 mov	 eax, DWORD PTR _pCSegState$69817[ebp]
  01363	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  01366	8b 91 28 01 00
	00		 mov	 edx, DWORD PTR [ecx+296]
  0136c	89 90 28 01 00
	00		 mov	 DWORD PTR [eax+296], edx

; 1098 :                                 m_pSongSegState = NULL;

  01372	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  01375	c7 80 28 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+296], 0

; 1099 :                             }
; 1100 :                             else

  0137f	eb 18		 jmp	 SHORT $L69833
$L69832:

; 1101 :                             {
; 1102 :                                 // This is the first, so have the next segstate point to this.
; 1103 :                                 pCSegState->m_pSongSegState = this;

  01381	8b 4d a0	 mov	 ecx, DWORD PTR _pCSegState$69817[ebp]
  01384	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  01387	89 91 28 01 00
	00		 mov	 DWORD PTR [ecx+296], edx

; 1104 :                                 AddRef();

  0138d	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  01390	8b 08		 mov	 ecx, DWORD PTR [eax]
  01392	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  01395	52		 push	 edx
  01396	ff 51 04	 call	 DWORD PTR [ecx+4]
$L69833:

; 1105 :                             }
; 1106 :                             pCSegState->m_fSongMode = TRUE;

  01399	8b 45 a0	 mov	 eax, DWORD PTR _pCSegState$69817[ebp]
  0139c	c7 80 18 01 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+280], 1

; 1107 :                             pCSegState->Release();

  013a6	8b 4d a0	 mov	 ecx, DWORD PTR _pCSegState$69817[ebp]
  013a9	8b 11		 mov	 edx, DWORD PTR [ecx]
  013ab	8b 45 a0	 mov	 eax, DWORD PTR _pCSegState$69817[ebp]
  013ae	50		 push	 eax
  013af	ff 52 08	 call	 DWORD PTR [edx+8]
$L69831:

; 1108 :                         }
; 1109 :                         if (pInternalPath)

  013b2	83 7d a8 00	 cmp	 DWORD PTR _pInternalPath$69819[ebp], 0
  013b6	74 0c		 je	 SHORT $L69834

; 1110 :                         {
; 1111 :                             pInternalPath->Release();

  013b8	8b 4d a8	 mov	 ecx, DWORD PTR _pInternalPath$69819[ebp]
  013bb	8b 11		 mov	 edx, DWORD PTR [ecx]
  013bd	8b 45 a8	 mov	 eax, DWORD PTR _pInternalPath$69819[ebp]
  013c0	50		 push	 eax
  013c1	ff 52 08	 call	 DWORD PTR [edx+8]
$L69834:

; 1112 :                         }
; 1113 :                         pSegment->Release();

  013c4	8b 4d ac	 mov	 ecx, DWORD PTR _pSegment$69814[ebp]
  013c7	8b 11		 mov	 edx, DWORD PTR [ecx]
  013c9	8b 45 ac	 mov	 eax, DWORD PTR _pSegment$69814[ebp]
  013cc	50		 push	 eax
  013cd	ff 52 08	 call	 DWORD PTR [edx+8]
$L69805:

; 1114 :                     }
; 1115 :                 }
; 1116 :             }
; 1117 :         }
; 1118 :     }
; 1119 :     m_dwPlayTrackFlags &= ~DMUS_TRACKF_DIRTY;

  013d0	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  013d3	8b 51 58	 mov	 edx, DWORD PTR [ecx+88]
  013d6	83 e2 ef	 and	 edx, -17		; ffffffefH
  013d9	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  013dc	89 50 58	 mov	 DWORD PTR [eax+88], edx

; 1120 :     m_pPerformance->m_dwGetParamFlags = 0;

  013df	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  013e2	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  013e5	c7 82 d8 03 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+984], 0

; 1121 :     m_pPerformance->m_pGetParamSegmentState = NULL;

  013ef	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  013f2	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  013f5	c7 81 d4 03 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+980], 0

; 1122 :     m_fInPlay = false;

  013ff	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  01402	c7 82 20 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+288], 0

; 1123 :     if (m_fDelayShutDown)

  0140c	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  0140f	83 b8 24 01 00
	00 00		 cmp	 DWORD PTR [eax+292], 0
  01416	74 16		 je	 SHORT $L69835

; 1124 :     {
; 1125 :         Shutdown();

  01418	8b 4d 90	 mov	 ecx, DWORD PTR _this$[ebp]
  0141b	51		 push	 ecx
  0141c	e8 00 00 00 00	 call	 ?Shutdown@CSegState@@QAGJXZ ; CSegState::Shutdown

; 1126 :         m_fDelayShutDown = false;

  01421	8b 55 90	 mov	 edx, DWORD PTR _this$[ebp]
  01424	c7 82 24 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+292], 0
$L69835:

; 1127 :     }
; 1128 :     LeaveCriticalSection(&m_CriticalSection);

  0142e	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  01431	83 c0 14	 add	 eax, 20			; 00000014H
  01434	50		 push	 eax
  01435	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 1129 :     return hr;

  0143b	8b 45 e4	 mov	 eax, DWORD PTR _hr$[ebp]
$L69673:

; 1130 : }

  0143e	5e		 pop	 esi
  0143f	8b e5		 mov	 esp, ebp
  01441	5d		 pop	 ebp
  01442	c2 04 00	 ret	 4
?Play@CSegState@@QAEJJ@Z ENDP				; CSegState::Play
_TEXT	ENDS
PUBLIC	__GUID_00000000_0000_0000_0000_000000000000
PUBLIC	?GetTrackByParam@CSegState@@AAEPAVCTrack@@PAV2@ABU_GUID@@KK@Z ; CSegState::GetTrackByParam
;	COMDAT __GUID_00000000_0000_0000_0000_000000000000
CONST	SEGMENT
__GUID_00000000_0000_0000_0000_000000000000 DD 00H
	DW	00H
	DW	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?GetTrackByParam@CSegState@@AAEPAVCTrack@@PAV2@ABU_GUID@@KK@Z
_TEXT	SEGMENT
_this$ = -4
_pCTrack$ = 8
_rguidType$ = 12
_dwGroupBits$ = 16
_dwIndex$ = 20
?GetTrackByParam@CSegState@@AAEPAVCTrack@@PAV2@ABU_GUID@@KK@Z PROC NEAR ; CSegState::GetTrackByParam, COMDAT
; _this$ = ecx

; 1134 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1135 :     // If the caller was already part way through the list, it passes the current
; 1136 :     // track. Otherwise, NULL to indicate start at the top.
; 1137 :     if (pCTrack)

  00007	83 7d 08 00	 cmp	 DWORD PTR _pCTrack$[ebp], 0
  0000b	74 0d		 je	 SHORT $L69843

; 1138 :     {
; 1139 :         pCTrack = pCTrack->GetNext();

  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _pCTrack$[ebp]
  00010	e8 00 00 00 00	 call	 ?GetNext@CTrack@@QAEPAV1@XZ ; CTrack::GetNext
  00015	89 45 08	 mov	 DWORD PTR _pCTrack$[ebp], eax

; 1140 :     }
; 1141 :     else

  00018	eb 0e		 jmp	 SHORT $L69846
$L69843:

; 1142 :     {
; 1143 : 	    pCTrack = m_TrackList.GetHead();

  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	83 c1 44	 add	 ecx, 68			; 00000044H
  00020	e8 00 00 00 00	 call	 ?GetHead@CTrackList@@QAEPAVCTrack@@XZ ; CTrackList::GetHead
  00025	89 45 08	 mov	 DWORD PTR _pCTrack$[ebp], eax
$L69846:

; 1144 :     }
; 1145 : 	while( pCTrack )

  00028	83 7d 08 00	 cmp	 DWORD PTR _pCTrack$[ebp], 0
  0002c	0f 84 8a 00 00
	00		 je	 $L69847

; 1146 : 	{
; 1147 : 		ASSERT(pCTrack->m_pTrack);

  00032	8b 45 08	 mov	 eax, DWORD PTR _pCTrack$[ebp]
  00035	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  00039	75 17		 jne	 SHORT $L69848
  0003b	6a 00		 push	 0
  0003d	68 7b 04 00 00	 push	 1147			; 0000047bH
  00042	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NBCHJFPK@c?3?2xbox?2private?2windows?2directx?2@
  00047	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BC@LLLGOMEJ@pCTrack?9?$DOm_pTrack?$AA@
  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
$L69848:

; 1148 : 		if( (pCTrack->m_dwGroupBits & dwGroupBits ) && 
; 1149 :             (pCTrack->m_dwFlags & DMUS_TRACKCONFIG_CONTROL_ENABLED))

  00052	8b 4d 08	 mov	 ecx, DWORD PTR _pCTrack$[ebp]
  00055	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  00058	23 55 10	 and	 edx, DWORD PTR _dwGroupBits$[ebp]
  0005b	85 d2		 test	 edx, edx
  0005d	74 4d		 je	 SHORT $L69849
  0005f	8b 45 08	 mov	 eax, DWORD PTR _pCTrack$[ebp]
  00062	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00065	83 e1 08	 and	 ecx, 8
  00068	85 c9		 test	 ecx, ecx
  0006a	74 40		 je	 SHORT $L69849

; 1150 : 		{
; 1151 : 			if( (GUID_NULL == rguidType) || (pCTrack->m_pTrack->IsParamSupported( rguidType ) == S_OK ))

  0006c	8b 55 0c	 mov	 edx, DWORD PTR _rguidType$[ebp]
  0006f	52		 push	 edx
  00070	68 00 00 00 00	 push	 OFFSET FLAT:__GUID_00000000_0000_0000_0000_000000000000
  00075	e8 00 00 00 00	 call	 _==@8
  0007a	85 c0		 test	 eax, eax
  0007c	75 1a		 jne	 SHORT $L69853
  0007e	8b 45 0c	 mov	 eax, DWORD PTR _rguidType$[ebp]
  00081	50		 push	 eax
  00082	8b 4d 08	 mov	 ecx, DWORD PTR _pCTrack$[ebp]
  00085	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00088	8b 45 08	 mov	 eax, DWORD PTR _pCTrack$[ebp]
  0008b	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0008e	8b 12		 mov	 edx, DWORD PTR [edx]
  00090	51		 push	 ecx
  00091	ff 52 24	 call	 DWORD PTR [edx+36]
  00094	85 c0		 test	 eax, eax
  00096	75 14		 jne	 SHORT $L69849
$L69853:

; 1152 : 			{
; 1153 : 				if( 0 == dwIndex )

  00098	83 7d 14 00	 cmp	 DWORD PTR _dwIndex$[ebp], 0
  0009c	75 05		 jne	 SHORT $L69854

; 1154 : 				{
; 1155 :                     return pCTrack;

  0009e	8b 45 08	 mov	 eax, DWORD PTR _pCTrack$[ebp]
  000a1	eb 1b		 jmp	 SHORT $L69842
$L69854:

; 1156 : 				}
; 1157 : 				dwIndex--;

  000a3	8b 45 14	 mov	 eax, DWORD PTR _dwIndex$[ebp]
  000a6	83 e8 01	 sub	 eax, 1
  000a9	89 45 14	 mov	 DWORD PTR _dwIndex$[ebp], eax
$L69849:

; 1158 : 			}
; 1159 : 		}
; 1160 : 		pCTrack = pCTrack->GetNext();

  000ac	8b 4d 08	 mov	 ecx, DWORD PTR _pCTrack$[ebp]
  000af	e8 00 00 00 00	 call	 ?GetNext@CTrack@@QAEPAV1@XZ ; CTrack::GetNext
  000b4	89 45 08	 mov	 DWORD PTR _pCTrack$[ebp], eax

; 1161 : 	}

  000b7	e9 6c ff ff ff	 jmp	 $L69846
$L69847:

; 1162 :     return NULL;

  000bc	33 c0		 xor	 eax, eax
$L69842:

; 1163 : }

  000be	8b e5		 mov	 esp, ebp
  000c0	5d		 pop	 ebp
  000c1	c2 10 00	 ret	 16			; 00000010H
?GetTrackByParam@CSegState@@AAEPAVCTrack@@PAV2@ABU_GUID@@KK@Z ENDP ; CSegState::GetTrackByParam
_TEXT	ENDS
PUBLIC	??_C@_0GD@LBIELNMC@Warning?3?5Segmentstate?3?3GetParam?5@ ; `string'
PUBLIC	?GetParam@CSegState@@QAEJPAVCPerformance@@ABU_GUID@@KKJPAJPAX@Z ; CSegState::GetParam
;	COMDAT ??_C@_0GD@LBIELNMC@Warning?3?5Segmentstate?3?3GetParam?5@
CONST	SEGMENT
??_C@_0GD@LBIELNMC@Warning?3?5Segmentstate?3?3GetParam?5@ DB 'Warning: Se'
	DB	'gmentstate::GetParam failed, unable to find a track that supp'
	DB	'orts the requested param.', 0aH, 00H	; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?GetParam@CSegState@@QAEJPAVCPerformance@@ABU_GUID@@KKJPAJPAX@Z
_TEXT	SEGMENT
_this$ = -48
_prtNext$69882 = -44
_rtNext$69881 = -40
_rtTime$69875 = -32
_rtNext$69876 = -24
_fMultipleTry$ = -12
_pTrack$ = -8
_hr$ = -4
_pPerf$ = 8
_rguidType$ = 12
_dwGroupBits$ = 16
_dwIndex$ = 20
_mtTime$ = 24
_pmtNext$ = 28
_pParam$ = 32
?GetParam@CSegState@@QAEJPAVCPerformance@@ABU_GUID@@KKJPAJPAX@Z PROC NEAR ; CSegState::GetParam, COMDAT
; _this$ = ecx

; 1179 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	89 4d d0	 mov	 DWORD PTR _this$[ebp], ecx

; 1180 :     HRESULT hr = DMUS_E_TRACK_NOT_FOUND;

  00009	c7 45 fc 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H

; 1181 :     BOOL fMultipleTry = FALSE;

  00010	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _fMultipleTry$[ebp], 0

; 1182 :     if (dwIndex == DMUS_SEG_ANYTRACK)

  00017	81 7d 14 00 00
	00 80		 cmp	 DWORD PTR _dwIndex$[ebp], -2147483648 ; 80000000H
  0001e	75 0e		 jne	 SHORT $L69868

; 1183 :     {
; 1184 :         dwIndex = 0;

  00020	c7 45 14 00 00
	00 00		 mov	 DWORD PTR _dwIndex$[ebp], 0

; 1185 :         // Even though DX7 didn't support this, this is always safe because an index this high could never happen.
; 1186 :         fMultipleTry = TRUE; 

  00027	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _fMultipleTry$[ebp], 1
$L69868:

; 1187 :     }
; 1188 :     CTrack * pTrack = GetTrackByParam( NULL, rguidType, dwGroupBits, dwIndex);

  0002e	8b 45 14	 mov	 eax, DWORD PTR _dwIndex$[ebp]
  00031	50		 push	 eax
  00032	8b 4d 10	 mov	 ecx, DWORD PTR _dwGroupBits$[ebp]
  00035	51		 push	 ecx
  00036	8b 55 0c	 mov	 edx, DWORD PTR _rguidType$[ebp]
  00039	52		 push	 edx
  0003a	6a 00		 push	 0
  0003c	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?GetTrackByParam@CSegState@@AAEPAVCTrack@@PAV2@ABU_GUID@@KK@Z ; CSegState::GetTrackByParam
  00044	89 45 f8	 mov	 DWORD PTR _pTrack$[ebp], eax
$L69871:

; 1189 :     while (pTrack)

  00047	83 7d f8 00	 cmp	 DWORD PTR _pTrack$[ebp], 0
  0004b	0f 84 d0 01 00
	00		 je	 $L69872

; 1190 :     {
; 1191 :         if (pTrack->m_pTrack8)

  00051	8b 45 f8	 mov	 eax, DWORD PTR _pTrack$[ebp]
  00054	83 78 18 00	 cmp	 DWORD PTR [eax+24], 0
  00058	0f 84 2d 01 00
	00		 je	 $L69873

; 1192 :         {
; 1193 :             if (pTrack->m_dwFlags & DMUS_TRACKCONFIG_PLAY_CLOCKTIME)

  0005e	8b 4d f8	 mov	 ecx, DWORD PTR _pTrack$[ebp]
  00061	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00064	83 e2 40	 and	 edx, 64			; 00000040H
  00067	85 d2		 test	 edx, edx
  00069	0f 84 c7 00 00
	00		 je	 $L69874

; 1194 :             {
; 1195 :                 REFERENCE_TIME rtTime, rtNext;
; 1196 :                 // Convert mtTime into reference time units:
; 1197 :                 pPerf->MusicToReferenceTime(m_mtOffset + mtTime,&rtTime);

  0006f	8d 45 e0	 lea	 eax, DWORD PTR _rtTime$69875[ebp]
  00072	50		 push	 eax
  00073	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  00076	8b 51 6c	 mov	 edx, DWORD PTR [ecx+108]
  00079	03 55 18	 add	 edx, DWORD PTR _mtTime$[ebp]
  0007c	52		 push	 edx
  0007d	8b 45 08	 mov	 eax, DWORD PTR _pPerf$[ebp]
  00080	8b 08		 mov	 ecx, DWORD PTR [eax]
  00082	8b 55 08	 mov	 edx, DWORD PTR _pPerf$[ebp]
  00085	52		 push	 edx
  00086	ff 51 14	 call	 DWORD PTR [ecx+20]

; 1198 :                 rtTime -= m_rtOffset;

  00089	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  0008c	8b 4d e0	 mov	 ecx, DWORD PTR _rtTime$69875[ebp]
  0008f	2b 88 b8 00 00
	00		 sub	 ecx, DWORD PTR [eax+184]
  00095	8b 55 e4	 mov	 edx, DWORD PTR _rtTime$69875[ebp+4]
  00098	1b 90 bc 00 00
	00		 sbb	 edx, DWORD PTR [eax+188]
  0009e	89 4d e0	 mov	 DWORD PTR _rtTime$69875[ebp], ecx
  000a1	89 55 e4	 mov	 DWORD PTR _rtTime$69875[ebp+4], edx

; 1199 :                 hr = pTrack->m_pTrack8->GetParamEx( rguidType, rtTime, &rtNext, 
; 1200 :                     pParam, pTrack->m_pTrackState, DMUS_TRACK_PARAMF_CLOCK );

  000a4	6a 01		 push	 1
  000a6	8b 45 f8	 mov	 eax, DWORD PTR _pTrack$[ebp]
  000a9	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  000ac	51		 push	 ecx
  000ad	8b 55 20	 mov	 edx, DWORD PTR _pParam$[ebp]
  000b0	52		 push	 edx
  000b1	8d 45 e8	 lea	 eax, DWORD PTR _rtNext$69876[ebp]
  000b4	50		 push	 eax
  000b5	8b 4d e4	 mov	 ecx, DWORD PTR _rtTime$69875[ebp+4]
  000b8	51		 push	 ecx
  000b9	8b 55 e0	 mov	 edx, DWORD PTR _rtTime$69875[ebp]
  000bc	52		 push	 edx
  000bd	8b 45 0c	 mov	 eax, DWORD PTR _rguidType$[ebp]
  000c0	50		 push	 eax
  000c1	8b 4d f8	 mov	 ecx, DWORD PTR _pTrack$[ebp]
  000c4	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  000c7	8b 45 f8	 mov	 eax, DWORD PTR _pTrack$[ebp]
  000ca	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  000cd	8b 12		 mov	 edx, DWORD PTR [edx]
  000cf	51		 push	 ecx
  000d0	ff 52 38	 call	 DWORD PTR [edx+56]
  000d3	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 1201 :                 if (pmtNext)

  000d6	83 7d 1c 00	 cmp	 DWORD PTR _pmtNext$[ebp], 0
  000da	74 58		 je	 SHORT $L69877

; 1202 :                 {
; 1203 :                     if (rtNext == 0) *pmtNext = 0;

  000dc	8b 45 e8	 mov	 eax, DWORD PTR _rtNext$69876[ebp]
  000df	0b 45 ec	 or	 eax, DWORD PTR _rtNext$69876[ebp+4]
  000e2	85 c0		 test	 eax, eax
  000e4	75 0b		 jne	 SHORT $L69878
  000e6	8b 4d 1c	 mov	 ecx, DWORD PTR _pmtNext$[ebp]
  000e9	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 1204 :                     else

  000ef	eb 43		 jmp	 SHORT $L69877
$L69878:

; 1205 :                     {
; 1206 :                         rtNext += m_rtOffset;

  000f1	8b 55 d0	 mov	 edx, DWORD PTR _this$[ebp]
  000f4	8b 45 e8	 mov	 eax, DWORD PTR _rtNext$69876[ebp]
  000f7	03 82 b8 00 00
	00		 add	 eax, DWORD PTR [edx+184]
  000fd	8b 4d ec	 mov	 ecx, DWORD PTR _rtNext$69876[ebp+4]
  00100	13 8a bc 00 00
	00		 adc	 ecx, DWORD PTR [edx+188]
  00106	89 45 e8	 mov	 DWORD PTR _rtNext$69876[ebp], eax
  00109	89 4d ec	 mov	 DWORD PTR _rtNext$69876[ebp+4], ecx

; 1207 :                         pPerf->ReferenceToMusicTime(rtNext,pmtNext);

  0010c	8b 55 1c	 mov	 edx, DWORD PTR _pmtNext$[ebp]
  0010f	52		 push	 edx
  00110	8b 45 ec	 mov	 eax, DWORD PTR _rtNext$69876[ebp+4]
  00113	50		 push	 eax
  00114	8b 4d e8	 mov	 ecx, DWORD PTR _rtNext$69876[ebp]
  00117	51		 push	 ecx
  00118	8b 55 08	 mov	 edx, DWORD PTR _pPerf$[ebp]
  0011b	8b 02		 mov	 eax, DWORD PTR [edx]
  0011d	8b 4d 08	 mov	 ecx, DWORD PTR _pPerf$[ebp]
  00120	51		 push	 ecx
  00121	ff 50 18	 call	 DWORD PTR [eax+24]

; 1208 :                         *pmtNext -= m_mtOffset;

  00124	8b 55 1c	 mov	 edx, DWORD PTR _pmtNext$[ebp]
  00127	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  0012a	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0012c	2b 48 6c	 sub	 ecx, DWORD PTR [eax+108]
  0012f	8b 55 1c	 mov	 edx, DWORD PTR _pmtNext$[ebp]
  00132	89 0a		 mov	 DWORD PTR [edx], ecx
$L69877:

; 1209 :                     }
; 1210 :                 }
; 1211 :             }
; 1212 :             else

  00134	eb 53		 jmp	 SHORT $L69880
$L69874:

; 1213 :             {
; 1214 :                 REFERENCE_TIME rtNext, *prtNext;
; 1215 :                 // We need to store the next time in a 64 bit pointer. But, don't
; 1216 :                 // make 'em fill it in unless the caller requested it. 
; 1217 :                 if (pmtNext)

  00136	83 7d 1c 00	 cmp	 DWORD PTR _pmtNext$[ebp], 0
  0013a	74 08		 je	 SHORT $L69883

; 1218 :                 {
; 1219 :                     prtNext = &rtNext;

  0013c	8d 45 d8	 lea	 eax, DWORD PTR _rtNext$69881[ebp]
  0013f	89 45 d4	 mov	 DWORD PTR _prtNext$69882[ebp], eax

; 1220 :                 }
; 1221 :                 else

  00142	eb 07		 jmp	 SHORT $L69884
$L69883:

; 1222 :                 {
; 1223 :                     prtNext = NULL;

  00144	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _prtNext$69882[ebp], 0
$L69884:

; 1224 :                 }
; 1225 :                 hr = pTrack->m_pTrack8->GetParamEx( rguidType, mtTime, prtNext, pParam,
; 1226 :                     pTrack->m_pTrackState, 0 );

  0014b	6a 00		 push	 0
  0014d	8b 4d f8	 mov	 ecx, DWORD PTR _pTrack$[ebp]
  00150	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00153	52		 push	 edx
  00154	8b 45 20	 mov	 eax, DWORD PTR _pParam$[ebp]
  00157	50		 push	 eax
  00158	8b 4d d4	 mov	 ecx, DWORD PTR _prtNext$69882[ebp]
  0015b	51		 push	 ecx
  0015c	8b 45 18	 mov	 eax, DWORD PTR _mtTime$[ebp]
  0015f	99		 cdq
  00160	52		 push	 edx
  00161	50		 push	 eax
  00162	8b 55 0c	 mov	 edx, DWORD PTR _rguidType$[ebp]
  00165	52		 push	 edx
  00166	8b 45 f8	 mov	 eax, DWORD PTR _pTrack$[ebp]
  00169	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0016c	8b 55 f8	 mov	 edx, DWORD PTR _pTrack$[ebp]
  0016f	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00172	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00174	50		 push	 eax
  00175	ff 51 38	 call	 DWORD PTR [ecx+56]
  00178	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 1227 :                 if (pmtNext)

  0017b	83 7d 1c 00	 cmp	 DWORD PTR _pmtNext$[ebp], 0
  0017f	74 08		 je	 SHORT $L69880

; 1228 :                 {
; 1229 :                     *pmtNext = (MUSIC_TIME) rtNext;

  00181	8b 55 d8	 mov	 edx, DWORD PTR _rtNext$69881[ebp]
  00184	8b 45 1c	 mov	 eax, DWORD PTR _pmtNext$[ebp]
  00187	89 10		 mov	 DWORD PTR [eax], edx
$L69880:

; 1230 :                 }
; 1231 :             }
; 1232 :         }
; 1233 :         else

  00189	eb 25		 jmp	 SHORT $L69887
$L69873:

; 1234 :         {
; 1235 :             // This is a pre DX8 track...
; 1236 :             hr = pTrack->m_pTrack->GetParam( rguidType, mtTime, pmtNext, pParam );

  0018b	8b 4d 20	 mov	 ecx, DWORD PTR _pParam$[ebp]
  0018e	51		 push	 ecx
  0018f	8b 55 1c	 mov	 edx, DWORD PTR _pmtNext$[ebp]
  00192	52		 push	 edx
  00193	8b 45 18	 mov	 eax, DWORD PTR _mtTime$[ebp]
  00196	50		 push	 eax
  00197	8b 4d 0c	 mov	 ecx, DWORD PTR _rguidType$[ebp]
  0019a	51		 push	 ecx
  0019b	8b 55 f8	 mov	 edx, DWORD PTR _pTrack$[ebp]
  0019e	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  001a1	8b 4d f8	 mov	 ecx, DWORD PTR _pTrack$[ebp]
  001a4	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  001a7	8b 00		 mov	 eax, DWORD PTR [eax]
  001a9	52		 push	 edx
  001aa	ff 50 1c	 call	 DWORD PTR [eax+28]
  001ad	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
$L69887:

; 1237 :         }
; 1238 :         if (SUCCEEDED(hr))

  001b0	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  001b4	7c 35		 jl	 SHORT $L69889

; 1239 :         {
; 1240 :             if( pmtNext )

  001b6	83 7d 1c 00	 cmp	 DWORD PTR _pmtNext$[ebp], 0
  001ba	74 26		 je	 SHORT $L69890

; 1241 :             { 
; 1242 :                 if(( *pmtNext == 0 ) || (*pmtNext > (m_mtLength - mtTime)))

  001bc	8b 4d 1c	 mov	 ecx, DWORD PTR _pmtNext$[ebp]
  001bf	83 39 00	 cmp	 DWORD PTR [ecx], 0
  001c2	74 10		 je	 SHORT $L69892
  001c4	8b 55 d0	 mov	 edx, DWORD PTR _this$[ebp]
  001c7	8b 42 54	 mov	 eax, DWORD PTR [edx+84]
  001ca	2b 45 18	 sub	 eax, DWORD PTR _mtTime$[ebp]
  001cd	8b 4d 1c	 mov	 ecx, DWORD PTR _pmtNext$[ebp]
  001d0	39 01		 cmp	 DWORD PTR [ecx], eax
  001d2	7e 0e		 jle	 SHORT $L69890
$L69892:

; 1243 :                 {
; 1244 :                     // If no next was found OR it's greater than the end of the segment, set 
; 1245 :                     // it to the end of the segment. 
; 1246 :                     *pmtNext = m_mtLength - mtTime;

  001d4	8b 55 d0	 mov	 edx, DWORD PTR _this$[ebp]
  001d7	8b 42 54	 mov	 eax, DWORD PTR [edx+84]
  001da	2b 45 18	 sub	 eax, DWORD PTR _mtTime$[ebp]
  001dd	8b 4d 1c	 mov	 ecx, DWORD PTR _pmtNext$[ebp]
  001e0	89 01		 mov	 DWORD PTR [ecx], eax
$L69890:

; 1247 :                 }
; 1248 :             }
; 1249 :             pTrack = NULL;

  001e2	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _pTrack$[ebp], 0

; 1250 :         }
; 1251 :         // If nothing was found and dwIndex was DMUS_SEG_ANYTRACK, try again...
; 1252 :         else if (fMultipleTry && (hr == DMUS_E_NOT_FOUND))

  001e9	eb 31		 jmp	 SHORT $L69893
$L69889:
  001eb	83 7d f4 00	 cmp	 DWORD PTR _fMultipleTry$[ebp], 0
  001ef	74 24		 je	 SHORT $L69898
  001f1	81 7d fc 61 11
	78 88		 cmp	 DWORD PTR _hr$[ebp], -2005397151 ; 88781161H
  001f8	75 1b		 jne	 SHORT $L69898

; 1253 :         {
; 1254 :             pTrack = GetTrackByParam( pTrack, rguidType, dwGroupBits, 0);

  001fa	6a 00		 push	 0
  001fc	8b 55 10	 mov	 edx, DWORD PTR _dwGroupBits$[ebp]
  001ff	52		 push	 edx
  00200	8b 45 0c	 mov	 eax, DWORD PTR _rguidType$[ebp]
  00203	50		 push	 eax
  00204	8b 4d f8	 mov	 ecx, DWORD PTR _pTrack$[ebp]
  00207	51		 push	 ecx
  00208	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  0020b	e8 00 00 00 00	 call	 ?GetTrackByParam@CSegState@@AAEPAVCTrack@@PAV2@ABU_GUID@@KK@Z ; CSegState::GetTrackByParam
  00210	89 45 f8	 mov	 DWORD PTR _pTrack$[ebp], eax

; 1255 :         }
; 1256 :         else

  00213	eb 07		 jmp	 SHORT $L69893
$L69898:

; 1257 :         {
; 1258 :             pTrack = NULL;

  00215	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _pTrack$[ebp], 0
$L69893:

; 1259 :         }
; 1260 :     }

  0021c	e9 26 fe ff ff	 jmp	 $L69871
$L69872:

; 1261 : #ifdef DBG
; 1262 :     if (hr == DMUS_E_TRACK_NOT_FOUND)

  00221	81 7d fc 05 40
	00 80		 cmp	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
  00228	75 0f		 jne	 SHORT $L69901

; 1263 :     {
; 1264 :         Trace(4,"Warning: Segmentstate::GetParam failed, unable to find a track that supports the requested param.\n");

  0022a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0GD@LBIELNMC@Warning?3?5Segmentstate?3?3GetParam?5@
  0022f	6a 04		 push	 4
  00231	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00236	83 c4 08	 add	 esp, 8
$L69901:

; 1265 :     }
; 1266 : #endif
; 1267 :     return hr;

  00239	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]

; 1268 : }

  0023c	8b e5		 mov	 esp, ebp
  0023e	5d		 pop	 ebp
  0023f	c2 1c 00	 ret	 28			; 0000001cH
?GetParam@CSegState@@QAEJPAVCPerformance@@ABU_GUID@@KKJPAJPAX@Z ENDP ; CSegState::GetParam
_TEXT	ENDS
PUBLIC	?GetTrack@CSegState@@AAEPAVCTrack@@ABU_GUID@@KK@Z ; CSegState::GetTrack
EXTRN	_GUID_All_Objects:BYTE
; Function compile flags: /Odt
;	COMDAT ?GetTrack@CSegState@@AAEPAVCTrack@@ABU_GUID@@KK@Z
_TEXT	SEGMENT
_this$ = -8
_pCTrack$ = -4
_rType$ = 8
_dwGroupBits$ = 12
_dwIndex$ = 16
?GetTrack@CSegState@@AAEPAVCTrack@@ABU_GUID@@KK@Z PROC NEAR ; CSegState::GetTrack, COMDAT
; _this$ = ecx

; 1275 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1276 : 	CTrack* pCTrack;
; 1277 : 	pCTrack = m_TrackList.GetHead();

  00009	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	83 c1 44	 add	 ecx, 68			; 00000044H
  0000f	e8 00 00 00 00	 call	 ?GetHead@CTrackList@@QAEPAVCTrack@@XZ ; CTrackList::GetHead
  00014	89 45 fc	 mov	 DWORD PTR _pCTrack$[ebp], eax
$L69911:

; 1278 : 	while( pCTrack )

  00017	83 7d fc 00	 cmp	 DWORD PTR _pCTrack$[ebp], 0
  0001b	74 71		 je	 SHORT $L69912

; 1279 : 	{
; 1280 : 		ASSERT(pCTrack->m_pTrack);

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _pCTrack$[ebp]
  00020	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  00024	75 17		 jne	 SHORT $L69913
  00026	6a 00		 push	 0
  00028	68 00 05 00 00	 push	 1280			; 00000500H
  0002d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NBCHJFPK@c?3?2xbox?2private?2windows?2directx?2@
  00032	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BC@LLLGOMEJ@pCTrack?9?$DOm_pTrack?$AA@
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
$L69913:

; 1281 : 		if( pCTrack->m_dwGroupBits & dwGroupBits )

  0003d	8b 4d fc	 mov	 ecx, DWORD PTR _pCTrack$[ebp]
  00040	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  00043	23 55 0c	 and	 edx, DWORD PTR _dwGroupBits$[ebp]
  00046	85 d2		 test	 edx, edx
  00048	74 37		 je	 SHORT $L69914

; 1282 : 		{
; 1283 : 			if( (GUID_All_Objects == rType) || (pCTrack->m_guidClassID == rType))

  0004a	8b 45 08	 mov	 eax, DWORD PTR _rType$[ebp]
  0004d	50		 push	 eax
  0004e	68 00 00 00 00	 push	 OFFSET FLAT:_GUID_All_Objects
  00053	e8 00 00 00 00	 call	 _==@8
  00058	85 c0		 test	 eax, eax
  0005a	75 14		 jne	 SHORT $L69916
  0005c	8b 4d 08	 mov	 ecx, DWORD PTR _rType$[ebp]
  0005f	51		 push	 ecx
  00060	8b 55 fc	 mov	 edx, DWORD PTR _pCTrack$[ebp]
  00063	83 c2 04	 add	 edx, 4
  00066	52		 push	 edx
  00067	e8 00 00 00 00	 call	 _==@8
  0006c	85 c0		 test	 eax, eax
  0006e	74 11		 je	 SHORT $L69914
$L69916:

; 1284 : 			{
; 1285 : 				if( 0 == dwIndex )

  00070	83 7d 10 00	 cmp	 DWORD PTR _dwIndex$[ebp], 0
  00074	75 02		 jne	 SHORT $L69917

; 1286 : 				{
; 1287 :                     break;

  00076	eb 16		 jmp	 SHORT $L69912
$L69917:

; 1288 : 				}
; 1289 : 				dwIndex--;

  00078	8b 45 10	 mov	 eax, DWORD PTR _dwIndex$[ebp]
  0007b	83 e8 01	 sub	 eax, 1
  0007e	89 45 10	 mov	 DWORD PTR _dwIndex$[ebp], eax
$L69914:

; 1290 : 			}
; 1291 : 		}
; 1292 : 		pCTrack = pCTrack->GetNext();

  00081	8b 4d fc	 mov	 ecx, DWORD PTR _pCTrack$[ebp]
  00084	e8 00 00 00 00	 call	 ?GetNext@CTrack@@QAEPAV1@XZ ; CTrack::GetNext
  00089	89 45 fc	 mov	 DWORD PTR _pCTrack$[ebp], eax

; 1293 : 	}

  0008c	eb 89		 jmp	 SHORT $L69911
$L69912:

; 1294 : 	return pCTrack;

  0008e	8b 45 fc	 mov	 eax, DWORD PTR _pCTrack$[ebp]

; 1295 : }

  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c2 0c 00	 ret	 12			; 0000000cH
?GetTrack@CSegState@@AAEPAVCTrack@@ABU_GUID@@KK@Z ENDP	; CSegState::GetTrack
_TEXT	ENDS
PUBLIC	??_C@_0BO@IBOJFPEI@?$CFs?3?5Invalid?5argument?5lVolume?6?$AA@ ; `string'
EXTRN	?VolumeToMidi@CParamMerger@@SGEJ@Z:NEAR		; CParamMerger::VolumeToMidi
;	COMDAT ?__szValidateInterfaceName@?1??SetVolume@CSegState@@UAGJJK@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??SetVolume@CSegState@@UAGJJK@Z@4QBDB DB 'Se'
	DB	'gState::SetVolume', 00H			; `CSegState::SetVolume'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0BO@IBOJFPEI@?$CFs?3?5Invalid?5argument?5lVolume?6?$AA@
CONST	SEGMENT
??_C@_0BO@IBOJFPEI@?$CFs?3?5Invalid?5argument?5lVolume?6?$AA@ DB '%s: Inv'
	DB	'alid argument lVolume', 0aH, 00H		; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?SetVolume@CSegState@@UAGJJK@Z
_TEXT	SEGMENT
tv235 = -44
tv234 = -36
tv207 = -32
_mtNow$69940 = -28
_rtTimeNow$69938 = -24
_hr$ = -12
_bMIDIVol$ = -5
_pCurve$ = -4
_this$ = 8
_lVolume$ = 12
_dwDuration$ = 16
?SetVolume@CSegState@@UAGJJK@Z PROC NEAR		; CSegState::SetVolume, COMDAT

; 1299 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH

; 1300 :     V_INAME(SegState::SetVolume);
; 1301 : #if defined(DBG) || defined(DXAPI)
; 1302 :     if (lVolume < DSBVOLUME_MIN || lVolume > DSBVOLUME_MAX)

  00006	81 7d 0c f0 d8
	ff ff		 cmp	 DWORD PTR _lVolume$[ebp], -10000 ; ffffd8f0H
  0000d	7c 06		 jl	 SHORT $L69926
  0000f	83 7d 0c 00	 cmp	 DWORD PTR _lVolume$[ebp], 0
  00013	7e 19		 jle	 SHORT $L69925
$L69926:

; 1303 :     {
; 1304 :         RIP_E_INVALIDARG(lVolume)

  00015	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??SetVolume@CSegState@@UAGJJK@Z@4QBDB
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@IBOJFPEI@?$CFs?3?5Invalid?5argument?5lVolume?6?$AA@
  0001f	6a ff		 push	 -1
  00021	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH
  00029	e8 00 00 00 00	 call	 _DebugBreak@0
$L69925:

; 1305 :     }
; 1306 : #endif
; 1307 :     HRESULT hr = E_FAIL; // This should never happen, since the audiopath is created by the performance. 

  0002e	c7 45 f4 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H

; 1308 :     BYTE bMIDIVol = CParamMerger::VolumeToMidi(lVolume);

  00035	8b 45 0c	 mov	 eax, DWORD PTR _lVolume$[ebp]
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 ?VolumeToMidi@CParamMerger@@SGEJ@Z ; CParamMerger::VolumeToMidi
  0003e	88 45 fb	 mov	 BYTE PTR _bMIDIVol$[ebp], al

; 1309 : 
; 1310 :     DMUS_CURVE_PMSG *pCurve;
; 1311 :     // Clamp to an hour!
; 1312 :     if (dwDuration > (60 * 60 * 1000)) dwDuration = (60 * 60 * 1000);

  00041	81 7d 10 80 ee
	36 00		 cmp	 DWORD PTR _dwDuration$[ebp], 3600000 ; 0036ee80H
  00048	76 07		 jbe	 SHORT $L69932
  0004a	c7 45 10 80 ee
	36 00		 mov	 DWORD PTR _dwDuration$[ebp], 3600000 ; 0036ee80H
$L69932:

; 1313 :     ENTER_CRITICAL_SECTION(&m_CriticalSection);

  00051	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	83 c1 14	 add	 ecx, 20			; 00000014H
  00057	51		 push	 ecx
  00058	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 1314 :     ENTER_API_CRITICAL_SECTION;
; 1315 :     if (m_pPerformance)

  0005e	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00061	83 7a 34 00	 cmp	 DWORD PTR [edx+52], 0
  00065	0f 84 cc 01 00
	00		 je	 $L69933

; 1316 :     {
; 1317 :         hr = m_pPerformance->AllocPMsg(sizeof(DMUS_CURVE_PMSG),(DMUS_PMSG **)&pCurve);

  0006b	8d 45 fc	 lea	 eax, DWORD PTR _pCurve$[ebp]
  0006e	50		 push	 eax
  0006f	6a 58		 push	 88			; 00000058H
  00071	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00074	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00077	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0007a	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0007d	8b 12		 mov	 edx, DWORD PTR [edx]
  0007f	51		 push	 ecx
  00080	ff 52 24	 call	 DWORD PTR [edx+36]
  00083	89 45 f4	 mov	 DWORD PTR _hr$[ebp], eax

; 1318 :         if (SUCCEEDED(hr))

  00086	83 7d f4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0008a	0f 8c a5 01 00
	00		 jl	 $L69937

; 1319 :         {
; 1320 :             REFERENCE_TIME rtTimeNow = 0;

  00090	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _rtTimeNow$69938[ebp], 0
  00097	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _rtTimeNow$69938[ebp+4], 0

; 1321 :             m_pPerformance->GetQueueTime(&rtTimeNow);

  0009e	8d 45 e8	 lea	 eax, DWORD PTR _rtTimeNow$69938[ebp]
  000a1	50		 push	 eax
  000a2	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000a5	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  000a8	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  000ab	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  000ae	8b 12		 mov	 edx, DWORD PTR [edx]
  000b0	51		 push	 ecx
  000b1	ff 92 84 00 00
	00		 call	 DWORD PTR [edx+132]

; 1322 :             // If this starts before a previous fade ended, invalidate it.
; 1323 :             if (m_rtLastVolChange > rtTimeNow)

  000b7	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  000ba	89 45 e0	 mov	 DWORD PTR tv207[ebp], eax
  000bd	8b 4d e0	 mov	 ecx, DWORD PTR tv207[ebp]
  000c0	8b 91 f4 00 00
	00		 mov	 edx, DWORD PTR [ecx+244]
  000c6	3b 55 ec	 cmp	 edx, DWORD PTR _rtTimeNow$69938[ebp+4]
  000c9	7c 49		 jl	 SHORT $L69939
  000cb	7f 0e		 jg	 SHORT $L70705
  000cd	8b 45 e0	 mov	 eax, DWORD PTR tv207[ebp]
  000d0	8b 88 f0 00 00
	00		 mov	 ecx, DWORD PTR [eax+240]
  000d6	3b 4d e8	 cmp	 ecx, DWORD PTR _rtTimeNow$69938[ebp]
  000d9	76 39		 jbe	 SHORT $L69939
$L70705:

; 1324 :             {
; 1325 :                 MUSIC_TIME mtNow;
; 1326 :                 m_pPerformance->ReferenceToMusicTime(rtTimeNow,&mtNow);

  000db	8d 55 e4	 lea	 edx, DWORD PTR _mtNow$69940[ebp]
  000de	52		 push	 edx
  000df	8b 45 ec	 mov	 eax, DWORD PTR _rtTimeNow$69938[ebp+4]
  000e2	50		 push	 eax
  000e3	8b 4d e8	 mov	 ecx, DWORD PTR _rtTimeNow$69938[ebp]
  000e6	51		 push	 ecx
  000e7	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  000ea	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  000ed	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000f0	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  000f3	8b 00		 mov	 eax, DWORD PTR [eax]
  000f5	52		 push	 edx
  000f6	ff 50 18	 call	 DWORD PTR [eax+24]

; 1327 :                 m_pPerformance->FlushVirtualTrack(m_dwTrackID,mtNow,0);

  000f9	6a 00		 push	 0
  000fb	8b 4d e4	 mov	 ecx, DWORD PTR _mtNow$69940[ebp]
  000fe	51		 push	 ecx
  000ff	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00102	8b 82 30 01 00
	00		 mov	 eax, DWORD PTR [edx+304]
  00108	50		 push	 eax
  00109	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0010c	8b 49 34	 mov	 ecx, DWORD PTR [ecx+52]
  0010f	e8 00 00 00 00	 call	 ?FlushVirtualTrack@CPerformance@@QAEJKJK@Z ; CPerformance::FlushVirtualTrack
$L69939:

; 1328 :             }
; 1329 :             if (m_rtLastVolChange < (rtTimeNow + (dwDuration * 10000)))

  00114	8b 55 10	 mov	 edx, DWORD PTR _dwDuration$[ebp]
  00117	69 d2 10 27 00
	00		 imul	 edx, 10000		; 00002710H
  0011d	33 c0		 xor	 eax, eax
  0011f	8b 4d e8	 mov	 ecx, DWORD PTR _rtTimeNow$69938[ebp]
  00122	03 ca		 add	 ecx, edx
  00124	8b 55 ec	 mov	 edx, DWORD PTR _rtTimeNow$69938[ebp+4]
  00127	13 d0		 adc	 edx, eax
  00129	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0012c	89 45 dc	 mov	 DWORD PTR tv234[ebp], eax
  0012f	89 4d d4	 mov	 DWORD PTR tv235[ebp], ecx
  00132	89 55 d8	 mov	 DWORD PTR tv235[ebp+4], edx
  00135	8b 4d dc	 mov	 ecx, DWORD PTR tv234[ebp]
  00138	8b 91 f4 00 00
	00		 mov	 edx, DWORD PTR [ecx+244]
  0013e	3b 55 d8	 cmp	 edx, DWORD PTR tv235[ebp+4]
  00141	7f 34		 jg	 SHORT $L69941
  00143	7c 0e		 jl	 SHORT $L70706
  00145	8b 45 dc	 mov	 eax, DWORD PTR tv234[ebp]
  00148	8b 88 f0 00 00
	00		 mov	 ecx, DWORD PTR [eax+240]
  0014e	3b 4d d4	 cmp	 ecx, DWORD PTR tv235[ebp]
  00151	73 24		 jae	 SHORT $L69941
$L70706:

; 1330 :             {
; 1331 :                 m_rtLastVolChange = rtTimeNow + (dwDuration * 10000);

  00153	8b 55 10	 mov	 edx, DWORD PTR _dwDuration$[ebp]
  00156	69 d2 10 27 00
	00		 imul	 edx, 10000		; 00002710H
  0015c	33 c0		 xor	 eax, eax
  0015e	8b 4d e8	 mov	 ecx, DWORD PTR _rtTimeNow$69938[ebp]
  00161	03 ca		 add	 ecx, edx
  00163	8b 55 ec	 mov	 edx, DWORD PTR _rtTimeNow$69938[ebp+4]
  00166	13 d0		 adc	 edx, eax
  00168	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0016b	89 88 f0 00 00
	00		 mov	 DWORD PTR [eax+240], ecx
  00171	89 90 f4 00 00
	00		 mov	 DWORD PTR [eax+244], edx
$L69941:

; 1332 :             }
; 1333 :                 pCurve->dwVirtualTrackID = m_dwTrackID;

  00177	8b 4d fc	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  0017a	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0017d	8b 82 30 01 00
	00		 mov	 eax, DWORD PTR [edx+304]
  00183	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 1334 :             pCurve->rtTime = rtTimeNow;

  00186	8b 4d fc	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  00189	8b 55 e8	 mov	 edx, DWORD PTR _rtTimeNow$69938[ebp]
  0018c	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  0018f	8b 45 ec	 mov	 eax, DWORD PTR _rtTimeNow$69938[ebp+4]
  00192	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 1335 :             pCurve->dwFlags = DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME | DMUS_PMSGF_DX8;

  00195	8b 4d fc	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  00198	c7 41 14 c1 00
	00 00		 mov	 DWORD PTR [ecx+20], 193	; 000000c1H

; 1336 :             pCurve->dwPChannel = DMUS_PCHANNEL_BROADCAST_SEGMENT;

  0019f	8b 55 fc	 mov	 edx, DWORD PTR _pCurve$[ebp]
  001a2	c7 42 18 fd ff
	ff ff		 mov	 DWORD PTR [edx+24], -3	; fffffffdH

; 1337 :             // dwVirtualTrackID: this isn't a track so leave as 0
; 1338 :             pCurve->dwType = DMUS_PMSGT_CURVE;

  001a9	8b 45 fc	 mov	 eax, DWORD PTR _pCurve$[ebp]
  001ac	c7 40 28 05 00
	00 00		 mov	 DWORD PTR [eax+40], 5

; 1339 :             pCurve->dwGroupID = -1; // this isn't a track so just say all groups

  001b3	8b 4d fc	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  001b6	c7 41 30 ff ff
	ff ff		 mov	 DWORD PTR [ecx+48], -1

; 1340 : 
; 1341 :             // curve PMsg fields
; 1342 :             pCurve->mtDuration = dwDuration; // setting the DMUS_PMSGF_LOCKTOREFTIME is interpreted by the performance that mtDuration is milliseconds

  001bd	8b 55 fc	 mov	 edx, DWORD PTR _pCurve$[ebp]
  001c0	8b 45 10	 mov	 eax, DWORD PTR _dwDuration$[ebp]
  001c3	89 42 38	 mov	 DWORD PTR [edx+56], eax

; 1343 :             // mtResetDuration: no reset so leave as 0
; 1344 :             pCurve->nStartValue = 127; //m_bLastVol;

  001c6	8b 4d fc	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  001c9	66 c7 41 44 7f
	00		 mov	 WORD PTR [ecx+68], 127	; 0000007fH

; 1345 :             // nStartValue: will be ignored
; 1346 :             pCurve->nEndValue = bMIDIVol;

  001cf	66 0f b6 55 fb	 movzx	 dx, BYTE PTR _bMIDIVol$[ebp]
  001d4	8b 45 fc	 mov	 eax, DWORD PTR _pCurve$[ebp]
  001d7	66 89 50 46	 mov	 WORD PTR [eax+70], dx

; 1347 :             // nResetValue: no reset so leave as 0
; 1348 :             pCurve->bType = DMUS_CURVET_CCCURVE;

  001db	8b 4d fc	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  001de	c6 41 50 04	 mov	 BYTE PTR [ecx+80], 4

; 1349 :             pCurve->bCurveShape = dwDuration ? DMUS_CURVES_LINEAR : DMUS_CURVES_INSTANT;

  001e2	33 d2		 xor	 edx, edx
  001e4	83 7d 10 00	 cmp	 DWORD PTR _dwDuration$[ebp], 0
  001e8	0f 94 c2	 sete	 dl
  001eb	8b 45 fc	 mov	 eax, DWORD PTR _pCurve$[ebp]
  001ee	88 50 51	 mov	 BYTE PTR [eax+81], dl

; 1350 :             pCurve->bCCData = 7; // MIDI volume controller number

  001f1	8b 4d fc	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  001f4	c6 41 52 07	 mov	 BYTE PTR [ecx+82], 7

; 1351 :             pCurve->bFlags = DMUS_CURVE_START_FROM_CURRENT;

  001f8	8b 55 fc	 mov	 edx, DWORD PTR _pCurve$[ebp]
  001fb	c6 42 53 02	 mov	 BYTE PTR [edx+83], 2

; 1352 :             // wParamType: leave as zero since this isn't a NRPN/RPN curve
; 1353 :             pCurve->wMergeIndex = 0xFFFF; //  special merge index so this won't get stepped on. is a big number OK? define a constant for this value?

  001ff	8b 45 fc	 mov	 eax, DWORD PTR _pCurve$[ebp]
  00202	66 c7 40 56 ff
	ff		 mov	 WORD PTR [eax+86], 65535 ; 0000ffffH

; 1354 : 
; 1355 :             // send it
; 1356 : 
; 1357 :             StampPMsg((DMUS_PMSG *)pCurve);

  00208	8b 4d fc	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  0020b	51		 push	 ecx
  0020c	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0020f	83 c2 04	 add	 edx, 4
  00212	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00215	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00218	52		 push	 edx
  00219	ff 51 0c	 call	 DWORD PTR [ecx+12]

; 1358 :             hr = m_pPerformance->SendPMsg((DMUS_PMSG*)pCurve);

  0021c	8b 55 fc	 mov	 edx, DWORD PTR _pCurve$[ebp]
  0021f	52		 push	 edx
  00220	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00223	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00226	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00229	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  0022c	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0022e	50		 push	 eax
  0022f	ff 51 10	 call	 DWORD PTR [ecx+16]
  00232	89 45 f4	 mov	 DWORD PTR _hr$[ebp], eax
$L69937:

; 1359 :         }
; 1360 :     }
; 1361 :     else

  00235	eb 07		 jmp	 SHORT $L69944
$L69933:

; 1362 :     {
; 1363 :         hr = DMUS_E_NOT_INIT;

  00237	c7 45 f4 62 11
	78 88		 mov	 DWORD PTR _hr$[ebp], -2005397150 ; 88781162H
$L69944:

; 1364 :     }
; 1365 :     LEAVE_CRITICAL_SECTION(&m_CriticalSection);

  0023e	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00241	83 c2 14	 add	 edx, 20			; 00000014H
  00244	52		 push	 edx
  00245	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 1366 :     LEAVE_API_CRITICAL_SECTION;
; 1367 :     return hr;

  0024b	8b 45 f4	 mov	 eax, DWORD PTR _hr$[ebp]

; 1368 : }

  0024e	8b e5		 mov	 esp, ebp
  00250	5d		 pop	 ebp
  00251	c2 0c 00	 ret	 12			; 0000000cH
?SetVolume@CSegState@@UAGJJK@Z ENDP			; CSegState::SetVolume
_TEXT	ENDS
PUBLIC	??_C@_0BN@MDFJNLGO@?$CFs?3?5Invalid?5argument?5lPitch?6?$AA@ ; `string'
;	COMDAT ?__szValidateInterfaceName@?1??SetPitch@CSegState@@UAGJJK@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??SetPitch@CSegState@@UAGJJK@Z@4QBDB DB 'Aud'
	DB	'ioPath::SetPitch', 00H			; `CSegState::SetPitch'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0BN@MDFJNLGO@?$CFs?3?5Invalid?5argument?5lPitch?6?$AA@
CONST	SEGMENT
??_C@_0BN@MDFJNLGO@?$CFs?3?5Invalid?5argument?5lPitch?6?$AA@ DB '%s: Inva'
	DB	'lid argument lPitch', 0aH, 00H		; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?SetPitch@CSegState@@UAGJJK@Z
_TEXT	SEGMENT
tv232 = -36
tv231 = -28
tv204 = -24
_mtNow$69970 = -20
_rtTimeNow$69968 = -16
_hr$ = -8
_pCurve$ = -4
_this$ = 8
_lPitch$ = 12
_dwDuration$ = 16
?SetPitch@CSegState@@UAGJJK@Z PROC NEAR			; CSegState::SetPitch, COMDAT

; 1372 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H

; 1373 :     V_INAME(AudioPath::SetPitch);
; 1374 :     HRESULT hr = E_FAIL; // This should never happen, since the audiopath is created by the performance. 

  00006	c7 45 f8 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H

; 1375 :     lPitch += 0x2000; // Bump up to center around 0x2000.

  0000d	8b 45 0c	 mov	 eax, DWORD PTR _lPitch$[ebp]
  00010	05 00 20 00 00	 add	 eax, 8192		; 00002000H
  00015	89 45 0c	 mov	 DWORD PTR _lPitch$[ebp], eax

; 1376 : #if defined(DBG) || defined(DXAPI)
; 1377 :     if (lPitch < 0 || lPitch > 0x3FFF)

  00018	83 7d 0c 00	 cmp	 DWORD PTR _lPitch$[ebp], 0
  0001c	7c 09		 jl	 SHORT $L69959
  0001e	81 7d 0c ff 3f
	00 00		 cmp	 DWORD PTR _lPitch$[ebp], 16383 ; 00003fffH
  00025	7e 19		 jle	 SHORT $L69958
$L69959:

; 1378 :     {
; 1379 :         RIP_E_INVALIDARG(lPitch)

  00027	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??SetPitch@CSegState@@UAGJJK@Z@4QBDB
  0002c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BN@MDFJNLGO@?$CFs?3?5Invalid?5argument?5lPitch?6?$AA@
  00031	6a ff		 push	 -1
  00033	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00038	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003b	e8 00 00 00 00	 call	 _DebugBreak@0
$L69958:

; 1380 :     }
; 1381 : #endif
; 1382 :     DMUS_CURVE_PMSG *pCurve;
; 1383 :     // Clamp to an hour!
; 1384 :     if (dwDuration > (60 * 60 * 1000)) dwDuration = (60 * 60 * 1000);

  00040	81 7d 10 80 ee
	36 00		 cmp	 DWORD PTR _dwDuration$[ebp], 3600000 ; 0036ee80H
  00047	76 07		 jbe	 SHORT $L69962
  00049	c7 45 10 80 ee
	36 00		 mov	 DWORD PTR _dwDuration$[ebp], 3600000 ; 0036ee80H
$L69962:

; 1385 :     ENTER_CRITICAL_SECTION(&m_CriticalSection);

  00050	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	83 c1 14	 add	 ecx, 20			; 00000014H
  00056	51		 push	 ecx
  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 1386 :     ENTER_API_CRITICAL_SECTION;
; 1387 :     if (m_pPerformance)

  0005d	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00060	83 7a 34 00	 cmp	 DWORD PTR [edx+52], 0
  00064	0f 84 cd 01 00
	00		 je	 $L69963

; 1388 :     {
; 1389 :         hr = m_pPerformance->AllocPMsg(sizeof(DMUS_CURVE_PMSG),(DMUS_PMSG **)&pCurve);

  0006a	8d 45 fc	 lea	 eax, DWORD PTR _pCurve$[ebp]
  0006d	50		 push	 eax
  0006e	6a 58		 push	 88			; 00000058H
  00070	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00073	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00076	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00079	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0007c	8b 12		 mov	 edx, DWORD PTR [edx]
  0007e	51		 push	 ecx
  0007f	ff 52 24	 call	 DWORD PTR [edx+36]
  00082	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax

; 1390 :         if (SUCCEEDED(hr))

  00085	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00089	0f 8c a6 01 00
	00		 jl	 $L69967

; 1391 :         {
; 1392 :             REFERENCE_TIME rtTimeNow = 0;

  0008f	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _rtTimeNow$69968[ebp], 0
  00096	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _rtTimeNow$69968[ebp+4], 0

; 1393 :             m_pPerformance->GetQueueTime(&rtTimeNow);

  0009d	8d 45 f0	 lea	 eax, DWORD PTR _rtTimeNow$69968[ebp]
  000a0	50		 push	 eax
  000a1	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000a4	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  000a7	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  000aa	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  000ad	8b 12		 mov	 edx, DWORD PTR [edx]
  000af	51		 push	 ecx
  000b0	ff 92 84 00 00
	00		 call	 DWORD PTR [edx+132]

; 1394 :             // If this starts before a previous fade ended, invalidate it.
; 1395 :             if (m_rtLastPitchChange > rtTimeNow)

  000b6	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  000b9	89 45 e8	 mov	 DWORD PTR tv204[ebp], eax
  000bc	8b 4d e8	 mov	 ecx, DWORD PTR tv204[ebp]
  000bf	8b 91 fc 00 00
	00		 mov	 edx, DWORD PTR [ecx+252]
  000c5	3b 55 f4	 cmp	 edx, DWORD PTR _rtTimeNow$69968[ebp+4]
  000c8	7c 49		 jl	 SHORT $L69969
  000ca	7f 0e		 jg	 SHORT $L70710
  000cc	8b 45 e8	 mov	 eax, DWORD PTR tv204[ebp]
  000cf	8b 88 f8 00 00
	00		 mov	 ecx, DWORD PTR [eax+248]
  000d5	3b 4d f0	 cmp	 ecx, DWORD PTR _rtTimeNow$69968[ebp]
  000d8	76 39		 jbe	 SHORT $L69969
$L70710:

; 1396 :             {
; 1397 :                 MUSIC_TIME mtNow;
; 1398 :                 m_pPerformance->ReferenceToMusicTime(rtTimeNow,&mtNow);

  000da	8d 55 ec	 lea	 edx, DWORD PTR _mtNow$69970[ebp]
  000dd	52		 push	 edx
  000de	8b 45 f4	 mov	 eax, DWORD PTR _rtTimeNow$69968[ebp+4]
  000e1	50		 push	 eax
  000e2	8b 4d f0	 mov	 ecx, DWORD PTR _rtTimeNow$69968[ebp]
  000e5	51		 push	 ecx
  000e6	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  000e9	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  000ec	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000ef	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  000f2	8b 00		 mov	 eax, DWORD PTR [eax]
  000f4	52		 push	 edx
  000f5	ff 50 18	 call	 DWORD PTR [eax+24]

; 1399 :                 m_pPerformance->FlushVirtualTrack(m_dwTrackID,mtNow,0);

  000f8	6a 00		 push	 0
  000fa	8b 4d ec	 mov	 ecx, DWORD PTR _mtNow$69970[ebp]
  000fd	51		 push	 ecx
  000fe	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00101	8b 82 30 01 00
	00		 mov	 eax, DWORD PTR [edx+304]
  00107	50		 push	 eax
  00108	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0010b	8b 49 34	 mov	 ecx, DWORD PTR [ecx+52]
  0010e	e8 00 00 00 00	 call	 ?FlushVirtualTrack@CPerformance@@QAEJKJK@Z ; CPerformance::FlushVirtualTrack
$L69969:

; 1400 :             }
; 1401 :             if (m_rtLastPitchChange < (rtTimeNow + (dwDuration * 10000)))

  00113	8b 55 10	 mov	 edx, DWORD PTR _dwDuration$[ebp]
  00116	69 d2 10 27 00
	00		 imul	 edx, 10000		; 00002710H
  0011c	33 c0		 xor	 eax, eax
  0011e	8b 4d f0	 mov	 ecx, DWORD PTR _rtTimeNow$69968[ebp]
  00121	03 ca		 add	 ecx, edx
  00123	8b 55 f4	 mov	 edx, DWORD PTR _rtTimeNow$69968[ebp+4]
  00126	13 d0		 adc	 edx, eax
  00128	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0012b	89 45 e4	 mov	 DWORD PTR tv231[ebp], eax
  0012e	89 4d dc	 mov	 DWORD PTR tv232[ebp], ecx
  00131	89 55 e0	 mov	 DWORD PTR tv232[ebp+4], edx
  00134	8b 4d e4	 mov	 ecx, DWORD PTR tv231[ebp]
  00137	8b 91 fc 00 00
	00		 mov	 edx, DWORD PTR [ecx+252]
  0013d	3b 55 e0	 cmp	 edx, DWORD PTR tv232[ebp+4]
  00140	7f 34		 jg	 SHORT $L69971
  00142	7c 0e		 jl	 SHORT $L70711
  00144	8b 45 e4	 mov	 eax, DWORD PTR tv231[ebp]
  00147	8b 88 f8 00 00
	00		 mov	 ecx, DWORD PTR [eax+248]
  0014d	3b 4d dc	 cmp	 ecx, DWORD PTR tv232[ebp]
  00150	73 24		 jae	 SHORT $L69971
$L70711:

; 1402 :             {
; 1403 :                 m_rtLastPitchChange = rtTimeNow + (dwDuration * 10000);

  00152	8b 55 10	 mov	 edx, DWORD PTR _dwDuration$[ebp]
  00155	69 d2 10 27 00
	00		 imul	 edx, 10000		; 00002710H
  0015b	33 c0		 xor	 eax, eax
  0015d	8b 4d f0	 mov	 ecx, DWORD PTR _rtTimeNow$69968[ebp]
  00160	03 ca		 add	 ecx, edx
  00162	8b 55 f4	 mov	 edx, DWORD PTR _rtTimeNow$69968[ebp+4]
  00165	13 d0		 adc	 edx, eax
  00167	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0016a	89 88 f8 00 00
	00		 mov	 DWORD PTR [eax+248], ecx
  00170	89 90 fc 00 00
	00		 mov	 DWORD PTR [eax+252], edx
$L69971:

; 1404 :             }
; 1405 :             pCurve->dwVirtualTrackID = m_dwTrackID;

  00176	8b 4d fc	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  00179	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0017c	8b 82 30 01 00
	00		 mov	 eax, DWORD PTR [edx+304]
  00182	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 1406 :             pCurve->rtTime = rtTimeNow;

  00185	8b 4d fc	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  00188	8b 55 f0	 mov	 edx, DWORD PTR _rtTimeNow$69968[ebp]
  0018b	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  0018e	8b 45 f4	 mov	 eax, DWORD PTR _rtTimeNow$69968[ebp+4]
  00191	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 1407 :             pCurve->dwFlags = DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME | DMUS_PMSGF_DX8;

  00194	8b 4d fc	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  00197	c7 41 14 c1 00
	00 00		 mov	 DWORD PTR [ecx+20], 193	; 000000c1H

; 1408 :             pCurve->dwPChannel = DMUS_PCHANNEL_BROADCAST_SEGMENT;

  0019e	8b 55 fc	 mov	 edx, DWORD PTR _pCurve$[ebp]
  001a1	c7 42 18 fd ff
	ff ff		 mov	 DWORD PTR [edx+24], -3	; fffffffdH

; 1409 :             // dwVirtualTrackID: this isn't a track so leave as 0
; 1410 :             pCurve->dwType = DMUS_PMSGT_CURVE;

  001a8	8b 45 fc	 mov	 eax, DWORD PTR _pCurve$[ebp]
  001ab	c7 40 28 05 00
	00 00		 mov	 DWORD PTR [eax+40], 5

; 1411 :             pCurve->dwGroupID = -1; // this isn't a track so just say all groups

  001b2	8b 4d fc	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  001b5	c7 41 30 ff ff
	ff ff		 mov	 DWORD PTR [ecx+48], -1

; 1412 : 
; 1413 :             // curve PMsg fields
; 1414 :             pCurve->mtDuration = dwDuration; // setting the DMUS_PMSGF_LOCKTOREFTIME is interpreted by the performance that mtDuration is milliseconds

  001bc	8b 55 fc	 mov	 edx, DWORD PTR _pCurve$[ebp]
  001bf	8b 45 10	 mov	 eax, DWORD PTR _dwDuration$[ebp]
  001c2	89 42 38	 mov	 DWORD PTR [edx+56], eax

; 1415 :             // mtResetDuration: no reset so leave as 0
; 1416 :             pCurve->nStartValue = 0;

  001c5	8b 4d fc	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  001c8	66 c7 41 44 00
	00		 mov	 WORD PTR [ecx+68], 0

; 1417 :             // nStartValue: will be ignored
; 1418 :             pCurve->nEndValue = (short) lPitch;

  001ce	8b 55 fc	 mov	 edx, DWORD PTR _pCurve$[ebp]
  001d1	66 8b 45 0c	 mov	 ax, WORD PTR _lPitch$[ebp]
  001d5	66 89 42 46	 mov	 WORD PTR [edx+70], ax

; 1419 :             // nResetValue: no reset so leave as 0
; 1420 :             pCurve->bType = DMUS_CURVET_PBCURVE;

  001d9	8b 4d fc	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  001dc	c6 41 50 03	 mov	 BYTE PTR [ecx+80], 3

; 1421 :             pCurve->bCurveShape = dwDuration ? DMUS_CURVES_LINEAR : DMUS_CURVES_INSTANT;

  001e0	33 d2		 xor	 edx, edx
  001e2	83 7d 10 00	 cmp	 DWORD PTR _dwDuration$[ebp], 0
  001e6	0f 94 c2	 sete	 dl
  001e9	8b 45 fc	 mov	 eax, DWORD PTR _pCurve$[ebp]
  001ec	88 50 51	 mov	 BYTE PTR [eax+81], dl

; 1422 :             // bCCData: Ignore, since this is pitch bend
; 1423 :             pCurve->bFlags = DMUS_CURVE_START_FROM_CURRENT;

  001ef	8b 4d fc	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  001f2	c6 41 53 02	 mov	 BYTE PTR [ecx+83], 2

; 1424 :             pCurve->wParamType = 0x2000;  // PB Range equivalent to pitch cents units.

  001f6	8b 55 fc	 mov	 edx, DWORD PTR _pCurve$[ebp]
  001f9	66 c7 42 54 00
	20		 mov	 WORD PTR [edx+84], 8192	; 00002000H

; 1425 :             pCurve->wMergeIndex = 0xFFFF; //  special merge index so this won't get stepped on. is a big number OK? define a constant for this value?

  001ff	8b 45 fc	 mov	 eax, DWORD PTR _pCurve$[ebp]
  00202	66 c7 40 56 ff
	ff		 mov	 WORD PTR [eax+86], 65535 ; 0000ffffH

; 1426 : 
; 1427 :             // send it
; 1428 : 
; 1429 :             StampPMsg((DMUS_PMSG *)pCurve);

  00208	8b 4d fc	 mov	 ecx, DWORD PTR _pCurve$[ebp]
  0020b	51		 push	 ecx
  0020c	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0020f	83 c2 04	 add	 edx, 4
  00212	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00215	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00218	52		 push	 edx
  00219	ff 51 0c	 call	 DWORD PTR [ecx+12]

; 1430 :             hr = m_pPerformance->SendPMsg((DMUS_PMSG*)pCurve);

  0021c	8b 55 fc	 mov	 edx, DWORD PTR _pCurve$[ebp]
  0021f	52		 push	 edx
  00220	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00223	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00226	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00229	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  0022c	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0022e	50		 push	 eax
  0022f	ff 51 10	 call	 DWORD PTR [ecx+16]
  00232	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax
$L69967:

; 1431 :         }
; 1432 :     }
; 1433 :     else

  00235	eb 07		 jmp	 SHORT $L69975
$L69963:

; 1434 :     {
; 1435 :         hr = DMUS_E_NOT_INIT;

  00237	c7 45 f8 62 11
	78 88		 mov	 DWORD PTR _hr$[ebp], -2005397150 ; 88781162H
$L69975:

; 1436 :     }
; 1437 :     LEAVE_CRITICAL_SECTION(&m_CriticalSection);

  0023e	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00241	83 c2 14	 add	 edx, 20			; 00000014H
  00244	52		 push	 edx
  00245	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 1438 :     LEAVE_API_CRITICAL_SECTION;
; 1439 :     return hr;

  0024b	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]

; 1440 : }

  0024e	8b e5		 mov	 esp, ebp
  00250	5d		 pop	 ebp
  00251	c2 0c 00	 ret	 12			; 0000000cH
?SetPitch@CSegState@@UAGJJK@Z ENDP			; CSegState::SetPitch
_TEXT	ENDS
PUBLIC	??_C@_0CP@FDCAMJIJ@?$CFs?3?5Invalid?5pointer?5?$CIvoid?$CK?$CJ?$CGrgui@ ; `string'
PUBLIC	??_C@_0FB@JJEDPCIN@Error?3?5Segmentstate?3?3SetTrackCon@ ; `string'
PUBLIC	?SetTrackConfig@CSegState@@QAGJABU_GUID@@KKKK@Z	; CSegState::SetTrackConfig
;	COMDAT ?__szValidateInterfaceName@?1??SetTrackConfig@CSegState@@QAGJABU_GUID@@KKKK@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??SetTrackConfig@CSegState@@QAGJABU_GUID@@KKKK@Z@4QBDB DB 'I'
	DB	'DirectMusicSegment::SetTrackConfig', 00H	; `CSegState::SetTrackConfig'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0CP@FDCAMJIJ@?$CFs?3?5Invalid?5pointer?5?$CIvoid?$CK?$CJ?$CGrgui@
CONST	SEGMENT
??_C@_0CP@FDCAMJIJ@?$CFs?3?5Invalid?5pointer?5?$CIvoid?$CK?$CJ?$CGrgui@ DB '%'
	DB	's: Invalid pointer (void*)&rguidTrackClassID', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FB@JJEDPCIN@Error?3?5Segmentstate?3?3SetTrackCon@
CONST	SEGMENT
??_C@_0FB@JJEDPCIN@Error?3?5Segmentstate?3?3SetTrackCon@ DB 'Error: Segme'
	DB	'ntstate::SetTrackConfig failed, unable to find the requested '
	DB	'track.', 0aH, 00H				; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?SetTrackConfig@CSegState@@QAGJABU_GUID@@KKKK@Z
_TEXT	SEGMENT
_hr$ = -16
_pCTrack$ = -12
_dwMax$ = -8
_dwCounter$ = -4
_this$ = 8
_rguidTrackClassID$ = 12
_dwGroup$ = 16
_dwIndex$ = 20
_dwFlagsOn$ = 24
_dwFlagsOff$ = 28
?SetTrackConfig@CSegState@@QAGJABU_GUID@@KKKK@Z PROC NEAR ; CSegState::SetTrackConfig, COMDAT

; 1445 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 1446 : 	V_INAME(IDirectMusicSegment::SetTrackConfig);
; 1447 : 	V_REFGUID(rguidTrackClassID);

  00006	6a 10		 push	 16			; 00000010H
  00008	8b 45 0c	 mov	 eax, DWORD PTR _rguidTrackClassID$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 _IsBadReadPtr@8
  00011	85 c0		 test	 eax, eax
  00013	74 19		 je	 SHORT $L69992
  00015	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??SetTrackConfig@CSegState@@QAGJABU_GUID@@KKKK@Z@4QBDB
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CP@FDCAMJIJ@?$CFs?3?5Invalid?5pointer?5?$CIvoid?$CK?$CJ?$CGrgui@
  0001f	6a ff		 push	 -1
  00021	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH
  00029	e8 00 00 00 00	 call	 _DebugBreak@0
$L69992:

; 1448 : #ifndef XBOX
; 1449 :     if (rguidTrackClassID == GUID_NULL)
; 1450 :     {
; 1451 :         return E_INVALIDARG;
; 1452 :     }
; 1453 : #endif
; 1454 : 	HRESULT hr = DMUS_E_TRACK_NOT_FOUND;

  0002e	c7 45 f0 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H

; 1455 :     CTrack* pCTrack;
; 1456 :     DWORD dwCounter = dwIndex;

  00035	8b 4d 14	 mov	 ecx, DWORD PTR _dwIndex$[ebp]
  00038	89 4d fc	 mov	 DWORD PTR _dwCounter$[ebp], ecx

; 1457 :     DWORD dwMax = dwIndex;

  0003b	8b 55 14	 mov	 edx, DWORD PTR _dwIndex$[ebp]
  0003e	89 55 f8	 mov	 DWORD PTR _dwMax$[ebp], edx

; 1458 :     if (dwIndex == DMUS_SEG_ALLTRACKS)

  00041	81 7d 14 00 00
	00 80		 cmp	 DWORD PTR _dwIndex$[ebp], -2147483648 ; 80000000H
  00048	75 0e		 jne	 SHORT $L69999

; 1459 :     {
; 1460 :         dwCounter = 0;

  0004a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _dwCounter$[ebp], 0

; 1461 :         dwMax = DMUS_SEG_ALLTRACKS;

  00051	c7 45 f8 00 00
	00 80		 mov	 DWORD PTR _dwMax$[ebp], -2147483648 ; 80000000H
$L69999:

; 1462 :     }
; 1463 :     ENTER_CRITICAL_SECTION(&m_CriticalSection);

  00058	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	83 c0 14	 add	 eax, 20			; 00000014H
  0005e	50		 push	 eax
  0005f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4
$L70001:

; 1464 :     while (pCTrack = GetTrack(rguidTrackClassID,dwGroup,dwIndex))

  00065	8b 4d 14	 mov	 ecx, DWORD PTR _dwIndex$[ebp]
  00068	51		 push	 ecx
  00069	8b 55 10	 mov	 edx, DWORD PTR _dwGroup$[ebp]
  0006c	52		 push	 edx
  0006d	8b 45 0c	 mov	 eax, DWORD PTR _rguidTrackClassID$[ebp]
  00070	50		 push	 eax
  00071	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00074	e8 00 00 00 00	 call	 ?GetTrack@CSegState@@AAEPAVCTrack@@ABU_GUID@@KK@Z ; CSegState::GetTrack
  00079	89 45 f4	 mov	 DWORD PTR _pCTrack$[ebp], eax
  0007c	83 7d f4 00	 cmp	 DWORD PTR _pCTrack$[ebp], 0
  00080	74 3e		 je	 SHORT $L70002

; 1465 :     {
; 1466 :         pCTrack->m_dwFlags &= ~dwFlagsOff;

  00082	8b 4d 1c	 mov	 ecx, DWORD PTR _dwFlagsOff$[ebp]
  00085	f7 d1		 not	 ecx
  00087	8b 55 f4	 mov	 edx, DWORD PTR _pCTrack$[ebp]
  0008a	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  0008d	23 c1		 and	 eax, ecx
  0008f	8b 4d f4	 mov	 ecx, DWORD PTR _pCTrack$[ebp]
  00092	89 41 34	 mov	 DWORD PTR [ecx+52], eax

; 1467 :         pCTrack->m_dwFlags |= dwFlagsOn;

  00095	8b 55 f4	 mov	 edx, DWORD PTR _pCTrack$[ebp]
  00098	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  0009b	0b 45 18	 or	 eax, DWORD PTR _dwFlagsOn$[ebp]
  0009e	8b 4d f4	 mov	 ecx, DWORD PTR _pCTrack$[ebp]
  000a1	89 41 34	 mov	 DWORD PTR [ecx+52], eax

; 1468 :         hr = S_OK;

  000a4	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _hr$[ebp], 0

; 1469 :         dwCounter++;

  000ab	8b 55 fc	 mov	 edx, DWORD PTR _dwCounter$[ebp]
  000ae	83 c2 01	 add	 edx, 1
  000b1	89 55 fc	 mov	 DWORD PTR _dwCounter$[ebp], edx

; 1470 :         if (dwCounter > dwMax) break;

  000b4	8b 45 fc	 mov	 eax, DWORD PTR _dwCounter$[ebp]
  000b7	3b 45 f8	 cmp	 eax, DWORD PTR _dwMax$[ebp]
  000ba	76 02		 jbe	 SHORT $L70004
  000bc	eb 02		 jmp	 SHORT $L70002
$L70004:

; 1471 :     }

  000be	eb a5		 jmp	 SHORT $L70001
$L70002:

; 1472 :     LEAVE_CRITICAL_SECTION(&m_CriticalSection);

  000c0	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000c3	83 c1 14	 add	 ecx, 20			; 00000014H
  000c6	51		 push	 ecx
  000c7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 1473 : #ifdef DBG
; 1474 :     if (hr == DMUS_E_TRACK_NOT_FOUND)

  000cd	81 7d f0 05 40
	00 80		 cmp	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H
  000d4	75 0f		 jne	 SHORT $L70006

; 1475 :     {
; 1476 :         Trace(1,"Error: Segmentstate::SetTrackConfig failed, unable to find the requested track.\n");

  000d6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0FB@JJEDPCIN@Error?3?5Segmentstate?3?3SetTrackCon@
  000db	6a 01		 push	 1
  000dd	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  000e2	83 c4 08	 add	 esp, 8
$L70006:

; 1477 :     }
; 1478 : #endif
; 1479 : 	return hr;

  000e5	8b 45 f0	 mov	 eax, DWORD PTR _hr$[ebp]

; 1480 : }

  000e8	8b e5		 mov	 esp, ebp
  000ea	5d		 pop	 ebp
  000eb	c2 18 00	 ret	 24			; 00000018H
?SetTrackConfig@CSegState@@QAGJABU_GUID@@KKKK@Z ENDP	; CSegState::SetTrackConfig
_TEXT	ENDS
PUBLIC	??_C@_09GLHEMJPI@pmtResult?$AA@			; `string'
PUBLIC	??_C@_0L@GHKMBHCB@m_mtLength?$AA@		; `string'
PUBLIC	?CheckPlay@CSegState@@QAEJJPAJ@Z		; CSegState::CheckPlay
;	COMDAT ??_C@_09GLHEMJPI@pmtResult?$AA@
CONST	SEGMENT
??_C@_09GLHEMJPI@pmtResult?$AA@ DB 'pmtResult', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GHKMBHCB@m_mtLength?$AA@
CONST	SEGMENT
??_C@_0L@GHKMBHCB@m_mtLength?$AA@ DB 'm_mtLength', 00H	; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?CheckPlay@CSegState@@QAEJJPAJ@Z
_TEXT	SEGMENT
_this$ = -16
_mtSeek$ = -12
_mtMyAmount$ = -8
_mtOffset$ = -4
_mtAmount$ = 8
_pmtResult$ = 12
?CheckPlay@CSegState@@QAEJJPAJ@Z PROC NEAR		; CSegState::CheckPlay, COMDAT
; _this$ = ecx

; 1484 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1485 : 	MUSIC_TIME mtMyAmount = mtAmount;

  00009	8b 45 08	 mov	 eax, DWORD PTR _mtAmount$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR _mtMyAmount$[ebp], eax

; 1486 : 	MUSIC_TIME mtSeek = m_mtSeek;

  0000f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 51 78	 mov	 edx, DWORD PTR [ecx+120]
  00015	89 55 f4	 mov	 DWORD PTR _mtSeek$[ebp], edx

; 1487 : 	MUSIC_TIME mtOffset = m_mtOffset;

  00018	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 48 6c	 mov	 ecx, DWORD PTR [eax+108]
  0001e	89 4d fc	 mov	 DWORD PTR _mtOffset$[ebp], ecx

; 1488 : 
; 1489 : 	ASSERT(pmtResult);

  00021	83 7d 0c 00	 cmp	 DWORD PTR _pmtResult$[ebp], 0
  00025	75 17		 jne	 SHORT $L70016
  00027	6a 00		 push	 0
  00029	68 d1 05 00 00	 push	 1489			; 000005d1H
  0002e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NBCHJFPK@c?3?2xbox?2private?2windows?2directx?2@
  00033	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_09GLHEMJPI@pmtResult?$AA@
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
$L70016:

; 1490 : 	// if this is the first call to play,
; 1491 : 	// We also need to check to see if we are supposed to start at the beginning,
; 1492 : 	// or at an offset.
; 1493 : 	if( m_dwPlayTrackFlags & DMUS_TRACKF_START )

  0003e	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00041	8b 42 58	 mov	 eax, DWORD PTR [edx+88]
  00044	83 e0 04	 and	 eax, 4
  00047	85 c0		 test	 eax, eax
  00049	74 09		 je	 SHORT $L70018

; 1494 : 	{
; 1495 : 		// set the current seek to the start point
; 1496 : 		mtSeek = m_mtStartPoint;

  0004b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0004e	8b 51 7c	 mov	 edx, DWORD PTR [ecx+124]
  00051	89 55 f4	 mov	 DWORD PTR _mtSeek$[ebp], edx
$L70018:

; 1497 : 	}
; 1498 : 	// if we need to do a loop or the end is near, restrict mtMyAmount
; 1499 : 	ASSERT( m_mtLength ); // length is 0, this segment won't do anything

  00054	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00057	83 78 54 00	 cmp	 DWORD PTR [eax+84], 0
  0005b	75 17		 jne	 SHORT $L70019
  0005d	6a 00		 push	 0
  0005f	68 db 05 00 00	 push	 1499			; 000005dbH
  00064	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DK@NBCHJFPK@c?3?2xbox?2private?2windows?2directx?2@
  00069	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0L@GHKMBHCB@m_mtLength?$AA@
  0006e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
$L70019:

; 1500 : 	if( m_dwRepeatsLeft )

  00074	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00077	83 b9 00 01 00
	00 00		 cmp	 DWORD PTR [ecx+256], 0
  0007e	74 1c		 je	 SHORT $L70021

; 1501 : 	{
; 1502 : 		if( mtMyAmount > m_mtLoopEnd - mtSeek )

  00080	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00083	8b 42 4c	 mov	 eax, DWORD PTR [edx+76]
  00086	2b 45 f4	 sub	 eax, DWORD PTR _mtSeek$[ebp]
  00089	39 45 f8	 cmp	 DWORD PTR _mtMyAmount$[ebp], eax
  0008c	7e 0c		 jle	 SHORT $L70022

; 1503 : 		{
; 1504 : 			mtMyAmount = m_mtLoopEnd - mtSeek;

  0008e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00091	8b 51 4c	 mov	 edx, DWORD PTR [ecx+76]
  00094	2b 55 f4	 sub	 edx, DWORD PTR _mtSeek$[ebp]
  00097	89 55 f8	 mov	 DWORD PTR _mtMyAmount$[ebp], edx
$L70022:

; 1505 : 		}
; 1506 : 	}
; 1507 : 	else if( mtMyAmount > m_mtLength - mtSeek )

  0009a	eb 1a		 jmp	 SHORT $L70023
$L70021:
  0009c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0009f	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  000a2	2b 4d f4	 sub	 ecx, DWORD PTR _mtSeek$[ebp]
  000a5	39 4d f8	 cmp	 DWORD PTR _mtMyAmount$[ebp], ecx
  000a8	7e 0c		 jle	 SHORT $L70023

; 1508 : 	{
; 1509 : 		mtMyAmount = m_mtLength - mtSeek;

  000aa	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  000ad	8b 42 54	 mov	 eax, DWORD PTR [edx+84]
  000b0	2b 45 f4	 sub	 eax, DWORD PTR _mtSeek$[ebp]
  000b3	89 45 f8	 mov	 DWORD PTR _mtMyAmount$[ebp], eax
$L70023:

; 1510 : 	}
; 1511 : 	
; 1512 : 	// take into account repeats if necessary
; 1513 : 	*pmtResult = mtMyAmount;

  000b6	8b 4d 0c	 mov	 ecx, DWORD PTR _pmtResult$[ebp]
  000b9	8b 55 f8	 mov	 edx, DWORD PTR _mtMyAmount$[ebp]
  000bc	89 11		 mov	 DWORD PTR [ecx], edx

; 1514 : 	return S_OK;

  000be	33 c0		 xor	 eax, eax

; 1515 : }

  000c0	8b e5		 mov	 esp, ebp
  000c2	5d		 pop	 ebp
  000c3	c2 08 00	 ret	 8
?CheckPlay@CSegState@@QAEJJPAJ@Z ENDP			; CSegState::CheckPlay
_TEXT	ENDS
PUBLIC	??_C@_0BO@ODPGIKAP@?$CFs?3?5Invalid?5pointer?5pmtStart?6?$AA@ ; `string'
;	COMDAT ?__szValidateInterfaceName@?1??GetStartTime@CSegState@@UAGJPAJ@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??GetStartTime@CSegState@@UAGJPAJ@Z@4QBDB DB 'I'
	DB	'DirectMusicSegmentState::GetStartTime', 00H	; `CSegState::GetStartTime'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0BO@ODPGIKAP@?$CFs?3?5Invalid?5pointer?5pmtStart?6?$AA@
CONST	SEGMENT
??_C@_0BO@ODPGIKAP@?$CFs?3?5Invalid?5pointer?5pmtStart?6?$AA@ DB '%s: Inv'
	DB	'alid pointer pmtStart', 0aH, 00H		; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?GetStartTime@CSegState@@UAGJPAJ@Z
_TEXT	SEGMENT
_this$ = 8
_pmtStart$ = 12
?GetStartTime@CSegState@@UAGJPAJ@Z PROC NEAR		; CSegState::GetStartTime, COMDAT

; 1532 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1533 : 	V_INAME(IDirectMusicSegmentState::GetStartTime);
; 1534 : 	V_PTR_WRITE(pmtStart,MUSIC_TIME);

  00003	6a 04		 push	 4
  00005	8b 45 0c	 mov	 eax, DWORD PTR _pmtStart$[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  0000e	85 c0		 test	 eax, eax
  00010	74 19		 je	 SHORT $L70033
  00012	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??GetStartTime@CSegState@@UAGJPAJ@Z@4QBDB
  00017	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@ODPGIKAP@?$CFs?3?5Invalid?5pointer?5pmtStart?6?$AA@
  0001c	6a ff		 push	 -1
  0001e	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH
  00026	e8 00 00 00 00	 call	 _DebugBreak@0
$L70033:

; 1535 : 
; 1536 : 	*pmtStart = m_mtResolvedStart;

  0002b	8b 4d 0c	 mov	 ecx, DWORD PTR _pmtStart$[ebp]
  0002e	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00031	8b 42 64	 mov	 eax, DWORD PTR [edx+100]
  00034	89 01		 mov	 DWORD PTR [ecx], eax

; 1537 : 	return S_OK;

  00036	33 c0		 xor	 eax, eax

; 1538 : }

  00038	5d		 pop	 ebp
  00039	c2 08 00	 ret	 8
?GetStartTime@CSegState@@UAGJPAJ@Z ENDP			; CSegState::GetStartTime
_TEXT	ENDS
;	COMDAT ?__szValidateInterfaceName@?1??GetStartPoint@CSegState@@UAGJPAJ@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??GetStartPoint@CSegState@@UAGJPAJ@Z@4QBDB DB 'I'
	DB	'DirectMusicSegmentState::GetStartPoint', 00H ; `CSegState::GetStartPoint'::`2'::__szValidateInterfaceName
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?GetStartPoint@CSegState@@UAGJPAJ@Z
_TEXT	SEGMENT
_this$ = 8
_pmtStart$ = 12
?GetStartPoint@CSegState@@UAGJPAJ@Z PROC NEAR		; CSegState::GetStartPoint, COMDAT

; 1558 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1559 : 	V_INAME(IDirectMusicSegmentState::GetStartPoint);
; 1560 : 	V_PTR_WRITE(pmtStart,MUSIC_TIME);

  00003	6a 04		 push	 4
  00005	8b 45 0c	 mov	 eax, DWORD PTR _pmtStart$[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  0000e	85 c0		 test	 eax, eax
  00010	74 19		 je	 SHORT $L70043
  00012	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??GetStartPoint@CSegState@@UAGJPAJ@Z@4QBDB
  00017	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@ODPGIKAP@?$CFs?3?5Invalid?5pointer?5pmtStart?6?$AA@
  0001c	6a ff		 push	 -1
  0001e	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH
  00026	e8 00 00 00 00	 call	 _DebugBreak@0
$L70043:

; 1561 : 
; 1562 : 	*pmtStart = m_mtStartPoint;

  0002b	8b 4d 0c	 mov	 ecx, DWORD PTR _pmtStart$[ebp]
  0002e	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00031	8b 42 7c	 mov	 eax, DWORD PTR [edx+124]
  00034	89 01		 mov	 DWORD PTR [ecx], eax

; 1563 : 	return S_OK;

  00036	33 c0		 xor	 eax, eax

; 1564 : }

  00038	5d		 pop	 ebp
  00039	c2 08 00	 ret	 8
?GetStartPoint@CSegState@@UAGJPAJ@Z ENDP		; CSegState::GetStartPoint
_TEXT	ENDS
PUBLIC	?SetSeek@CSegState@@QAEJJK@Z			; CSegState::SetSeek
; Function compile flags: /Odt
;	COMDAT ?SetSeek@CSegState@@QAEJJK@Z
_TEXT	SEGMENT
_this$ = -4
_mtSeek$ = 8
_dwPlayFlags$ = 12
?SetSeek@CSegState@@QAEJJK@Z PROC NEAR			; CSegState::SetSeek, COMDAT
; _this$ = ecx

; 1581 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1582 : 	m_mtSeek = mtSeek;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _mtSeek$[ebp]
  0000d	89 48 78	 mov	 DWORD PTR [eax+120], ecx

; 1583 : 	m_dwPlayTrackFlags |= dwPlayFlags | DMUS_TRACKF_SEEK;

  00010	8b 55 0c	 mov	 edx, DWORD PTR _dwPlayFlags$[ebp]
  00013	83 ca 01	 or	 edx, 1
  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	8b 48 58	 mov	 ecx, DWORD PTR [eax+88]
  0001c	0b ca		 or	 ecx, edx
  0001e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00021	89 4a 58	 mov	 DWORD PTR [edx+88], ecx

; 1584 : 	return S_OK;

  00024	33 c0		 xor	 eax, eax

; 1585 : }

  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
?SetSeek@CSegState@@QAEJJK@Z ENDP			; CSegState::SetSeek
_TEXT	ENDS
PUBLIC	?SetInvalidate@CSegState@@QAEJJ@Z		; CSegState::SetInvalidate
; Function compile flags: /Odt
;	COMDAT ?SetInvalidate@CSegState@@QAEJJ@Z
_TEXT	SEGMENT
_this$ = -24
_dwRepeat$ = -20
_dwFlags$ = -16
_hr$ = -12
_pCTrack$ = -8
_mtOffset$ = -4
_mtTime$ = 8
?SetInvalidate@CSegState@@QAEJJ@Z PROC NEAR		; CSegState::SetInvalidate, COMDAT
; _this$ = ecx

; 1594 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 1595 : 	MUSIC_TIME mtOffset;
; 1596 : 	DWORD dwRepeat;
; 1597 : 	DWORD dwFlags = DMUS_TRACKF_FLUSH | DMUS_TRACKF_SEEK;

  00009	c7 45 f0 09 00
	00 00		 mov	 DWORD PTR _dwFlags$[ebp], 9

; 1598 : 
; 1599 : 	HRESULT hr = ConvertToSegTime( &mtTime, &mtOffset, &dwRepeat );

  00010	8d 45 ec	 lea	 eax, DWORD PTR _dwRepeat$[ebp]
  00013	50		 push	 eax
  00014	8d 4d fc	 lea	 ecx, DWORD PTR _mtOffset$[ebp]
  00017	51		 push	 ecx
  00018	8d 55 08	 lea	 edx, DWORD PTR _mtTime$[ebp]
  0001b	52		 push	 edx
  0001c	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ?ConvertToSegTime@CSegState@@QAEJPAJ0PAK@Z ; CSegState::ConvertToSegTime
  00024	89 45 f4	 mov	 DWORD PTR _hr$[ebp], eax

; 1600 : 	if( hr != S_OK )

  00027	83 7d f4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0002b	74 2d		 je	 SHORT $L70060

; 1601 : 	{
; 1602 : 		mtTime = 0;

  0002d	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _mtTime$[ebp], 0

; 1603 : 		m_dwRepeatsLeft = m_dwRepeats;

  00034	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00037	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	8b 51 50	 mov	 edx, DWORD PTR [ecx+80]
  0003d	89 90 00 01 00
	00		 mov	 DWORD PTR [eax+256], edx

; 1604 : 		m_mtOffset = m_mtResolvedStart;

  00043	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00046	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	8b 51 64	 mov	 edx, DWORD PTR [ecx+100]
  0004c	89 50 6c	 mov	 DWORD PTR [eax+108], edx

; 1605 : 		dwFlags |= DMUS_TRACKF_START;

  0004f	8b 45 f0	 mov	 eax, DWORD PTR _dwFlags$[ebp]
  00052	83 c8 04	 or	 eax, 4
  00055	89 45 f0	 mov	 DWORD PTR _dwFlags$[ebp], eax

; 1606 : 	}
; 1607 : 	else

  00058	eb 1b		 jmp	 SHORT $L70061
$L70060:

; 1608 : 	{
; 1609 : 		m_dwRepeatsLeft = m_dwRepeats - dwRepeat;

  0005a	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	8b 51 50	 mov	 edx, DWORD PTR [ecx+80]
  00060	2b 55 ec	 sub	 edx, DWORD PTR _dwRepeat$[ebp]
  00063	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00066	89 90 00 01 00
	00		 mov	 DWORD PTR [eax+256], edx

; 1610 : 		m_mtOffset = mtOffset;

  0006c	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0006f	8b 55 fc	 mov	 edx, DWORD PTR _mtOffset$[ebp]
  00072	89 51 6c	 mov	 DWORD PTR [ecx+108], edx
$L70061:

; 1611 : 	}
; 1612 :     ENTER_CRITICAL_SECTION(&m_CriticalSection);

  00075	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00078	83 c0 14	 add	 eax, 20			; 00000014H
  0007b	50		 push	 eax
  0007c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 1613 : 	CTrack* pCTrack = m_TrackList.GetHead();

  00082	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00085	83 c1 44	 add	 ecx, 68			; 00000044H
  00088	e8 00 00 00 00	 call	 ?GetHead@CTrackList@@QAEPAVCTrack@@XZ ; CTrackList::GetHead
  0008d	89 45 f8	 mov	 DWORD PTR _pCTrack$[ebp], eax
$L70064:

; 1614 : 	while( pCTrack )

  00090	83 7d f8 00	 cmp	 DWORD PTR _pCTrack$[ebp], 0
  00094	74 17		 je	 SHORT $L70065

; 1615 : 	{
; 1616 : 		pCTrack->m_bDone = FALSE;

  00096	8b 4d f8	 mov	 ecx, DWORD PTR _pCTrack$[ebp]
  00099	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0

; 1617 : 		pCTrack = pCTrack->GetNext();

  000a0	8b 4d f8	 mov	 ecx, DWORD PTR _pCTrack$[ebp]
  000a3	e8 00 00 00 00	 call	 ?GetNext@CTrack@@QAEPAV1@XZ ; CTrack::GetNext
  000a8	89 45 f8	 mov	 DWORD PTR _pCTrack$[ebp], eax

; 1618 : 	}

  000ab	eb e3		 jmp	 SHORT $L70064
$L70065:

; 1619 :     LEAVE_CRITICAL_SECTION(&m_CriticalSection);

  000ad	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  000b0	83 c2 14	 add	 edx, 20			; 00000014H
  000b3	52		 push	 edx
  000b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 1620 : 	return SetSeek( mtTime, dwFlags );

  000ba	8b 45 f0	 mov	 eax, DWORD PTR _dwFlags$[ebp]
  000bd	50		 push	 eax
  000be	8b 4d 08	 mov	 ecx, DWORD PTR _mtTime$[ebp]
  000c1	51		 push	 ecx
  000c2	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000c5	e8 00 00 00 00	 call	 ?SetSeek@CSegState@@QAEJJK@Z ; CSegState::SetSeek

; 1621 : }

  000ca	8b e5		 mov	 esp, ebp
  000cc	5d		 pop	 ebp
  000cd	c2 04 00	 ret	 4
?SetInvalidate@CSegState@@QAEJJ@Z ENDP			; CSegState::SetInvalidate
_TEXT	ENDS
PUBLIC	??_C@_0BN@FPNBBHE@?$CFs?3?5Invalid?5pointer?5pmtSeek?6?$AA@ ; `string'
;	COMDAT ?__szValidateInterfaceName@?1??GetSeek@CSegState@@UAGJPAJ@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??GetSeek@CSegState@@UAGJPAJ@Z@4QBDB DB 'IDi'
	DB	'rectMusicSegmentState::GetSeek', 00H	; `CSegState::GetSeek'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0BN@FPNBBHE@?$CFs?3?5Invalid?5pointer?5pmtSeek?6?$AA@
CONST	SEGMENT
??_C@_0BN@FPNBBHE@?$CFs?3?5Invalid?5pointer?5pmtSeek?6?$AA@ DB '%s: Inval'
	DB	'id pointer pmtSeek', 0aH, 00H		; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?GetSeek@CSegState@@UAGJPAJ@Z
_TEXT	SEGMENT
_this$ = 8
_pmtSeek$ = 12
?GetSeek@CSegState@@UAGJPAJ@Z PROC NEAR			; CSegState::GetSeek, COMDAT

; 1629 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1630 : 	V_INAME(IDirectMusicSegmentState::GetSeek);
; 1631 : 	V_PTR_WRITE(pmtSeek, MUSIC_TIME);

  00003	6a 04		 push	 4
  00005	8b 45 0c	 mov	 eax, DWORD PTR _pmtSeek$[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  0000e	85 c0		 test	 eax, eax
  00010	74 19		 je	 SHORT $L70073
  00012	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??GetSeek@CSegState@@UAGJPAJ@Z@4QBDB
  00017	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BN@FPNBBHE@?$CFs?3?5Invalid?5pointer?5pmtSeek?6?$AA@
  0001c	6a ff		 push	 -1
  0001e	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH
  00026	e8 00 00 00 00	 call	 _DebugBreak@0
$L70073:

; 1632 : 
; 1633 : 	*pmtSeek = m_mtSeek;

  0002b	8b 4d 0c	 mov	 ecx, DWORD PTR _pmtSeek$[ebp]
  0002e	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00031	8b 42 78	 mov	 eax, DWORD PTR [edx+120]
  00034	89 01		 mov	 DWORD PTR [ecx], eax

; 1634 : 	return S_OK;

  00036	33 c0		 xor	 eax, eax

; 1635 : }

  00038	5d		 pop	 ebp
  00039	c2 08 00	 ret	 8
?GetSeek@CSegState@@UAGJPAJ@Z ENDP			; CSegState::GetSeek
_TEXT	ENDS
PUBLIC	?Flush@CSegState@@QAGJJ@Z			; CSegState::Flush
; Function compile flags: /Odt
;	COMDAT ?Flush@CSegState@@QAGJJ@Z
_TEXT	SEGMENT
_pTrack$ = -4
_this$ = 8
_mtTime$ = 12
?Flush@CSegState@@QAGJJ@Z PROC NEAR			; CSegState::Flush, COMDAT

; 1638 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1639 : 	CTrack*	pTrack;
; 1640 :     ENTER_CRITICAL_SECTION(&m_CriticalSection);

  00004	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00007	83 c0 14	 add	 eax, 20			; 00000014H
  0000a	50		 push	 eax
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 1641 : 	pTrack = m_TrackList.GetHead();

  00011	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	83 c1 44	 add	 ecx, 68			; 00000044H
  00017	e8 00 00 00 00	 call	 ?GetHead@CTrackList@@QAEPAVCTrack@@XZ ; CTrackList::GetHead
  0001c	89 45 fc	 mov	 DWORD PTR _pTrack$[ebp], eax
$L70082:

; 1642 : 	while( pTrack )

  0001f	83 7d fc 00	 cmp	 DWORD PTR _pTrack$[ebp], 0
  00023	74 25		 je	 SHORT $L70083

; 1643 : 	{
; 1644 : 		m_pPerformance->FlushVirtualTrack( pTrack->m_dwVirtualID, mtTime, 0 );

  00025	6a 00		 push	 0
  00027	8b 4d 0c	 mov	 ecx, DWORD PTR _mtTime$[ebp]
  0002a	51		 push	 ecx
  0002b	8b 55 fc	 mov	 edx, DWORD PTR _pTrack$[ebp]
  0002e	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00031	50		 push	 eax
  00032	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	8b 49 34	 mov	 ecx, DWORD PTR [ecx+52]
  00038	e8 00 00 00 00	 call	 ?FlushVirtualTrack@CPerformance@@QAEJKJK@Z ; CPerformance::FlushVirtualTrack

; 1645 : 		pTrack = pTrack->GetNext();

  0003d	8b 4d fc	 mov	 ecx, DWORD PTR _pTrack$[ebp]
  00040	e8 00 00 00 00	 call	 ?GetNext@CTrack@@QAEPAV1@XZ ; CTrack::GetNext
  00045	89 45 fc	 mov	 DWORD PTR _pTrack$[ebp], eax

; 1646 : 	}

  00048	eb d5		 jmp	 SHORT $L70082
$L70083:

; 1647 :     LEAVE_CRITICAL_SECTION(&m_CriticalSection);

  0004a	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0004d	83 c2 14	 add	 edx, 20			; 00000014H
  00050	52		 push	 edx
  00051	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 1648 : 	return S_OK;

  00057	33 c0		 xor	 eax, eax

; 1649 : }

  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 08 00	 ret	 8
?Flush@CSegState@@QAGJJ@Z ENDP				; CSegState::Flush
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?Shutdown@CSegState@@QAGJXZ
_TEXT	SEGMENT
_this$ = 8
?Shutdown@CSegState@@QAGJXZ PROC NEAR			; CSegState::Shutdown, COMDAT

; 1652 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1653 : 	return E_NOTIMPL;

  00003	b8 01 40 00 80	 mov	 eax, -2147467263	; 80004001H

; 1654 : }

  00008	5d		 pop	 ebp
  00009	c2 04 00	 ret	 4
?Shutdown@CSegState@@QAGJXZ ENDP			; CSegState::Shutdown
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?InsertTool@CSegState@@UAGJPAUIDirectMusicTool@@PAKKJ@Z
_TEXT	SEGMENT
_this$ = 8
_pTool$ = 12
_pdwPChannels$ = 16
_cPChannels$ = 20
_lIndex$ = 24
?InsertTool@CSegState@@UAGJPAUIDirectMusicTool@@PAKKJ@Z PROC NEAR ; CSegState::InsertTool, COMDAT

; 1661 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1662 : 	return E_NOTIMPL;

  00003	b8 01 40 00 80	 mov	 eax, -2147467263	; 80004001H

; 1663 : }

  00008	5d		 pop	 ebp
  00009	c2 14 00	 ret	 20			; 00000014H
?InsertTool@CSegState@@UAGJPAUIDirectMusicTool@@PAKKJ@Z ENDP ; CSegState::InsertTool
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?GetTool@CSegState@@UAGJKPAPAUIDirectMusicTool@@@Z
_TEXT	SEGMENT
_this$ = 8
_dwIndex$ = 12
_ppTool$ = 16
?GetTool@CSegState@@UAGJKPAPAUIDirectMusicTool@@@Z PROC NEAR ; CSegState::GetTool, COMDAT

; 1668 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1669 : 	return E_NOTIMPL;

  00003	b8 01 40 00 80	 mov	 eax, -2147467263	; 80004001H

; 1670 : }

  00008	5d		 pop	 ebp
  00009	c2 0c 00	 ret	 12			; 0000000cH
?GetTool@CSegState@@UAGJKPAPAUIDirectMusicTool@@@Z ENDP	; CSegState::GetTool
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?RemoveTool@CSegState@@UAGJPAUIDirectMusicTool@@@Z
_TEXT	SEGMENT
_this$ = 8
_pTool$ = 12
?RemoveTool@CSegState@@UAGJPAUIDirectMusicTool@@@Z PROC NEAR ; CSegState::RemoveTool, COMDAT

; 1674 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1675 : 	return E_NOTIMPL;

  00003	b8 01 40 00 80	 mov	 eax, -2147467263	; 80004001H

; 1676 : }

  00008	5d		 pop	 ebp
  00009	c2 08 00	 ret	 8
?RemoveTool@CSegState@@UAGJPAUIDirectMusicTool@@@Z ENDP	; CSegState::RemoveTool
_TEXT	ENDS
PUBLIC	??_C@_0BL@KLPIMHHM@?$CFs?3?5Invalid?5pointer?5pPMsg?6?$AA@ ; `string'
PUBLIC	??_C@_0FN@BKJJAELJ@Error?3?5Segmentstate?3?3StampPMsg?5f@ ; `string'
;	COMDAT ?__szValidateInterfaceName@?1??StampPMsg@CSegState@@UAGJPAU_DMUS_PMSG@@@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??StampPMsg@CSegState@@UAGJPAU_DMUS_PMSG@@@Z@4QBDB DB 'I'
	DB	'DirectMusicSegmentState::StampPMsg', 00H	; `CSegState::StampPMsg'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0BL@KLPIMHHM@?$CFs?3?5Invalid?5pointer?5pPMsg?6?$AA@
CONST	SEGMENT
??_C@_0BL@KLPIMHHM@?$CFs?3?5Invalid?5pointer?5pPMsg?6?$AA@ DB '%s: Invali'
	DB	'd pointer pPMsg', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FN@BKJJAELJ@Error?3?5Segmentstate?3?3StampPMsg?5f@
CONST	SEGMENT
??_C@_0FN@BKJJAELJ@Error?3?5Segmentstate?3?3StampPMsg?5f@ DB 'Error: Segm'
	DB	'entstate::StampPMsg failed because the segmentstate is not pr'
	DB	'operly initialized.', 0aH, 00H		; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?StampPMsg@CSegState@@UAGJPAU_DMUS_PMSG@@@Z
_TEXT	SEGMENT
tv156 = -32
tv139 = -28
_hrTemp$70148 = -24
_pNewMsg$70145 = -20
_dwNewChannel$70142 = -16
_dwIndex$70138 = -12
_pSegment$70137 = -8
_hr$ = -4
_this$ = 8
_pPMsg$ = 12
?StampPMsg@CSegState@@UAGJPAU_DMUS_PMSG@@@Z PROC NEAR	; CSegState::StampPMsg, COMDAT

; 1680 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H

; 1681 : 	V_INAME(IDirectMusicSegmentState::StampPMsg);
; 1682 :     if( m_dwVersion < 8)

  00006	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00009	83 b8 04 01 00
	00 08		 cmp	 DWORD PTR [eax+260], 8
  00010	73 2a		 jae	 SHORT $L70114

; 1683 :     {
; 1684 :     	V_BUFPTR_WRITE(pPMsg,sizeof(DMUS_PMSG));

  00012	6a 38		 push	 56			; 00000038H
  00014	8b 4d 0c	 mov	 ecx, DWORD PTR _pPMsg$[ebp]
  00017	51		 push	 ecx
  00018	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  0001d	85 c0		 test	 eax, eax
  0001f	74 19		 je	 SHORT $L70116
  00021	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??StampPMsg@CSegState@@UAGJPAU_DMUS_PMSG@@@Z@4QBDB
  00026	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BL@KLPIMHHM@?$CFs?3?5Invalid?5pointer?5pPMsg?6?$AA@
  0002b	6a ff		 push	 -1
  0002d	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00032	83 c4 0c	 add	 esp, 12			; 0000000cH
  00035	e8 00 00 00 00	 call	 _DebugBreak@0
$L70116:

; 1685 :     }
; 1686 :     else

  0003a	eb 28		 jmp	 SHORT $L70118
$L70114:

; 1687 :     {
; 1688 : #ifdef DBG
; 1689 : 		V_BUFPTR_WRITE(pPMsg,sizeof(DMUS_PMSG));

  0003c	6a 38		 push	 56			; 00000038H
  0003e	8b 55 0c	 mov	 edx, DWORD PTR _pPMsg$[ebp]
  00041	52		 push	 edx
  00042	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  00047	85 c0		 test	 eax, eax
  00049	74 19		 je	 SHORT $L70118
  0004b	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??StampPMsg@CSegState@@UAGJPAU_DMUS_PMSG@@@Z@4QBDB
  00050	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BL@KLPIMHHM@?$CFs?3?5Invalid?5pointer?5pPMsg?6?$AA@
  00055	6a ff		 push	 -1
  00057	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0005c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005f	e8 00 00 00 00	 call	 _DebugBreak@0
$L70118:

; 1690 : #else
; 1691 :         if (!pPMsg)
; 1692 :         {
; 1693 :             return E_POINTER;
; 1694 :         }
; 1695 : #endif
; 1696 :     }
; 1697 : 	HRESULT hr = E_FAIL;

  00064	c7 45 fc 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H

; 1698 :     ENTER_CRITICAL_SECTION(&m_CriticalSection);

  0006b	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	83 c0 10	 add	 eax, 16			; 00000010H
  00071	50		 push	 eax
  00072	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 1699 : 	ENTER_API_CRITICAL_SECTION;
; 1700 : 
; 1701 :     if (m_pPerformance) 

  00078	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0007b	83 79 30 00	 cmp	 DWORD PTR [ecx+48], 0
  0007f	0f 84 77 02 00
	00		 je	 $L70123

; 1702 : 
; 1703 :     {
; 1704 :         // First, check if the segmentstate has its own graph.
; 1705 :         if (m_pGraph)

  00085	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00088	83 7a 3c 00	 cmp	 DWORD PTR [edx+60], 0
  0008c	0f 84 9a 00 00
	00		 je	 $L70124

; 1706 : 	    {
; 1707 :             // Could return DMUS_S_LAST_TOOL, indicating end of graph. 
; 1708 :             // If so, we'll treat that as a failure and drop on through to the next graph...
; 1709 : 		    if( S_OK == ( hr = m_pGraph->StampPMsg( pPMsg )))

  00092	8b 45 0c	 mov	 eax, DWORD PTR _pPMsg$[ebp]
  00095	50		 push	 eax
  00096	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00099	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  0009c	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0009f	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  000a2	8b 12		 mov	 edx, DWORD PTR [edx]
  000a4	51		 push	 ecx
  000a5	ff 52 0c	 call	 DWORD PTR [edx+12]
  000a8	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
  000ab	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000af	75 7b		 jne	 SHORT $L70124

; 1710 : 		    {
; 1711 : 			    if( pPMsg->pGraph != this ) // Make sure this is set to point to the segstate embedded graph so it will come here again.

  000b1	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  000b4	83 e8 04	 sub	 eax, 4
  000b7	85 c0		 test	 eax, eax
  000b9	74 08		 je	 SHORT $L70751
  000bb	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000be	89 4d e4	 mov	 DWORD PTR tv139[ebp], ecx
  000c1	eb 07		 jmp	 SHORT $L70752
$L70751:
  000c3	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR tv139[ebp], 0
$L70752:
  000ca	8b 55 0c	 mov	 edx, DWORD PTR _pPMsg$[ebp]
  000cd	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  000d0	3b 45 e4	 cmp	 eax, DWORD PTR tv139[ebp]
  000d3	74 57		 je	 SHORT $L70124

; 1712 : 			    {
; 1713 : 				    if( pPMsg->pGraph )

  000d5	8b 4d 0c	 mov	 ecx, DWORD PTR _pPMsg$[ebp]
  000d8	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  000dc	74 1c		 je	 SHORT $L70128

; 1714 : 				    {
; 1715 : 					    pPMsg->pGraph->Release();

  000de	8b 55 0c	 mov	 edx, DWORD PTR _pPMsg$[ebp]
  000e1	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  000e4	8b 4d 0c	 mov	 ecx, DWORD PTR _pPMsg$[ebp]
  000e7	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  000ea	8b 00		 mov	 eax, DWORD PTR [eax]
  000ec	52		 push	 edx
  000ed	ff 50 08	 call	 DWORD PTR [eax+8]

; 1716 : 					    pPMsg->pGraph = NULL;

  000f0	8b 4d 0c	 mov	 ecx, DWORD PTR _pPMsg$[ebp]
  000f3	c7 41 24 00 00
	00 00		 mov	 DWORD PTR [ecx+36], 0
$L70128:

; 1717 : 				    }
; 1718 : 				    pPMsg->pGraph = this;

  000fa	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  000fd	83 ea 04	 sub	 edx, 4
  00100	85 d2		 test	 edx, edx
  00102	74 08		 je	 SHORT $L70753
  00104	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00107	89 45 e0	 mov	 DWORD PTR tv156[ebp], eax
  0010a	eb 07		 jmp	 SHORT $L70754
$L70753:
  0010c	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR tv156[ebp], 0
$L70754:
  00113	8b 4d 0c	 mov	 ecx, DWORD PTR _pPMsg$[ebp]
  00116	8b 55 e0	 mov	 edx, DWORD PTR tv156[ebp]
  00119	89 51 24	 mov	 DWORD PTR [ecx+36], edx

; 1719 : 				    AddRef();

  0011c	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0011f	83 e8 04	 sub	 eax, 4
  00122	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00125	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  00128	50		 push	 eax
  00129	ff 52 04	 call	 DWORD PTR [edx+4]
$L70124:

; 1720 : 			    }
; 1721 : 		    }
; 1722 :         }
; 1723 :         // If done with the graph, send to the audio path, if it exists,
; 1724 :         // else the performance. Also, check for the special case of 
; 1725 :         // DMUS_PCHANNEL_BROADCAST_SEGMENT. If so, duplicate the pMsg
; 1726 :         // and send all the copies with the appropriate pchannel values.
; 1727 : 	    if( FAILED(hr) || (m_dwVersion && (hr == DMUS_S_LAST_TOOL)))

  0012c	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00130	7c 1d		 jl	 SHORT $L70135
  00132	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00135	83 b8 04 01 00
	00 00		 cmp	 DWORD PTR [eax+260], 0
  0013c	0f 84 b8 01 00
	00		 je	 $L70134
  00142	81 7d fc 11 12
	78 08		 cmp	 DWORD PTR _hr$[ebp], 142086673 ; 08781211H
  00149	0f 85 ab 01 00
	00		 jne	 $L70134
$L70135:

; 1728 :         {
; 1729 :             if (pPMsg->dwPChannel == DMUS_PCHANNEL_BROADCAST_SEGMENT)

  0014f	8b 4d 0c	 mov	 ecx, DWORD PTR _pPMsg$[ebp]
  00152	83 79 18 fd	 cmp	 DWORD PTR [ecx+24], -3	; fffffffdH
  00156	0f 85 59 01 00
	00		 jne	 $L70136

; 1730 :             {
; 1731 :                 CSegment *pSegment = m_pSegment;

  0015c	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0015f	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  00162	89 45 f8	 mov	 DWORD PTR _pSegment$70137[ebp], eax

; 1732 :                 ENTER_CRITICAL_SECTION(&pSegment->m_CriticalSection);

  00165	8b 4d f8	 mov	 ecx, DWORD PTR _pSegment$70137[ebp]
  00168	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0016b	51		 push	 ecx
  0016c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 1733 :                 DWORD dwIndex;
; 1734 :                 // Create new messages with new pchannels for all but one, which will
; 1735 :                 // be assigned to this message.
; 1736 :                 for (dwIndex = 1;dwIndex < pSegment->m_dwNumPChannels;dwIndex++)

  00172	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _dwIndex$70138[ebp], 1
  00179	eb 09		 jmp	 SHORT $L70139
$L70140:
  0017b	8b 55 f4	 mov	 edx, DWORD PTR _dwIndex$70138[ebp]
  0017e	83 c2 01	 add	 edx, 1
  00181	89 55 f4	 mov	 DWORD PTR _dwIndex$70138[ebp], edx
$L70139:
  00184	8b 45 f8	 mov	 eax, DWORD PTR _pSegment$70137[ebp]
  00187	8b 4d f4	 mov	 ecx, DWORD PTR _dwIndex$70138[ebp]
  0018a	3b 88 80 00 00
	00		 cmp	 ecx, DWORD PTR [eax+128]
  00190	0f 83 dd 00 00
	00		 jae	 $L70141

; 1737 :                 {
; 1738 :                     DWORD dwNewChannel = pSegment->m_paPChannels[dwIndex];

  00196	8b 55 f8	 mov	 edx, DWORD PTR _pSegment$70137[ebp]
  00199	8b 82 84 00 00
	00		 mov	 eax, DWORD PTR [edx+132]
  0019f	8b 4d f4	 mov	 ecx, DWORD PTR _dwIndex$70138[ebp]
  001a2	8b 14 88	 mov	 edx, DWORD PTR [eax+ecx*4]
  001a5	89 55 f0	 mov	 DWORD PTR _dwNewChannel$70142[ebp], edx

; 1739 :                     // Don't broadcast any broadcast messages!
; 1740 :                     // And, if this is a transpose on the drum channel, don't send it.
; 1741 :                     if ((dwNewChannel < DMUS_PCHANNEL_BROADCAST_GROUPS) &&
; 1742 :                         ((pPMsg->dwType != DMUS_PMSGT_TRANSPOSE) || ((dwNewChannel & 0xF) != 9)))

  001a8	83 7d f0 fc	 cmp	 DWORD PTR _dwNewChannel$70142[ebp], -4 ; fffffffcH
  001ac	0f 83 bc 00 00
	00		 jae	 $L70143
  001b2	8b 45 0c	 mov	 eax, DWORD PTR _pPMsg$[ebp]
  001b5	83 78 28 08	 cmp	 DWORD PTR [eax+40], 8
  001b9	75 0f		 jne	 SHORT $L70144
  001bb	8b 4d f0	 mov	 ecx, DWORD PTR _dwNewChannel$70142[ebp]
  001be	83 e1 0f	 and	 ecx, 15			; 0000000fH
  001c1	83 f9 09	 cmp	 ecx, 9
  001c4	0f 84 a4 00 00
	00		 je	 $L70143
$L70144:

; 1743 :                     {
; 1744 :                         DMUS_PMSG *pNewMsg;
; 1745 :                         if (SUCCEEDED(m_pPerformance->ClonePMsg(pPMsg,&pNewMsg)))

  001ca	8d 55 ec	 lea	 edx, DWORD PTR _pNewMsg$70145[ebp]
  001cd	52		 push	 edx
  001ce	8b 45 0c	 mov	 eax, DWORD PTR _pPMsg$[ebp]
  001d1	50		 push	 eax
  001d2	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  001d5	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  001d8	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  001db	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  001de	8b 12		 mov	 edx, DWORD PTR [edx]
  001e0	51		 push	 ecx
  001e1	ff 52 48	 call	 DWORD PTR [edx+72]
  001e4	85 c0		 test	 eax, eax
  001e6	0f 8c 82 00 00
	00		 jl	 $L70143

; 1746 :                         {
; 1747 :                             HRESULT hrTemp;
; 1748 :                             pNewMsg->dwPChannel = dwNewChannel;

  001ec	8b 45 ec	 mov	 eax, DWORD PTR _pNewMsg$70145[ebp]
  001ef	8b 4d f0	 mov	 ecx, DWORD PTR _dwNewChannel$70142[ebp]
  001f2	89 48 18	 mov	 DWORD PTR [eax+24], ecx

; 1749 :                             if (m_pAudioPath)

  001f5	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  001f8	83 7a 38 00	 cmp	 DWORD PTR [edx+56], 0
  001fc	74 1f		 je	 SHORT $L70149

; 1750 :                             {
; 1751 :                                 hrTemp = m_pAudioPath->StampPMsg(pNewMsg);

  001fe	8b 45 ec	 mov	 eax, DWORD PTR _pNewMsg$70145[ebp]
  00201	50		 push	 eax
  00202	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00205	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  00208	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0020b	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  0020e	83 c1 04	 add	 ecx, 4
  00211	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00214	51		 push	 ecx
  00215	ff 52 0c	 call	 DWORD PTR [edx+12]
  00218	89 45 e8	 mov	 DWORD PTR _hrTemp$70148[ebp], eax

; 1752 :                             }
; 1753 :                             else

  0021b	eb 1d		 jmp	 SHORT $L70150
$L70149:

; 1754 :                             {
; 1755 :                                 hrTemp = m_pPerformance->StampPMsg(pNewMsg);

  0021d	8b 45 ec	 mov	 eax, DWORD PTR _pNewMsg$70145[ebp]
  00220	50		 push	 eax
  00221	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00224	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  00227	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0022a	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  0022d	83 c1 08	 add	 ecx, 8
  00230	8b 52 08	 mov	 edx, DWORD PTR [edx+8]
  00233	51		 push	 ecx
  00234	ff 52 0c	 call	 DWORD PTR [edx+12]
  00237	89 45 e8	 mov	 DWORD PTR _hrTemp$70148[ebp], eax
$L70150:

; 1756 :                             }
; 1757 :                             if (SUCCEEDED(hrTemp))

  0023a	83 7d e8 00	 cmp	 DWORD PTR _hrTemp$70148[ebp], 0
  0023e	7c 18		 jl	 SHORT $L70152

; 1758 :                             {
; 1759 :                                 m_pPerformance->SendPMsg(pNewMsg);

  00240	8b 45 ec	 mov	 eax, DWORD PTR _pNewMsg$70145[ebp]
  00243	50		 push	 eax
  00244	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00247	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  0024a	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0024d	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00250	8b 12		 mov	 edx, DWORD PTR [edx]
  00252	51		 push	 ecx
  00253	ff 52 10	 call	 DWORD PTR [edx+16]

; 1760 :                             }
; 1761 :                             else

  00256	eb 16		 jmp	 SHORT $L70143
$L70152:

; 1762 :                             {
; 1763 :                                 m_pPerformance->FreePMsg(pNewMsg);

  00258	8b 45 ec	 mov	 eax, DWORD PTR _pNewMsg$70145[ebp]
  0025b	50		 push	 eax
  0025c	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0025f	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  00262	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00265	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00268	8b 12		 mov	 edx, DWORD PTR [edx]
  0026a	51		 push	 ecx
  0026b	ff 52 28	 call	 DWORD PTR [edx+40]
$L70143:

; 1764 :                             }
; 1765 :                         }
; 1766 :                     }
; 1767 :                 }

  0026e	e9 08 ff ff ff	 jmp	 $L70140
$L70141:

; 1768 :                 // Now, set the pchannel for this one. First check that there are any
; 1769 :                 // pchannels. If none, mark the PMsg to be deleted by the SendPMsg routine.
; 1770 :                 // Also, mark it this way if the PMsg is a broadcast PMsg.
; 1771 :                 pPMsg->dwPChannel = DMUS_PCHANNEL_KILL_ME;

  00273	8b 45 0c	 mov	 eax, DWORD PTR _pPMsg$[ebp]
  00276	c7 40 18 f0 ff
	ff ff		 mov	 DWORD PTR [eax+24], -16	; fffffff0H

; 1772 :                 if (pSegment->m_dwNumPChannels)

  0027d	8b 4d f8	 mov	 ecx, DWORD PTR _pSegment$70137[ebp]
  00280	83 b9 80 00 00
	00 00		 cmp	 DWORD PTR [ecx+128], 0
  00287	74 1f		 je	 SHORT $L70154

; 1773 :                 {
; 1774 :                     if (pSegment->m_paPChannels[0] < DMUS_PCHANNEL_BROADCAST_GROUPS)

  00289	8b 55 f8	 mov	 edx, DWORD PTR _pSegment$70137[ebp]
  0028c	8b 82 84 00 00
	00		 mov	 eax, DWORD PTR [edx+132]
  00292	83 38 fc	 cmp	 DWORD PTR [eax], -4	; fffffffcH
  00295	73 11		 jae	 SHORT $L70154

; 1775 :                     {
; 1776 :                         pPMsg->dwPChannel = pSegment->m_paPChannels[0];

  00297	8b 4d f8	 mov	 ecx, DWORD PTR _pSegment$70137[ebp]
  0029a	8b 91 84 00 00
	00		 mov	 edx, DWORD PTR [ecx+132]
  002a0	8b 45 0c	 mov	 eax, DWORD PTR _pPMsg$[ebp]
  002a3	8b 0a		 mov	 ecx, DWORD PTR [edx]
  002a5	89 48 18	 mov	 DWORD PTR [eax+24], ecx
$L70154:

; 1777 :                     }
; 1778 :                 }
; 1779 :                 LEAVE_CRITICAL_SECTION(&pSegment->m_CriticalSection);

  002a8	8b 55 f8	 mov	 edx, DWORD PTR _pSegment$70137[ebp]
  002ab	83 c2 1c	 add	 edx, 28			; 0000001cH
  002ae	52		 push	 edx
  002af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4
$L70136:

; 1780 :             }
; 1781 :             if (m_pAudioPath)

  002b5	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  002b8	83 78 38 00	 cmp	 DWORD PTR [eax+56], 0
  002bc	74 1f		 je	 SHORT $L70156

; 1782 :             {
; 1783 :                 hr = m_pAudioPath->StampPMsg(pPMsg);

  002be	8b 4d 0c	 mov	 ecx, DWORD PTR _pPMsg$[ebp]
  002c1	51		 push	 ecx
  002c2	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  002c5	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  002c8	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  002cb	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  002ce	83 c2 04	 add	 edx, 4
  002d1	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  002d4	52		 push	 edx
  002d5	ff 50 0c	 call	 DWORD PTR [eax+12]
  002d8	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 1784 :             }
; 1785 :             else

  002db	eb 1d		 jmp	 SHORT $L70134
$L70156:

; 1786 :             {
; 1787 :                 hr = m_pPerformance->StampPMsg(pPMsg);

  002dd	8b 4d 0c	 mov	 ecx, DWORD PTR _pPMsg$[ebp]
  002e0	51		 push	 ecx
  002e1	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  002e4	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  002e7	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  002ea	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  002ed	83 c2 08	 add	 edx, 8
  002f0	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  002f3	52		 push	 edx
  002f4	ff 50 0c	 call	 DWORD PTR [eax+12]
  002f7	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
$L70134:

; 1788 :             }
; 1789 :         }
; 1790 : 
; 1791 :     }
; 1792 :     else

  002fa	eb 16		 jmp	 SHORT $L70158
$L70123:

; 1793 :     {
; 1794 :         hr = DMUS_E_NOT_INIT;

  002fc	c7 45 fc 62 11
	78 88		 mov	 DWORD PTR _hr$[ebp], -2005397150 ; 88781162H

; 1795 :         Trace(1,"Error: Segmentstate::StampPMsg failed because the segmentstate is not properly initialized.\n");

  00303	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0FN@BKJJAELJ@Error?3?5Segmentstate?3?3StampPMsg?5f@
  00308	6a 01		 push	 1
  0030a	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  0030f	83 c4 08	 add	 esp, 8
$L70158:

; 1796 :     }
; 1797 :     LEAVE_CRITICAL_SECTION(&m_CriticalSection);

  00312	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00315	83 c1 10	 add	 ecx, 16			; 00000010H
  00318	51		 push	 ecx
  00319	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 1798 : 	LEAVE_API_CRITICAL_SECTION;
; 1799 : 	return hr;

  0031f	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]

; 1800 : }

  00322	8b e5		 mov	 esp, ebp
  00324	5d		 pop	 ebp
  00325	c2 08 00	 ret	 8
?StampPMsg@CSegState@@UAGJPAU_DMUS_PMSG@@@Z ENDP	; CSegState::StampPMsg
_TEXT	ENDS
PUBLIC	??_C@_0BO@EMDDDLDF@?$CFs?3?5Invalid?5pointer?5ppObject?6?$AA@ ; `string'
PUBLIC	??_C@_0DP@IFALCKJM@Error?3?5Unable?5to?5access?5audiopat@ ; `string'
EXTRN	??0CGraph@@QAE@XZ:NEAR				; CGraph::CGraph
EXTRN	?GetObjectInPath@CGraph@@QAEJKABU_GUID@@K0PAPAX@Z:NEAR ; CGraph::GetObjectInPath
EXTRN	?GetGraphInternal@CPerformance@@QAEJPAPAUIDirectMusicGraph@@@Z:NEAR ; CPerformance::GetGraphInternal
;	COMDAT ?__szValidateInterfaceName@?1??GetObjectInPath@CSegState@@UAGJKKKABU_GUID@@K0PAPAX@Z@4QBDB
CONST	SEGMENT
?__szValidateInterfaceName@?1??GetObjectInPath@CSegState@@UAGJKKKABU_GUID@@K0PAPAX@Z@4QBDB DB 'I'
	DB	'DirectMusicSegmentState::GetObjectInPath', 00H ; `CSegState::GetObjectInPath'::`2'::__szValidateInterfaceName
CONST	ENDS
;	COMDAT ??_C@_0BO@EMDDDLDF@?$CFs?3?5Invalid?5pointer?5ppObject?6?$AA@
CONST	SEGMENT
??_C@_0BO@EMDDDLDF@?$CFs?3?5Invalid?5pointer?5ppObject?6?$AA@ DB '%s: Inv'
	DB	'alid pointer ppObject', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@IFALCKJM@Error?3?5Unable?5to?5access?5audiopat@
CONST	SEGMENT
??_C@_0DP@IFALCKJM@Error?3?5Unable?5to?5access?5audiopat@ DB 'Error: Unab'
	DB	'le to access audiopath components of segmentstate.', 0aH, 00H ; `string'
; Function compile flags: /Odt
CONST	ENDS
;	COMDAT ?GetObjectInPath@CSegState@@UAGJKKKABU_GUID@@K0PAPAX@Z
_TEXT	SEGMENT
tv173 = -40
tv152 = -36
tv76 = -32
$T70761 = -28
$T70758 = -24
_pCGraph$70228 = -20
_pGraph$70225 = -16
_pGraph$70220 = -12
_pCTrack$70198 = -8
_hr$ = -4
_this$ = 8
_dwPChannel$ = 12
_dwStage$ = 16
_dwBuffer$ = 20
_guidObject$ = 24
_dwIndex$ = 28
_iidInterface$ = 32
_ppObject$ = 36
?GetObjectInPath@CSegState@@UAGJKKKABU_GUID@@K0PAPAX@Z PROC NEAR ; CSegState::GetObjectInPath, COMDAT

; 1805 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H

; 1806 : 	V_INAME(IDirectMusicSegmentState::GetObjectInPath);
; 1807 : 	V_PTRPTR_WRITE(ppObject);

  00006	6a 04		 push	 4
  00008	8b 45 24	 mov	 eax, DWORD PTR _ppObject$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 _IsBadWritePtr@8
  00011	85 c0		 test	 eax, eax
  00013	74 19		 je	 SHORT $L70177
  00015	68 00 00 00 00	 push	 OFFSET FLAT:?__szValidateInterfaceName@?1??GetObjectInPath@CSegState@@UAGJKKKABU_GUID@@K0PAPAX@Z@4QBDB
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@EMDDDLDF@?$CFs?3?5Invalid?5pointer?5ppObject?6?$AA@
  0001f	6a ff		 push	 -1
  00021	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH
  00029	e8 00 00 00 00	 call	 _DebugBreak@0
$L70177:

; 1808 :     *ppObject = NULL;

  0002e	8b 4d 24	 mov	 ecx, DWORD PTR _ppObject$[ebp]
  00031	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 1809 :     if (dwBuffer && ((dwStage < DMUS_PATH_BUFFER) || (dwStage >= DMUS_PATH_PRIMARY_BUFFER)))

  00037	83 7d 14 00	 cmp	 DWORD PTR _dwBuffer$[ebp], 0
  0003b	74 1c		 je	 SHORT $L70179
  0003d	81 7d 10 00 60
	00 00		 cmp	 DWORD PTR _dwStage$[ebp], 24576 ; 00006000H
  00044	72 09		 jb	 SHORT $L70180
  00046	81 7d 10 00 80
	00 00		 cmp	 DWORD PTR _dwStage$[ebp], 32768 ; 00008000H
  0004d	72 0a		 jb	 SHORT $L70179
$L70180:

; 1810 :     {
; 1811 :         return DMUS_E_NOT_FOUND;

  0004f	b8 61 11 78 88	 mov	 eax, -2005397151	; 88781161H
  00054	e9 2a 03 00 00	 jmp	 $L70173
$L70179:

; 1812 :     }
; 1813 :     HRESULT hr = DMUS_E_NOT_FOUND;

  00059	c7 45 fc 61 11
	78 88		 mov	 DWORD PTR _hr$[ebp], -2005397151 ; 88781161H

; 1814 :     ENTER_CRITICAL_SECTION(&m_CriticalSection);

  00060	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00063	83 c2 14	 add	 edx, 20			; 00000014H
  00066	52		 push	 edx
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlEnterCriticalSection@4

; 1815 :     ENTER_API_CRITICAL_SECTION;
; 1816 :     switch (dwStage)
; 1817 :     {

  0006d	8b 45 10	 mov	 eax, DWORD PTR _dwStage$[ebp]
  00070	89 45 e0	 mov	 DWORD PTR tv76[ebp], eax
  00073	81 7d e0 00 13
	00 00		 cmp	 DWORD PTR tv76[ebp], 4864 ; 00001300H
  0007a	77 31		 ja	 SHORT $L70764
  0007c	81 7d e0 00 13
	00 00		 cmp	 DWORD PTR tv76[ebp], 4864 ; 00001300H
  00083	0f 84 4c 01 00
	00		 je	 $L70209
  00089	81 7d e0 00 10
	00 00		 cmp	 DWORD PTR tv76[ebp], 4096 ; 00001000H
  00090	74 47		 je	 SHORT $L70194
  00092	81 7d e0 00 11
	00 00		 cmp	 DWORD PTR tv76[ebp], 4352 ; 00001100H
  00099	74 74		 je	 SHORT $L70196
  0009b	81 7d e0 00 12
	00 00		 cmp	 DWORD PTR tv76[ebp], 4608 ; 00001200H
  000a2	0f 84 b2 00 00
	00		 je	 $L70201
  000a8	e9 7b 02 00 00	 jmp	 $L70230
$L70764:
  000ad	81 7d e0 00 30
	00 00		 cmp	 DWORD PTR tv76[ebp], 12288 ; 00003000H
  000b4	0f 84 90 01 00
	00		 je	 $L70216
  000ba	81 7d e0 00 32
	00 00		 cmp	 DWORD PTR tv76[ebp], 12800 ; 00003200H
  000c1	0f 84 b9 01 00
	00		 je	 $L70218
  000c7	81 7d e0 00 33
	00 00		 cmp	 DWORD PTR tv76[ebp], 13056 ; 00003300H
  000ce	0f 84 00 02 00
	00		 je	 $L70223
  000d4	e9 4f 02 00 00	 jmp	 $L70230
$L70194:

; 1818 :     case DMUS_PATH_SEGMENT:
; 1819 :         if (m_pSegment && (dwIndex == 0) && (dwPChannel == 0))

  000d9	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000dc	83 79 38 00	 cmp	 DWORD PTR [ecx+56], 0
  000e0	74 28		 je	 SHORT $L70195
  000e2	83 7d 1c 00	 cmp	 DWORD PTR _dwIndex$[ebp], 0
  000e6	75 22		 jne	 SHORT $L70195
  000e8	83 7d 0c 00	 cmp	 DWORD PTR _dwPChannel$[ebp], 0
  000ec	75 1c		 jne	 SHORT $L70195

; 1820 :         {
; 1821 :             hr = m_pSegment->QueryInterface(iidInterface,ppObject);

  000ee	8b 55 24	 mov	 edx, DWORD PTR _ppObject$[ebp]
  000f1	52		 push	 edx
  000f2	8b 45 20	 mov	 eax, DWORD PTR _iidInterface$[ebp]
  000f5	50		 push	 eax
  000f6	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000f9	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  000fc	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  000ff	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00102	8b 12		 mov	 edx, DWORD PTR [edx]
  00104	51		 push	 ecx
  00105	ff 12		 call	 DWORD PTR [edx]
  00107	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
$L70195:

; 1822 :         }
; 1823 :         break;

  0010a	e9 64 02 00 00	 jmp	 $L70191
$L70196:

; 1824 :     case DMUS_PATH_SEGMENT_TRACK:
; 1825 :         if (dwPChannel == 0)

  0010f	83 7d 0c 00	 cmp	 DWORD PTR _dwPChannel$[ebp], 0
  00113	75 40		 jne	 SHORT $L70197

; 1826 :         {
; 1827 :             CTrack * pCTrack = GetTrack(guidObject,-1,dwIndex);

  00115	8b 45 1c	 mov	 eax, DWORD PTR _dwIndex$[ebp]
  00118	50		 push	 eax
  00119	6a ff		 push	 -1
  0011b	8b 4d 18	 mov	 ecx, DWORD PTR _guidObject$[ebp]
  0011e	51		 push	 ecx
  0011f	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00122	e8 00 00 00 00	 call	 ?GetTrack@CSegState@@AAEPAVCTrack@@ABU_GUID@@KK@Z ; CSegState::GetTrack
  00127	89 45 f8	 mov	 DWORD PTR _pCTrack$70198[ebp], eax

; 1828 : 	        if (pCTrack)

  0012a	83 7d f8 00	 cmp	 DWORD PTR _pCTrack$70198[ebp], 0
  0012e	74 25		 je	 SHORT $L70197

; 1829 :             {
; 1830 :                 if (pCTrack->m_pTrack)

  00130	8b 55 f8	 mov	 edx, DWORD PTR _pCTrack$70198[ebp]
  00133	83 7a 14 00	 cmp	 DWORD PTR [edx+20], 0
  00137	74 1c		 je	 SHORT $L70197

; 1831 :                 {
; 1832 :                     hr = pCTrack->m_pTrack->QueryInterface(iidInterface,ppObject);

  00139	8b 45 24	 mov	 eax, DWORD PTR _ppObject$[ebp]
  0013c	50		 push	 eax
  0013d	8b 4d 20	 mov	 ecx, DWORD PTR _iidInterface$[ebp]
  00140	51		 push	 ecx
  00141	8b 55 f8	 mov	 edx, DWORD PTR _pCTrack$70198[ebp]
  00144	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00147	8b 4d f8	 mov	 ecx, DWORD PTR _pCTrack$70198[ebp]
  0014a	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0014d	8b 00		 mov	 eax, DWORD PTR [eax]
  0014f	52		 push	 edx
  00150	ff 10		 call	 DWORD PTR [eax]
  00152	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
$L70197:

; 1833 :                 }
; 1834 :             }
; 1835 :         }
; 1836 :         break;

  00155	e9 19 02 00 00	 jmp	 $L70191
$L70201:

; 1837 :     case DMUS_PATH_SEGMENT_GRAPH:
; 1838 :         if ((dwIndex == 0) && (dwPChannel == 0))

  0015a	83 7d 1c 00	 cmp	 DWORD PTR _dwIndex$[ebp], 0
  0015e	75 70		 jne	 SHORT $L70202
  00160	83 7d 0c 00	 cmp	 DWORD PTR _dwPChannel$[ebp], 0
  00164	75 6a		 jne	 SHORT $L70202

; 1839 :         {
; 1840 :             if (!m_pGraph)

  00166	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00169	83 79 40 00	 cmp	 DWORD PTR [ecx+64], 0
  0016d	75 33		 jne	 SHORT $L70203

; 1841 :             {
; 1842 :                 m_pGraph = new CGraph;

  0016f	68 70 03 00 00	 push	 880			; 00000370H
  00174	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00179	83 c4 04	 add	 esp, 4
  0017c	89 45 e8	 mov	 DWORD PTR $T70758[ebp], eax
  0017f	83 7d e8 00	 cmp	 DWORD PTR $T70758[ebp], 0
  00183	74 0d		 je	 SHORT $L70759
  00185	8b 4d e8	 mov	 ecx, DWORD PTR $T70758[ebp]
  00188	e8 00 00 00 00	 call	 ??0CGraph@@QAE@XZ	; CGraph::CGraph
  0018d	89 45 dc	 mov	 DWORD PTR tv152[ebp], eax
  00190	eb 07		 jmp	 SHORT $L70760
$L70759:
  00192	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR tv152[ebp], 0
$L70760:
  00199	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0019c	8b 45 dc	 mov	 eax, DWORD PTR tv152[ebp]
  0019f	89 42 40	 mov	 DWORD PTR [edx+64], eax
$L70203:

; 1843 :             }
; 1844 :             if (m_pGraph)

  001a2	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  001a5	83 79 40 00	 cmp	 DWORD PTR [ecx+64], 0
  001a9	74 1e		 je	 SHORT $L70206

; 1845 :             {
; 1846 :                 hr = m_pGraph->QueryInterface(iidInterface,ppObject);

  001ab	8b 55 24	 mov	 edx, DWORD PTR _ppObject$[ebp]
  001ae	52		 push	 edx
  001af	8b 45 20	 mov	 eax, DWORD PTR _iidInterface$[ebp]
  001b2	50		 push	 eax
  001b3	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  001b6	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  001b9	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  001bc	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  001bf	8b 12		 mov	 edx, DWORD PTR [edx]
  001c1	51		 push	 ecx
  001c2	ff 12		 call	 DWORD PTR [edx]
  001c4	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 1847 :             }
; 1848 :             else

  001c7	eb 07		 jmp	 SHORT $L70202
$L70206:

; 1849 :             {
; 1850 :                 hr = E_OUTOFMEMORY;

  001c9	c7 45 fc 0e 00
	07 80		 mov	 DWORD PTR _hr$[ebp], -2147024882 ; 8007000eH
$L70202:

; 1851 :             }
; 1852 :         }
; 1853 :         break;

  001d0	e9 9e 01 00 00	 jmp	 $L70191
$L70209:

; 1854 :     case DMUS_PATH_SEGMENT_TOOL:
; 1855 :         if (!m_pGraph)

  001d5	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  001d8	83 78 40 00	 cmp	 DWORD PTR [eax+64], 0
  001dc	75 33		 jne	 SHORT $L70210

; 1856 :         {
; 1857 :             m_pGraph = new CGraph;

  001de	68 70 03 00 00	 push	 880			; 00000370H
  001e3	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  001e8	83 c4 04	 add	 esp, 4
  001eb	89 45 e4	 mov	 DWORD PTR $T70761[ebp], eax
  001ee	83 7d e4 00	 cmp	 DWORD PTR $T70761[ebp], 0
  001f2	74 0d		 je	 SHORT $L70762
  001f4	8b 4d e4	 mov	 ecx, DWORD PTR $T70761[ebp]
  001f7	e8 00 00 00 00	 call	 ??0CGraph@@QAE@XZ	; CGraph::CGraph
  001fc	89 45 d8	 mov	 DWORD PTR tv173[ebp], eax
  001ff	eb 07		 jmp	 SHORT $L70763
$L70762:
  00201	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR tv173[ebp], 0
$L70763:
  00208	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0020b	8b 55 d8	 mov	 edx, DWORD PTR tv173[ebp]
  0020e	89 51 40	 mov	 DWORD PTR [ecx+64], edx
$L70210:

; 1858 :         }
; 1859 :         if (m_pGraph)

  00211	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00214	83 78 40 00	 cmp	 DWORD PTR [eax+64], 0
  00218	74 24		 je	 SHORT $L70213

; 1860 :         {
; 1861 :             hr = m_pGraph->GetObjectInPath(dwPChannel,guidObject,dwIndex,iidInterface,ppObject);

  0021a	8b 4d 24	 mov	 ecx, DWORD PTR _ppObject$[ebp]
  0021d	51		 push	 ecx
  0021e	8b 55 20	 mov	 edx, DWORD PTR _iidInterface$[ebp]
  00221	52		 push	 edx
  00222	8b 45 1c	 mov	 eax, DWORD PTR _dwIndex$[ebp]
  00225	50		 push	 eax
  00226	8b 4d 18	 mov	 ecx, DWORD PTR _guidObject$[ebp]
  00229	51		 push	 ecx
  0022a	8b 55 0c	 mov	 edx, DWORD PTR _dwPChannel$[ebp]
  0022d	52		 push	 edx
  0022e	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00231	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  00234	e8 00 00 00 00	 call	 ?GetObjectInPath@CGraph@@QAEJKABU_GUID@@K0PAPAX@Z ; CGraph::GetObjectInPath
  00239	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 1862 :         }
; 1863 :         else

  0023c	eb 07		 jmp	 SHORT $L70214
$L70213:

; 1864 :         {
; 1865 :             hr = E_OUTOFMEMORY;

  0023e	c7 45 fc 0e 00
	07 80		 mov	 DWORD PTR _hr$[ebp], -2147024882 ; 8007000eH
$L70214:

; 1866 :         }
; 1867 :         break;

  00245	e9 29 01 00 00	 jmp	 $L70191
$L70216:

; 1868 :     case DMUS_PATH_PERFORMANCE:
; 1869 :         if (m_pPerformance && (dwIndex == 0) && (dwPChannel == 0))

  0024a	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0024d	83 79 34 00	 cmp	 DWORD PTR [ecx+52], 0
  00251	74 28		 je	 SHORT $L70217
  00253	83 7d 1c 00	 cmp	 DWORD PTR _dwIndex$[ebp], 0
  00257	75 22		 jne	 SHORT $L70217
  00259	83 7d 0c 00	 cmp	 DWORD PTR _dwPChannel$[ebp], 0
  0025d	75 1c		 jne	 SHORT $L70217

; 1870 :         {
; 1871 :             hr = m_pPerformance->QueryInterface(iidInterface,ppObject);

  0025f	8b 55 24	 mov	 edx, DWORD PTR _ppObject$[ebp]
  00262	52		 push	 edx
  00263	8b 45 20	 mov	 eax, DWORD PTR _iidInterface$[ebp]
  00266	50		 push	 eax
  00267	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0026a	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  0026d	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00270	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00273	8b 12		 mov	 edx, DWORD PTR [edx]
  00275	51		 push	 ecx
  00276	ff 12		 call	 DWORD PTR [edx]
  00278	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
$L70217:

; 1872 :         }
; 1873 :         break;

  0027b	e9 f3 00 00 00	 jmp	 $L70191
$L70218:

; 1874 :     case DMUS_PATH_PERFORMANCE_GRAPH:
; 1875 :         if (m_pPerformance && (dwIndex == 0) && (dwPChannel == 0))

  00280	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00283	83 78 34 00	 cmp	 DWORD PTR [eax+52], 0
  00287	74 46		 je	 SHORT $L70219
  00289	83 7d 1c 00	 cmp	 DWORD PTR _dwIndex$[ebp], 0
  0028d	75 40		 jne	 SHORT $L70219
  0028f	83 7d 0c 00	 cmp	 DWORD PTR _dwPChannel$[ebp], 0
  00293	75 3a		 jne	 SHORT $L70219

; 1876 :         {
; 1877 :             IDirectMusicGraph *pGraph;
; 1878 :             if (SUCCEEDED(hr = m_pPerformance->GetGraphInternal(&pGraph)))

  00295	8d 4d f4	 lea	 ecx, DWORD PTR _pGraph$70220[ebp]
  00298	51		 push	 ecx
  00299	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0029c	8b 4a 34	 mov	 ecx, DWORD PTR [edx+52]
  0029f	e8 00 00 00 00	 call	 ?GetGraphInternal@CPerformance@@QAEJPAPAUIDirectMusicGraph@@@Z ; CPerformance::GetGraphInternal
  002a4	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
  002a7	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  002ab	7c 22		 jl	 SHORT $L70219

; 1879 :             {
; 1880 :                 hr = pGraph->QueryInterface(iidInterface,ppObject);

  002ad	8b 45 24	 mov	 eax, DWORD PTR _ppObject$[ebp]
  002b0	50		 push	 eax
  002b1	8b 4d 20	 mov	 ecx, DWORD PTR _iidInterface$[ebp]
  002b4	51		 push	 ecx
  002b5	8b 55 f4	 mov	 edx, DWORD PTR _pGraph$70220[ebp]
  002b8	8b 02		 mov	 eax, DWORD PTR [edx]
  002ba	8b 4d f4	 mov	 ecx, DWORD PTR _pGraph$70220[ebp]
  002bd	51		 push	 ecx
  002be	ff 10		 call	 DWORD PTR [eax]
  002c0	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 1881 :                 pGraph->Release();

  002c3	8b 55 f4	 mov	 edx, DWORD PTR _pGraph$70220[ebp]
  002c6	8b 02		 mov	 eax, DWORD PTR [edx]
  002c8	8b 4d f4	 mov	 ecx, DWORD PTR _pGraph$70220[ebp]
  002cb	51		 push	 ecx
  002cc	ff 50 08	 call	 DWORD PTR [eax+8]
$L70219:

; 1882 :             }
; 1883 :         }
; 1884 :         break;

  002cf	e9 9f 00 00 00	 jmp	 $L70191
$L70223:

; 1885 :     case DMUS_PATH_PERFORMANCE_TOOL:
; 1886 :         if (m_pPerformance)

  002d4	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  002d7	83 7a 34 00	 cmp	 DWORD PTR [edx+52], 0
  002db	74 49		 je	 SHORT $L70224

; 1887 :         {
; 1888 :             IDirectMusicGraph *pGraph;
; 1889 :             if (SUCCEEDED(hr = m_pPerformance->GetGraphInternal(&pGraph)))

  002dd	8d 45 f0	 lea	 eax, DWORD PTR _pGraph$70225[ebp]
  002e0	50		 push	 eax
  002e1	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  002e4	8b 49 34	 mov	 ecx, DWORD PTR [ecx+52]
  002e7	e8 00 00 00 00	 call	 ?GetGraphInternal@CPerformance@@QAEJPAPAUIDirectMusicGraph@@@Z ; CPerformance::GetGraphInternal
  002ec	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
  002ef	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  002f3	7c 31		 jl	 SHORT $L70224

; 1890 :             {
; 1891 :                 CGraph *pCGraph = (CGraph *) pGraph;

  002f5	8b 55 f0	 mov	 edx, DWORD PTR _pGraph$70225[ebp]
  002f8	89 55 ec	 mov	 DWORD PTR _pCGraph$70228[ebp], edx

; 1892 :                 hr = pCGraph->GetObjectInPath(dwPChannel,guidObject,dwIndex,iidInterface,ppObject);

  002fb	8b 45 24	 mov	 eax, DWORD PTR _ppObject$[ebp]
  002fe	50		 push	 eax
  002ff	8b 4d 20	 mov	 ecx, DWORD PTR _iidInterface$[ebp]
  00302	51		 push	 ecx
  00303	8b 55 1c	 mov	 edx, DWORD PTR _dwIndex$[ebp]
  00306	52		 push	 edx
  00307	8b 45 18	 mov	 eax, DWORD PTR _guidObject$[ebp]
  0030a	50		 push	 eax
  0030b	8b 4d 0c	 mov	 ecx, DWORD PTR _dwPChannel$[ebp]
  0030e	51		 push	 ecx
  0030f	8b 4d ec	 mov	 ecx, DWORD PTR _pCGraph$70228[ebp]
  00312	e8 00 00 00 00	 call	 ?GetObjectInPath@CGraph@@QAEJKABU_GUID@@K0PAPAX@Z ; CGraph::GetObjectInPath
  00317	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 1893 :                 pGraph->Release();

  0031a	8b 55 f0	 mov	 edx, DWORD PTR _pGraph$70225[ebp]
  0031d	8b 02		 mov	 eax, DWORD PTR [edx]
  0031f	8b 4d f0	 mov	 ecx, DWORD PTR _pGraph$70225[ebp]
  00322	51		 push	 ecx
  00323	ff 50 08	 call	 DWORD PTR [eax+8]
$L70224:

; 1894 :             }
; 1895 :         }
; 1896 :         break;

  00326	eb 4b		 jmp	 SHORT $L70191
$L70230:

; 1897 :     default:
; 1898 :         if (m_pAudioPath)

  00328	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0032b	83 7a 3c 00	 cmp	 DWORD PTR [edx+60], 0
  0032f	74 33		 je	 SHORT $L70231

; 1899 :         {
; 1900 :             hr = m_pAudioPath->GetObjectInPath(dwPChannel,dwStage,dwBuffer,guidObject,dwIndex,iidInterface,ppObject);

  00331	8b 45 24	 mov	 eax, DWORD PTR _ppObject$[ebp]
  00334	50		 push	 eax
  00335	8b 4d 20	 mov	 ecx, DWORD PTR _iidInterface$[ebp]
  00338	51		 push	 ecx
  00339	8b 55 1c	 mov	 edx, DWORD PTR _dwIndex$[ebp]
  0033c	52		 push	 edx
  0033d	8b 45 18	 mov	 eax, DWORD PTR _guidObject$[ebp]
  00340	50		 push	 eax
  00341	8b 4d 14	 mov	 ecx, DWORD PTR _dwBuffer$[ebp]
  00344	51		 push	 ecx
  00345	8b 55 10	 mov	 edx, DWORD PTR _dwStage$[ebp]
  00348	52		 push	 edx
  00349	8b 45 0c	 mov	 eax, DWORD PTR _dwPChannel$[ebp]
  0034c	50		 push	 eax
  0034d	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00350	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  00353	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00356	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  00359	8b 12		 mov	 edx, DWORD PTR [edx]
  0035b	51		 push	 ecx
  0035c	ff 52 0c	 call	 DWORD PTR [edx+12]
  0035f	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 1901 :         }
; 1902 :         else

  00362	eb 0f		 jmp	 SHORT $L70191
$L70231:

; 1903 :         {
; 1904 :             Trace(1,"Error: Unable to access audiopath components of segmentstate.\n");

  00364	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DP@IFALCKJM@Error?3?5Unable?5to?5access?5audiopat@
  00369	6a 01		 push	 1
  0036b	e8 00 00 00 00	 call	 ?DebugTrace@@YAXHPADZZ	; DebugTrace
  00370	83 c4 08	 add	 esp, 8
$L70191:

; 1905 :         }
; 1906 :     }
; 1907 :     LEAVE_CRITICAL_SECTION(&m_CriticalSection);

  00373	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00376	83 c0 14	 add	 eax, 20			; 00000014H
  00379	50		 push	 eax
  0037a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlLeaveCriticalSection@4

; 1908 :     LEAVE_API_CRITICAL_SECTION;
; 1909 :     return hr;

  00380	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]
$L70173:

; 1910 : }

  00383	8b e5		 mov	 esp, ebp
  00385	5d		 pop	 ebp
  00386	c2 20 00	 ret	 32			; 00000020H
?GetObjectInPath@CSegState@@UAGJKKKABU_GUID@@K0PAPAX@Z ENDP ; CSegState::GetObjectInPath
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?QueryInterface@CSegState@@W3AGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
?QueryInterface@CSegState@@W3AGJABU_GUID@@PAPAX@Z PROC NEAR ; CSegState::QueryInterface, COMDAT
  00000	83 6c 24 04 04	 sub	 DWORD PTR [esp+4], 4
  00005	e9 00 00 00 00	 jmp	 ?QueryInterface@CSegState@@UAGJABU_GUID@@PAPAX@Z ; CSegState::QueryInterface
?QueryInterface@CSegState@@W3AGJABU_GUID@@PAPAX@Z ENDP	; CSegState::QueryInterface
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?AddRef@CSegState@@W3AGKXZ
_TEXT	SEGMENT
?AddRef@CSegState@@W3AGKXZ PROC NEAR			; CSegState::AddRef, COMDAT
  00000	83 6c 24 04 04	 sub	 DWORD PTR [esp+4], 4
  00005	e9 00 00 00 00	 jmp	 ?AddRef@CSegState@@UAGKXZ ; CSegState::AddRef
?AddRef@CSegState@@W3AGKXZ ENDP				; CSegState::AddRef
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?Release@CSegState@@W3AGKXZ
_TEXT	SEGMENT
?Release@CSegState@@W3AGKXZ PROC NEAR			; CSegState::Release, COMDAT
  00000	83 6c 24 04 04	 sub	 DWORD PTR [esp+4], 4
  00005	e9 00 00 00 00	 jmp	 ?Release@CSegState@@UAGKXZ ; CSegState::Release
?Release@CSegState@@W3AGKXZ ENDP			; CSegState::Release
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\alist.h
_TEXT	ENDS
;	COMDAT ??0AListItem@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0AListItem@@QAE@XZ PROC NEAR				; AListItem::AListItem, COMDAT
; _this$ = ecx

; 17   :     AListItem() { m_pNext=NULL; };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??0AListItem@@QAE@XZ ENDP				; AListItem::AListItem
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0AList@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0AList@@QAE@XZ PROC NEAR				; AList::AList, COMDAT
; _this$ = ecx

; 34   :     AList() {m_pHead=NULL;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??0AList@@QAE@XZ ENDP					; AList::AList
_TEXT	ENDS
EXTRN	?DirectMusicAllocI@@YGPAXI@Z:NEAR		; DirectMusicAllocI
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\xalloc.h
;	COMDAT ??2@YAPAXI@Z
_TEXT	SEGMENT
_cb$ = 8
??2@YAPAXI@Z PROC NEAR					; operator new, COMDAT

; 12   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 13   :     return DirectMusicAllocI(cb);

  00003	8b 45 08	 mov	 eax, DWORD PTR _cb$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ?DirectMusicAllocI@@YGPAXI@Z ; DirectMusicAllocI

; 14   : }

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??2@YAPAXI@Z ENDP					; operator new
_TEXT	ENDS
EXTRN	?DirectMusicFreeI@@YGXPAX@Z:NEAR		; DirectMusicFreeI
; Function compile flags: /Odt
;	COMDAT ??3@YAXPAX@Z
_TEXT	SEGMENT
_pv$ = 8
??3@YAXPAX@Z PROC NEAR					; operator delete, COMDAT

; 17   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 18   :     DirectMusicFreeI(pv);

  00003	8b 45 08	 mov	 eax, DWORD PTR _pv$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ?DirectMusicFreeI@@YGXPAX@Z ; DirectMusicFreeI

; 19   : }

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??3@YAXPAX@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	?GetNext@AListItem@@QBEPAV1@XZ			; AListItem::GetNext
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\dmime\trklist.h
;	COMDAT ?GetNext@CTrack@@QAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4
?GetNext@CTrack@@QAEPAV1@XZ PROC NEAR			; CTrack::GetNext, COMDAT
; _this$ = ecx

; 23   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 24   : 		return (CTrack*)AListItem::GetNext();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?GetNext@AListItem@@QBEPAV1@XZ ; AListItem::GetNext

; 25   : 	};

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?GetNext@CTrack@@QAEPAV1@XZ ENDP			; CTrack::GetNext
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\alist.h
_TEXT	ENDS
;	COMDAT ?GetNext@AListItem@@QBEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4
?GetNext@AListItem@@QBEPAV1@XZ PROC NEAR		; AListItem::GetNext, COMDAT
; _this$ = ecx

; 18   :     AListItem *GetNext() const {return m_pNext;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?GetNext@AListItem@@QBEPAV1@XZ ENDP			; AListItem::GetNext
_TEXT	ENDS
PUBLIC	?GetHead@AList@@QBEPAVAListItem@@XZ		; AList::GetHead
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\dmime\trklist.h
;	COMDAT ?GetHead@CTrackList@@QAEPAVCTrack@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetHead@CTrackList@@QAEPAVCTrack@@XZ PROC NEAR		; CTrackList::GetHead, COMDAT
; _this$ = ecx

; 58   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 59   : 		return (CTrack*)AList::GetHead();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?GetHead@AList@@QBEPAVAListItem@@XZ ; AList::GetHead

; 60   : 	};

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?GetHead@CTrackList@@QAEPAVCTrack@@XZ ENDP		; CTrackList::GetHead
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\alist.h
_TEXT	ENDS
;	COMDAT ?GetHead@AList@@QBEPAVAListItem@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetHead@AList@@QBEPAVAListItem@@XZ PROC NEAR		; AList::GetHead, COMDAT
; _this$ = ecx

; 35   :     AListItem *GetHead() const { return m_pHead;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?GetHead@AList@@QBEPAVAListItem@@XZ ENDP		; AList::GetHead
_TEXT	ENDS
PUBLIC	??_GCTrack@@QAEPAXI@Z				; CTrack::`scalar deleting destructor'
PUBLIC	?RemoveHead@CTrackList@@QAEPAVCTrack@@XZ	; CTrackList::RemoveHead
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\dmime\trklist.h
;	COMDAT ?Clear@CTrackList@@QAEXXZ
_TEXT	SEGMENT
tv71 = -20
_this$ = -16
$T70802 = -12
$T70801 = -8
_pTrack$ = -4
?Clear@CTrackList@@QAEXXZ PROC NEAR			; CTrackList::Clear, COMDAT
; _this$ = ecx

; 70   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
$L40796:

; 71   : 		CTrack* pTrack;
; 72   : 		while( pTrack = RemoveHead() )

  00009	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?RemoveHead@CTrackList@@QAEPAVCTrack@@XZ ; CTrackList::RemoveHead
  00011	89 45 fc	 mov	 DWORD PTR _pTrack$[ebp], eax
  00014	83 7d fc 00	 cmp	 DWORD PTR _pTrack$[ebp], 0
  00018	74 2a		 je	 SHORT $L40793

; 73   : 		{
; 74   : 			delete pTrack;

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _pTrack$[ebp]
  0001d	89 45 f4	 mov	 DWORD PTR $T70802[ebp], eax
  00020	8b 4d f4	 mov	 ecx, DWORD PTR $T70802[ebp]
  00023	89 4d f8	 mov	 DWORD PTR $T70801[ebp], ecx
  00026	83 7d f8 00	 cmp	 DWORD PTR $T70801[ebp], 0
  0002a	74 0f		 je	 SHORT $L70803
  0002c	6a 01		 push	 1
  0002e	8b 4d f8	 mov	 ecx, DWORD PTR $T70801[ebp]
  00031	e8 00 00 00 00	 call	 ??_GCTrack@@QAEPAXI@Z
  00036	89 45 ec	 mov	 DWORD PTR tv71[ebp], eax
  00039	eb 07		 jmp	 SHORT $L70804
$L70803:
  0003b	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
$L70804:

; 75   : 		}

  00042	eb c5		 jmp	 SHORT $L40796
$L40793:

; 76   : 	}

  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
?Clear@CTrackList@@QAEXXZ ENDP				; CTrackList::Clear
_TEXT	ENDS
PUBLIC	?RemoveHead@AList@@QAEPAVAListItem@@XZ		; AList::RemoveHead
; Function compile flags: /Odt
;	COMDAT ?RemoveHead@CTrackList@@QAEPAVCTrack@@XZ
_TEXT	SEGMENT
_this$ = -4
?RemoveHead@CTrackList@@QAEPAVCTrack@@XZ PROC NEAR	; CTrackList::RemoveHead, COMDAT
; _this$ = ecx

; 62   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 63   : 		return (CTrack*)AList::RemoveHead();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?RemoveHead@AList@@QAEPAVAListItem@@XZ ; AList::RemoveHead

; 64   : 	};

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?RemoveHead@CTrackList@@QAEPAVCTrack@@XZ ENDP		; CTrackList::RemoveHead
_TEXT	ENDS
PUBLIC	?SetNext@AListItem@@QAEXPAV1@@Z			; AListItem::SetNext
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\alist.h
;	COMDAT ?RemoveHead@AList@@QAEPAVAListItem@@XZ
_TEXT	SEGMENT
_this$ = -8
_li$ = -4
?RemoveHead@AList@@QAEPAVAListItem@@XZ PROC NEAR	; AList::RemoveHead, COMDAT
; _this$ = ecx

; 71   :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 72   :             AListItem *li;
; 73   :             li = m_pHead;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 4d fc	 mov	 DWORD PTR _li$[ebp], ecx

; 74   :             if(m_pHead)

  00011	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00014	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00017	74 19		 je	 SHORT $L32744

; 75   :             {
; 76   :                 m_pHead = m_pHead->GetNext();

  00019	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001e	e8 00 00 00 00	 call	 ?GetNext@AListItem@@QBEPAV1@XZ ; AListItem::GetNext
  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	89 01		 mov	 DWORD PTR [ecx], eax

; 77   :                 li->SetNext(NULL);

  00028	6a 00		 push	 0
  0002a	8b 4d fc	 mov	 ecx, DWORD PTR _li$[ebp]
  0002d	e8 00 00 00 00	 call	 ?SetNext@AListItem@@QAEXPAV1@@Z ; AListItem::SetNext
$L32744:

; 78   :             }
; 79   :             return li;

  00032	8b 45 fc	 mov	 eax, DWORD PTR _li$[ebp]

; 80   :         }

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?RemoveHead@AList@@QAEPAVAListItem@@XZ ENDP		; AList::RemoveHead
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ?SetNext@AListItem@@QAEXPAV1@@Z
_TEXT	SEGMENT
_this$ = -4
_pNext$ = 8
?SetNext@AListItem@@QAEXPAV1@@Z PROC NEAR		; AListItem::SetNext, COMDAT
; _this$ = ecx

; 19   :     void SetNext(AListItem *pNext) {m_pNext=pNext;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _pNext$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?SetNext@AListItem@@QAEXPAV1@@Z ENDP			; AListItem::SetNext
_TEXT	ENDS
EXTRN	??1CTrack@@QAE@XZ:NEAR				; CTrack::~CTrack
; Function compile flags: /Odt
;	COMDAT ??_GCTrack@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4
___flags$ = 8
??_GCTrack@@QAEPAXI@Z PROC NEAR				; CTrack::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CTrack@@QAE@XZ	; CTrack::~CTrack
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $L40803
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$L40803:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GCTrack@@QAEPAXI@Z ENDP				; CTrack::`scalar deleting destructor'
; Function compile flags: /Odt
; File c:\xbox\private\windows\directx\dmusic\shared\xboxutil.h
_TEXT	ENDS
;	COMDAT ?DeleteCriticalSection@@YGXPAX@Z
_TEXT	SEGMENT
___formal$ = 8
?DeleteCriticalSection@@YGXPAX@Z PROC NEAR		; DeleteCriticalSection, COMDAT

; 16   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 17   : }

  00003	5d		 pop	 ebp
  00004	c2 04 00	 ret	 4
?DeleteCriticalSection@@YGXPAX@Z ENDP			; DeleteCriticalSection
; Function compile flags: /Odt
_TEXT	ENDS
;	COMDAT ??0IUnknown@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0IUnknown@@QAE@XZ PROC NEAR				; IUnknown::IUnknown, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??0IUnknown@@QAE@XZ ENDP				; IUnknown::IUnknown
_TEXT	ENDS
END
