//==================================================================================
// Includes
//==================================================================================
#include "dptest.h"
#include "macros.h"
#include "parmvalidation.h"

using namespace DPlayCoreNamespace;

namespace DPlayCoreNamespace {

//==================================================================================
// Structures
//==================================================================================

typedef struct tagPARMVPCANCELCONTEXT
{
	HANDLE					hLog; // Handle to logging subsystem
	BOOL					fConnectCanComplete; // whether the connect can complete or not
	HANDLE					hConnectCompleteEvent; // event to set when connect completes
	DPNHANDLE				dpnhExpectedAsyncOp; // the expected handle of the completing connect
	HRESULT					hrExpectedResult; // the expected result code of the connect completion
	BOOL					fCompleted; // whether the connect has completed or not
} PARMVPCANCELCONTEXT, * PPARMVPCANCELCONTEXT;

typedef struct tagPARMVPCONNECTCONTEXT
{
	HANDLE					hLog; // Handle to logging subsystem
	BOOL					fHost; // whether this is the host context or not
	DPNID					dpnidHost; // ID of host player
	DPNID					dpnidClient; // ID of client player
	BOOL					fConnectCanComplete; // whether the connect can complete or not
	DPNHANDLE				dpnhCompletedAsyncOp; // the handle of the asynchronous operation given in the completion
	HRESULT					hrExpectedResult; // the expected result code of the connect completion
	BOOL					fCompleted; // whether the connect has completed or not
	HANDLE					hConnectCompleteEvent; // event to set when connect completes
	HANDLE					hClientCreatedEvent; // event to set when CREATE_PLAYER for client arrives on host
} PARMVPCONNECTCONTEXT, * PPARMVPCONNECTCONTEXT;

typedef struct tagPARMVPSENDTOCONTEXT
{
	HANDLE					hLog; // Handle to logging subsystem
	DPNID					dpnidPlayer; // ID of player created
	BOOL					fSendCanComplete; // whether the send can complete or not
	DPNHANDLE				dpnhCompletedAsyncOp; // the handle of the completed send
	HRESULT					hrExpectedResult; // the expected result code of the send completion
	BOOL					fSendCompleted; // whether the send has completed or not
	HANDLE					hSendCompleteEvent; // event to set when send completes
	BOOL					fCanReceive; // whether a (the) receive is allowed or not
	DWORD					dwExpectedReceiveSize; // expected size of the received message
	BOOL					fReceived; // whether the receive has arrived or not
	HANDLE					hReceiveEvent; // event to set when message is received
} PARMVPSENDTOCONTEXT, * PPARMVPSENDTOCONTEXT;

typedef struct tagPARMVPGETSENDQINFOCONTEXT
{
	HANDLE					hLog; // Handle to logging subsystem
	BOOL					fHost; // whether this is the host context or not
	DPNID					dpnidHost; // ID of host player
	DPNID					dpnidClient; // ID of client player
	BOOL					fConnectCanComplete; // whether the connect can complete or not
	BOOL					fConnectCompleted; // whether the connect has completed or not
	HANDLE					hClientCreatedEvent; // event to set when CREATE_PLAYER for client arrives on host
} PARMVPGETSENDQINFOCONTEXT, * PPARMVPGETSENDQINFOCONTEXT;

typedef struct tagPARMVPHOSTCONTEXT
{
	HANDLE					hLog; // Handle to logging subsystem
	BOOL					fCreatePlayerAllowed; // whether create player is allowed or not
	DPNID					dpnidPlayer; // ID of player created
} PARMVPHOSTCONTEXT, * PPARMVPHOSTCONTEXT;

typedef struct tagPARMVPGETAPPDESCCONTEXT
{
	HANDLE					hLog; // Handle to logging subsystem
	BOOL					fHost; // whether this is the host context or not
	DPNID					dpnidHost; // ID of host player
	DPNID					dpnidClient; // ID of client player
	BOOL					fConnectCanComplete; // whether the connect can complete or not
	BOOL					fConnectCompleted; // whether the connect has completed or not
	HANDLE					hClientCreatedEvent; // event to set when CREATE_PLAYER for client arrives on host
} PARMVPGETAPPDESCCONTEXT, * PPARMVPGETAPPDESCCONTEXT;

typedef struct tagPARMVPSETAPPDESCCONTEXT
{
	HANDLE					hLog; // Handle to logging subsystem
	BOOL					fHost; // whether this is the host context or not
	DPNID					dpnidHost; // ID of host player
	DPNID					dpnidClient; // ID of client player
	BOOL					fConnectCanComplete; // whether the connect can complete or not
	BOOL					fConnectCompleted; // whether the connect has completed or not
	HANDLE					hClientCreatedEvent; // event to set when CREATE_PLAYER for client arrives on host
	BOOL					fCanGetAppDescUpdate; // whether the app desc message can arrive or not
	BOOL					fGotAppDescUpdate; // whether the app desc message has arrived or not
	HANDLE					hGotAppDescUpdateEvent; // event to set when app desc message is received
} PARMVPSETAPPDESCCONTEXT, * PPARMVPSETAPPDESCCONTEXT;

typedef struct tagPARMVPCREATEGROUPCONTEXT
{
	HANDLE					hLog; // Handle to logging subsystem
	BOOL					fHost; // whether this is the host context or not
	DPNID					dpnidHost; // ID of host player
	DPNID					dpnidClient; // ID of client player
	BOOL					fConnectCanComplete; // whether the connect can complete or not
	DPNHANDLE				dpnhCompletedAsyncOp; // the handle of the asynchronous operation given in the completion
	HRESULT					hrExpectedResult; // the expected result code of the connect/group creation
	BOOL					fConnectCompleted; // whether the connect has completed or not
	HANDLE					hClientCreatedEvent; // event to set when CREATE_PLAYER for client arrives on host
	BOOL					fAsyncOpCanComplete; // whether the async op completion can arrive or not
	HANDLE					hAsyncOpCompletedEvent; // event to set when async op completes
	BOOL					fAsyncOpCompleted; // whether the async op has completed or not
	BOOL					fCanGetCreateGroup; // whether the create group indication can arrive or not
	DPNID					dpnidExpectedGroupOwner; // expected group owner DPNID
	DPNID					dpnidGroupCreated; // the DPNID of the group created
	HANDLE					hGotCreateGroupEvent; // event to set when create group indication is received
} PARMVPCREATEGROUPCONTEXT, * PPARMVPCREATEGROUPCONTEXT;

typedef struct tagPARMVPDESTROYGROUPCONTEXT
{
	HANDLE					hLog; // Handle to logging subsystem
	BOOL					fHost; // whether this is the host context or not
	DPNID					dpnidHost; // ID of host player
	DPNID					dpnidClient; // ID of client player
	BOOL					fConnectCanComplete; // whether the connect can complete or not
	DPNHANDLE				dpnhCompletedAsyncOp; // the handle of the asynchronous operation given in the completion
	HRESULT					hrExpectedResult; // the expected result code of the connect/group creation
	BOOL					fConnectCompleted; // whether the connect has completed or not
	HANDLE					hClientCreatedEvent; // event to set when CREATE_PLAYER for client arrives on host
	BOOL					fAsyncOpCanComplete; // whether the async op completion can arrive or not
	HANDLE					hAsyncOpCompletedEvent; // event to set when async op completes
	BOOL					fAsyncOpCompleted; // whether the async op has completed or not
	BOOL					fCanGetCreateGroup; // whether the create group indication can arrive or not
	DPNID					dpnidExpectedGroupOwner; // expected group owner DPNID
	BOOL					fCanGetDestroyGroup; // whether the destroy group indication can arrive or not
	DPNID					dpnidGroup; // the DPNID of the group created/to be destroyed
	HANDLE					hGotGroupMsgEvent; // event to set when create/destroy group indication is received
} PARMVPDESTROYGROUPCONTEXT, * PPARMVPDESTROYGROUPCONTEXT;

typedef struct tagPARMVPADDTOGROUPCONTEXT
{
	HANDLE					hLog; // Handle to logging subsystem
	BOOL					fHost; // whether this is the host context or not
	DPNID					dpnidHost; // ID of host player
	DPNID					dpnidClient; // ID of client player
	BOOL					fConnectCanComplete; // whether the connect can complete or not
	DPNHANDLE				dpnhCompletedAsyncOp; // the handle of the asynchronous operation given in the completion
	HRESULT					hrExpectedResult; // the expected result code of the connect/group creation
	BOOL					fConnectCompleted; // whether the connect has completed or not
	HANDLE					hClientCreatedEvent; // event to set when CREATE_PLAYER for client arrives on host
	BOOL					fAsyncOpCanComplete; // whether the async op completion can arrive or not
	HANDLE					hAsyncOpCompletedEvent; // event to set when async op completes
	BOOL					fAsyncOpCompleted; // whether the async op has completed or not
	BOOL					fCanGetCreateGroup; // whether the create group indication can arrive or not
	DPNID					dpnidExpectedGroupOwner; // expected group owner DPNID
	BOOL					fCanGetAddToGroup; // whether the add player to group indication can arrive or not
	DPNID					dpnidGroup; // the DPNID of the group created/to be destroyed
	DPNID					dpnidExpectedPlayer; // the DPNID of the player being added
	PVOID					pvExpectedPlayerContext; // the context of the player being added
	HANDLE					hGotGroupMsgEvent; // event to set when create/destroy/addto group indication is received
	BOOL					fGotAddToGroup; // whether the add player to group indication did arrive
} PARMVPADDTOGROUPCONTEXT, * PPARMVPADDTOGROUPCONTEXT;

typedef struct tagPARMVPREMOVEFROMGROUPCONTEXT
{
	HANDLE					hLog; // Handle to logging subsystem
	BOOL					fHost; // whether this is the host context or not
	DPNID					dpnidHost; // ID of host player
	DPNID					dpnidClient; // ID of client player
	BOOL					fConnectCanComplete; // whether the connect can complete or not
	DPNHANDLE				dpnhCompletedAsyncOp; // the handle of the asynchronous operation given in the completion
	HRESULT					hrExpectedResult; // the expected result code of the connect/group creation
	BOOL					fConnectCompleted; // whether the connect has completed or not
	HANDLE					hClientCreatedEvent; // event to set when CREATE_PLAYER for client arrives on host
	BOOL					fAsyncOpCanComplete; // whether the async op completion can arrive or not
	HANDLE					hAsyncOpCompletedEvent; // event to set when async op completes
	BOOL					fAsyncOpCompleted; // whether the async op has completed or not
	BOOL					fCanGetCreateGroup; // whether the create group indication can arrive or not
	DPNID					dpnidExpectedGroupOwner; // expected group owner DPNID
	BOOL					fCanGetAddToGroup; // whether the add player to group indication can arrive or not
	BOOL					fCanGetRemoveFromGroup; // whether the remove player from group indication can arrive or not
	DPNID					dpnidGroup; // the DPNID of the group created/to be destroyed
	DPNID					dpnidExpectedPlayer; // the DPNID of the player being added
	PVOID					pvExpectedPlayerContext; // the context of the player being added
	HANDLE					hGotGroupMsgEvent; // event to set when create/destroy/addto/removefrom group indication is received
	BOOL					fGotAddToGroup; // whether the add player to group indication did arrive
	BOOL					fGotRemoveFromGroup; // whether the remove player from group indication did arrive
} PARMVPREMOVEFROMGROUPCONTEXT, * PPARMVPREMOVEFROMGROUPCONTEXT;

typedef struct tagPARMVPSETGROUPINFOCONTEXT
{
	HANDLE					hLog; // Handle to logging subsystem
	BOOL					fHost; // whether this is the host context or not
	DPNID					dpnidHost; // ID of host player
	DPNID					dpnidClient; // ID of client player
	BOOL					fConnectCanComplete; // whether the connect can complete or not
	HANDLE					hClientCreatedEvent; // event to set when CREATE_PLAYER for client arrives on host
	DPNHANDLE				dpnhCompletedAsyncOp; // the handle of the asynchronous operation given in the completion
	HRESULT					hrExpectedResult; // the expected result code of the connect/group creation
	BOOL					fConnectCompleted; // whether the connect has completed or not
	BOOL					fAsyncOpCanComplete; // whether the async op completion can arrive or not
	HANDLE					hAsyncOpCompletedEvent; // event to set when async op completes
	BOOL					fAsyncOpCompleted; // whether the async op has completed or not
	BOOL					fCanGetCreateGroup; // whether the create group indication can arrive or not
	DPNID					dpnidExpectedGroupOwner; // expected group owner DPNID
	BOOL					fCanGetGroupInfo; // whether the add player to group indication can arrive or not
	DPNID					dpnidGroup; // the DPNID of the group created/to be destroyed
	HANDLE					hGotGroupMsgEvent; // event to set when create/destroy/addto group indication is received
	BOOL					fGotGroupInfo; // whether the add player to group indication did arrive
} PARMVPSETGROUPINFOCONTEXT, * PPARMVPSETGROUPINFOCONTEXT;

typedef struct tagPARMVPGETGROUPINFOCONTEXT
{
	HANDLE					hLog; // Handle to logging subsystem
	BOOL					fHost; // whether this is the host context or not
	DPNID					dpnidHost; // ID of host player
	DPNID					dpnidClient; // ID of client player
	BOOL					fConnectCanComplete; // whether the connect can complete or not
	BOOL					fConnectCompleted; // whether the connect has completed or not
	HANDLE					hClientCreatedEvent; // event to set when CREATE_PLAYER for client arrives on host
	BOOL					fCanGetCreateGroup; // whether the create group indication can arrive or not
	DPNID					dpnidExpectedGroupOwner; // expected group owner DPNID
	DPNID					dpnidGroup; // the DPNID of the group created/to be destroyed
	HANDLE					hGotGroupMsgEvent; // event to set when create/destroy/addto group indication is received
} PARMVPGETGROUPINFOCONTEXT, * PPARMVPGETGROUPINFOCONTEXT;

typedef struct tagPARMVPENUMPANDGCONTEXT
{
	HANDLE					hLog; // Handle to logging subsystem
	BOOL					fHost; // whether this is the host context or not
	DPNID					dpnidHost; // ID of host player
	DPNID					dpnidClient; // ID of client player
	BOOL					fConnectCanComplete; // whether the connect can complete or not
	BOOL					fConnectCompleted; // whether the connect has completed or not
	HANDLE					hClientCreatedEvent; // event to set when CREATE_PLAYER for client arrives on host
	BOOL					fCanGetCreateGroup; // whether the create group indication can arrive or not
	BOOL					fCanGetCreateGroup2; // whether the create group indication can arrive or not
	DPNID					dpnidExpectedGroupOwner; // expected group owner DPNID
	DPNID					dpnidGroup; // the DPNID of the group created/to be destroyed
	DPNID					dpnidGroup2; // the DPNID of the second group created/to be destroyed
	HANDLE					hGotGroupMsgEvent; // event to set when create/destroy/addto group indication is received
} PARMVPENUMPANDGCONTEXT, * PPARMVPENUMPANDGCONTEXT;

typedef struct tagPARMVPENUMGROUPMEMBERSCONTEXT
{
	HANDLE					hLog; // Handle to logging subsystem
	BOOL					fHost; // whether this is the host context or not
	DPNID					dpnidHost; // ID of host player
	DPNID					dpnidClient; // ID of client player
	BOOL					fConnectCanComplete; // whether the connect can complete or not
	BOOL					fConnectCompleted; // whether the connect has completed or not
	HANDLE					hClientCreatedEvent; // event to set when CREATE_PLAYER for client arrives on host
	BOOL					fCanGetCreateGroup; // whether the create group indication can arrive or not
	DPNID					dpnidExpectedGroupOwner; // expected group owner DPNID
	DPNID					dpnidExpectedPlayer; // the DPNID of the player being added
	PVOID					pvExpectedPlayerContext; // the context of the player being added
	DPNID					dpnidGroup; // the DPNID of the group created/to be destroyed
	HANDLE					hGotGroupMsgEvent; // event to set when create/destroy/addto group indication is received
	BOOL					fCanGetAddToGroup; // whether the add player to group indication can arrive or not
	BOOL					fGotAddToGroup; // whether the add player to group indication did arrive
} PARMVPENUMGROUPMEMBERSCONTEXT, * PPARMVPENUMGROUPMEMBERSCONTEXT;

typedef struct tagPARMVPSETPEERINFOCONTEXT
{
	HANDLE					hLog; // Handle to logging subsystem
	BOOL					fHost; // whether this is the host context or not
	DPNID					dpnidHost; // ID of host player
	DPNID					dpnidClient; // ID of client player
	BOOL					fConnectCanComplete; // whether the connect can complete or not
	BOOL					fConnectCompleted; // whether the connect has completed or not
	HANDLE					hClientCreatedEvent; // event to set when CREATE_PLAYER for client arrives on host
	BOOL					fAsyncOpCanComplete; // whether the async op completion can arrive or not
	HANDLE					hAsyncOpCompletedEvent; // event to set when async op completes
	BOOL					fAsyncOpCompleted; // whether the async op has completed or not
	DPNHANDLE				dpnhCompletedAsyncOp; // the handle of the asynchronous operation given in the completion
	BOOL					fCanGetPeerInfoUpdate; // whether the peer info indication can arrive or not
	BOOL					fGotPeerInfoUpdate; // whether the peer info indication did arrive
	HANDLE					hGotPeerInfoUpdateEvent; // event to set when peer info message is received
	PWRAPDP8PEER			pDP8Peer; // pointer to DP8Peer wrapper object to use
	WCHAR*					pwszExpectedPeerInfoName; // expected client info name
	PVOID*					pvExpectedPeerInfoData; // expected peer info data
	DWORD					dwExpectedPeerInfoDataSize; // expected peer info data size
	DWORD					dwExpectedPeerInfoPlayerFlags; // expected peer info player flags
} PARMVPSETPEERINFOCONTEXT, * PPARMVPSETPEERINFOCONTEXT;

typedef struct tagPARMVPGETPEERINFOCONTEXT
{
	HANDLE					hLog; // Handle to logging subsystem
	BOOL					fHost; // whether this is the host context or not
	DPNID					dpnidHost; // ID of host player
	DPNID					dpnidClient; // ID of client player
	BOOL					fConnectCanComplete; // whether the connect can complete or not
	BOOL					fConnectCompleted; // whether the connect has completed or not
	HANDLE					hClientCreatedEvent; // event to set when CREATE_PLAYER for client arrives on host
} PARMVPGETPEERINFOCONTEXT, * PPARMVPGETPEERINFOCONTEXT;

typedef struct tagPARMVPGETPEERADDRESSCONTEXT
{
	HANDLE					hLog; // Handle to logging subsystem
	BOOL					fHost; // whether this is the host context or not
	DPNID					dpnidHost; // ID of host player
	DPNID					dpnidClient; // ID of client player
	BOOL					fConnectCanComplete; // whether the connect can complete or not
	BOOL					fConnectCompleted; // whether the connect has completed or not
	HANDLE					hClientCreatedEvent; // event to set when CREATE_PLAYER for client arrives on host
} PARMVPGETPEERADDRESSCONTEXT, * PPARMVPGETPEERADDRESSCONTEXT;

typedef struct tagPARMVPGETLHOSTADDRESSESCONTEXT
{
	HANDLE					hLog; // Handle to logging subsystem
	BOOL					fHost; // whether this is the host context or not
	DPNID					dpnidHost; // ID of host player
	DPNID					dpnidClient; // ID of client player
	BOOL					fConnectCanComplete; // whether the connect can complete or not
	BOOL					fConnectCompleted; // whether the connect has completed or not
	HANDLE					hClientCreatedEvent; // event to set when CREATE_PLAYER for client arrives on host
} PARMVPGETLHOSTADDRESSESCONTEXT, * PPARMVPGETLHOSTADDRESSESCONTEXT;

typedef struct tagPARMVPCLOSECONTEXT
{
	HANDLE					hLog; // Handle to logging subsystem
	BOOL					fConnectCanComplete; // whether the connect can complete or not
	BOOL					fConnectCompleted; // whether the connect has completed or not
	DPNHANDLE				dpnhCompletedAsyncOp; // the handle of the asynchronous operation given in the completion
	BOOL					fAsyncOpCanComplete; // whether the async op completion can arrive or not
	BOOL					fAsyncOpCompleted; // whether the async op has completed or not
} PARMVPCLOSECONTEXT, * PPARMVPCLOSECONTEXT;

typedef struct tagPARMVPENUMHOSTSCONTEXT
{
	HANDLE					hLog; // Handle to logging subsystem
	BOOL					fHost; // whether this is the host context or not
	DPNID					dpnidHost; // ID of host player
	DPNID					dpnidClient; // ID of client player
	BOOL					fConnectCanComplete; // whether the connect can complete or not
	BOOL					fConnectCompleted; // whether the connect has completed or not
	HANDLE					hClientCreatedEvent; // event to set when CREATE_PLAYER for client arrives on host
	BOOL					afAsyncOpCanComplete[2]; // whether the async op completion can arrive or not
	BOOL					afAsyncOpCompleted[2]; // whether the async op has completed or not
	DPNHANDLE				adpnhCompletedAsyncOp[2]; // the handle of the asynchronous operation given in the completion
	HRESULT					ahrExpectedResult[2]; // the expected result code of the async op
	HANDLE					ahAsyncOpCompletedEvent[2]; // event to set when async op completes
	GUID*					pguidExpectedApplication; // pointer to expected application desc application GUID
	PDIRECTPLAY8ADDRESS		apExpectedDP8AddressSender[2]; // expected address of sender
	PDIRECTPLAY8ADDRESS		apExpectedDP8AddressDevice[2]; // expected address of device
	DWORD					adwExpectedCurrentPlayers[2]; // expected number of current players
	BOOL					afCanGetResponses[2]; // are queries allowed
	DWORD					dwNumQueries; // number of queries received
	DWORD					adwNumResponses[2]; // number of responses received
} PARMVPENUMHOSTSCONTEXT, * PPARMVPENUMHOSTSCONTEXT;

typedef struct tagPARMVPDESTROYPEERCONTEXT
{
	HANDLE					hLog; // Handle to logging subsystem
	BOOL					afExpectCreatePlayer[2]; // whether create player messages are allowed or not
	DPNID					adpnidPlayers[2]; // IDs of the players
	BOOL					fConnectCanComplete; // whether the connect can complete or not
	BOOL					fConnectCompleted; // whether the connect has completed or not
	DPNHANDLE				dpnhCompletedAsyncOp; // the handle of the asynchronous operation given in the completion
	BOOL					fAsyncOpCanComplete; // whether the async op completion can arrive or not
	BOOL					fAsyncOpCompleted; // whether the async op has completed or not
	BOOL					afExpectDestroyPlayer[2]; // whether destroy players are allowed or not
	DWORD					dwNumDestroyPlayersRemaining; // number of destroy player messages that should happen
	HANDLE					hLastPlayerMsgEvent; // event to set when last create/destroy player expected arrives
	BOOL					fExpectTerminateSession; // whether the terminate session message is allowed or not
	BOOL					fGotTerminateSession; // whether the terminate session message arrived or not
	HANDLE					hSendCompleteEvent; // used to indicate when a send completes
	HRESULT					hrExpectedResult; // indicates expected result from send complete callback
	HRESULT					hrActualResult; // indicates the actual result from the send callback
	BOOL					fSendCanComplete; // that indicates if a send is allowed to complete
} PARMVPDESTROYPEERCONTEXT, * PPARMVPDESTROYPEERCONTEXT;

typedef struct tagPARMVPRETURNCONTEXT
{
	HANDLE					hLog; // Handle to logging subsystem
	DPNID					dpnidPlayer; // ID of player
	BOOL					fExpectReceive; // whether receives are allowed or not
	DPNHANDLE				dpnhBuffer; // handle to buffer kept
	HANDLE					hReceivedMsgEvent; // handle to event to set when message arrives
} PARMVPRETURNCONTEXT, * PPARMVPRETURNCONTEXT;

typedef struct tagPARMVPGETPLAYERCONTEXTCONTEXT
{
	HANDLE					hLog; // Handle to logging subsystem
	BOOL					afExpectCreatePlayer[2]; // whether create player messages are allowed or not
	DPNID					adpnidPlayers[2]; // IDs of the players
	BOOL					fConnectCanComplete; // whether the connect can complete or not
	BOOL					fConnectCompleted; // whether the connect has completed or not
	BOOL					afExpectDestroyPlayer[2]; // whether destroy players are allowed or not
	DWORD					dwNumDestroyPlayersRemaining; // number of destroy player messages that should happen
	HANDLE					hLastPlayerMsgEvent; // event to set when last create/destroy player expected arrives
} PARMVPGETPLAYERCONTEXTCONTEXT, * PPARMVPGETPLAYERCONTEXTCONTEXT;

typedef struct tagPARMVPGETGROUPCONTEXTCONTEXT
{
	HANDLE					hLog; // Handle to logging subsystem
	BOOL					fHost; // whether this is the host context or not
	DPNID					dpnidHost; // ID of host player
	DPNID					dpnidClient; // ID of client player
	BOOL					fConnectCanComplete; // whether the connect can complete or not
	BOOL					fConnectCompleted; // whether the connect has completed or not
	HANDLE					hClientCreatedEvent; // event to set when CREATE_PLAYER for client arrives on host
	BOOL					fCanGetCreateGroup; // whether the create group indication can arrive or not
	DPNID					dpnidExpectedGroupOwner; // expected group owner DPNID
	DPNID					dpnidGroup; // the DPNID of the group created/to be destroyed
	HANDLE					hGotGroupMsgEvent; // event to set when create/destroy/addto group indication is received
} PARMVPGETGROUPCONTEXTCONTEXT, * PPARMVPGETGROUPCONTEXTCONTEXT;

typedef struct tagPARMVPGETCONNINFOCONTEXT
{
	HANDLE					hLog; // Handle to logging subsystem
	BOOL					fHost; // whether this is the host context or not
	DPNID					dpnidHost; // ID of host player
	DPNID					dpnidClient; // ID of client player
	BOOL					fConnectCanComplete; // whether the connect can complete or not
	BOOL					fConnectCompleted; // whether the connect has completed or not
	HANDLE					hClientCreatedEvent; // event to set when CREATE_PLAYER for client arrives on host
} PARMVPGETCONNINFOCONTEXT, * PPARMVPGETCONNINFOCONTEXT;

typedef struct tagPARMVPTERMINATECONTEXT
{
	HANDLE					hLog; // Handle to logging subsystem
	BOOL					afExpectCreatePlayer[2]; // whether create player messages are allowed or not
	DPNID					adpnidPlayers[2]; // IDs of the players
	BOOL					fConnectCanComplete; // whether the connect can complete or not
	BOOL					fConnectCompleted; // whether the connect has completed or not
	DPNHANDLE				dpnhCompletedAsyncOp; // the handle of the asynchronous operation given in the completion
	BOOL					fAsyncOpCanComplete; // whether the async op completion can arrive or not
	BOOL					fAsyncOpCompleted; // whether the async op has completed or not
	BOOL					afExpectDestroyPlayer[2]; // whether destroy players are allowed or not
	DWORD					dwNumDestroyPlayersRemaining; // number of destroy player messages that should happen
	HANDLE					hLastPlayerMsgEvent; // event to set when last create/destroy player expected arrives
	BOOL					fExpectTerminateSession; // whether the terminate session message is allowed or not
	BOOL					fGotTerminateSession; // whether the terminate session message arrived or not
} PARMVPTERMINATECONTEXT, * PPARMVPTERMINATECONTEXT;

typedef struct tagPARMVPGENERICCONTEXT
{
	HANDLE					hLog; // Handle to logging subsystem
} PARMVPGENERICCONTEXT, * PPARMVPGENERICCONTEXT;




//==================================================================================
// Prototypes
//==================================================================================
HRESULT ParmVPeerExec_CreateQI(HANDLE hLog);
HRESULT ParmVPeerExec_Init(HANDLE hLog);
HRESULT ParmVPeerExec_EnumSPs(HANDLE hLog);
HRESULT ParmVPeerExec_Cancel(HANDLE hLog);
HRESULT ParmVPeerExec_Connect(HANDLE hLog);
HRESULT ParmVPeerExec_SendTo(HANDLE hLog);
HRESULT ParmVPeerExec_GetSendQInfo(HANDLE hLog);
HRESULT ParmVPeerExec_Host(HANDLE hLog);
HRESULT ParmVPeerExec_GetAppDesc(HANDLE hLog);
HRESULT ParmVPeerExec_SetAppDesc(HANDLE hLog);
HRESULT ParmVPeerExec_CreateGroup(HANDLE hLog);
HRESULT ParmVPeerExec_DestroyGroup(HANDLE hLog);
HRESULT ParmVPeerExec_AddToGroup(HANDLE hLog);
HRESULT ParmVPeerExec_RemoveFromGroup(HANDLE hLog);
HRESULT ParmVPeerExec_SetGroupInfo(HANDLE hLog);
HRESULT ParmVPeerExec_GetGroupInfo(HANDLE hLog);
HRESULT ParmVPeerExec_EnumPAndG(HANDLE hLog);
HRESULT ParmVPeerExec_EnumGroupMembers(HANDLE hLog);
HRESULT ParmVPeerExec_SetPeerInfo(HANDLE hLog);
HRESULT ParmVPeerExec_GetPeerInfo(HANDLE hLog);
HRESULT ParmVPeerExec_GetPeerAddress(HANDLE hLog);
HRESULT ParmVPeerExec_GetLHostAddresses(HANDLE hLog);
HRESULT ParmVPeerExec_Close(HANDLE hLog);
HRESULT ParmVPeerExec_EnumHosts(HANDLE hLog);
HRESULT ParmVPeerExec_DestroyPeer(HANDLE hLog);
HRESULT ParmVPeerExec_Return(HANDLE hLog);
HRESULT ParmVPeerExec_GetPlayerContext(HANDLE hLog);
HRESULT ParmVPeerExec_GetGroupContext(HANDLE hLog);
HRESULT ParmVPeerExec_GetCaps(HANDLE hLog);
HRESULT ParmVPeerExec_SetCaps(HANDLE hLog);
HRESULT ParmVPeerExec_SetSPCaps(HANDLE hLog);
HRESULT ParmVPeerExec_GetSPCaps(HANDLE hLog);
HRESULT ParmVPeerExec_GetConnInfo(HANDLE hLog);
HRESULT ParmVPeerExec_Terminate(HANDLE hLog);


HRESULT ParmVPCancelDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg);
HRESULT ParmVPConnectDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg);
HRESULT ParmVPSendToDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg);
HRESULT ParmVPGetSendQInfoDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg);
HRESULT ParmVPHostDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg);
HRESULT ParmVPGetAppDescDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg);
HRESULT ParmVPSetAppDescDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg);
HRESULT ParmVPCreateGroupDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg);
HRESULT ParmVPDestroyGroupDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg);
HRESULT ParmVPAddToGroupDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg);
HRESULT ParmVPRemoveFromGroupDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg);
HRESULT ParmVPSetGroupInfoDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg);
HRESULT ParmVPGetGroupInfoDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg);
HRESULT ParmVPEnumPAndGDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg);
HRESULT ParmVPEnumGroupMembersDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg);
HRESULT ParmVPSetPeerInfoDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg);
HRESULT ParmVPGetPeerInfoDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg);
HRESULT ParmVPGetPeerAddressDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg);
HRESULT ParmVPGetLHostAddressesDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg);
HRESULT ParmVPCloseDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg);
HRESULT ParmVPEnumHostsDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg);
HRESULT ParmVPDestroyPeerDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg);
HRESULT ParmVPReturnDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg);
HRESULT ParmVPGetPlayerContextDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg);
HRESULT ParmVPGetGroupContextDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg);
HRESULT ParmVPGetCapsDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg);
HRESULT ParmVPSetCapsDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg);
HRESULT ParmVPGetSPCapsDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg);
HRESULT ParmVPSetSPCapsDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg);
HRESULT ParmVPGetConnInfoDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg);
HRESULT ParmVPTerminateDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg);



/*
#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVPeerLoadTestTable()"
//==================================================================================
// ParmVPeerLoadTestTable
//----------------------------------------------------------------------------------
//
// Description: Loads all the possible tests into the table passed in:
//				2.1.1		Peer interface parameter validation tests
//				2.1.1.1		Peer DirectPlay8Create and QueryInterface parameter validation
//				2.1.1.2		Peer Initialize parameter validation
//				2.1.1.3		Peer EnumServiceProviders parameter validation
//				2.1.1.4		Peer CancelAsyncOperation parameter validation
//				2.1.1.5		Peer Connect parameter validation
//				2.1.1.6		Peer SendTo parameter validation
//				2.1.1.7		Peer GetSendQueueInfo parameter validation
//				2.1.1.8		Peer Host parameter validation
//				2.1.1.9		Peer GetApplicationDesc parameter validation
//				2.1.1.10	Peer SetApplicationDesc parameter validation
//				2.1.1.11	Peer CreateGroup parameter validation
//				2.1.1.12	Peer DestroyGroup parameter validation
//				2.1.1.13	Peer AddPlayerToGroup parameter validation
//				2.1.1.14	Peer RemovePlayerFromGroup parameter validation
//				2.1.1.15	Peer SetGroupInfo parameter validation
//				2.1.1.16	Peer GetGroupInfo parameter validation
//				2.1.1.17	Peer EnumPlayersAndGroups parameter validation
//				2.1.1.18	Peer EnumGroupMembers parameter validation
//				2.1.1.19	Peer SetPeerInfo parameter validation
//				2.1.1.20	Peer GetPeerInfo parameter validation
//				2.1.1.21	Peer GetPeerAddress parameter validation
//				2.1.1.22	Peer GetLocalHostAddresses parameter validation
//				2.1.1.23	Peer Close parameter validation
//				2.1.1.24	Peer EnumHosts parameter validation
//				2.1.1.25	Peer DestroyPeer parameter validation
//				2.1.1.26	Peer ReturnBuffer parameter validation
//				2.1.1.27	Peer GetPlayerContext parameter validation
//				2.1.1.28	Peer GetGroupContext parameter validation
//				2.1.1.29	Peer GetCaps parameter validation
//				2.1.1.30	Peer SetCaps parameter validation
//				2.1.1.31	Peer SetSPCaps parameter validation
//				2.1.1.32	Peer GetSPCaps parameter validation
//				2.1.1.33	Peer GetConnectionInfo parameter validation
//				2.1.1.34	Peer RegisterLobby parameter validation
//				2.1.1.35	Peer TerminateSession parameter validation
//
// Arguments:
//	PTNLOADTESTTABLEDATA pTNlttd	Pointer to data to use when loading the tests.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT ParmVPeerLoadTestTable(PTNLOADTESTTABLEDATA pTNlttd)
{
	PTNTESTTABLEGROUP	pSubGroup;
	TNADDTESTDATA		tnatd;



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.1.1	Peer interface parameter validation tests
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	NEWSUBGROUP(pTNlttd->pBase,
				"2.1.1", "Peer interface parameter validation tests",
				&pSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.1.1.1	Peer DirectPlay8Create and QueryInterface parameter validation
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.1.1.1";
	tnatd.pszName			= "Peer DirectPlay8Create and QueryInterface parameter validation";
	tnatd.pszDescription	= "Peer DirectPlay8Create and QueryInterface parameter validation";
	tnatd.pszInputDataHelp	= NULL;

	tnatd.iNumMachines		= 1;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST | TNTCO_SUBTEST
								| TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= NULL;
	tnatd.pfnGetInputData	= NULL;
	tnatd.pfnExecCase		= ParmVPeerExec_CreateQI;
	tnatd.pfnWriteData		= NULL;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.1.1.2	Peer Initialize parameter validation
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.1.1.2";
	tnatd.pszName			= "Peer Initialize parameter validation";
	tnatd.pszDescription	= "Peer Initialize parameter validation";
	tnatd.pszInputDataHelp	= NULL;

	tnatd.iNumMachines		= 1;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST | TNTCO_SUBTEST
								| TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= NULL;
	tnatd.pfnGetInputData	= NULL;
	tnatd.pfnExecCase		= ParmVPeerExec_Init;
	tnatd.pfnWriteData		= NULL;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.1.1.3	Peer EnumServiceProviders parameter validation
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.1.1.3";
	tnatd.pszName			= "Peer EnumServiceProviders parameter validation";
	tnatd.pszDescription	= "Peer EnumServiceProviders parameter validation";
	tnatd.pszInputDataHelp	= NULL;

	tnatd.iNumMachines		= 1;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST | TNTCO_SUBTEST
								| TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= NULL;
	tnatd.pfnGetInputData	= NULL;
	tnatd.pfnExecCase		= ParmVPeerExec_EnumSPs;
	tnatd.pfnWriteData		= NULL;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.1.1.4	Peer CancelAsyncOperation parameter validation
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.1.1.4";
	tnatd.pszName			= "Peer CancelAsyncOperation parameter validation";
	tnatd.pszDescription	= "Peer CancelAsyncOperation parameter validation";
	tnatd.pszInputDataHelp	= NULL;

	tnatd.iNumMachines		= 1;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST | TNTCO_SUBTEST
								| TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= NULL;
	tnatd.pfnGetInputData	= NULL;
	tnatd.pfnExecCase		= ParmVPeerExec_Cancel;
	tnatd.pfnWriteData		= NULL;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.1.1.5	Peer Connect parameter validation
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.1.1.5";
	tnatd.pszName			= "Peer Connect parameter validation";
	tnatd.pszDescription	= "Peer Connect parameter validation";
	tnatd.pszInputDataHelp	= NULL;

	tnatd.iNumMachines		= 1;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST | TNTCO_SUBTEST
								| TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= NULL;
	tnatd.pfnGetInputData	= NULL;
	tnatd.pfnExecCase		= ParmVPeerExec_Connect;
	tnatd.pfnWriteData		= NULL;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.1.1.6	Peer SendTo parameter validation
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.1.1.6";
	tnatd.pszName			= "Peer SendTo parameter validation";
	tnatd.pszDescription	= "Peer SendTo parameter validation";
	tnatd.pszInputDataHelp	= NULL;

	tnatd.iNumMachines		= 1;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST | TNTCO_SUBTEST
								| TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= NULL;
	tnatd.pfnGetInputData	= NULL;
	tnatd.pfnExecCase		= ParmVPeerExec_SendTo;
	tnatd.pfnWriteData		= NULL;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.1.1.7	Peer GetSendQueueInfo parameter validation
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.1.1.7";
	tnatd.pszName			= "Peer GetSendQueueInfo parameter validation";
	tnatd.pszDescription	= "Peer GetSendQueueInfo parameter validation";
	tnatd.pszInputDataHelp	= NULL;

	tnatd.iNumMachines		= 1;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST | TNTCO_SUBTEST
								| TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= NULL;
	tnatd.pfnGetInputData	= NULL;
	tnatd.pfnExecCase		= ParmVPeerExec_GetSendQInfo;
	tnatd.pfnWriteData		= NULL;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.1.1.8	Peer Host parameter validation
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.1.1.8";
	tnatd.pszName			= "Peer Host parameter validation";
	tnatd.pszDescription	= "Peer Host parameter validation";
	tnatd.pszInputDataHelp	= NULL;

	tnatd.iNumMachines		= 1;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST | TNTCO_SUBTEST
								| TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= NULL;
	tnatd.pfnGetInputData	= NULL;
	tnatd.pfnExecCase		= ParmVPeerExec_Host;
	tnatd.pfnWriteData		= NULL;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.1.1.9	Peer GetApplicationDesc parameter validation
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.1.1.9";
	tnatd.pszName			= "Peer GetApplicationDesc parameter validation";
	tnatd.pszDescription	= "Peer GetApplicationDesc parameter validation";
	tnatd.pszInputDataHelp	= NULL;

	tnatd.iNumMachines		= 1;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST | TNTCO_SUBTEST
								| TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= NULL;
	tnatd.pfnGetInputData	= NULL;
	tnatd.pfnExecCase		= ParmVPeerExec_GetAppDesc;
	tnatd.pfnWriteData		= NULL;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.1.1.10	Peer SetApplicationDesc parameter validation
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.1.1.10";
	tnatd.pszName			= "Peer SetApplicationDesc parameter validation";
	tnatd.pszDescription	= "Peer SetApplicationDesc parameter validation";
	tnatd.pszInputDataHelp	= NULL;

	tnatd.iNumMachines		= 1;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST | TNTCO_SUBTEST
								| TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= NULL;
	tnatd.pfnGetInputData	= NULL;
	tnatd.pfnExecCase		= ParmVPeerExec_SetAppDesc;
	tnatd.pfnWriteData		= NULL;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.1.1.11	Peer CreateGroup parameter validation
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.1.1.11";
	tnatd.pszName			= "Peer CreateGroup parameter validation";
	tnatd.pszDescription	= "Peer CreateGroup parameter validation";
	tnatd.pszInputDataHelp	= NULL;

	tnatd.iNumMachines		= 1;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST | TNTCO_SUBTEST
								| TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= NULL;
	tnatd.pfnGetInputData	= NULL;
	tnatd.pfnExecCase		= ParmVPeerExec_CreateGroup;
	tnatd.pfnWriteData		= NULL;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.1.1.12	Peer DestroyGroup parameter validation
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.1.1.12";
	tnatd.pszName			= "Peer DestroyGroup parameter validation";
	tnatd.pszDescription	= "Peer DestroyGroup parameter validation";
	tnatd.pszInputDataHelp	= NULL;

	tnatd.iNumMachines		= 1;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST | TNTCO_SUBTEST
								| TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= NULL;
	tnatd.pfnGetInputData	= NULL;
	tnatd.pfnExecCase		= ParmVPeerExec_DestroyGroup;
	tnatd.pfnWriteData		= NULL;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.1.1.13	Peer AddPlayerToGroup parameter validation
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.1.1.13";
	tnatd.pszName			= "Peer AddPlayerToGroup parameter validation";
	tnatd.pszDescription	= "Peer AddPlayerToGroup parameter validation";
	tnatd.pszInputDataHelp	= NULL;

	tnatd.iNumMachines		= 1;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST | TNTCO_SUBTEST
								| TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= NULL;
	tnatd.pfnGetInputData	= NULL;
	tnatd.pfnExecCase		= ParmVPeerExec_AddToGroup;
	tnatd.pfnWriteData		= NULL;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.1.1.14	Peer RemovePlayerFromGroup parameter validation
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.1.1.14";
	tnatd.pszName			= "Peer RemovePlayerFromGroup parameter validation";
	tnatd.pszDescription	= "Peer RemovePlayerFromGroup parameter validation";
	tnatd.pszInputDataHelp	= NULL;

	tnatd.iNumMachines		= 1;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST | TNTCO_SUBTEST
								| TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= NULL;
	tnatd.pfnGetInputData	= NULL;
	tnatd.pfnExecCase		= ParmVPeerExec_RemoveFromGroup;
	tnatd.pfnWriteData		= NULL;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.1.1.15	Peer SetGroupInfo parameter validation
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.1.1.15";
	tnatd.pszName			= "Peer SetGroupInfo parameter validation";
	tnatd.pszDescription	= "Peer SetGroupInfo parameter validation";
	tnatd.pszInputDataHelp	= NULL;

	tnatd.iNumMachines		= 1;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST | TNTCO_SUBTEST
								| TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= NULL;
	tnatd.pfnGetInputData	= NULL;
	tnatd.pfnExecCase		= ParmVPeerExec_SetGroupInfo;
	tnatd.pfnWriteData		= NULL;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.1.1.16	Peer GetGroupInfo parameter validation
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.1.1.16";
	tnatd.pszName			= "Peer GetGroupInfo parameter validation";
	tnatd.pszDescription	= "Peer GetGroupInfo parameter validation";
	tnatd.pszInputDataHelp	= NULL;

	tnatd.iNumMachines		= 1;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST | TNTCO_SUBTEST
								| TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= NULL;
	tnatd.pfnGetInputData	= NULL;
	tnatd.pfnExecCase		= ParmVPeerExec_GetGroupInfo;
	tnatd.pfnWriteData		= NULL;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.1.1.17	Peer EnumPlayersAndGroups parameter validation
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.1.1.17";
	tnatd.pszName			= "Peer EnumPlayersAndGroups parameter validation";
	tnatd.pszDescription	= "Peer EnumPlayersAndGroups parameter validation";
	tnatd.pszInputDataHelp	= NULL;

	tnatd.iNumMachines		= 1;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST | TNTCO_SUBTEST
								| TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= NULL;
	tnatd.pfnGetInputData	= NULL;
	tnatd.pfnExecCase		= ParmVPeerExec_EnumPAndG;
	tnatd.pfnWriteData		= NULL;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.1.1.18	Peer EnumGroupMembers parameter validation
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.1.1.18";
	tnatd.pszName			= "Peer EnumGroupMembers parameter validation";
	tnatd.pszDescription	= "Peer EnumGroupMembers parameter validation";
	tnatd.pszInputDataHelp	= NULL;

	tnatd.iNumMachines		= 1;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST | TNTCO_SUBTEST
								| TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= NULL;
	tnatd.pfnGetInputData	= NULL;
	tnatd.pfnExecCase		= ParmVPeerExec_EnumGroupMembers;
	tnatd.pfnWriteData		= NULL;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.1.1.19	Peer SetPeerInfo parameter validation
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.1.1.19";
	tnatd.pszName			= "Peer SetPeerInfo parameter validation";
	tnatd.pszDescription	= "Peer SetPeerInfo parameter validation";
	tnatd.pszInputDataHelp	= NULL;

	tnatd.iNumMachines		= 1;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST | TNTCO_SUBTEST
								| TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= NULL;
	tnatd.pfnGetInputData	= NULL;
	tnatd.pfnExecCase		= ParmVPeerExec_SetPeerInfo;
	tnatd.pfnWriteData		= NULL;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.1.1.20	Peer GetPeerInfo parameter validation
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.1.1.20";
	tnatd.pszName			= "Peer GetPeerInfo parameter validation";
	tnatd.pszDescription	= "Peer GetPeerInfo parameter validation";
	tnatd.pszInputDataHelp	= NULL;

	tnatd.iNumMachines		= 1;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST | TNTCO_SUBTEST
								| TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= NULL;
	tnatd.pfnGetInputData	= NULL;
	tnatd.pfnExecCase		= ParmVPeerExec_GetPeerInfo;
	tnatd.pfnWriteData		= NULL;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.1.1.21	Peer GetPeerAddress parameter validation
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.1.1.21";
	tnatd.pszName			= "Peer GetPeerAddress parameter validation";
	tnatd.pszDescription	= "Peer GetPeerAddress parameter validation";
	tnatd.pszInputDataHelp	= NULL;

	tnatd.iNumMachines		= 1;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST | TNTCO_SUBTEST
								| TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= NULL;
	tnatd.pfnGetInputData	= NULL;
	tnatd.pfnExecCase		= ParmVPeerExec_GetPeerAddress;
	tnatd.pfnWriteData		= NULL;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.1.1.22	Peer GetLocalHostAddresses parameter validation
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.1.1.22";
	tnatd.pszName			= "Peer GetLocalHostAddresses parameter validation";
	tnatd.pszDescription	= "Peer GetLocalHostAddresses parameter validation";
	tnatd.pszInputDataHelp	= NULL;

	tnatd.iNumMachines		= 1;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST | TNTCO_SUBTEST
								| TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= NULL;
	tnatd.pfnGetInputData	= NULL;
	tnatd.pfnExecCase		= ParmVPeerExec_GetLHostAddresses;
	tnatd.pfnWriteData		= NULL;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.1.1.23	Peer Close parameter validation
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.1.1.23";
	tnatd.pszName			= "Peer Close parameter validation";
	tnatd.pszDescription	= "Peer Close parameter validation";
	tnatd.pszInputDataHelp	= NULL;

	tnatd.iNumMachines		= 1;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST | TNTCO_SUBTEST
								| TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= NULL;
	tnatd.pfnGetInputData	= NULL;
	tnatd.pfnExecCase		= ParmVPeerExec_Close;
	tnatd.pfnWriteData		= NULL;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.1.1.24	Peer EnumHosts parameter validation
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.1.1.24";
	tnatd.pszName			= "Peer EnumHosts parameter validation";
	tnatd.pszDescription	= "Peer EnumHosts parameter validation";
	tnatd.pszInputDataHelp	= NULL;

	tnatd.iNumMachines		= 1;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST | TNTCO_SUBTEST
								| TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= NULL;
	tnatd.pfnGetInputData	= NULL;
	tnatd.pfnExecCase		= ParmVPeerExec_EnumHosts;
	tnatd.pfnWriteData		= NULL;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.1.1.25	Peer DestroyPeer parameter validation
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.1.1.25";
	tnatd.pszName			= "Peer DestroyPeer parameter validation";
	tnatd.pszDescription	= "Peer DestroyPeer parameter validation";
	tnatd.pszInputDataHelp	= NULL;

	tnatd.iNumMachines		= 1;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST | TNTCO_SUBTEST
								| TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= NULL;
	tnatd.pfnGetInputData	= NULL;
	tnatd.pfnExecCase		= ParmVPeerExec_DestroyPeer;
	tnatd.pfnWriteData		= NULL;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.1.1.26	Peer ReturnBuffer parameter validation
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.1.1.26";
	tnatd.pszName			= "Peer ReturnBuffer parameter validation";
	tnatd.pszDescription	= "Peer ReturnBuffer parameter validation";
	tnatd.pszInputDataHelp	= NULL;

	tnatd.iNumMachines		= 1;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST | TNTCO_SUBTEST
								| TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= NULL;
	tnatd.pfnGetInputData	= NULL;
	tnatd.pfnExecCase		= ParmVPeerExec_Return;
	tnatd.pfnWriteData		= NULL;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.1.1.27	Peer GetPlayerContext parameter validation
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.1.1.27";
	tnatd.pszName			= "Peer GetPlayerContext parameter validation";
	tnatd.pszDescription	= "Peer GetPlayerContext parameter validation";
	tnatd.pszInputDataHelp	= NULL;

	tnatd.iNumMachines		= 1;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST | TNTCO_SUBTEST
								| TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= NULL;
	tnatd.pfnGetInputData	= NULL;
	tnatd.pfnExecCase		= ParmVPeerExec_GetPlayerContext;
	tnatd.pfnWriteData		= NULL;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.1.1.28	Peer GetGroupContext parameter validation
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.1.1.28";
	tnatd.pszName			= "Peer GetGroupContext parameter validation";
	tnatd.pszDescription	= "Peer GetGroupContext parameter validation";
	tnatd.pszInputDataHelp	= NULL;

	tnatd.iNumMachines		= 1;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST | TNTCO_SUBTEST
								| TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= NULL;
	tnatd.pfnGetInputData	= NULL;
	tnatd.pfnExecCase		= ParmVPeerExec_GetGroupContext;
	tnatd.pfnWriteData		= NULL;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.1.1.29	Peer GetCaps parameter validation
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.1.1.29";
	tnatd.pszName			= "Peer GetCaps parameter validation";
	tnatd.pszDescription	= "Peer GetCaps parameter validation";
	tnatd.pszInputDataHelp	= NULL;

	tnatd.iNumMachines		= 1;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST | TNTCO_SUBTEST
								| TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= NULL;
	tnatd.pfnGetInputData	= NULL;
	tnatd.pfnExecCase		= ParmVPeerExec_GetCaps;
	tnatd.pfnWriteData		= NULL;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.1.1.30	Peer SetCaps parameter validation
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.1.1.30";
	tnatd.pszName			= "Peer SetCaps parameter validation";
	tnatd.pszDescription	= "Peer SetCaps parameter validation";
	tnatd.pszInputDataHelp	= NULL;

	tnatd.iNumMachines		= 1;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST | TNTCO_SUBTEST
								| TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= NULL;
	tnatd.pfnGetInputData	= NULL;
	tnatd.pfnExecCase		= ParmVPeerExec_SetCaps;
	tnatd.pfnWriteData		= NULL;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.1.1.31	Peer SetSPCaps parameter validation
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.1.1.31";
	tnatd.pszName			= "Peer SetSPCaps parameter validation";
	tnatd.pszDescription	= "Peer SetSPCaps parameter validation";
	tnatd.pszInputDataHelp	= NULL;

	tnatd.iNumMachines		= 1;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST | TNTCO_SUBTEST
								| TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= NULL;
	tnatd.pfnGetInputData	= NULL;
	tnatd.pfnExecCase		= ParmVPeerExec_SetSPCaps;
	tnatd.pfnWriteData		= NULL;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.1.1.32	Peer GetSPCaps parameter validation
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.1.1.32";
	tnatd.pszName			= "Peer GetSPCaps parameter validation";
	tnatd.pszDescription	= "Peer GetSPCaps parameter validation";
	tnatd.pszInputDataHelp	= NULL;

	tnatd.iNumMachines		= 1;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST | TNTCO_SUBTEST
								| TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= NULL;
	tnatd.pfnGetInputData	= NULL;
	tnatd.pfnExecCase		= ParmVPeerExec_GetSPCaps;
	tnatd.pfnWriteData		= NULL;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.1.1.33	Peer GetConnectionInfo parameter validation
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.1.1.33";
	tnatd.pszName			= "Peer GetConnectionInfo parameter validation";
	tnatd.pszDescription	= "Peer GetConnectionInfo parameter validation";
	tnatd.pszInputDataHelp	= NULL;

	tnatd.iNumMachines		= 1;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST | TNTCO_SUBTEST
								| TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= NULL;
	tnatd.pfnGetInputData	= NULL;
	tnatd.pfnExecCase		= ParmVPeerExec_GetConnInfo;
	tnatd.pfnWriteData		= NULL;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.1.1.34	Peer RegisterLobby parameter validation
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.1.1.34";
	tnatd.pszName			= "Peer RegisterLobby parameter validation";
	tnatd.pszDescription	= "Peer RegisterLobby parameter validation";
	tnatd.pszInputDataHelp	= NULL;

	tnatd.iNumMachines		= 1;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST | TNTCO_SUBTEST
								| TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= NULL;
	tnatd.pfnGetInputData	= NULL;
	tnatd.pfnExecCase		= ParmVPeerExec_RegLobby;
	tnatd.pfnWriteData		= NULL;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.1.1.35	Peer TerminateSession parameter validation
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.1.1.35";
	tnatd.pszName			= "Peer TerminateSession parameter validation";
	tnatd.pszDescription	= "Peer TerminateSession parameter validation";
	tnatd.pszInputDataHelp	= NULL;

	tnatd.iNumMachines		= 1;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST | TNTCO_SUBTEST
								| TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= NULL;
	tnatd.pfnGetInputData	= NULL;
	tnatd.pfnExecCase		= ParmVPeerExec_Terminate;
	tnatd.pfnWriteData		= NULL;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubGroup);


	return (S_OK);
} // ParmVPeerLoadTestTable
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
*/





#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVPeerExec_CreateQI()"
//==================================================================================
// ParmVPeerExec_CreateQI
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.1.1 - Peer DirectPlay8Create and QueryInterface parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVPeerExec_CreateQI(HANDLE hLog)
{
	CTNSystemResult			sr;
	CTNTestResult			tr;
	PWRAPDP8PEER			pDP8Peer = NULL;



	BEGIN_TESTCASE
	{
		pDP8Peer = new CWrapDP8Peer(hLog);
		if (pDP8Peer == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("DirectPlay8Creating a DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = DirectPlay8Create(IID_IDirectPlay8Peer, (LPVOID *) &pDP8Peer->m_pDP8Peer, NULL);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "DirectPlay8Creating a DirectPlay8Peer object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't DirectPlay8Create)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Peer);
		pDP8Peer = NULL;

		FINAL_SUCCESS;
	}
	END_TESTCASE


	if (pDP8Peer != NULL)
	{
		delete (pDP8Peer);
		pDP8Peer = NULL;
	} // end if (have peer object)

	return (sr);
} // ParmVPeerExec_CreateQI
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVPeerExec_Init()"
//==================================================================================
// ParmVPeerExec_Init
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.1.2 - Peer Initialize parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVPeerExec_Init(HANDLE hLog)
{
	CTNSystemResult		sr;
	CTNTestResult		tr;
	PWRAPDP8PEER		pDP8Peer = NULL;



	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Peer = new CWrapDP8Peer(hLog);
		if (pDP8Peer == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8Peer->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Initializing with NULL context, handler, 0 flags using C++ macro");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = IDirectPlay8Peer_Initialize(pDP8Peer->m_pDP8Peer, NULL, NULL, 0);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Initializing with NULL context, handler, 0 flags using C++ macro didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Initializing with NULL context, handler, 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Initialize(NULL, NULL, 0);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Initializing with NULL context, handler, 0 flags didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Initializing with NULL context, invalid flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Initialize(NULL, ParmVNoMessagesDPNMessageHandler, 0x666);
		if (tr != DPNERR_INVALIDFLAGS)
		{
			DPTEST_FAIL(hLog, "Initializing with NULL context, invalid flags didn't return expected error INVALIDFLAGS!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Initializing with 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Initialize(NULL, ParmVNoMessagesDPNMessageHandler, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Initializing with context, 0 flags failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Initializing with 0 flags again");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Initialize(NULL, ParmVNoMessagesDPNMessageHandler, 0);
		if (tr != DPNERR_ALREADYINITIALIZED)
		{
			DPTEST_FAIL(hLog, "Initializing with context, 0 flags again didn't return expected error ALREADYINITIALIZED!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)
*/


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Re-initializing with 0 flags after init and close");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Initialize(NULL, ParmVNoMessagesDPNMessageHandler, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Re-initializing with 0 flags after init and close failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Peer);
		pDP8Peer = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE


	if (pDP8Peer != NULL)
	{
		delete (pDP8Peer);
		pDP8Peer = NULL;
	} // end if (have peer object)


	return (sr);
} // ParmVPeerExec_Init
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVPeerExec_EnumSPs()"
//==================================================================================
// ParmVPeerExec_EnumSPs
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.1.3 - Peer EnumServiceProviders parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVPeerExec_EnumSPs(HANDLE hLog)
{
	CTNSystemResult				sr;
	CTNTestResult				tr;
	PWRAPDP8PEER				pDP8Peer = NULL;
	DWORD						dwSPBufferSize;
	DWORD						dwExpectedSPBufferSize;
	DWORD						dwNumSPs;
	DWORD						dwExpectedNumSPs;
	PDPN_SERVICE_PROVIDER_INFO	pdpnspi = NULL;



	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Peer = new CWrapDP8Peer(hLog);
		if (pDP8Peer == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8Peer->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enumerating service providers with all NULLs and 0 flags using C++ macro");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = IDirectPlay8Peer_EnumServiceProviders(pDP8Peer->m_pDP8Peer, NULL, NULL,
													NULL, NULL, NULL, 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Enumerating service providers with all NULLs and 0 flags using C++ macro didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum service providers)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enumerating service providers with all NULLs and 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_EnumServiceProviders(NULL, NULL, NULL, NULL, NULL, 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Enumerating service providers with all NULLs and 0 flags didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum service providers)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enumerating service providers with NULL GUIDs, NULL buffer, NULL size, and 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwNumSPs = 0;

		tr = pDP8Peer->DP8P_EnumServiceProviders(NULL, NULL, NULL, NULL, &dwNumSPs, 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Enumerating service providers with NULL GUIDs, NULL buffer, NULL size, and 0 flags didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum service providers)

		if (dwNumSPs != 0)
		{
			DPTEST_FAIL(hLog, "Number of SPs modified (%u != 0)!", 1, dwNumSPs);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (count modified)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enumerating service providers with NULL GUIDs, NULL buffer, NULL count, and 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwSPBufferSize = 0;

		tr = pDP8Peer->DP8P_EnumServiceProviders(NULL, NULL, NULL, &dwSPBufferSize, NULL, 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Enumerating service providers with NULL GUIDs, NULL buffer, NULL count, and 0 flags didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum service providers)

		if (dwSPBufferSize != 0)
		{
			DPTEST_FAIL(hLog, "Buffer size modified (%u != 0)!", 1, dwSPBufferSize);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (size modified)
*/


/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enumerating service providers with NULL GUIDs, NULL buffer, and invalid flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwSPBufferSize = 0;
		dwNumSPs = 0;

		tr = pDP8Peer->DP8P_EnumServiceProviders(NULL, NULL, NULL, &dwSPBufferSize,
												&dwNumSPs, 0x666);
		if (tr != DPNERR_INVALIDFLAGS)
		{
			DPTEST_FAIL(hLog, "Enumerating service providers with NULL GUIDs, NULL buffer, and invalid flags didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum service providers)

		if (dwSPBufferSize != 0)
		{
			DPTEST_FAIL(hLog, "Buffer size modified (%u != 0)!", 1, dwSPBufferSize);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (size modified)

		if (dwNumSPs != 0)
		{
			DPTEST_FAIL(hLog, "Number of SPs modified (%u != 0)!", 1, dwNumSPs);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (count modified)
*/


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Initializing with NULL context, 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Initialize(NULL, ParmVNoMessagesDPNMessageHandler, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Initializing with NULL context, 0 flags failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enumerating service providers with NULL GUIDs, NULL buffer, and 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwSPBufferSize = 0;
		// We expect to see at least the IP Service Provider.  We could technically
		// make sure there's room for the string, too, but that would have to be
		// localized.
		dwExpectedSPBufferSize = sizeof (DPN_SERVICE_PROVIDER_INFO);
		dwNumSPs = 0;

		tr = pDP8Peer->DP8P_EnumServiceProviders(NULL, NULL, NULL, &dwSPBufferSize,
												&dwNumSPs, 0);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Enumerating service providers with NULL GUIDs, NULL buffer, and 0 flags didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum service providers)

		if (dwSPBufferSize <= dwExpectedSPBufferSize)
		{
			DPTEST_FAIL(hLog, "Buffer size smaller than expected (%u <= %u)!",
				2, dwSPBufferSize, dwExpectedSPBufferSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (size not expected)

		if (dwNumSPs < 1)
		{
			DPTEST_FAIL(hLog, "Number of SPs not expected (%u < 1)!", 1, dwNumSPs);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (count not expected)



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enumerating service providers with NULL GUIDs, NULL buffer, non-zero size, and 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwSPBufferSize = 12345;
		dwNumSPs = 0;

		tr = pDP8Peer->DP8P_EnumServiceProviders(NULL, NULL, NULL, &dwSPBufferSize,
												&dwNumSPs, 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Enumerating service providers with NULL GUIDs, NULL buffer, non-zero size, and 0 flags didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum service providers)

		if (dwSPBufferSize != 12345)
		{
			DPTEST_FAIL(hLog, "Buffer size modified (%u != 12345)!", 1, dwSPBufferSize);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (size modified)

		if (dwNumSPs != 0)
		{
			DPTEST_FAIL(hLog, "Number of SPs modified (%u != 0)!", 1, dwNumSPs);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (count modified)
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enumerating service providers with NULL GUIDs, NULL buffer, non-zero count, and 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwSPBufferSize = 0;
		//dwExpectedSPBufferSize = above;
		dwNumSPs = 12345;

		tr = pDP8Peer->DP8P_EnumServiceProviders(NULL, NULL, NULL, &dwSPBufferSize,
												&dwNumSPs, 0);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Enumerating service providers with NULL GUIDs, NULL buffer, non-zero count, and 0 flags didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum service providers)

		if (dwSPBufferSize <= dwExpectedSPBufferSize)
		{
			DPTEST_FAIL(hLog, "Buffer size smaller than expected (%u <= %u)!",
				2, dwSPBufferSize, dwExpectedSPBufferSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (size not expected)

		if (dwNumSPs < 1)
		{
			DPTEST_FAIL(hLog, "Number of SPs not expected (%u < 1)!", 1, dwNumSPs);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (count not expected)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enumerating service providers with NULL GUIDs, NULL buffer, and 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwSPBufferSize = 0;
		//dwExpectedSPBufferSize = above;
		dwNumSPs = 0;

		tr = pDP8Peer->DP8P_EnumServiceProviders(NULL, NULL, NULL, &dwSPBufferSize,
												&dwNumSPs, 0);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Enumerating service providers with NULL GUIDs, NULL buffer, and 0 flags didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum service providers)

		if (dwSPBufferSize <= dwExpectedSPBufferSize)
		{
			DPTEST_FAIL(hLog, "Buffer size smaller than expected (%u <= %u)!",
				2, dwSPBufferSize, dwExpectedSPBufferSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (size not expected)

		if (dwNumSPs < 1)
		{
			DPTEST_FAIL(hLog, "Number of SPs not expected (%u < 1)!", 1, dwNumSPs);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (count not expected)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enumerating service providers with NULL GUIDs, 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		LOCALALLOC_OR_THROW(PDPN_SERVICE_PROVIDER_INFO, pdpnspi,
							dwSPBufferSize + BUFFERPADDING_SIZE);

		FillWithDWord(((PBYTE) pdpnspi) + dwSPBufferSize, BUFFERPADDING_SIZE,
					DONT_TOUCH_MEMORY_PATTERN);

		// Expect to get the same values again
		dwExpectedSPBufferSize = dwSPBufferSize;
		dwExpectedNumSPs = dwNumSPs;

		dwNumSPs = 0;

		tr = pDP8Peer->DP8P_EnumServiceProviders(NULL, NULL, pdpnspi, &dwSPBufferSize,
												&dwNumSPs, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Enumerating service providers with NULL GUIDs, and 0 flags failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum service providers)

		if (dwSPBufferSize != dwExpectedSPBufferSize)
		{
			DPTEST_FAIL(hLog, "Buffer size not expected (%u != %u)!",
				2, dwSPBufferSize, dwExpectedSPBufferSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (size not expected)

		if (dwNumSPs != dwExpectedNumSPs)
		{
			DPTEST_FAIL(hLog, "Number of SPs not expected (%u != %u)!",
				2, dwNumSPs, dwExpectedNumSPs);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (count not expected)

#pragma TODO(vanceo, "Verify TCP/IP is in results")

		// Make sure the buffer wasn't overrun.
		if (! IsFilledWithDWord(((PBYTE) pdpnspi) + dwSPBufferSize, BUFFERPADDING_SIZE, DONT_TOUCH_MEMORY_PATTERN))
		{
			DPTEST_FAIL(hLog, "Data was written beyond end of buffer!", 0);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (not still filled with pattern)

		SAFE_LOCALFREE(pdpnspi);
		pdpnspi = NULL;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enumerating invalid SP GUID devices");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwSPBufferSize = 0;
		dwNumSPs = 0;

		tr = pDP8Peer->DP8P_EnumServiceProviders(&GUID_UNKNOWN, NULL, NULL,
												&dwSPBufferSize, &dwNumSPs, 0);
		if (tr != DPNERR_DOESNOTEXIST)
		{
			if(tr == DPNERR_UNSUPPORTED)
			{
				DPTEST_FAIL(hLog, "Xbox bug 1557 occurred!", 0);
				fPassed = FALSE;
			}
			else
			{
				DPTEST_FAIL(hLog, "Enumerating invalid SP GUID devices didn't return expected error DOESNOTEXIST!", 0);
				THROW_TESTRESULT;
			}
		} // end if (couldn't enum service providers)

		if (dwSPBufferSize != 0)
		{
			DPTEST_FAIL(hLog, "Buffer size not expected (%u != 0)!", 1, dwSPBufferSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (size not expected)

		if (dwNumSPs != 0)
		{
			DPTEST_FAIL(hLog, "Number of SPs modified (%u != 0)!", 1, dwNumSPs);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (count modified)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enumerating TCP/IP devices with invalid app GUID");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		//dwExpectedSPBufferSize = ?;

		tr = pDP8Peer->DP8P_EnumServiceProviders(&CLSID_DP8SP_TCPIP, &GUID_UNKNOWN,
												NULL, &dwSPBufferSize, &dwNumSPs, 0);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			if(tr == DPNERR_UNSUPPORTED)
			{
				DPTEST_FAIL(hLog, "Xbox bug 1557 occurred!", 0);
				fPassed = FALSE;
			}
			else
			{
				DPTEST_FAIL(hLog, "Enumerating TCP/IP devices with invalid app GUID didn't return expected error BUFFERTOOSMALL!", 0);
				THROW_TESTRESULT;
			}
		} // end if (couldn't enum service providers)

#pragma TODO(vanceo, "What do we expect?")
		/*
		if (dwSPBufferSize != dwExpectedSPBufferSize)
		{
			DPTEST_FAIL(hLog, "Buffer size not expected (%u != %u)!",
				2, dwSPBufferSize, dwExpectedSPBufferSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (size not expected)

		if (dwNumSPs != 4)
		{
			DPTEST_FAIL(hLog, "Number of SPs modified (%u != 4)!", 1, dwNumSPs);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (count modified)
		*/




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enumerating TCP/IP devices with NULL GUIDs, NULL buffer, and 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwSPBufferSize = 0;
		//dwExpectedSPBufferSize = ?;
		dwNumSPs = 0;

		tr = pDP8Peer->DP8P_EnumServiceProviders(&CLSID_DP8SP_TCPIP, NULL, NULL,
												&dwSPBufferSize, &dwNumSPs, 0);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			if(tr == DPNERR_UNSUPPORTED)
			{
				DPTEST_FAIL(hLog, "Xbox bug 1557 occurred!", 0);
				fPassed = FALSE;
			}
			else
			{
				DPTEST_FAIL(hLog, "Enumerating TCP/IP devices with NULL GUIDs, NULL buffer, and 0 flags didn't return expected error BUFFERTOOSMALL!", 0);
				THROW_TESTRESULT;
			}
		} // end if (couldn't enum service providers)

#pragma TODO(vanceo, "What do we expect?")
		/*
		if (dwSPBufferSize != dwExpectedSPBufferSize)
		{
			DPTEST_FAIL(hLog, "Buffer size not expected (%u != %u)!",
				2, dwSPBufferSize, dwExpectedSPBufferSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (size not expected)

		if (dwNumSPs != 4)
		{
			DPTEST_FAIL(hLog, "Number of SPs modified (%u != 4)!", 1, dwNumSPs);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (count modified)
		*/




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enumerating TCP/IP devices with NULL GUIDs, 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		LOCALALLOC_OR_THROW(PDPN_SERVICE_PROVIDER_INFO, pdpnspi,
							dwSPBufferSize + BUFFERPADDING_SIZE);

		FillWithDWord(((PBYTE) pdpnspi) + dwSPBufferSize, BUFFERPADDING_SIZE,
					DONT_TOUCH_MEMORY_PATTERN);

		// Expect to get the same values again
		dwExpectedSPBufferSize = dwSPBufferSize;
		dwExpectedNumSPs = dwNumSPs;

		dwNumSPs = 0;

		tr = pDP8Peer->DP8P_EnumServiceProviders(&CLSID_DP8SP_TCPIP, NULL, pdpnspi,
												&dwSPBufferSize, &dwNumSPs, 0);
		if (tr != DPN_OK)
		{
			if(tr == DPNERR_UNSUPPORTED)
			{
				DPTEST_FAIL(hLog, "Xbox bug 1557 occurred!", 0);
				fPassed = FALSE;
			}
			else
			{
				DPTEST_FAIL(hLog, "Enumerating TCP/IP devices with NULL GUIDs, and 0 flags failed!", 0);
				THROW_TESTRESULT;
			}
		} // end if (couldn't enum service providers)

		if (dwSPBufferSize != dwExpectedSPBufferSize)
		{
			if(tr == DPNERR_UNSUPPORTED)
			{
				DPTEST_FAIL(hLog, "Xbox bug 1557 occurred!", 0);
				fPassed = FALSE;
			}
			else
			{
				DPTEST_FAIL(hLog, "Buffer size not expected (%u != %u)!",
					2, dwSPBufferSize, dwExpectedSPBufferSize);
				SETTHROW_TESTRESULT(ERROR_NO_MATCH);
			}
		} // end if (size not expected)
		
		if (dwNumSPs != dwExpectedNumSPs)
		{
			if(tr == DPNERR_UNSUPPORTED)
			{
				DPTEST_FAIL(hLog, "Xbox bug 1557 occurred!", 0);
				fPassed = FALSE;
			}
			else
			{
				DPTEST_FAIL(hLog, "Number of SPs not expected (%u != %u)!",
					2, dwNumSPs, dwExpectedNumSPs);
				SETTHROW_TESTRESULT(ERROR_NO_MATCH);
			}
		} // end if (count not expected)

#pragma TODO(vanceo, "Verify results")

		// Make sure the buffer wasn't overrun.
		if (! IsFilledWithDWord(((PBYTE) pdpnspi) + dwSPBufferSize, BUFFERPADDING_SIZE, DONT_TOUCH_MEMORY_PATTERN))
		{
			DPTEST_FAIL(hLog, "Data was written beyond end of buffer!", 0);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (not still filled with pattern)

		SAFE_LOCALFREE(pdpnspi);
		pdpnspi = NULL;



/* XBOX - IPX not supported
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enumerating IPX devices with NULL GUIDs, NULL buffer, and 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwSPBufferSize = 0;
		//dwExpectedSPBufferSize = ?;
		dwNumSPs = 0;

		tr = pDP8Peer->DP8P_EnumServiceProviders(&CLSID_DP8SP_IPX, NULL, NULL,
												&dwSPBufferSize, &dwNumSPs, 0);

		// If IPX is not installed, then this will return UNSUPPORTED.
		if ((tr != DPNERR_BUFFERTOOSMALL) && (tr != DPNERR_UNSUPPORTED))
		{
			DPTEST_FAIL(hLog, "Enumerating IPX devices with NULL GUIDs, NULL buffer, and 0 flags didn't return expected error BUFFERTOOSMALL or UNSUPPORTED!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum service providers)

#pragma TODO(vanceo, "What do we expect?")
		if (dwSPBufferSize != dwExpectedSPBufferSize)
		{
			DPTEST_FAIL(hLog, "Buffer size not expected (%u != %u)!",
				2, dwSPBufferSize, dwExpectedSPBufferSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (size not expected)

		if (dwNumSPs != 4)
		{
			DPTEST_FAIL(hLog, "Number of SPs modified (%u != 4)!", 1, dwNumSPs);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (count modified)
*/



/* XBOX - MODEM not supported
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enumerating modem devices with NULL GUIDs, NULL buffer, and 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwSPBufferSize = 0;
		//dwExpectedSPBufferSize = ?;
		dwNumSPs = 0;

		tr = pDP8Peer->DP8P_EnumServiceProviders(&CLSID_DP8SP_MODEM, NULL, NULL,
												&dwSPBufferSize, &dwNumSPs, 0);

		// If there aren't any modems installed, then this will return UNSUPPORTED.
		if ((tr != DPNERR_BUFFERTOOSMALL) && (tr != DPNERR_UNSUPPORTED))
		{
			DPTEST_FAIL(hLog, "Enumerating modem devices with NULL GUIDs, NULL buffer, and 0 flags didn't return expected error BUFFERTOOSMALL or UNSUPPORTED!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum service providers)

#pragma TODO(vanceo, "What do we expect?")
		if (dwSPBufferSize != dwExpectedSPBufferSize)
		{
			DPTEST_FAIL(hLog, "Buffer size not expected (%u != %u)!",
				2, dwSPBufferSize, dwExpectedSPBufferSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (size not expected)

		if (dwNumSPs != 4)
		{
			DPTEST_FAIL(hLog, "Number of SPs modified (%u != 4)!", 1, dwNumSPs);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (count modified)
*/




/* XBOX - SERIAL not supported
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enumerating serial devices with NULL GUIDs, NULL buffer, and 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwSPBufferSize = 0;
		//dwExpectedSPBufferSize = ?;
		dwNumSPs = 0;

		tr = pDP8Peer->DP8P_EnumServiceProviders(&CLSID_DP8SP_SERIAL, NULL, NULL,
												&dwSPBufferSize, &dwNumSPs, 0);

		// If there aren't any modems installed, then this will return UNSUPPORTED.
		if ((tr != DPNERR_BUFFERTOOSMALL) && (tr != DPNERR_UNSUPPORTED))
		{
			DPTEST_FAIL(hLog, "Enumerating serial devices with NULL GUIDs, NULL buffer, and 0 flags didn't return expected error BUFFERTOOSMALL or UNSUPPORTED!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum service providers)

#pragma TODO(vanceo, "What do we expect?")
		if (dwSPBufferSize != dwExpectedSPBufferSize)
		{
			DPTEST_FAIL(hLog, "Buffer size not expected (%u != %u)!",
				2, dwSPBufferSize, dwExpectedSPBufferSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (size not expected)

		if (dwNumSPs != 4)
		{
			DPTEST_FAIL(hLog, "Number of SPs modified (%u != 4)!", 1, dwNumSPs);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (count modified)
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Peer);
		pDP8Peer = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE


	if (pDP8Peer != NULL)
	{
		delete (pDP8Peer);
		pDP8Peer = NULL;
	} // end if (have peer object)

	SAFE_LOCALFREE(pdpnspi);


	return (sr);
} // ParmVPeerExec_EnumSPs
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVPeerExec_Cancel()"
//==================================================================================
// ParmVPeerExec_Cancel
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.1.4 - Peer CancelAsyncOperation parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVPeerExec_Cancel(HANDLE hLog)
{
	CTNSystemResult			sr;
	CTNTestResult			tr;
	PWRAPDP8PEER			pDP8Peer = NULL;
	PARMVPCANCELCONTEXT		context;
	PDIRECTPLAY8ADDRESS		pDP8AddressHost = NULL;
	PDIRECTPLAY8ADDRESS		pDP8AddressDevice = NULL;
	DPN_APPLICATION_DESC	dpnad;
	HOSTENT *pHostent;
	WCHAR szLocalIPAddress[16];
	CHAR szLocalMacAddress[16], *szAnsiLocalIPAddress = NULL;
	DP_DOWORKLIST			DoWorkList;

	ZeroMemory(&DoWorkList, sizeof(DP_DOWORKLIST));

	ZeroMemory(&context, sizeof (PARMVPCANCELCONTEXT));


	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Peer = new CWrapDP8Peer(hLog);
		if (pDP8Peer == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8Peer->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating host DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (LPVOID *) &pDP8AddressHost, NULL);
		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't create host DirectPlay8Address object!", 0);
			THROW_SYSTEMRESULT;
		} // end if (create failed)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting host DirectPlay8Address SP to TCP/IP");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressHost->SetSP(&CLSID_DP8SP_TCPIP);

		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't set host DirectPlay8Address SP!", 0);
			THROW_TESTRESULT;
		} // end if (set SP failed)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Duplicating host DirectPlay8Address for a device address");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressHost->Duplicate(&pDP8AddressDevice);

		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't duplicate host DirectPlay8Address for a device address!", 0);
			THROW_TESTRESULT;
		} // end if (duplicate failed)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting remote address hostname to local machine");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// In order to run these tests, need to get the local address information
		// Start by getting the Mac address
		if(gethostname(szLocalMacAddress, sizeof(szLocalMacAddress)))
		{
			xLog(hLog, XLL_FAIL, "Couldn't retrieve local Mac address");
			SETTHROW_TESTRESULT(E_FAIL);
		}
		
		// Then get the IP address
		pHostent = NULL;
		if((pHostent = gethostbyname(szLocalMacAddress)) == NULL)
		{
			xLog(hLog, XLL_FAIL, "Couldn't retrieve IP information for local host");
			SETTHROW_TESTRESULT(E_FAIL);
		}
		
		szAnsiLocalIPAddress = inet_ntoa(*((IN_ADDR *)pHostent->h_addr));

		// Extract the IP address from the hostent stucture
		mbstowcs(szLocalIPAddress, szAnsiLocalIPAddress, strlen(szAnsiLocalIPAddress));
		szLocalIPAddress[strlen(szAnsiLocalIPAddress)] = 0;

		tr = pDP8AddressHost->AddComponent(DPNA_KEY_HOSTNAME,
											szLocalIPAddress,
											(wcslen(szLocalIPAddress) + 1) * sizeof(WCHAR),
											DPNA_DATATYPE_STRING);

		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't set remote address hostname to local machine!", 0);
			THROW_TESTRESULT;
		} // end if (add component failed)



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Cancelling async operation with NULL and 0 flags using C++ macro");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = IDirectPlay8Peer_CancelAsyncOperation(pDP8Peer->m_pDP8Peer, NULL, 0);
		if (tr != DPNERR_INVALIDHANDLE)
		{
			DPTEST_FAIL(hLog, "Cancelling async operation with NULL and 0 flags using C++ macro didn't return expected error INVALIDHANDLE!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cancel async operation)
*/


/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Cancelling async operation with NULL and 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_CancelAsyncOperation(NULL, 0);
		if (tr != DPNERR_INVALIDHANDLE)
		{
			DPTEST_FAIL(hLog, "Cancelling async operation with NULL and 0 flags didn't return expected error INVALIDHANDLE!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cancel async operation)
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Initializing with context, 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		context.hLog = hLog;

		tr = pDP8Peer->DP8P_Initialize(&context, ParmVPCancelDPNMessageHandler, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Initializing with context, 0 flags failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Starting async connect to self which would eventually complete with failure");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		CREATEEVENT_OR_THROW(context.hConnectCompleteEvent,
							NULL, FALSE, FALSE, NULL);

		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		//dpnad.dwFlags = 0;
		//dpnad.guidInstance = GUID_NULL;
		dpnad.guidApplication = GUID_PARMV_PEER_CANCEL;
		//dpnad.dwMaxPlayers = 0;
		//dpnad.dwCurrentPlayers = 0;
		//dpnad.pwszSessionName = NULL;
		//dpnad.pwszPassword = NULL;
		//dpnad.pvReservedData = NULL;
		//dpnad.dwReservedDataSize = 0;
		//dpnad.pvApplicationReservedData = NULL;
		//dpnad.dwApplicationReservedDataSize = 0;

		tr = pDP8Peer->DP8P_Connect(&dpnad, pDP8AddressHost, pDP8AddressDevice,
									NULL, NULL, NULL, 0,
									NULL, context.hConnectCompleteEvent,
									&(context.dpnhExpectedAsyncOp), 0);
		if (tr != (HRESULT) DPNSUCCESS_PENDING)
		{
			DPTEST_FAIL(hLog, "Couldn't start async connect to self which would eventually complete with failure!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't start connecting)

		if (context.dpnhExpectedAsyncOp == (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "No async operation handle was returned!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (handle was not set)

		if (context.dpnhExpectedAsyncOp == NULL)
		{
			DPTEST_FAIL(hLog, "Async operation handle returned is NULL!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (handle was set to NULL)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Cancelling invalid handle with 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_CancelAsyncOperation(0xABABABAB, 0);
		if (tr != DPNERR_INVALIDHANDLE)
		{
			DPTEST_FAIL(hLog, "Cancelling invalid handle with 0 flags didn't return expected error INVALIDHANDLE!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cancel async operation)



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Cancelling NULL handle with invalid flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_CancelAsyncOperation(NULL, 0x666);
		if (tr != DPNERR_INVALIDFLAGS)
		{
			DPTEST_FAIL(hLog, "Cancelling NULL handle with invalid flags didn't return expected error INVALIDFLAGS!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cancel async operation)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Cancelling valid connect handle with CONNECT flag");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_CancelAsyncOperation(context.dpnhExpectedAsyncOp,
												DPNCANCEL_CONNECT);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Cancelling valid connect handle with CONNECT flag didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cancel async operation)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Cancelling valid connect handle with ALL_OPERATIONS flag");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_CancelAsyncOperation(context.dpnhExpectedAsyncOp,
												DPNCANCEL_ALL_OPERATIONS);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Cancelling valid connect handle with ALL_OPERATIONS flag didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cancel async operation)
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Cancelling valid connect handle");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Allow the connect to complete.
		context.hrExpectedResult = DPNERR_USERCANCEL;
		context.fConnectCanComplete = TRUE;

		tr = pDP8Peer->DP8P_CancelAsyncOperation(context.dpnhExpectedAsyncOp, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Cancelling valid connect handle failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cancel async operation)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for connect to complete");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 1;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, context.hConnectCompleteEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any wierd connects from completing.
		context.fConnectCanComplete = FALSE;

#ifdef DEBUG
		// Make sure the connect completed (how else would we get here?).
		if (! context.fCompleted)
		{
			DPTEST_FAIL(hLog, "Cancelling connect didn't cause it to complete!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (connect didn't complete)
#endif // DEBUG

		// Reset the context.
		context.dpnhExpectedAsyncOp = (DPNHANDLE) 0x666;
		context.fCompleted = FALSE;

		


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Starting async connect to self which would eventually complete with failure");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		//dpnad.dwFlags = 0;
		//dpnad.guidInstance = GUID_NULL;
		dpnad.guidApplication = GUID_PARMV_PEER_CANCEL;
		//dpnad.dwMaxPlayers = 0;
		//dpnad.dwCurrentPlayers = 0;
		//dpnad.pwszSessionName = NULL;
		//dpnad.pwszPassword = NULL;
		//dpnad.pvReservedData = NULL;
		//dpnad.dwReservedDataSize = 0;
		//dpnad.pvApplicationReservedData = NULL;
		//dpnad.dwApplicationReservedDataSize = 0;

		tr = pDP8Peer->DP8P_Connect(&dpnad, pDP8AddressHost, pDP8AddressDevice,
									NULL, NULL, NULL, 0,
									NULL, context.hConnectCompleteEvent,
									&(context.dpnhExpectedAsyncOp), 0);
		if (tr != (HRESULT) DPNSUCCESS_PENDING)
		{
			DPTEST_FAIL(hLog, "Couldn't start async connect to self which would eventually complete with failure!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't start connecting)

		if (context.dpnhExpectedAsyncOp == NULL)
		{
			DPTEST_FAIL(hLog, "Connect didn't return a valid operation handle!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get valid handle)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Cancelling ENUMs");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_CancelAsyncOperation(NULL, DPNCANCEL_ENUM);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Cancelling ENUMs failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cancel async operation)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Cancelling CONNECTs");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Allow the connect to complete.
		context.hrExpectedResult = DPNERR_USERCANCEL;
		context.fConnectCanComplete = TRUE;

		tr = pDP8Peer->DP8P_CancelAsyncOperation(NULL, DPNCANCEL_CONNECT);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Cancelling CONNECTs failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cancel async operation)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for connect to complete");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 1;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, context.hConnectCompleteEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any wierd connects from completing.
		context.fConnectCanComplete = FALSE;

#ifdef DEBUG
		// Make sure the connect completed (how else would we get here?).
		if (! context.fCompleted)
		{
			DPTEST_FAIL(hLog, "Cancelling connect didn't cause it to complete!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (connect didn't complete)
#endif // DEBUG

		// Reset the context.
		CloseHandle(context.hConnectCompleteEvent);
		context.hConnectCompleteEvent = NULL;

		context.dpnhExpectedAsyncOp = (DPNHANDLE) 0x666;
		context.fCompleted = FALSE;




#pragma TODO(vanceo, "Cancel send")




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)






		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Peer);
		pDP8Peer = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE


	if (pDP8Peer != NULL)
	{
		delete (pDP8Peer);
		pDP8Peer = NULL;
	} // end if (have peer object)

	SAFE_RELEASE(pDP8AddressHost);
	SAFE_RELEASE(pDP8AddressDevice);
	SAFE_CLOSEHANDLE(context.hConnectCompleteEvent);
	ClearDoWorkList(&DoWorkList);

	return (sr);
} // ParmVPeerExec_Cancel
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVPeerExec_Connect()"
//==================================================================================
// ParmVPeerExec_Connect
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.1.5 - Peer Connect parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVPeerExec_Connect(HANDLE hLog)
{
	CTNSystemResult			sr;
	CTNTestResult			tr;
	PWRAPDP8PEER			pDP8Peer = NULL;
	PWRAPDP8PEER			pDP8PeerHost = NULL;
	PDIRECTPLAY8ADDRESS		pDP8AddressHost = NULL;
	PDIRECTPLAY8ADDRESS		pDP8AddressHostCompare = NULL;
	PDIRECTPLAY8ADDRESS		pDP8AddressDevice = NULL;
	DPN_APPLICATION_DESC	dpnad;
	DPN_APPLICATION_DESC	dpnadCompare;
	PARMVPCONNECTCONTEXT	hostcontext;
	PARMVPCONNECTCONTEXT	nonhostcontext;
	DPNHANDLE				dpnhConnect = 0x666;
	DPNHANDLE				dpnhDuplicate = 0x666;
	HOSTENT					*pHostent;
	DWORD					dwPort = 0;
	WCHAR					szLocalIPAddress[16];
	CHAR					szLocalMacAddress[16], *szAnsiLocalIPAddress = NULL;
	DP_DOWORKLIST			DoWorkList;

	ZeroMemory(&DoWorkList, sizeof(DP_DOWORKLIST));

	ZeroMemory(&hostcontext, sizeof (PARMVPCONNECTCONTEXT));
	hostcontext.fHost = TRUE;

	ZeroMemory(&nonhostcontext, sizeof (PARMVPCONNECTCONTEXT));
	//nonhostcontext.fHost = FALSE;


	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Peer = new CWrapDP8Peer(hLog);
		if (pDP8Peer == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8Peer->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating host DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (LPVOID *) &pDP8AddressHost, NULL);
		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't create host DirectPlay8Address object!", 0);
			THROW_SYSTEMRESULT;
		} // end if (create failed)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating device DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (LPVOID *) &pDP8AddressDevice, NULL);
		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't create device DirectPlay8Address object!", 0);
			THROW_SYSTEMRESULT;
		} // end if (create failed)





/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Connecting with all NULLs and 0 flags using C++ macro");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = IDirectPlay8Peer_Connect(pDP8Peer->m_pDP8Peer, NULL, NULL, NULL, NULL,
									NULL, NULL, 0, NULL, NULL, NULL, 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Connecting with all NULLs and 0 flags using C++ macro didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't connect)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Connecting with all NULLs and 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Connect(NULL, NULL, NULL, NULL, NULL, NULL, 0,
									NULL, NULL, NULL, 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Connecting with all NULLs and 0 flags didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't connect)
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Saving host address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressHost->Duplicate(&pDP8AddressHostCompare);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't duplicate host address object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't duplicate host address object)


/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Connecting with NULL app desc");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Connect(NULL,
									pDP8AddressHost,
									NULL,
									NULL,
									NULL,
									NULL,
									0,
									NULL,
									NULL,
									&dpnhConnect,
									0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Connecting with NULL app desc didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't connect)

		tr = pDP8AddressHost->IsEqual(pDP8AddressHostCompare);
		if (tr != DPNSUCCESS_EQUAL)
		{
			DPTEST_FAIL(hLog, "Device address object was modified (0x%08x != 0x%08x)!",
				2, pDP8AddressHost, pDP8AddressHostCompare);
			THROW_TESTRESULT;
		} // end if (addresses aren't equal)

		if (dpnhConnect != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async operation handle was touched (%x)!",
				1, dpnhConnect);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (handle was set)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Connecting with app desc of 0 size");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		//dpnad.dwSize = 0;
		//dpnad.dwFlags = 0;
		//dpnad.guidInstance = GUID_NULL;
		dpnad.guidApplication = GUID_PARMV_PEER_CONNECT;
		//dpnad.dwMaxPlayers = 0;
		//dpnad.dwCurrentPlayers = 0;
		//dpnad.pwszSessionName = NULL;
		//dpnad.pwszPassword = NULL;
		//dpnad.pvReservedData = NULL;
		//dpnad.dwReservedDataSize = 0;
		//dpnad.pvApplicationReservedData = NULL;
		//dpnad.dwApplicationReservedDataSize = 0;

		// Save what we're passing in to make sure it's not touched.
		CopyMemory(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC));

		tr = pDP8Peer->DP8P_Connect(&dpnad,
									pDP8AddressHost,
									NULL,
									NULL,
									NULL,
									NULL,
									0,
									NULL,
									NULL,
									&dpnhConnect,
									0);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Connecting with app desc of 0 size didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't connect)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		tr = pDP8AddressHost->IsEqual(pDP8AddressHostCompare);
		if (tr != DPNSUCCESS_EQUAL)
		{
			DPTEST_FAIL(hLog, "Device address object was modified (0x%08x != 0x%08x)!",
				2, pDP8AddressHost, pDP8AddressHostCompare);
			THROW_TESTRESULT;
		} // end if (addresses aren't equal)

		if (dpnhConnect != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async operation handle was touched (%x)!",
				1, dpnhConnect);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (handle was set)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Connecting with app desc of too-large size");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC) + 1;
		//dpnad.dwFlags = 0;
		//dpnad.guidInstance = GUID_NULL;
		dpnad.guidApplication = GUID_PARMV_PEER_CONNECT;
		//dpnad.dwMaxPlayers = 0;
		//dpnad.dwCurrentPlayers = 0;
		//dpnad.pwszSessionName = NULL;
		//dpnad.pwszPassword = NULL;
		//dpnad.pvReservedData = NULL;
		//dpnad.dwReservedDataSize = 0;
		//dpnad.pvApplicationReservedData = NULL;
		//dpnad.dwApplicationReservedDataSize = 0;

		// Save what we're passing in to make sure it's not touched.
		CopyMemory(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC));

		tr = pDP8Peer->DP8P_Connect(&dpnad,
									pDP8AddressHost,
									NULL,
									NULL,
									NULL,
									NULL,
									0,
									NULL,
									NULL,
									&dpnhConnect,
									0);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Connecting with app desc of too-large size didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't connect)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		tr = pDP8AddressHost->IsEqual(pDP8AddressHostCompare);
		if (tr != DPNSUCCESS_EQUAL)
		{
			DPTEST_FAIL(hLog, "Device address object was modified (0x%08x != 0x%08x)!",
				2, pDP8AddressHost, pDP8AddressHostCompare);
			THROW_TESTRESULT;
		} // end if (addresses aren't equal)

		if (dpnhConnect != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async operation handle was touched (%x)!",
				1, dpnhConnect);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (handle was set)
*/



#pragma TODO(vanceo, "Test these types of scenarios, even though they're accepted")
		/*
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Connecting with app desc using invalid flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		dpnad.dwFlags = 0x666;
		//dpnad.guidInstance = GUID_NULL;
		dpnad.guidApplication = GUID_PARMV_PEER_CONNECT;
		//dpnad.dwMaxPlayers = 0;
		//dpnad.dwCurrentPlayers = 0;
		//dpnad.pwszSessionName = NULL;
		//dpnad.pwszPassword = NULL;
		//dpnad.pvReservedData = NULL;
		//dpnad.dwReservedDataSize = 0;
		//dpnad.pvApplicationReservedData = NULL;
		//dpnad.dwApplicationReservedDataSize = 0;

		// Save what we're passing in to make sure it's not touched.
		CopyMemory(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC));

		tr = pDP8Peer->DP8P_Connect(&dpnad,
									pDP8AddressHost,
									NULL,
									NULL,
									NULL,
									NULL,
									0,
									NULL,
									NULL,
									&dpnhConnect,
									0);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Connecting with app desc using invalid flags didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't connect)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		tr = pDP8AddressHost->IsEqual(pDP8AddressHostCompare);
		if (tr != DPNSUCCESS_EQUAL)
		{
			DPTEST_FAIL(hLog, "Device address object was modified (0x%08x != 0x%08x)!",
				2, pDP8AddressHost, pDP8AddressHostCompare);
			THROW_TESTRESULT;
		} // end if (addresses aren't equal)

		if (dpnhConnect != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async operation handle was touched (%x)!",
				1, dpnhConnect);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (handle was set)
		*/


		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		//dpnad.dwFlags = 0;
		//dpnad.guidInstance = GUID_NULL;
		dpnad.guidApplication = GUID_PARMV_PEER_CONNECT;
		//dpnad.dwMaxPlayers = 0;
		//dpnad.dwCurrentPlayers = 0;
		//dpnad.pwszSessionName = NULL;
		//dpnad.pwszPassword = NULL;
		//dpnad.pvReservedData = NULL;
		//dpnad.dwReservedDataSize = 0;
		//dpnad.pvApplicationReservedData = NULL;
		//dpnad.dwApplicationReservedDataSize = 0;

		// Save what we're passing in to make sure it's not touched.
		CopyMemory(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC));



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Connecting with NULL host address");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Connect(&dpnad,
									NULL,
									NULL,
									NULL,
									NULL,
									NULL,
									0,
									NULL,
									NULL,
									&dpnhConnect,
									0);
		if (tr != DPNERR_INVALIDHOSTADDRESS)
		{
			DPTEST_FAIL(hLog, "Connecting with NULL host address didn't return expected error INVALIDHOSTADDRESS!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't connect)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		if (dpnhConnect != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async operation handle was touched (%x)!",
				1, dpnhConnect);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (handle was set)
*/

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting remote host address SP to TCP/IP");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressHost->SetSP(&CLSID_DP8SP_TCPIP);

		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't set remote host address SP!", 0);
			THROW_TESTRESULT;
		} // end if (set SP failed)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Saving new host address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8AddressHostCompare->Release();
		pDP8AddressHostCompare = NULL;

		tr = pDP8AddressHost->Duplicate(&pDP8AddressHostCompare);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't duplicate host address object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't duplicate host address object)

/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Connecting with non-NULL security desc");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Connect(&dpnad,
									pDP8AddressHost,
									NULL,
									(PDPN_SECURITY_DESC) ((DWORD_PTR) 0xABABABAB),
									NULL,
									NULL,
									0,
									NULL,
									NULL,
									&dpnhConnect,
									0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Connecting with non-NULL security desc didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't connect)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		tr = pDP8AddressHost->IsEqual(pDP8AddressHostCompare);
		if (tr != DPNSUCCESS_EQUAL)
		{
			DPTEST_FAIL(hLog, "Device address object was modified (0x%08x != 0x%08x)!",
				2, pDP8AddressHost, pDP8AddressHostCompare);
			THROW_TESTRESULT;
		} // end if (addresses aren't equal)

		if (dpnhConnect != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async operation handle was touched (%x)!",
				1, dpnhConnect);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (handle was set)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Connecting with non-NULL security credentials");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Connect(&dpnad,
									pDP8AddressHost,
									NULL,
									NULL,
									(PDPN_SECURITY_CREDENTIALS) ((DWORD_PTR) 0xABABABAB),
									NULL,
									0,
									NULL,
									NULL,
									&dpnhConnect,
									0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Connecting with non-NULL security credentials didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't connect)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		tr = pDP8AddressHost->IsEqual(pDP8AddressHostCompare);
		if (tr != DPNSUCCESS_EQUAL)
		{
			DPTEST_FAIL(hLog, "Device address object was modified (0x%08x != 0x%08x)!",
				2, pDP8AddressHost, pDP8AddressHostCompare);
			THROW_TESTRESULT;
		} // end if (addresses aren't equal)

		if (dpnhConnect != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async operation handle was touched (%x)!",
				1, dpnhConnect);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (handle was set)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Connecting asynchronously with NULL async op handle");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Connect(&dpnad,
									pDP8AddressHost,
									NULL,
									NULL,
									NULL,
									NULL,
									0,
									NULL,
									NULL,
									NULL,
									0);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Connecting asynchronously with NULL async op handle didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't connect)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		tr = pDP8AddressHost->IsEqual(pDP8AddressHostCompare);
		if (tr != DPNSUCCESS_EQUAL)
		{
			DPTEST_FAIL(hLog, "Device address object was modified (0x%08x != 0x%08x)!",
				2, pDP8AddressHost, pDP8AddressHostCompare);
			THROW_TESTRESULT;
		} // end if (addresses aren't equal)
*/


/* XBOX - SYNC operations not supported
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Connecting synchronously with async op handle");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Connect(&dpnad,
									pDP8AddressHost,
									NULL,
									NULL,
									NULL,
									NULL,
									0,
									NULL,
									NULL,
									&dpnhConnect,
									DPNCONNECT_SYNC);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Connecting synchronously with async op handle didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't connect)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		tr = pDP8AddressHost->IsEqual(pDP8AddressHostCompare);
		if (tr != DPNSUCCESS_EQUAL)
		{
			DPTEST_FAIL(hLog, "Device address object was modified (0x%08x != 0x%08x)!",
				2, pDP8AddressHost, pDP8AddressHostCompare);
			THROW_TESTRESULT;
		} // end if (addresses aren't equal)

		if (dpnhConnect != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async operation handle was touched (%x)!",
				1, dpnhConnect);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (handle was set)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Connecting with invalid flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Connect(&dpnad,
									pDP8AddressHost,
									NULL,
									NULL,
									NULL,
									NULL,
									0,
									NULL,
									NULL,
									&dpnhConnect,
									0x666);
		if (tr != DPNERR_INVALIDFLAGS)
		{
			DPTEST_FAIL(hLog, "Connecting with invalid flags didn't return expected error INVALIDFLAGS!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't connect)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		tr = pDP8AddressHost->IsEqual(pDP8AddressHostCompare);
		if (tr != DPNSUCCESS_EQUAL)
		{
			DPTEST_FAIL(hLog, "Device address object was modified (0x%08x != 0x%08x)!",
				2, pDP8AddressHost, pDP8AddressHostCompare);
			THROW_TESTRESULT;
		} // end if (addresses aren't equal)

		if (dpnhConnect != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async operation handle was touched (%x)!",
				1, dpnhConnect);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (handle was set)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Connecting without being initialized");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Connect(&dpnad,
									pDP8AddressHost,
									NULL,
									NULL,
									NULL,
									NULL,
									0,
									NULL,
									NULL,
									&dpnhConnect,
									0);
		if (tr != DPNERR_UNINITIALIZED)
		{
			DPTEST_FAIL(hLog, "Connecting without being initialized didn't return expected error UNINITIALIZED!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't connect)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		tr = pDP8AddressHost->IsEqual(pDP8AddressHostCompare);
		if (tr != DPNSUCCESS_EQUAL)
		{
			DPTEST_FAIL(hLog, "Device address object was modified (0x%08x != 0x%08x)!",
				2, pDP8AddressHost, pDP8AddressHostCompare);
			THROW_TESTRESULT;
		} // end if (addresses aren't equal)

		if (dpnhConnect != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async operation handle was touched (%x)!",
				1, dpnhConnect);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (handle was set)
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Initializing with context, 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		nonhostcontext.hLog = hLog;

		tr = pDP8Peer->DP8P_Initialize(&nonhostcontext,
										ParmVPConnectDPNMessageHandler, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Initializing with context, 0 flags failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Connecting with SP-only host address, empty device address");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Connect(&dpnad,
									pDP8AddressHost,
									pDP8AddressDevice,
									NULL,
									NULL,
									NULL,
									0,
									NULL,
									NULL,
									&dpnhConnect,
									0);

		if (tr != DPNERR_INCOMPLETEADDRESS)
		{
			DPTEST_FAIL(hLog, "Connecting with SP-only host address, empty device address didn't return expected error INVALIDDEVICEADDRESS!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't connect)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		if (dpnhConnect != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async operation handle was touched (%x)!",
				1, dpnhConnect);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (handle was set)


/* XBOX - IPX not supported
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting local device address SP to IPX");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressDevice->SetSP(&CLSID_DP8SP_IPX);

		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't set local device address SP!", 0);
			THROW_TESTRESULT;
		} // end if (set SP failed)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Connecting with different-SP device address");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Connect(&dpnad,
									pDP8AddressHost,
									pDP8AddressDevice,
									NULL,
									NULL,
									NULL,
									0,
									NULL,
									NULL,
									&dpnhConnect,
									0);
		if (tr != DPNERR_INVALIDDEVICEADDRESS)
		{
			DPTEST_FAIL(hLog, "Connecting with different-SP device address didn't return expected error INVALIDDEVICEADDRESS!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't connect)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		if (dpnhConnect != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async operation handle was touched (%x)!",
				1, dpnhConnect);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (handle was set)
*/

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting remote address hostname to local machine");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// In order to run these tests, need to get the local address information
		// Start by getting the Mac address
		if(gethostname(szLocalMacAddress, sizeof(szLocalMacAddress)))
		{
			xLog(hLog, XLL_FAIL, "Couldn't retrieve local Mac address");
			SETTHROW_TESTRESULT(E_FAIL);
		}
		


		// Then get the IP address
		pHostent = NULL;
		if((pHostent = gethostbyname(szLocalMacAddress)) == NULL)
		{
			xLog(hLog, XLL_FAIL, "Couldn't retrieve IP information for local host");
			SETTHROW_TESTRESULT(E_FAIL);
		}
		
		szAnsiLocalIPAddress = inet_ntoa(*((IN_ADDR *)pHostent->h_addr));

		// Extract the IP address from the hostent stucture
		mbstowcs(szLocalIPAddress, szAnsiLocalIPAddress, strlen(szAnsiLocalIPAddress));
		szLocalIPAddress[strlen(szAnsiLocalIPAddress)] = 0;

		tr = pDP8AddressHost->AddComponent(DPNA_KEY_HOSTNAME,
											szLocalIPAddress,
											(wcslen(szLocalIPAddress) + 1) * sizeof(WCHAR),
											DPNA_DATATYPE_STRING);

		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't set remote address hostname to local machine!", 0);
			THROW_TESTRESULT;
		} // end if (add component failed)






		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Saving new host address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8AddressHostCompare->Release();
		pDP8AddressHostCompare = NULL;

		tr = pDP8AddressHost->Duplicate(&pDP8AddressHostCompare);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't duplicate host address object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't duplicate host address object)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Starting async connect to self which will eventually complete with failure");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Connect(&dpnad,
									pDP8AddressHost,
									NULL,
									NULL,
									NULL,
									NULL,
									0,
									NULL,
									NULL,
									&dpnhConnect,
									0);
		if (tr != (HRESULT) DPNSUCCESS_PENDING)
		{
			DPTEST_FAIL(hLog, "Couldn't start async connect to self which will eventually complete with failure!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't connect)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		tr = pDP8AddressHost->IsEqual(pDP8AddressHostCompare);
		if (tr != DPNSUCCESS_EQUAL)
		{
			DPTEST_FAIL(hLog, "Device address object was modified (0x%08x != 0x%08x)!",
				2, pDP8AddressHost, pDP8AddressHostCompare);
			THROW_TESTRESULT;
		} // end if (addresses aren't equal)

		if (dpnhConnect == (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "No async operation handle was returned!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (handle was not set)

		if (dpnhConnect == NULL)
		{
			DPTEST_FAIL(hLog, "Async operation handle returned is NULL!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (handle was set to NULL)


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Trying another async connect with one still pending");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Connect(&dpnad,
									pDP8AddressHost,
									NULL,
									NULL,
									NULL,
									NULL,
									0,
									NULL,
									NULL,
									&dpnhDuplicate,
									0);
		if (tr != DPNERR_CONNECTING)
		{
			DPTEST_FAIL(hLog, "Trying another async connect with one still pending didn't return expected error CONNECTING!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't connect)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		tr = pDP8AddressHost->IsEqual(pDP8AddressHostCompare);
		if (tr != DPNSUCCESS_EQUAL)
		{
			DPTEST_FAIL(hLog, "Device address object was modified (0x%08x != 0x%08x)!",
				2, pDP8AddressHost, pDP8AddressHostCompare);
			THROW_TESTRESULT;
		} // end if (addresses aren't equal)

		if (dpnhDuplicate != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async operation handle was touched (%x)!", 1, dpnhDuplicate);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (handle was set)

		// It will now be okay for the connect to complete.
		CREATEEVENT_OR_THROW(nonhostcontext.hConnectCompleteEvent,
							NULL, FALSE, FALSE, NULL);
		nonhostcontext.hrExpectedResult = DPNERR_NORESPONSE;
		nonhostcontext.fConnectCanComplete = TRUE;


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for async connect to fail (this may take some time)");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 1;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 240000, nonhostcontext.hConnectCompleteEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird connects from completing.
		nonhostcontext.fConnectCanComplete = FALSE;

#ifdef DEBUG
		// Make sure the connect completed (how else would we get here?).
		if (! nonhostcontext.fCompleted)
		{
			DPTEST_FAIL(hLog, "Connect didn't complete!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (connect didn't complete)
#endif // DEBUG

		// Make sure the operation handle is correct.
		if (nonhostcontext.dpnhCompletedAsyncOp != dpnhConnect)
		{
			DPTEST_FAIL(hLog, "Connect completed with different async op handle (%x != %x)!",
				2, nonhostcontext.dpnhCompletedAsyncOp, dpnhConnect);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (completed operation handle wrong)

		// Reset the context.
		CloseHandle(nonhostcontext.hConnectCompleteEvent);
		nonhostcontext.hConnectCompleteEvent = NULL;
		nonhostcontext.fCompleted = FALSE;

#pragma TODO(vanceo, "Verify time taken is expected")


/* XBOX - SYNC operations not supported
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Synchronously connecting to self without a host (this may take some time)");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Even though it's synchronous, we'll still get a completion.  The async op
		// handle will be NULL, though.
		nonhostcontext.hrExpectedResult = DPNERR_NORESPONSE;
		nonhostcontext.fConnectCanComplete = TRUE;


		// This sometimes seems to take longer than the deadlock check time, so I'm
		// going to turn checking off and hope for the best.
		sr = pTNecd->pExecutor->SetDeadlockCheck(FALSE);
		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Turning deadlock check off failed!", 0);
			THROW_SYSTEMRESULT;
		} // end if (turning deadlock check off failed)

		tr = pDP8Peer->DP8P_Connect(&dpnad,
									pDP8AddressHost,
									NULL,
									NULL,
									NULL,
									NULL,
									0,
									NULL,
									NULL,
									NULL,
									DPNCONNECT_SYNC);

		// Prevent connects from completing.
		nonhostcontext.fConnectCanComplete = FALSE;

		// Turn deadlock checking back on.
		pTNecd->pExecutor->SetDeadlockCheck(TRUE);
		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Turning deadlock check back on failed!", 0);
			THROW_SYSTEMRESULT;
		} // end if (turning deadlock check on failed)

		if (tr != DPNERR_NORESPONSE)
		{
			DPTEST_FAIL(hLog, "Synchronously connecting to self without a host didn't return expected error NORESPONSE!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't connect)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		tr = pDP8AddressHost->IsEqual(pDP8AddressHostCompare);
		if (tr != DPNSUCCESS_EQUAL)
		{
			DPTEST_FAIL(hLog, "Device address object was modified (0x%08x != 0x%08x)!",
				2, pDP8AddressHost, pDP8AddressHostCompare);
			THROW_TESTRESULT;
		} // end if (addresses aren't equal)

		// Make sure we saw the connect completion indication.
		if (! nonhostcontext.fCompleted)
		{
			DPTEST_FAIL(hLog, "Didn't get connect complete indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (connect didn't complete)

		// Make sure the operation handle was not set.
		if (nonhostcontext.dpnhCompletedAsyncOp != NULL)
		{
			DPTEST_FAIL(hLog, "Connect completed with an async op handle (%x)!",
				1, nonhostcontext.dpnhCompletedAsyncOp);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (completed operation handle wrong)

		// Reset the context.
		nonhostcontext.fCompleted = FALSE;


#pragma TODO(vanceo, "Verify time taken is expected")
*/

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting local device address SP to TCP/IP");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressDevice->SetSP(&CLSID_DP8SP_TCPIP);

		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't set local device address SP!", 0);
			THROW_TESTRESULT;
		} // end if (set SP failed)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Hosting session");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Host(&dpnad,
								&pDP8AddressDevice,
								1,
								NULL,
								NULL,
								&(nonhostcontext.dpnidHost),
								0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't start hosting session!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't host)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		// Make sure we got the create player message.
		if (nonhostcontext.dpnidHost == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Connecting when already hosting");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dpnhConnect = (DPNHANDLE) 0x666;

		tr = pDP8Peer->DP8P_Connect(&dpnad,
									pDP8AddressHost,
									NULL,
									NULL,
									NULL,
									NULL,
									0,
									NULL,
									NULL,
									&dpnhConnect,
									0);
		if (tr != DPNERR_ALREADYCONNECTED)
		{
			DPTEST_FAIL(hLog, "Connecting when already hosting didn't return expected error ALREADYCONNECTED!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't connect)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		tr = pDP8AddressHost->IsEqual(pDP8AddressHostCompare);
		if (tr != DPNSUCCESS_EQUAL)
		{
			DPTEST_FAIL(hLog, "Device address object was modified (0x%08x != 0x%08x)!",
				2, pDP8AddressHost, pDP8AddressHostCompare);
			THROW_TESTRESULT;
		} // end if (addresses aren't equal)

		if (dpnhConnect != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async operation handle was touched (%x)!",
				1, dpnhConnect);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (handle was set)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing peer object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure we got the destroy player message.
		if (nonhostcontext.dpnidHost != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Re-initializing peer object with context, 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		nonhostcontext.hLog = hLog;

		tr = pDP8Peer->DP8P_Initialize(&nonhostcontext,
										ParmVPConnectDPNMessageHandler, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Re-initializing peer object with context, 0 flags failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating new peer host object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8AddressHost->Release();
		pDP8AddressHost = NULL;

		hostcontext.hLog = hLog;

		tr = ParmVCreatePeerHost(hLog, ParmVPConnectDPNMessageHandler,
								&hostcontext,
								&dpnad,
								&(hostcontext.dpnidHost),
								&pDP8PeerHost,
								&pDP8AddressHost);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Creating peer host failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't create peer host)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Saving new host address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8AddressHostCompare->Release();
		pDP8AddressHostCompare = NULL;

		tr = pDP8AddressHost->Duplicate(&pDP8AddressHostCompare);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't duplicate host address object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't duplicate host address object)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Starting async connect");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Host should get the create player now.
		CREATEEVENT_OR_THROW(hostcontext.hClientCreatedEvent,
							NULL, FALSE, FALSE, NULL);

		// It will now be okay for the connect to complete.
		CREATEEVENT_OR_THROW(nonhostcontext.hConnectCompleteEvent,
							NULL, FALSE, FALSE, NULL);
		nonhostcontext.hrExpectedResult = DPN_OK;
		nonhostcontext.fConnectCanComplete = TRUE;

		tr = pDP8Peer->DP8P_Connect(&dpnad,
									pDP8AddressHost,
									NULL,
									NULL,
									NULL,
									NULL,
									0,
									&(nonhostcontext.dpnidClient),
									NULL,
									&dpnhConnect,
									0);
		if (tr != (HRESULT) DPNSUCCESS_PENDING)
		{
			DPTEST_FAIL(hLog, "Couldn't start async connect!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't connect)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		tr = pDP8AddressHost->IsEqual(pDP8AddressHostCompare);
		if (tr != DPNSUCCESS_EQUAL)
		{
			DPTEST_FAIL(hLog, "Device address object was modified (0x%08x != 0x%08x)!",
				2, pDP8AddressHost, pDP8AddressHostCompare);
			THROW_TESTRESULT;
		} // end if (addresses aren't equal)

		if (dpnhConnect == (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "No async operation handle was returned!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (handle was not set)

		if (dpnhConnect == NULL)
		{
			DPTEST_FAIL(hLog, "Async operation handle returned is NULL!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (handle was set to NULL)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for async connect to succeed");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, nonhostcontext.hConnectCompleteEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird connects from completing.
		nonhostcontext.fConnectCanComplete = FALSE;

#ifdef DEBUG
		// Make sure the connect completed (how else would we get here?).
		if (! nonhostcontext.fCompleted)
		{
			DPTEST_FAIL(hLog, "Connect didn't complete!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (connect didn't complete)
#endif // DEBUG

		// Make sure the operation handle is correct.
		if (nonhostcontext.dpnhCompletedAsyncOp != dpnhConnect)
		{
			DPTEST_FAIL(hLog, "Connect completed with different async op handle (%x != %x)!",
				2, nonhostcontext.dpnhCompletedAsyncOp, dpnhConnect);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (completed operation handle wrong)

		// Make sure we got the create player messages.
		if (nonhostcontext.dpnidHost == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication for host on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player)

		if (nonhostcontext.dpnidClient == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication for client on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player)

		// Reset the context.
		CloseHandle(nonhostcontext.hConnectCompleteEvent);
		nonhostcontext.hConnectCompleteEvent = NULL;
		nonhostcontext.fCompleted = FALSE;

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Connecting when already connected");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dpnhConnect = (DPNHANDLE) 0x666;

		tr = pDP8Peer->DP8P_Connect(&dpnad,
									pDP8AddressHost,
									NULL,
									NULL,
									NULL,
									NULL,
									0,
									NULL,
									NULL,
									&dpnhConnect,
									0);
		if (tr != DPNERR_ALREADYCONNECTED)
		{
			DPTEST_FAIL(hLog, "Connecting when already hosting didn't return expected error ALREADYCONNECTED!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't connect)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		tr = pDP8AddressHost->IsEqual(pDP8AddressHostCompare);
		if (tr != DPNSUCCESS_EQUAL)
		{
			DPTEST_FAIL(hLog, "Device address object was modified (0x%08x != 0x%08x)!",
				2, pDP8AddressHost, pDP8AddressHostCompare);
			THROW_TESTRESULT;
		} // end if (addresses aren't equal)

		if (dpnhConnect != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async operation handle was touched (%x)!",
				1, dpnhConnect);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (handle was set)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for create player to be indicated on host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hostcontext.hClientCreatedEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		SAFE_CLOSEHANDLE(hostcontext.hClientCreatedEvent);

// START NEW STUFF

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing peer object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure we got the destroy player message.
		if (nonhostcontext.dpnidHost != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Re-initializing peer object with context, 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		nonhostcontext.hLog = hLog;

		tr = pDP8Peer->DP8P_Initialize(&nonhostcontext,
										ParmVPConnectDPNMessageHandler, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Re-initializing peer object with context, 0 flags failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Starting another async connect from the same reinitialized peer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Host should get the create player now.
		CREATEEVENT_OR_THROW(hostcontext.hClientCreatedEvent, NULL, FALSE, FALSE, NULL);

		// It will now be okay for the connect to complete.
		CREATEEVENT_OR_THROW(nonhostcontext.hConnectCompleteEvent, NULL, FALSE, FALSE, NULL);
		nonhostcontext.hrExpectedResult = DPN_OK;
		nonhostcontext.fConnectCanComplete = TRUE;

		tr = pDP8Peer->DP8P_Connect(&dpnad,
									pDP8AddressHost,
									NULL,
									NULL,
									NULL,
									NULL,
									0,
									&(nonhostcontext.dpnidClient),
									NULL,
									&dpnhConnect,
									0);
		if (tr != (HRESULT) DPNSUCCESS_PENDING)
		{
			DPTEST_FAIL(hLog, "Couldn't start async connect!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't connect)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		tr = pDP8AddressHost->IsEqual(pDP8AddressHostCompare);
		if (tr != DPNSUCCESS_EQUAL)
		{
			DPTEST_FAIL(hLog, "Device address object was modified (0x%08x != 0x%08x)!",
				2, pDP8AddressHost, pDP8AddressHostCompare);
			THROW_TESTRESULT;
		} // end if (addresses aren't equal)

		if (dpnhConnect == (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "No async operation handle was returned!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (handle was not set)

		if (dpnhConnect == NULL)
		{
			DPTEST_FAIL(hLog, "Async operation handle returned is NULL!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (handle was set to NULL)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for async connect to succeed");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, nonhostcontext.hConnectCompleteEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird connects from completing.
		nonhostcontext.fConnectCanComplete = FALSE;

#ifdef DEBUG
		// Make sure the connect completed (how else would we get here?).
		if (! nonhostcontext.fCompleted)
		{
			DPTEST_FAIL(hLog, "Connect didn't complete!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (connect didn't complete)
#endif // DEBUG

		// Make sure the operation handle is correct.
		if (nonhostcontext.dpnhCompletedAsyncOp != dpnhConnect)
		{
			DPTEST_FAIL(hLog, "Connect completed with different async op handle (%x != %x)!",
				2, nonhostcontext.dpnhCompletedAsyncOp, dpnhConnect);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (completed operation handle wrong)

		// Make sure we got the create player messages.
		if (nonhostcontext.dpnidHost == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication for host on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player)

		if (nonhostcontext.dpnidClient == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication for client on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player)

		// Reset the context.
		CloseHandle(nonhostcontext.hConnectCompleteEvent);
		nonhostcontext.hConnectCompleteEvent = NULL;
		nonhostcontext.fCompleted = FALSE;

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for create player to be indicated on host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hostcontext.hClientCreatedEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

// END NEW STUFF

/* XBOX - SYNC operations not supported

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Re-initializing peer object with context, 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		nonhostcontext.hLog = hLog;

		tr = pDP8Peer->DP8P_Initialize(&nonhostcontext,
										ParmVPConnectDPNMessageHandler, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Re-initializing peer object with context, 0 flags failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Connecting synchronously");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Host should get the create player now.  Event we need has already been
		// created.

		// Even though it's synchronous, we'll still get a completion.  The async op
		// handle will be NULL, though.
		nonhostcontext.hrExpectedResult = DPN_OK;
		nonhostcontext.fConnectCanComplete = TRUE;

		tr = pDP8Peer->DP8P_Connect(&dpnad,
									pDP8AddressHost,
									NULL,
									NULL,
									NULL,
									NULL,
									0,
									&(nonhostcontext.dpnidClient),
									NULL,
									NULL,
									DPNCONNECT_SYNC);

		// Prevent any weird connects from completing.
		nonhostcontext.fConnectCanComplete = FALSE;

		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't connect synchronously!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't connect)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		tr = pDP8AddressHost->IsEqual(pDP8AddressHostCompare);
		if (tr != DPNSUCCESS_EQUAL)
		{
			DPTEST_FAIL(hLog, "Device address object was modified (0x%08x != 0x%08x)!",
				2, pDP8AddressHost, pDP8AddressHostCompare);
			THROW_TESTRESULT;
		} // end if (addresses aren't equal)

		// Make sure we saw the connect completion indication.
		if (! nonhostcontext.fCompleted)
		{
			DPTEST_FAIL(hLog, "Didn't get connect complete indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (connect didn't complete)

		// Make sure the operation handle was not set.
		if (nonhostcontext.dpnhCompletedAsyncOp != NULL)
		{
			DPTEST_FAIL(hLog, "Connect completed with an async op handle (%x)!",
				1, nonhostcontext.dpnhCompletedAsyncOp);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (completed operation handle wrong)

		// Make sure we got the create player messages.
		if (nonhostcontext.dpnidHost == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication for host on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player)

		if (nonhostcontext.dpnidClient == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication for client on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player)

		// Reset the context.
		nonhostcontext.fCompleted = FALSE;



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for create player to be indicated on host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, 60000, hostcontext.hClientCreatedEvent, NULL))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing peer object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure we got the destroy player messages.
		if (nonhostcontext.dpnidHost != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for host on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)

		if (nonhostcontext.dpnidClient != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for client on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)


		// Technically we should wait to make sure the host saw the client go away
		// as expected but that's more hassle than it's worth.  Just make sure he's
		// gone after Close() has returned.
*/

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing peer object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure we got the destroy player message.
		if (nonhostcontext.dpnidHost != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing host object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8PeerHost->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing host object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure we got the destroy player messages.
		if (hostcontext.dpnidHost != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for host on host!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)

		if (hostcontext.dpnidClient != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for client on host!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing hosting DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8PeerHost->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release hosting DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8PeerHost);
		pDP8PeerHost = NULL;






		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Peer);
		pDP8Peer = NULL;




		FINAL_SUCCESS;
	}
	END_TESTCASE


	if (pDP8Peer != NULL)
	{
		delete (pDP8Peer);
		pDP8Peer = NULL;
	} // end if (have peer object)

	if (pDP8PeerHost != NULL)
	{
		delete (pDP8PeerHost);
		pDP8PeerHost = NULL;
	} // end if (have peer object)

	SAFE_CLOSEHANDLE(nonhostcontext.hConnectCompleteEvent);
	SAFE_CLOSEHANDLE(hostcontext.hClientCreatedEvent);
	SAFE_RELEASE(pDP8AddressHost);
	SAFE_RELEASE(pDP8AddressHostCompare);
	SAFE_RELEASE(pDP8AddressDevice);
	ClearDoWorkList(&DoWorkList);

	return (sr);
} // ParmVPeerExec_Connect
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVPeerExec_SendTo()"
//==================================================================================
// ParmVPeerExec_SendTo
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.1.6 - Peer SendTo parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVPeerExec_SendTo(HANDLE hLog)
{
	CTNSystemResult			sr;
	CTNTestResult			tr;
	PWRAPDP8PEER			pDP8Peer = NULL;
	PDIRECTPLAY8ADDRESS		pDP8Address = NULL;
	PDIRECTPLAY8ADDRESS		pDP8AddressCompare = NULL;
	PARMVPSENDTOCONTEXT		context;
	DPN_BUFFER_DESC			dpnbd;
	DPN_BUFFER_DESC			dpnbdCompare;
	DPNHANDLE				dpnhSendTo = (DPNHANDLE) 0x666;
	DPN_APPLICATION_DESC	dpnad;
	DPN_APPLICATION_DESC	dpnadCompare;
	DP_DOWORKLIST			DoWorkList;


	ZeroMemory(&DoWorkList, sizeof(DP_DOWORKLIST));
	ZeroMemory(&dpnbd, sizeof (DPN_BUFFER_DESC));
	ZeroMemory(&context, sizeof (PARMVPSENDTOCONTEXT));


	BEGIN_TESTCASE
	{
		// Allocate a 10 meg buffer.
		LOCALALLOC_OR_THROW(PBYTE, dpnbd.pBufferData, (10 * 1024 * 1024));

#pragma TODO(vanceo, "It would probably be good to fill and validate buffer contents, but 10 megs...")

		// Start by sending a 1 byte buffer
		dpnbd.dwBufferSize = 1;

		CopyMemory(&dpnbdCompare, &dpnbd, sizeof (DPN_BUFFER_DESC));




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Peer = new CWrapDP8Peer(hLog);
		if (pDP8Peer == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8Peer->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (LPVOID *) &pDP8Address, NULL);
		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't create DirectPlay8Address object!", 0);
			THROW_SYSTEMRESULT;
		} // end if (create failed)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting address SP to TCP/IP");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->SetSP(&CLSID_DP8SP_TCPIP);

		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't set address SP!", 0);
			THROW_TESTRESULT;
		} // end if (set SP failed)





/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Sending to 0 with all NULLs and 0s using C++ macro");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = IDirectPlay8Peer_SendTo(pDP8Peer->m_pDP8Peer, 0, NULL, 0, 0, NULL,
									NULL, 0);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Sending to 0 with all NULLs and 0s using C++ macro didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't send to)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Sending to 0 with all NULLs and 0s");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_SendTo(0, NULL, 0, 0, NULL, NULL, 0);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Sending to 0 with all NULLs and 0s didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't send to)
*/




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Sending asynchronously to AllPlayersGroup with NULL buffer desc");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_SendTo(DPNID_ALL_PLAYERS_GROUP, NULL, 1, 0, NULL,
									&dpnhSendTo, 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Sending asynchronously to AllPlayersGroup with NULL buffer desc didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't send to)

		if (dpnhSendTo != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async operation handle was touched (%x)!", 1, dpnhSendTo);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (handle was set)
*/




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Sending asynchronously to AllPlayersGroup with 0 buffer desc count");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_SendTo(DPNID_ALL_PLAYERS_GROUP, &dpnbd, 0, 0, NULL,
									&dpnhSendTo, 0);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Sending asynchronously to AllPlayersGroup with 0 buffer desc count didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't send to)

		if (memcmp(&dpnbdCompare, &dpnbd, sizeof (DPN_BUFFER_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Buffer desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnbdCompare, &dpnbd);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (buffer desc changed)

		if (dpnhSendTo != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async operation handle was touched (%x)!", 1, dpnhSendTo);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (handle was set)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Sending asynchronously to AllPlayersGroup with NULL async handle");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_SendTo(DPNID_ALL_PLAYERS_GROUP, &dpnbd, 1, 0, NULL,
									NULL, 0);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Sending asynchronously to AllPlayersGroup with NULL async handle didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't send to)

		if (memcmp(&dpnbdCompare, &dpnbd, sizeof (DPN_BUFFER_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Buffer desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnbdCompare, &dpnbd);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (buffer desc changed)
*/




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Sending asynchronously to AllPlayersGroup with NULL async handle and NOCOMPLETE");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_SendTo(DPNID_ALL_PLAYERS_GROUP, &dpnbd, 1, 0, NULL,
									NULL, DPNSEND_NOCOMPLETE);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Sending asynchronously to AllPlayersGroup with NULL async handle and NOCOMPLETE didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't send to)

		if (memcmp(&dpnbdCompare, &dpnbd, sizeof (DPN_BUFFER_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Buffer desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnbdCompare, &dpnbd);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (buffer desc changed)
*/





/* XBOX - SYNC operations not supported
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Sending synchronously to AllPlayersGroup with async handle");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_SendTo(DPNID_ALL_PLAYERS_GROUP, &dpnbd, 1, 0, NULL,
									&dpnhSendTo, DPNSEND_SYNC);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Sending synchronously to AllPlayersGroup with async handle didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't send to)

		if (memcmp(&dpnbdCompare, &dpnbd, sizeof (DPN_BUFFER_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Buffer desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnbdCompare, &dpnbd);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (buffer desc changed)

		if (dpnhSendTo != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async operation handle was touched (%x)!", 1, dpnhSendTo);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (handle was set)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Sending to AllPlayersGroup with invalid flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_SendTo(DPNID_ALL_PLAYERS_GROUP, &dpnbd, 1, 0, NULL,
									&dpnhSendTo, 0x666000);
		if (tr != DPNERR_INVALIDFLAGS)
		{
			DPTEST_FAIL(hLog, "Sending to AllPlayersGroup with invalid flags didn't return expected error INVALIDFLAGS!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't send to)

		if (memcmp(&dpnbdCompare, &dpnbd, sizeof (DPN_BUFFER_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Buffer desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnbdCompare, &dpnbd);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (buffer desc changed)

		if (dpnhSendTo != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async operation handle was touched (%x)!", 1, dpnhSendTo);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (handle was set)
*/




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Sending to AllPlayersGroup with NOCOPY and NOCOMPLETE");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_SendTo(DPNID_ALL_PLAYERS_GROUP, &dpnbd, 1, 0, NULL,
									&dpnhSendTo,
									(DPNSEND_NOCOPY | DPNSEND_NOCOMPLETE));
		if (tr != DPNERR_INVALIDFLAGS)
		{
			DPTEST_FAIL(hLog, "Sending to AllPlayersGroup with NOCOPY and NOCOMPLETE didn't return expected error INVALIDFLAGS!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't send to)

		if (memcmp(&dpnbdCompare, &dpnbd, sizeof (DPN_BUFFER_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Buffer desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnbdCompare, &dpnbd);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (buffer desc changed)

		if (dpnhSendTo != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async operation handle was touched (%x)!", 1, dpnhSendTo);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (handle was set)
*/




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Sending to AllPlayersGroup with only COMPLETEONPROCESS");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_SendTo(DPNID_ALL_PLAYERS_GROUP, &dpnbd, 1, 0, NULL,
									&dpnhSendTo,
									DPNSEND_COMPLETEONPROCESS);
		if (tr != DPNERR_INVALIDFLAGS)
		{
			DPTEST_FAIL(hLog, "Sending to AllPlayersGroup with only COMPLETEONPROCESS didn't return expected error INVALIDFLAGS!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't send to)

		if (memcmp(&dpnbdCompare, &dpnbd, sizeof (DPN_BUFFER_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Buffer desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnbdCompare, &dpnbd);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (buffer desc changed)

		if (dpnhSendTo != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async operation handle was touched (%x)!", 1, dpnhSendTo);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (handle was set)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Sending to AllPlayersGroup with PRIORITY_LOW and PRIORITY_HIGH");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_SendTo(DPNID_ALL_PLAYERS_GROUP, &dpnbd, 1, 0, NULL,
									&dpnhSendTo,
									(DPNSEND_PRIORITY_LOW | DPNSEND_PRIORITY_HIGH));
		if (tr != DPNERR_INVALIDFLAGS)
		{
			DPTEST_FAIL(hLog, "Sending to AllPlayersGroup with PRIORITY_LOW and PRIORITY_HIGH didn't return expected error INVALIDFLAGS!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't send to)

		if (memcmp(&dpnbdCompare, &dpnbd, sizeof (DPN_BUFFER_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Buffer desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnbdCompare, &dpnbd);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (buffer desc changed)

		if (dpnhSendTo != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async operation handle was touched (%x)!", 1, dpnhSendTo);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (handle was set)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Sending to AllPlayersGroup with NOCOPY when uninitialized");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_SendTo(DPNID_ALL_PLAYERS_GROUP, &dpnbd, 1, 0, NULL,
									&dpnhSendTo, DPNSEND_NOCOPY);
		if (tr != DPNERR_UNINITIALIZED)
		{
			DPTEST_FAIL(hLog, "Sending to AllPlayersGroup with NOCOPY when uninitialized didn't return expected error UNINITIALIZED!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't send to)

		if (memcmp(&dpnbdCompare, &dpnbd, sizeof (DPN_BUFFER_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Buffer desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnbdCompare, &dpnbd);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (buffer desc changed)

		if (dpnhSendTo != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async operation handle was touched (%x)!", 1, dpnhSendTo);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (handle was set)
*/




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Initializing with context, 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		context.hLog = hLog;

		tr = pDP8Peer->DP8P_Initialize(&context, ParmVPSendToDPNMessageHandler, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Initializing with context, 0 flags failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Sending to AllPlayersGroup without a connection");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_SendTo(DPNID_ALL_PLAYERS_GROUP, &dpnbd, 1, 0, NULL,
									&dpnhSendTo, 0);
		if (tr != DPNERR_NOCONNECTION)
		{
			DPTEST_FAIL(hLog, "Sending to AllPlayersGroup without a connection didn't return expected error NOCONNECTION!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't send to)

		if (memcmp(&dpnbdCompare, &dpnbd, sizeof (DPN_BUFFER_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Buffer desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnbdCompare, &dpnbd);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (buffer desc changed)

		if (dpnhSendTo != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async operation handle was touched (%x)!", 1, dpnhSendTo);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (handle was set)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Saving device address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->Duplicate(&pDP8AddressCompare);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't duplicate device address object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't duplicate device address object)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Hosting session");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		//dpnad.dwFlags = 0;
		//dpnad.guidInstance = GUID_NULL;
		dpnad.guidApplication = GUID_PARMV_PEER_SENDTO;
		//dpnad.dwMaxPlayers = 0;
		//dpnad.dwCurrentPlayers = 0;
		//dpnad.pwszSessionName = NULL;
		//dpnad.pwszPassword = NULL;
		//dpnad.pvReservedData = NULL;
		//dpnad.dwReservedDataSize = 0;
		//dpnad.pvApplicationReservedData = NULL;
		//dpnad.dwApplicationReservedDataSize = 0;

		// Save what we're passing in to make sure it's not touched.
		CopyMemory(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC));

		tr = pDP8Peer->DP8P_Host(&dpnad,
								&pDP8Address,
								1,
								NULL,
								NULL,
								&(context.dpnidPlayer),
								0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't start hosting session!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't host)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		tr = pDP8Address->IsEqual(pDP8AddressCompare);
		if (tr != DPNSUCCESS_EQUAL)
		{
			DPTEST_FAIL(hLog, "Device address object was modified (0x%08x != 0x%08x)!",
				2, pDP8Address, pDP8AddressCompare);
			THROW_TESTRESULT;
		} // end if (addresses aren't equal)

		// Make sure we got the create player message.
		if (context.dpnidPlayer == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Sending to invalid player ID");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_SendTo((DPNID) 0x666, &dpnbd, 1, 0, NULL,
								&dpnhSendTo, 0);
		if (tr != DPNERR_INVALIDPLAYER)
		{
			DPTEST_FAIL(hLog, "Sending to invalid player ID didn't return expected error INVALIDPLAYER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't send to)

		if (memcmp(&dpnbdCompare, &dpnbd, sizeof (DPN_BUFFER_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Buffer desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnbdCompare, &dpnbd);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (buffer desc changed)

		if (dpnhSendTo != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async operation handle was touched (%x)!", 1, dpnhSendTo);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (handle was set)







		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Sending 1 byte to AllPlayersGroup");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// It will now be okay for a receive to come in.
		CREATEEVENT_OR_THROW(context.hReceiveEvent, NULL, FALSE, FALSE, NULL);
		context.dwExpectedReceiveSize = 1;
		context.fCanReceive = TRUE;

		// It will now be okay for the send to complete.
		CREATEEVENT_OR_THROW(context.hSendCompleteEvent, NULL, FALSE, FALSE, NULL);
		context.hrExpectedResult = DPN_OK;
		context.fSendCanComplete = TRUE;

		tr = pDP8Peer->DP8P_SendTo(DPNID_ALL_PLAYERS_GROUP, &dpnbd, 1, 0, NULL,
									&dpnhSendTo, 0);
		if (tr != (HRESULT) DPNSUCCESS_PENDING)
		{
			DPTEST_FAIL(hLog, "Sending 1 byte to AllPlayersGroup didn't return expected PENDING success code!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't send to)

		if (memcmp(&dpnbdCompare, &dpnbd, sizeof (DPN_BUFFER_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Buffer desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnbdCompare, &dpnbd);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (buffer desc changed)

		if (dpnhSendTo == (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "No async operation handle was returned!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (handle was not set)

		if (dpnhSendTo == NULL)
		{
			DPTEST_FAIL(hLog, "Async operation handle returned is NULL!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (handle was set to NULL)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for async send to succeed");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 1;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, context.hSendCompleteEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird sends from completing.
		context.fSendCanComplete = FALSE;

#ifdef DEBUG
		// Make sure the send completed (how else would we get here?).
		if (! context.fSendCompleted)
		{
			DPTEST_FAIL(hLog, "Send didn't complete!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (send didn't complete)
#endif // DEBUG

		// Make sure the completion indicated the same op handle that we were
		// returned.
		if (context.dpnhCompletedAsyncOp != dpnhSendTo)
		{
			DPTEST_FAIL(hLog, "Async operation handle in send completion differs from one returned to us (%x != %x)!",
				2, context.dpnhCompletedAsyncOp, dpnhSendTo);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (async op handle is wrong)

		// Reset the context.
		CloseHandle(context.hSendCompleteEvent);
		context.hSendCompleteEvent = NULL;
		context.dpnhCompletedAsyncOp = NULL;
		context.fSendCompleted = FALSE;



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for the receive to be indicated");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 1;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, context.hReceiveEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird receives from coming in.
		context.fCanReceive = FALSE;

#ifdef DEBUG
		// Make sure the receive indication was triggered (how else would we get here?).
		if (! context.fReceived)
		{
			DPTEST_FAIL(hLog, "Didn't get receive indication!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (receive didn't arrive)
#endif // DEBUG

		// Reset the context.
		CloseHandle(context.hReceiveEvent);
		context.hReceiveEvent = NULL;
		context.fReceived = FALSE;






		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Sending 128 bytes to self");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// It will now be okay for a receive to come in.
		CREATEEVENT_OR_THROW(context.hReceiveEvent, NULL, FALSE, FALSE, NULL);
		context.dwExpectedReceiveSize = 128;
		dpnbd.dwBufferSize = context.dwExpectedReceiveSize;
		dpnbdCompare.dwBufferSize = context.dwExpectedReceiveSize;
		context.fCanReceive = TRUE;

		// It will now be okay for the send to complete.
		CREATEEVENT_OR_THROW(context.hSendCompleteEvent, NULL, FALSE, FALSE, NULL);
		context.hrExpectedResult = DPN_OK;
		context.fSendCanComplete = TRUE;

		tr = pDP8Peer->DP8P_SendTo(context.dpnidPlayer, &dpnbd, 1, 0, NULL,
									&dpnhSendTo, 0);
		if (tr != (HRESULT) DPNSUCCESS_PENDING)
		{
			DPTEST_FAIL(hLog, "Sending 128 bytes to self didn't return expected PENDING success code!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't send to)

		if (memcmp(&dpnbdCompare, &dpnbd, sizeof (DPN_BUFFER_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Buffer desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnbdCompare, &dpnbd);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (buffer desc changed)

		if (dpnhSendTo == (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "No async operation handle was returned!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (handle was not set)

		if (dpnhSendTo == NULL)
		{
			DPTEST_FAIL(hLog, "Async operation handle returned is NULL!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (handle was set to NULL)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for async send to succeed");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 1;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, context.hSendCompleteEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird sends from completing.
		context.fSendCanComplete = FALSE;

#ifdef DEBUG
		// Make sure the send completed (how else would we get here?).
		if (! context.fSendCompleted)
		{
			DPTEST_FAIL(hLog, "Send didn't complete!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (send didn't complete)
#endif // DEBUG

		// Make sure the completion indicated the same op handle that we were
		// returned.
		if (context.dpnhCompletedAsyncOp != dpnhSendTo)
		{
			DPTEST_FAIL(hLog, "Async operation handle in send completion differs from one returned to us (%x != %x)!",
				2, context.dpnhCompletedAsyncOp, dpnhSendTo);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (async op handle is wrong)

		// Reset the context.
		CloseHandle(context.hSendCompleteEvent);
		context.hSendCompleteEvent = NULL;
		context.dpnhCompletedAsyncOp = NULL;
		context.fSendCompleted = FALSE;



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for the receive to be indicated");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 1;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, context.hReceiveEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird receives from coming in.
		context.fCanReceive = FALSE;

#ifdef DEBUG
		// Make sure the receive indication was triggered (how else would we get here?).
		if (! context.fReceived)
		{
			DPTEST_FAIL(hLog, "Didn't get receive indication!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (receive didn't arrive)
#endif // DEBUG

		// Reset the context.
		CloseHandle(context.hReceiveEvent);
		context.hReceiveEvent = NULL;
		context.fReceived = FALSE;







		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Sending 10MB NOCOPY to AllPlayersGroup");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// It will now be okay for a receive to come in.
		CREATEEVENT_OR_THROW(context.hReceiveEvent, NULL, FALSE, FALSE, NULL);
		context.dwExpectedReceiveSize = 10 * 1024 * 1024;
		dpnbd.dwBufferSize = context.dwExpectedReceiveSize;
		dpnbdCompare.dwBufferSize = context.dwExpectedReceiveSize;
		context.fCanReceive = TRUE;

		// It will now be okay for the send to complete.
		CREATEEVENT_OR_THROW(context.hSendCompleteEvent, NULL, FALSE, FALSE, NULL);
		context.hrExpectedResult = DPN_OK;
		context.fSendCanComplete = TRUE;

		tr = pDP8Peer->DP8P_SendTo(DPNID_ALL_PLAYERS_GROUP, &dpnbd, 1, 0, NULL,
									&dpnhSendTo, DPNSEND_NOCOPY);
		if (tr != (HRESULT) DPNSUCCESS_PENDING)
		{
			DPTEST_FAIL(hLog, "Sending 10MB NOCOPY to AllPlayersGroup didn't return expected PENDING success code!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't send to)

		if (memcmp(&dpnbdCompare, &dpnbd, sizeof (DPN_BUFFER_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Buffer desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnbdCompare, &dpnbd);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (buffer desc changed)

		if (dpnhSendTo == (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "No async operation handle was returned!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (handle was not set)

		if (dpnhSendTo == NULL)
		{
			DPTEST_FAIL(hLog, "Async operation handle returned is NULL!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (handle was set to NULL)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for async send to succeed");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 1;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, context.hSendCompleteEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird sends from completing.
		context.fSendCanComplete = FALSE;

#ifdef DEBUG
		// Make sure the send completed (how else would we get here?).
		if (! context.fSendCompleted)
		{
			DPTEST_FAIL(hLog, "Send didn't complete!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (send didn't complete)
#endif // DEBUG

		// Make sure the completion indicated the same op handle that we were
		// returned.
		if (context.dpnhCompletedAsyncOp != dpnhSendTo)
		{
			DPTEST_FAIL(hLog, "Async operation handle in send completion differs from one returned to us (%x != %x)!",
				2, context.dpnhCompletedAsyncOp, dpnhSendTo);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (async op handle is wrong)

		// Reset the context.
		CloseHandle(context.hSendCompleteEvent);
		context.hSendCompleteEvent = NULL;
		context.dpnhCompletedAsyncOp = NULL;
		context.fSendCompleted = FALSE;



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for the receive to be indicated");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 1;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, context.hReceiveEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird receives from coming in.
		context.fCanReceive = FALSE;

#ifdef DEBUG
		// Make sure the receive indication was triggered (how else would we get here?).
		if (! context.fReceived)
		{
			DPTEST_FAIL(hLog, "Didn't get receive indication!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (receive didn't arrive)
#endif // DEBUG

		// Reset the context.
		CloseHandle(context.hReceiveEvent);
		context.hReceiveEvent = NULL;
		context.fReceived = FALSE;







/* XBOX - SYNC operations not supported
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Sending 10MB to self synchronously");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// It will now be okay for a receive to come in.
		CREATEEVENT_OR_THROW(context.hReceiveEvent, NULL, FALSE, FALSE, NULL);
		context.dwExpectedReceiveSize = 10 * 1024 * 1024;
		dpnbd.dwBufferSize = context.dwExpectedReceiveSize;
		dpnbdCompare.dwBufferSize = context.dwExpectedReceiveSize;
		context.fCanReceive = TRUE;


		tr = pDP8Peer->DP8P_SendTo(context.dpnidPlayer, &dpnbd, 1, 0, NULL,
									NULL, DPNSEND_SYNC);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Sending 10MB to self synchronously didn't return expected error PENDING!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't send to)

		if (memcmp(&dpnbdCompare, &dpnbd, sizeof (DPN_BUFFER_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Buffer desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnbdCompare, &dpnbd);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (buffer desc changed)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for the receive to be indicated");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 1;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, context.hReceiveEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird receives from coming in.
		context.fCanReceive = FALSE;

#ifdef DEBUG
		// Make sure the receive indication was triggered (how else would we get here?).
		if (! context.fReceived)
		{
			DPTEST_FAIL(hLog, "Didn't get receive indication!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (receive didn't arrive)
#endif // DEBUG

		// Reset the context.
		CloseHandle(context.hReceiveEvent);
		context.hReceiveEvent = NULL;
		context.fReceived = FALSE;
*/






		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Sending 10MB to AllPlayersGroup");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// It will now be okay for a receive to come in.
		CREATEEVENT_OR_THROW(context.hReceiveEvent, NULL, FALSE, FALSE, NULL);
		context.dwExpectedReceiveSize = 10 * 1024 * 1024;
		dpnbd.dwBufferSize = context.dwExpectedReceiveSize;
		dpnbdCompare.dwBufferSize = context.dwExpectedReceiveSize;
		context.fCanReceive = TRUE;

		// It will now be okay for the send to complete.
		CREATEEVENT_OR_THROW(context.hSendCompleteEvent, NULL, FALSE, FALSE, NULL);
		context.hrExpectedResult = DPN_OK;
		context.fSendCanComplete = TRUE;

		tr = pDP8Peer->DP8P_SendTo(DPNID_ALL_PLAYERS_GROUP, &dpnbd, 1, 0, NULL,
									&dpnhSendTo, 0);

		// Free the buffer right now.  This will hopefully catch DPlay trying to
		// use our buffer even though we didn't specify NOCOPY.
		// NOTE: We're not NULL-ing it right after the free!  Be sure to so before
		// bailing to the cleanup code!
		SAFE_LOCALFREE(dpnbd.pBufferData);
		dpnbdCompare.pBufferData = NULL;

		if (tr != (HRESULT) DPNSUCCESS_PENDING)
		{
			DPTEST_FAIL(hLog, "Sending 10MB to AllPlayersGroup didn't return expected PENDING success code!", 0);
			dpnbd.pBufferData = NULL;
			THROW_TESTRESULT;
		} // end if (couldn't send to)

		if (memcmp(&dpnbdCompare, &dpnbd, sizeof (DPN_BUFFER_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Buffer desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnbdCompare, &dpnbd);
			dpnbd.pBufferData = NULL;
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (buffer desc changed)

		// Okay, now we can NULL out the pointer since we've done the compare.
		dpnbd.pBufferData = NULL;

		if (dpnhSendTo == (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "No async operation handle was returned!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (handle was not set)

		if (dpnhSendTo == NULL)
		{
			DPTEST_FAIL(hLog, "Async operation handle returned is NULL!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (handle was set to NULL)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for async send to succeed");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 1;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, context.hSendCompleteEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird sends from completing.
		context.fSendCanComplete = FALSE;

#ifdef DEBUG
		// Make sure the send completed (how else would we get here?).
		if (! context.fSendCompleted)
		{
			DPTEST_FAIL(hLog, "Send didn't complete!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (send didn't complete)
#endif // DEBUG

		// Make sure the completion indicated the same op handle that we were
		// returned.
		if (context.dpnhCompletedAsyncOp != dpnhSendTo)
		{
			DPTEST_FAIL(hLog, "Async operation handle in send completion differs from one returned to us (%x != %x)!",
				2, context.dpnhCompletedAsyncOp, dpnhSendTo);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (async op handle is wrong)

		// Reset the context.
		CloseHandle(context.hSendCompleteEvent);
		context.hSendCompleteEvent = NULL;
		context.dpnhCompletedAsyncOp = NULL;
		context.fSendCompleted = FALSE;



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for the receive to be indicated");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 1;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, context.hReceiveEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird receives from coming in.
		context.fCanReceive = FALSE;

#ifdef DEBUG
		// Make sure the receive indication was triggered (how else would we get here?).
		if (! context.fReceived)
		{
			DPTEST_FAIL(hLog, "Didn't get receive indication!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (receive didn't arrive)
#endif // DEBUG

		// Reset the context.
		CloseHandle(context.hReceiveEvent);
		context.hReceiveEvent = NULL;
		context.fReceived = FALSE;





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure we got the destroy player message.
		if (context.dpnidPlayer != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Peer);
		pDP8Peer = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE


	if (pDP8Peer != NULL)
	{
		delete (pDP8Peer);
		pDP8Peer = NULL;
	} // end if (have peer object)

	SAFE_RELEASE(pDP8Address);
	SAFE_RELEASE(pDP8AddressCompare);
	SAFE_LOCALFREE(dpnbd.pBufferData);
	ClearDoWorkList(&DoWorkList);


	return (sr);
} // ParmVPeerExec_SendTo
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVPeerExec_GetSendQInfo()"
//==================================================================================
// ParmVPeerExec_GetSendQInfo
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.1.7 - Peer GetSendQueueInfo parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVPeerExec_GetSendQInfo(HANDLE hLog)
{
	CTNSystemResult				sr;
	CTNTestResult				tr;
	PWRAPDP8PEER				pDP8Peer = NULL;
	PWRAPDP8PEER				pDP8PeerHost = NULL;
	PDIRECTPLAY8ADDRESS			pDP8Address = NULL;
	DWORD						dwNumMsgs = 666;
	DWORD						dwNumBytes = 666;
	DPN_APPLICATION_DESC		dpnad;
	DPN_APPLICATION_DESC		dpnadCompare;
	PARMVPGETSENDQINFOCONTEXT	hostcontext;
	PARMVPGETSENDQINFOCONTEXT	nonhostcontext;
	DP_DOWORKLIST				DoWorkList;
	DPNHANDLE					hAsyncOp;
	HANDLE						hAsyncOpComplete = NULL;
	DWORD						dwTemp = 0;


	ZeroMemory(&DoWorkList, sizeof(DP_DOWORKLIST));
	ZeroMemory(&hostcontext, sizeof (PARMVPGETSENDQINFOCONTEXT));
	hostcontext.fHost = TRUE;

	ZeroMemory(&nonhostcontext, sizeof (PARMVPGETSENDQINFOCONTEXT));
	//nonhostcontext.fHost = FALSE;


	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Peer = new CWrapDP8Peer(hLog);
		if (pDP8Peer == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8Peer->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (LPVOID *) &pDP8Address, NULL);
		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't create DirectPlay8Address object!", 0);
			THROW_SYSTEMRESULT;
		} // end if (create failed)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting address object's SP to TCP/IP");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->SetSP(&CLSID_DP8SP_TCPIP);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting address object's SP to TCP/IP failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set SP)





/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting send queue info with all NULLs and 0s using C++ macro");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = IDirectPlay8Peer_GetSendQueueInfo(pDP8Peer->m_pDP8Peer, 0, NULL, NULL, 0);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Getting send queue info with all NULLs and 0s using C++ macro didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get send queue info)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting send queue info with all NULLs and 0s");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_GetSendQueueInfo(0, NULL, NULL, 0);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Getting send queue info with all NULLs and 0s didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get send queue info)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting send queue info with invalid flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_GetSendQueueInfo(0, &dwNumMsgs, &dwNumBytes, 0x666);
		if (tr != DPNERR_INVALIDFLAGS)
		{
			DPTEST_FAIL(hLog, "Getting send queue info with invalid flags didn't return expected error INVALIDFLAGS!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get send queue info)

		if (dwNumMsgs != 666)
		{
			DPTEST_FAIL(hLog, "Num msgs was changed (%u != 666)!", 1, dwNumMsgs);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num msgs was touched)

		if (dwNumBytes != 666)
		{
			DPTEST_FAIL(hLog, "Num bytes was changed (%u != 666)!", 1, dwNumBytes);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num bytes was touched)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting send queue info before initialization");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_GetSendQueueInfo(0, &dwNumMsgs, &dwNumBytes, 0);
		if (tr != DPNERR_UNINITIALIZED)
		{
			DPTEST_FAIL(hLog, "Getting send queue info before initialization didn't return expected error UNINITIALIZED!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get send queue info)

		if (dwNumMsgs != 666)
		{
			DPTEST_FAIL(hLog, "Num msgs was changed (%u != 666)!", 1, dwNumMsgs);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num msgs was touched)

		if (dwNumBytes != 666)
		{
			DPTEST_FAIL(hLog, "Num bytes was changed (%u != 666)!", 1, dwNumBytes);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num bytes was touched)
*/


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Initializing peer object with host context");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		hostcontext.hLog = hLog;

		tr = pDP8Peer->DP8P_Initialize(&hostcontext,
										ParmVPGetSendQInfoDPNMessageHandler, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Initializing peer object with host context failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting send queue info without a connection");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_GetSendQueueInfo(0, &dwNumMsgs, &dwNumBytes, 0);
		if (tr != DPNERR_NOCONNECTION)
		{
			DPTEST_FAIL(hLog, "Getting send queue info without a connection didn't return expected error NOCONNECTION!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get send queue info)

		if (dwNumMsgs != 666)
		{
			DPTEST_FAIL(hLog, "Num msgs was changed (%u != 666)!", 1, dwNumMsgs);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num msgs was touched)

		if (dwNumBytes != 666)
		{
			DPTEST_FAIL(hLog, "Num bytes was changed (%u != 666)!", 1, dwNumBytes);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num bytes was touched)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Hosting session");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		//dpnad.dwFlags = 0;
		//dpnad.guidInstance = GUID_NULL;
		dpnad.guidApplication = GUID_PARMV_PEER_SENDTO;
		//dpnad.dwMaxPlayers = 0;
		//dpnad.dwCurrentPlayers = 0;
		//dpnad.pwszSessionName = NULL;
		//dpnad.pwszPassword = NULL;
		//dpnad.pvReservedData = NULL;
		//dpnad.dwReservedDataSize = 0;
		//dpnad.pvApplicationReservedData = NULL;
		//dpnad.dwApplicationReservedDataSize = 0;

		// Save what we're passing in to make sure it's not touched.
		CopyMemory(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC));


		tr = pDP8Peer->DP8P_Host(&dpnad,
								&pDP8Address,
								1,
								NULL,
								NULL,
								&(hostcontext.dpnidHost),
								0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't start hosting session!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't host)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		// Make sure we got the create player message.
		if (hostcontext.dpnidHost == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting send queue info for 0");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_GetSendQueueInfo(0, &dwNumMsgs, &dwNumBytes, 0);
		if (tr != DPNERR_INVALIDPLAYER)
		{
			DPTEST_FAIL(hLog, "Getting send queue info for 0 didn't return expected error INVALIDPLAYER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get send queue info)

		if (dwNumMsgs != 666)
		{
			DPTEST_FAIL(hLog, "Num msgs was changed (%u != 666)!", 1, dwNumMsgs);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num msgs was touched)

		if (dwNumBytes != 666)
		{
			DPTEST_FAIL(hLog, "Num bytes was changed (%u != 666)!", 1, dwNumBytes);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num bytes was touched)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting send queue info for invalid player ID");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_GetSendQueueInfo((DPNID) 0x666, &dwNumMsgs, &dwNumBytes, 0);
		if (tr != DPNERR_INVALIDPLAYER)
		{
			DPTEST_FAIL(hLog, "Getting send queue info for invalid player ID didn't return expected error INVALIDPLAYER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get send queue info)

		if (dwNumMsgs != 666)
		{
			DPTEST_FAIL(hLog, "Num msgs was changed (%u != 666)!", 1, dwNumMsgs);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num msgs was touched)

		if (dwNumBytes != 666)
		{
			DPTEST_FAIL(hLog, "Num bytes was changed (%u != 666)!", 1, dwNumBytes);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num bytes was touched)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting send queue info for local player");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_GetSendQueueInfo(hostcontext.dpnidHost, &dwNumMsgs,
											&dwNumBytes, 0);
		if (tr != DPNERR_INVALIDPLAYER)
		{
			DPTEST_FAIL(hLog, "Getting send queue info for local player didn't return expected error INVALIDPLAYER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get send queue info)

		if (dwNumMsgs != 666)
		{
			DPTEST_FAIL(hLog, "Num msgs was changed (%u != 666)!", 1, dwNumMsgs);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num msgs was touched)

		if (dwNumBytes != 666)
		{
			DPTEST_FAIL(hLog, "Num bytes was changed (%u != 666)!", 1, dwNumBytes);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num bytes was touched)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing peer object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure we got the destroy player message.
		if (hostcontext.dpnidHost != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Re-initializing peer object with nonhost context");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		nonhostcontext.hLog = hLog;

		tr = pDP8Peer->DP8P_Initialize(&nonhostcontext,
										ParmVPGetSendQInfoDPNMessageHandler, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Re-initializing peer object with context, 0 flags failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating new peer host object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Address->Release();
		pDP8Address = NULL;

		hostcontext.hLog = hLog;

		tr = ParmVCreatePeerHost(hLog, ParmVPGetSendQInfoDPNMessageHandler,
								&hostcontext,
								&dpnad,
								&(hostcontext.dpnidHost),
								&pDP8PeerHost,
								&pDP8Address);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Creating peer host failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't create peer host)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Connecting peer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

// XBOX - Had to make connection asynchronous

		// Host should get the create player now.
		CREATEEVENT_OR_THROW(hostcontext.hClientCreatedEvent, NULL, FALSE, FALSE, NULL);
		SAFE_CLOSEHANDLE(hAsyncOpComplete);
		CREATEEVENT_OR_THROW(hAsyncOpComplete, NULL, FALSE, FALSE, NULL);

		// Even though it's synchronous, we'll still get a completion.  The async op
		// handle will be NULL, though.
		nonhostcontext.fConnectCanComplete = TRUE;

		tr = pDP8Peer->DP8P_Connect(&dpnad,
									pDP8Address,
									NULL,
									NULL,
									NULL,
									NULL,
									0,
									&(nonhostcontext.dpnidClient),
									hAsyncOpComplete,
									&hAsyncOp,
									0);

		if((tr != DPNSUCCESS_PENDING) && (tr != DPN_OK))
		{
			DPTEST_FAIL(hLog, "Couldn't connect! (error 0x%08x)", 1, tr);
			THROW_TESTRESULT;
		} // end if (couldn't connect)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for connect to complete on non-host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hAsyncOpComplete))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird connects from completing.
		nonhostcontext.fConnectCanComplete = FALSE;

		// Make sure we saw the connect completion indication.
		if (! nonhostcontext.fConnectCompleted)
		{
			DPTEST_FAIL(hLog, "Didn't get connect complete indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (connect didn't complete)

		// Reset the context.
		nonhostcontext.fConnectCompleted = FALSE;

		// Make sure we got the create player messages.
		if (nonhostcontext.dpnidHost == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication for host on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player)

		if (nonhostcontext.dpnidClient == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication for client on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player)


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for create player to be indicated on host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hostcontext.hClientCreatedEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting send queue info of host on client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_GetSendQueueInfo(nonhostcontext.dpnidHost, &dwNumMsgs,
											&dwNumBytes, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting send queue info of host on client failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get send queue info)

		if (dwNumMsgs != 0)
		{
			DPTEST_FAIL(hLog, "Num msgs was not expected (%u != 0)!", 1, dwNumMsgs);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num msgs was unexpected)

		if (dwNumBytes != 0)
		{
			DPTEST_FAIL(hLog, "Num bytes was not expected (%u != 0)!", 1, dwNumBytes);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num bytes was unexpected)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting send queue info of host on client with NULL num msgs");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Reset the modification value.
		dwNumBytes = 666;

		tr = pDP8Peer->DP8P_GetSendQueueInfo(nonhostcontext.dpnidHost, NULL,
											&dwNumBytes, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting send queue info of host on client with NULL num msgs failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get send queue info)

		if (dwNumBytes != 0)
		{
			DPTEST_FAIL(hLog, "Num bytes was not expected (%u != 0)!", 1, dwNumBytes);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num bytes was unexpected)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting send queue info of host on client with NULL num bytes");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Reset the modification value.
		dwNumMsgs = 666;

		tr = pDP8Peer->DP8P_GetSendQueueInfo(nonhostcontext.dpnidHost, &dwNumMsgs,
											NULL, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting send queue info of host on client with NULL num bytes failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get send queue info)

		if (dwNumMsgs != 0)
		{
			DPTEST_FAIL(hLog, "Num msgs was not expected (%u != 0)!", 1, dwNumMsgs);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num msgs was unexpected)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting low priority send queue info of host on client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Reset the modification values.
		dwNumMsgs = 666;
		dwNumBytes = 666;

		tr = pDP8Peer->DP8P_GetSendQueueInfo(nonhostcontext.dpnidHost,
											&dwNumMsgs, &dwNumBytes,
											DPNGETSENDQUEUEINFO_PRIORITY_LOW);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting low priority send queue info of host on client failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get send queue info)

		if (dwNumMsgs != 0)
		{
			DPTEST_FAIL(hLog, "Num msgs was not expected (%u != 0)!", 1, dwNumMsgs);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num msgs was unexpected)

		if (dwNumBytes != 0)
		{
			DPTEST_FAIL(hLog, "Num bytes was not expected (%u != 0)!", 1, dwNumBytes);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num bytes was unexpected)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting normal priority send queue info of host on client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Reset the modification values.
		dwNumMsgs = 666;
		dwNumBytes = 666;

		tr = pDP8Peer->DP8P_GetSendQueueInfo(nonhostcontext.dpnidHost,
											&dwNumMsgs, &dwNumBytes,
											DPNGETSENDQUEUEINFO_PRIORITY_NORMAL);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting normal priority send queue info of host on client failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get send queue info)

		if (dwNumMsgs != 0)
		{
			DPTEST_FAIL(hLog, "Num msgs was not expected (%u != 0)!", 1, dwNumMsgs);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num msgs was unexpected)

		if (dwNumBytes != 0)
		{
			DPTEST_FAIL(hLog, "Num bytes was not expected (%u != 0)!", 1, dwNumBytes);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num bytes was unexpected)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting high priority send queue info of host on client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Reset the modification values.
		dwNumMsgs = 666;
		dwNumBytes = 666;

		tr = pDP8Peer->DP8P_GetSendQueueInfo(nonhostcontext.dpnidHost,
											&dwNumMsgs, &dwNumBytes,
											DPNGETSENDQUEUEINFO_PRIORITY_HIGH);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting high priority send queue info of host on client failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get send queue info)

		if (dwNumMsgs != 0)
		{
			DPTEST_FAIL(hLog, "Num msgs was not expected (%u != 0)!", 1, dwNumMsgs);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num msgs was unexpected)

		if (dwNumBytes != 0)
		{
			DPTEST_FAIL(hLog, "Num bytes was not expected (%u != 0)!", 1, dwNumBytes);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num bytes was unexpected)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting all priority send queues' info of host on client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Reset the modification values.
		dwNumMsgs = 666;
		dwNumBytes = 666;

		tr = pDP8Peer->DP8P_GetSendQueueInfo(nonhostcontext.dpnidHost,
											&dwNumMsgs, &dwNumBytes,
											(DPNGETSENDQUEUEINFO_PRIORITY_LOW | DPNGETSENDQUEUEINFO_PRIORITY_NORMAL | DPNGETSENDQUEUEINFO_PRIORITY_HIGH));
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting all priority send queues' info of host on client failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get send queue info)

		if (dwNumMsgs != 0)
		{
			DPTEST_FAIL(hLog, "Num msgs was not expected (%u != 0)!", 1, dwNumMsgs);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num msgs was unexpected)

		if (dwNumBytes != 0)
		{
			DPTEST_FAIL(hLog, "Num bytes was not expected (%u != 0)!", 1, dwNumBytes);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num bytes was unexpected)

/*
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Finishing pending work on non-host peer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		for(dwTemp = 0;(dwTemp < 50) && (pDP8Peer->m_pDP8Peer->DoWork(0) != S_FALSE); ++dwTemp);

		if(dwTemp >= 50)
		{
			DPTEST_FAIL(hLog, "DoWork didn't return S_FALSE on non-host after %u calls", 1, dwTemp);
			SETTHROW_TESTRESULT(E_FAIL);
		}
		else
		{
			DPTEST_FAIL(hLog, "DoWork returned S_FALSE on non-host after %u calls", 1, dwTemp);
		}
*/

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing peer client object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing peer client object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure we got the destroy player messages.
		if (nonhostcontext.dpnidHost != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for host on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)

		if (nonhostcontext.dpnidClient != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for client on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)


		// Technically we should wait to make sure the host saw the client go away
		// as expected but that's more hassle than it's worth.  Just make sure he's
		// gone after Close() has returned.


/*
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Finishing pending work on host peer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		for(dwTemp = 0;(dwTemp < 50) && (pDP8PeerHost->m_pDP8Peer->DoWork(0) != S_FALSE); ++dwTemp);

		if(dwTemp >= 50)
		{
			DPTEST_FAIL(hLog, "DoWork didn't return S_FALSE on host after %u calls", 1, dwTemp);
			SETTHROW_TESTRESULT(E_FAIL);
		}
		else
		{
			DPTEST_FAIL(hLog, "DoWork returned S_FALSE on host after %u calls", 1, dwTemp);
		}
*/

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing host object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8PeerHost->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing host object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure we got the destroy player messages.
		if (hostcontext.dpnidHost != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for host on host!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)

		if (hostcontext.dpnidClient != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for client on host!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing hosting DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8PeerHost->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release hosting DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8PeerHost);
		pDP8PeerHost = NULL;





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Peer);
		pDP8Peer = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE


	if (pDP8Peer != NULL)
	{
		delete (pDP8Peer);
		pDP8Peer = NULL;
	} // end if (have peer object)

	if (pDP8PeerHost != NULL)
	{
		delete (pDP8PeerHost);
		pDP8PeerHost = NULL;
	} // end if (have peer object)

	SAFE_RELEASE(pDP8Address);
	SAFE_CLOSEHANDLE(hostcontext.hClientCreatedEvent);
	ClearDoWorkList(&DoWorkList);
	SAFE_CLOSEHANDLE(hAsyncOpComplete);

	return (sr);
} // ParmVPeerExec_GetSendQInfo
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVPeerExec_Host()"
//==================================================================================
// ParmVPeerExec_Host
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.1.8 - Peer Host parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVPeerExec_Host(HANDLE hLog)
{
	CTNSystemResult			sr;
	CTNTestResult			tr;
	PWRAPDP8PEER			pDP8Peer = NULL;
	PDIRECTPLAY8ADDRESS		aDP8Addresses[2];
	PDIRECTPLAY8ADDRESS		aDP8AddressesCompare[2];
	DPN_APPLICATION_DESC	dpnad;
	DPN_APPLICATION_DESC	dpnadCompare;
	PARMVPHOSTCONTEXT		context;
	PVOID					pvTooLargeAppReservedData = NULL;
	DWORD					dwTooLargeAppReservedDataSize;
	DP_DOWORKLIST			DoWorkList;


	ZeroMemory(&DoWorkList, sizeof(DP_DOWORKLIST));
	ZeroMemory(aDP8Addresses, (2 * sizeof (PDIRECTPLAY8ADDRESS)));
	ZeroMemory(aDP8AddressesCompare, (2 * sizeof (PDIRECTPLAY8ADDRESS)));
	ZeroMemory(&context, sizeof (PARMVPHOSTCONTEXT));


	BEGIN_TESTCASE
	{
		// Allocate a buffer larger than the maximum allowable size for the IP
		// service provider.
		dwTooLargeAppReservedDataSize = 984;
		LOCALALLOC_OR_THROW(PVOID, pvTooLargeAppReservedData,
							dwTooLargeAppReservedDataSize);


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Peer = new CWrapDP8Peer(hLog);
		if (pDP8Peer == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8Peer->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating first DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (LPVOID *) &aDP8Addresses[0], NULL);
		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't create first DirectPlay8Address object!", 0);
			THROW_SYSTEMRESULT;
		} // end if (create failed)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating second DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (LPVOID *) &aDP8Addresses[1], NULL);
		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't create second DirectPlay8Address object!", 0);
			THROW_SYSTEMRESULT;
		} // end if (create failed)




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Hosting with all NULLs and 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Host(NULL, NULL, 0, NULL, NULL, NULL, 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Hosting with all NULLs and 0 flags didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't host)
*/




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Saving first device address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = aDP8Addresses[0]->Duplicate(&aDP8AddressesCompare[0]);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't duplicate first device address object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't duplicate device address object)




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Hosting with NULL app desc");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Host(NULL, aDP8Addresses, 1, NULL, NULL, NULL, 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Hosting with NULL app desc didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't host)

		tr = aDP8Addresses[0]->IsEqual(aDP8AddressesCompare[0]);
		if (tr != DPNSUCCESS_EQUAL)
		{
			DPTEST_FAIL(hLog, "Device address object was modified (0x%08x != 0x%08x)!",
				2, aDP8Addresses[0], aDP8AddressesCompare[0]);
			THROW_TESTRESULT;
		} // end if (addresses aren't equal)
*/




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Hosting with app desc of 0 size");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		//dpnad.dwSize = 0;
		//dpnad.dwFlags = 0;
		//dpnad.guidInstance = GUID_NULL;
		dpnad.guidApplication = GUID_PARMV_PEER_HOST;
		//dpnad.dwMaxPlayers = 0;
		//dpnad.dwCurrentPlayers = 0;
		//dpnad.pwszSessionName = NULL;
		//dpnad.pwszPassword = NULL;
		//dpnad.pvReservedData = NULL;
		//dpnad.dwReservedDataSize = 0;
		//dpnad.pvApplicationReservedData = NULL;
		//dpnad.dwApplicationReservedDataSize = 0;

		// Save what we're passing in to make sure it's not touched.
		CopyMemory(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC));


		tr = pDP8Peer->DP8P_Host(&dpnad, NULL, 0, NULL, NULL, NULL, 0);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Hosting with app desc of 0 size didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't host)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)
*/




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Hosting with app desc of too-large size");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC) + 1;
		//dpnad.dwFlags = 0;
		//dpnad.guidInstance = GUID_NULL;
		dpnad.guidApplication = GUID_PARMV_PEER_HOST;
		//dpnad.dwMaxPlayers = 0;
		//dpnad.dwCurrentPlayers = 0;
		//dpnad.pwszSessionName = NULL;
		//dpnad.pwszPassword = NULL;
		//dpnad.pvReservedData = NULL;
		//dpnad.dwReservedDataSize = 0;
		//dpnad.pvApplicationReservedData = NULL;
		//dpnad.dwApplicationReservedDataSize = 0;

		// Save what we're passing in to make sure it's not touched.
		CopyMemory(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC));


		tr = pDP8Peer->DP8P_Host(&dpnad, NULL, 0, NULL, NULL, NULL, 0);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Hosting with app desc of too-large size didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't host)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)
*/




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Hosting with app desc using invalid flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		dpnad.dwFlags = 0x666;
		//dpnad.guidInstance = GUID_NULL;
		dpnad.guidApplication = GUID_PARMV_PEER_HOST;
		//dpnad.dwMaxPlayers = 0;
		//dpnad.dwCurrentPlayers = 0;
		//dpnad.pwszSessionName = NULL;
		//dpnad.pwszPassword = NULL;
		//dpnad.pvReservedData = NULL;
		//dpnad.dwReservedDataSize = 0;
		//dpnad.pvApplicationReservedData = NULL;
		//dpnad.dwApplicationReservedDataSize = 0;

		// Save what we're passing in to make sure it's not touched.
		CopyMemory(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC));


		tr = pDP8Peer->DP8P_Host(&dpnad, NULL, 0, NULL, NULL, NULL, 0);
		if (tr != DPNERR_INVALIDFLAGS)
		{
			DPTEST_FAIL(hLog, "Hosting with app desc using invalid flags didn't return expected error INVALIDFLAGS!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't host)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)
*/




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Hosting with app desc using REQUIREPASSWORD flag without string specified");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		dpnad.dwFlags = DPNSESSION_REQUIREPASSWORD;
		//dpnad.guidInstance = GUID_NULL;
		dpnad.guidApplication = GUID_PARMV_PEER_HOST;
		//dpnad.dwMaxPlayers = 0;
		//dpnad.dwCurrentPlayers = 0;
		//dpnad.pwszSessionName = NULL;
		//dpnad.pwszPassword = NULL;
		//dpnad.pvReservedData = NULL;
		//dpnad.dwReservedDataSize = 0;
		//dpnad.pvApplicationReservedData = NULL;
		//dpnad.dwApplicationReservedDataSize = 0;

		// Save what we're passing in to make sure it's not touched.
		CopyMemory(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC));


		tr = pDP8Peer->DP8P_Host(&dpnad, NULL, 0, NULL, NULL, NULL, 0);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Hosting with app desc using REQUIREPASSWORD flag without string specified didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't host)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Hosting with app desc using password string without flag specified");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		//dpnad.dwFlags = 0;
		//dpnad.guidInstance = GUID_NULL;
		dpnad.guidApplication = GUID_PARMV_PEER_HOST;
		//dpnad.dwMaxPlayers = 0;
		//dpnad.dwCurrentPlayers = 0;
		//dpnad.pwszSessionName = NULL;
		dpnad.pwszPassword = L"Password";
		//dpnad.pvReservedData = NULL;
		//dpnad.dwReservedDataSize = 0;
		//dpnad.pvApplicationReservedData = NULL;
		//dpnad.dwApplicationReservedDataSize = 0;

		// Save what we're passing in to make sure it's not touched.
		CopyMemory(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC));


		tr = pDP8Peer->DP8P_Host(&dpnad, NULL, 0, NULL, NULL, NULL, 0);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Hosting with app desc using password string without flag specified didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't host)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)
*/




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Hosting with app desc using GUID_NULL application");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		//dpnad.dwFlags = 0;
		//dpnad.guidInstance = GUID_NULL;
		//dpnad.guidApplication = GUID_NULL;
		//dpnad.dwMaxPlayers = 0;
		//dpnad.dwCurrentPlayers = 0;
		//dpnad.pwszSessionName = NULL;
		//dpnad.pwszPassword = NULL;
		//dpnad.pvReservedData = NULL;
		//dpnad.dwReservedDataSize = 0;
		//dpnad.pvApplicationReservedData = NULL;
		//dpnad.dwApplicationReservedDataSize = 0;

		// Save what we're passing in to make sure it's not touched.
		CopyMemory(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC));


		tr = pDP8Peer->DP8P_Host(&dpnad, NULL, 0, NULL, NULL, NULL, 0);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Hosting with app desc using GUID_NULL application didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't host)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)
*/

		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		//dpnad.dwFlags = 0;
		//dpnad.guidInstance = GUID_NULL;
		dpnad.guidApplication = GUID_PARMV_PEER_HOST;
		//dpnad.dwMaxPlayers = 0;
		//dpnad.dwCurrentPlayers = 0;
		//dpnad.pwszSessionName = NULL;
		//dpnad.pwszPassword = NULL;
		//dpnad.pvReservedData = NULL;
		//dpnad.dwReservedDataSize = 0;
		//dpnad.pvApplicationReservedData = NULL;
		//dpnad.dwApplicationReservedDataSize = 0;

		// Save what we're passing in to make sure it's not touched.
		CopyMemory(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC));

/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Hosting with NULL device address");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Host(&dpnad, NULL, 1, NULL, NULL, NULL, 0);
		if (tr != DPNERR_INVALIDDEVICEADDRESS)
		{
			DPTEST_FAIL(hLog, "Hosting with app desc didn't return expected error INVALIDDEVICEADDRESS!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't host)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)
*/




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Hosting with 0 device address count");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Host(&dpnad, aDP8Addresses, 0, NULL, NULL, NULL, 0);
		if (tr != DPNERR_INVALIDDEVICEADDRESS)
		{
			DPTEST_FAIL(hLog, "Hosting with app desc didn't return expected error INVALIDDEVICEADDRESS!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't host)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)
*/

/* XBOX - For now, Xbox doesn't require an SP to be set
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Hosting with empty address");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Host(&dpnad, aDP8Addresses, 1, NULL, NULL, NULL, 0);
		if (tr != DPNERR_INVALIDDEVICEADDRESS)
		{
			if(tr == DPNERR_UNINITIALIZED)
			{
				DPTEST_FAIL(hLog, "Xbox bug 3000 occurred!", 0);
				fPassed = FALSE;
			}
			else
			{
				DPTEST_FAIL(hLog, "Hosting with app desc and empty address didn't return expected error INVALIDDEVICEADDRESS!", 0);
				THROW_TESTRESULT;
			}
		} // end if (couldn't host)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)
*/

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting first address object's SP to unknown GUID");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = aDP8Addresses[0]->SetSP(&GUID_UNKNOWN);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting first address object's SP to unknown GUID failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set SP)




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Hosting before initialization");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Host(&dpnad, aDP8Addresses, 1, NULL, NULL, NULL, 0);
		if (tr != DPNERR_UNINITIALIZED)
		{
			DPTEST_FAIL(hLog, "Hosting before initialization didn't return expected error UNINITIALIZED!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't host)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)
*/





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Initializing with context, 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		context.hLog = hLog;

		tr = pDP8Peer->DP8P_Initialize(&context, ParmVPHostDPNMessageHandler, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Initializing with context, 0 flags failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)


/* XBOX - This test behaves differently on the Xbox than on the PC, it is a marginal case
          and it causes certain side-effects that are a pain to deal with here, so I'm
		  removing it for now
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Hosting with address using unknown GUID");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Host(&dpnad, aDP8Addresses, 1, NULL, NULL, NULL, 0);
		if (tr != DPNERR_INVALIDDEVICEADDRESS)
		{
			if(tr == DPN_OK)
			{
				DPTEST_FAIL(hLog, "Xbox behavior differs from PC, but is acceptable (see bug 3000)", 0);
				pDP8Peer->DP8P_Close(0);
				pDP8Peer->DP8P_Initialize(&context, ParmVPHostDPNMessageHandler, 0);
			}
			else
			{
				DPTEST_FAIL(hLog, "Hosting with app desc and empty address didn't return expected error INVALIDDEVICEADDRESS!", 0);
				THROW_TESTRESULT;
			}
		} // end if (couldn't host)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)
*/




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting first address object's SP to TCP/IP");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = aDP8Addresses[0]->SetSP(&CLSID_DP8SP_TCPIP);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting first address object's SP to TCP/IP failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set SP)




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Hosting with app desc using CLIENT_SERVER flag");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		dpnad.dwFlags = DPNSESSION_CLIENT_SERVER;
		//dpnad.guidInstance = GUID_NULL;
		dpnad.guidApplication = GUID_PARMV_PEER_HOST;
		//dpnad.dwMaxPlayers = 0;
		//dpnad.dwCurrentPlayers = 0;
		//dpnad.pwszSessionName = NULL;
		//dpnad.pwszPassword = NULL;
		//dpnad.pvReservedData = NULL;
		//dpnad.dwReservedDataSize = 0;
		//dpnad.pvApplicationReservedData = NULL;
		//dpnad.dwApplicationReservedDataSize = 0;

		// Save what we're passing in to make sure it's not touched.
		CopyMemory(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC));


		tr = pDP8Peer->DP8P_Host(&dpnad, aDP8Addresses, 1, NULL, NULL, NULL, 0);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Hosting with app desc using CLIENT_SERVER flag didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't host)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)
*/




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Hosting using app desc with app reserved data too large");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		//dpnad.dwFlags = 0;
		//dpnad.guidInstance = GUID_NULL;
		dpnad.guidApplication = GUID_PARMV_PEER_HOST;
		//dpnad.dwMaxPlayers = 0;
		//dpnad.dwCurrentPlayers = 0;
		//dpnad.pwszSessionName = NULL;
		//dpnad.pwszPassword = NULL;
		//dpnad.pvReservedData = NULL;
		//dpnad.dwReservedDataSize = 0;
		dpnad.pvApplicationReservedData = pvTooLargeAppReservedData;
		dpnad.dwApplicationReservedDataSize = dwTooLargeAppReservedDataSize;

		// Save what we're passing in to make sure it's not touched.
		CopyMemory(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC));


		tr = pDP8Peer->DP8P_Host(&dpnad, aDP8Addresses, 1, NULL, NULL, NULL, 0);
		if (tr != DPNERR_DATATOOLARGE)
		{
			DPTEST_FAIL(hLog, "Hosting using app desc with app reserved data too large didn't return expected error DATATOOLARGE!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't host)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		//dpnad.dwFlags = 0;
		//dpnad.guidInstance = GUID_NULL;
		dpnad.guidApplication = GUID_PARMV_PEER_HOST;
		//dpnad.dwMaxPlayers = 0;
		//dpnad.dwCurrentPlayers = 0;
		//dpnad.pwszSessionName = NULL;
		//dpnad.pwszPassword = NULL;
		//dpnad.pvReservedData = NULL;
		//dpnad.dwReservedDataSize = 0;
		//dpnad.pvApplicationReservedData = NULL;
		//dpnad.dwApplicationReservedDataSize = 0;

		// Save what we're passing in to make sure it's not touched.
		CopyMemory(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC));

/* XBOX - This test behaves differently on the Xbox than on the PC, it is a marginal case
          and it causes certain side-effects that are a pain to deal with here, so I'm
		  removing it for now
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Hosting with 2 devices, second with no SP specified");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Host(&dpnad, aDP8Addresses, 2, NULL, NULL, NULL, 0);
		if (tr != DPNERR_INVALIDDEVICEADDRESS)
		{
			if(tr == DPN_OK)
			{
				DPTEST_FAIL(hLog, "Xbox bug 3000 occurred!", 0);
				pDP8Peer->DP8P_Close(0);
				pDP8Peer->DP8P_Initialize(&context, ParmVPHostDPNMessageHandler, 0);
				fPassed = FALSE;
			}
			else
			{
				DPTEST_FAIL(hLog, "Hosting with 2 devices, second with no SP specified didn't return expected error INVALIDDEVICEADDRESS!", 0);
				THROW_TESTRESULT;
			}
		} // end if (couldn't host)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)
*/




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting second address object's SP to TCP/IP");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = aDP8Addresses[1]->SetSP(&CLSID_DP8SP_TCPIP);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting second address object's SP to TCP/IP failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set SP)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Hosting with 2 devices using same SPs");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Okay, we can now get a CREATE_PLAYER indication.
		context.fCreatePlayerAllowed = TRUE;

		tr = pDP8Peer->DP8P_Host(&dpnad,
								aDP8Addresses,
								2,
								NULL,
								NULL,
								&(context.dpnidPlayer),
								0);

		// Prevent any weird CREATE_PLAYER indications.
		context.fCreatePlayerAllowed = FALSE;

		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Hosting with 2 devices using same SPs failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't host)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		// Make sure we got the create player message.
		if (context.dpnidPlayer == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Hosting when already hosting");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Host(&dpnad, aDP8Addresses, 2, NULL, NULL, NULL, 0);
		if (tr != DPNERR_HOSTING)
		{
			DPTEST_FAIL(hLog, "Hosting when already hosting didn't return expected error HOSTING!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't host)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)


/* XBOX - No support for DPNSVR
#pragma TODO(vanceo, "We're trusting the DPNSVR library")
		// Since we did not set NODPNSVR, and we're on an SP which SUPPORTSDPNSVR,
		// DPNSVR.EXE should be running, and thus killing it should succeed.

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Killing DPNSvr");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = KillDPNSvr();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Killing DPNSvr failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't kill DPNSvr)
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure we got the destroy player message.
		if (context.dpnidPlayer != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Reinitializing with context, 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		context.hLog = hLog;

		tr = pDP8Peer->DP8P_Initialize(&context, ParmVPHostDPNMessageHandler, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Reinitializing with context, 0 flags failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)




/* XBOX - IPX not supported
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting second address object's SP to IPX");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = aDP8Addresses[1]->SetSP(&CLSID_DP8SP_IPX);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting second address object's SP to IPX failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set SP)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Hosting with 2 devices using different SPs");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Okay, we can now get a CREATE_PLAYER indication.
		context.fCreatePlayerAllowed = TRUE;

		tr = pDP8Peer->DP8P_Host(&dpnad,
								aDP8Addresses,
								2,
								NULL,
								NULL,
								&(context.dpnidPlayer),
								0);

		// Prevent any weird CREATE_PLAYER indications.
		context.fCreatePlayerAllowed = FALSE;

		// This should always succeed, even if IPX was not installed, simply
		// because if one address is succesfully used, then Host should succeed.
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Hosting with 2 devices using different SPs failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't host)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		// Make sure we got the create player message.
		if (context.dpnidPlayer == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player)
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure we got the destroy player message.
		if (context.dpnidPlayer != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)


/* XBOX - No support for DPNSVR
#pragma TODO(vanceo, "We're trusting the DPNSVR library")
		// We Close()ed, but DPNSVR.EXE should still be running, and thus killing it
		// should succeed.

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Killing DPNSvr");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = KillDPNSvr();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Killing DPNSvr failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't kill DPNSvr)
*/


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Reinitializing with context, 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		context.hLog = hLog;

		tr = pDP8Peer->DP8P_Initialize(&context, ParmVPHostDPNMessageHandler, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Reinitializing with context, 0 flags failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)




/* XBOX - No support for DPNSVR
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Hosting with 2 devices using different SPs without DPNSVR");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		dpnad.dwFlags = DPNSESSION_NODPNSVR;
		//dpnad.guidInstance = GUID_NULL;
		dpnad.guidApplication = GUID_PARMV_PEER_HOST;
		//dpnad.dwMaxPlayers = 0;
		//dpnad.dwCurrentPlayers = 0;
		//dpnad.pwszSessionName = NULL;
		//dpnad.pwszPassword = NULL;
		//dpnad.pvReservedData = NULL;
		//dpnad.dwReservedDataSize = 0;
		//dpnad.pvApplicationReservedData = NULL;
		//dpnad.dwApplicationReservedDataSize = 0;

		// Save what we're passing in to make sure it's not touched.
		CopyMemory(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC));


		// Okay, we can now get a CREATE_PLAYER indication.
		context.fCreatePlayerAllowed = TRUE;

		tr = pDP8Peer->DP8P_Host(&dpnad,
								aDP8Addresses,
								2,
								NULL,
								NULL,
								&(context.dpnidPlayer),
								0);

		// Prevent any weird CREATE_PLAYER indications.
		context.fCreatePlayerAllowed = FALSE;

		// This should always succeed, even if IPX was not installed, simply
		// because if one address is succesfully used, then Host should succeed.
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Hosting with 2 devices using different SPs again failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't host)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		// Make sure we got the create player message.
		if (context.dpnidPlayer == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player)

#pragma TODO(vanceo, "We're trusting the DPNSVR library")
		// Since we said NODPNSVR, DPNSVR.EXE had better not be running.
		if (IsDPNSvrRunning())
		{
			DPTEST_FAIL(hLog, "DPNSvr is running even though it shouldn't be!", 0);
			SETTHROW_TESTRESULT(ERROR_ALREADY_EXISTS);
		} // end if (couldn't kill DPNSvr)
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure we got the destroy player message.
		if (context.dpnidPlayer != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Peer);
		pDP8Peer = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE


	if (pDP8Peer != NULL)
	{
		delete (pDP8Peer);
		pDP8Peer = NULL;
	} // end if (have peer object)

	SAFE_RELEASE(aDP8Addresses[0]);
	SAFE_RELEASE(aDP8Addresses[1]);
	SAFE_RELEASE(aDP8AddressesCompare[0]);
	SAFE_RELEASE(aDP8AddressesCompare[1]);
	SAFE_LOCALFREE(pvTooLargeAppReservedData);


	return (sr);
} // ParmVPeerExec_Host
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVPeerExec_GetAppDesc()"
//==================================================================================
// ParmVPeerExec_GetAppDesc
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.1.9 - Peer GetApplicationDesc parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVPeerExec_GetAppDesc(HANDLE hLog)
{
	CTNSystemResult				sr;
	CTNTestResult				tr;
	PWRAPDP8PEER				pDP8Peer = NULL;
	PWRAPDP8PEER				pDP8PeerHost = NULL;
	DPN_APPLICATION_DESC		dpnad;
	DPN_APPLICATION_DESC		dpnadCompare;
	PDIRECTPLAY8ADDRESS			pDP8Address = NULL;
	PDIRECTPLAY8ADDRESS			pDP8AddressCompare = NULL;
	PDPN_APPLICATION_DESC		pdpnad = NULL;
	DWORD						dwSize = 0;
	DWORD						dwExpectedSize;
	PARMVPGETAPPDESCCONTEXT		hostcontext;
	PARMVPGETAPPDESCCONTEXT		nonhostcontext;
	DP_DOWORKLIST				DoWorkList;
	DPNHANDLE					hAsyncOp;
	HANDLE						hAsyncOpComplete = NULL;

	ZeroMemory(&DoWorkList, sizeof(DP_DOWORKLIST));
	ZeroMemory(&hostcontext, sizeof (PARMVPGETAPPDESCCONTEXT));
	hostcontext.fHost = TRUE;

	ZeroMemory(&nonhostcontext, sizeof (PARMVPGETAPPDESCCONTEXT));
	//nonhostcontext.fHost = FALSE;


	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Peer = new CWrapDP8Peer(hLog);
		if (pDP8Peer == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8Peer->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (LPVOID *) &pDP8Address, NULL);
		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't create DirectPlay8Address object!", 0);
			THROW_SYSTEMRESULT;
		} // end if (create failed)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting address object's SP to TCP/IP");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->SetSP(&CLSID_DP8SP_TCPIP);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting address object's SP to TCP/IP failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set SP)



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting app desc with NULLs and 0 flags using C++ macro");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = IDirectPlay8Peer_GetApplicationDesc(pDP8Peer->m_pDP8Peer, NULL, NULL, 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Getting app desc with NULLs and 0 flags using C++ macro didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get app desc)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting app desc with NULLs and 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_GetApplicationDesc(NULL, NULL, 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Getting app desc with NULLs and 0 flags didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get app desc)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting app desc with NULL buffer and invalid flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_GetApplicationDesc(NULL, &dwSize, 0x666);
		if (tr != DPNERR_INVALIDFLAGS)
		{
			DPTEST_FAIL(hLog, "Getting app desc with NULL buffer and invalid flags didn't return expected error INVALIDFLAGS!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get app desc)

		if (dwSize != 0)
		{
			DPTEST_FAIL(hLog, "Size was changed (%u != 0)!", 1, dwSize);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (size is not 0)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting app desc with NULL buffer before initialization");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_GetApplicationDesc(NULL, &dwSize, 0);
		if (tr != DPNERR_UNINITIALIZED)
		{
			DPTEST_FAIL(hLog, "Getting app desc with NULL buffer before initialization didn't return expected error UNINITIALIZED!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get app desc)

		if (dwSize != 0)
		{
			DPTEST_FAIL(hLog, "Size was changed (%u != 0)!", 1, dwSize);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (size is not 0)
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Initializing peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		hostcontext.hLog = hLog;

		tr = pDP8Peer->DP8P_Initialize(&hostcontext, ParmVPGetAppDescDPNMessageHandler, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Initializing peer object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting app desc with NULL buffer without a connection");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_GetApplicationDesc(NULL, &dwSize, 0);
		if (tr != DPNERR_NOCONNECTION)
		{
			DPTEST_FAIL(hLog, "Getting app desc with NULL buffer without a connection didn't return expected error NOCONNECTION!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get app desc)

		if (dwSize != 0)
		{
			DPTEST_FAIL(hLog, "Size was changed (%u != 0)!", 1, dwSize);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (size is not 0)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Saving device address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->Duplicate(&pDP8AddressCompare);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't duplicate device address object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't duplicate device address object)

		

		
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Hosting session");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		//dpnad.dwFlags = 0;
		//dpnad.guidInstance = GUID_NULL;
		dpnad.guidApplication = GUID_PARMV_PEER_GETAPPDESC;
		//dpnad.dwMaxPlayers = 0;
		//dpnad.dwCurrentPlayers = 0;
		//dpnad.pwszSessionName = NULL;
		//dpnad.pwszPassword = NULL;
		//dpnad.pvReservedData = NULL;
		//dpnad.dwReservedDataSize = 0;
		//dpnad.pvApplicationReservedData = NULL;
		//dpnad.dwApplicationReservedDataSize = 0;

		// Save what we're passing in to make sure it's not touched.
		CopyMemory(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC));

		tr = pDP8Peer->DP8P_Host(&dpnad,
								&pDP8Address,
								1,
								NULL,
								NULL,
								&(hostcontext.dpnidHost),
								0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't start hosting session!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't host)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		tr = pDP8Address->IsEqual(pDP8AddressCompare);
		if (tr != DPNSUCCESS_EQUAL)
		{
			DPTEST_FAIL(hLog, "Device address object was modified (0x%08x != 0x%08x)!",
				2, pDP8Address, pDP8AddressCompare);
			THROW_TESTRESULT;
		} // end if (addresses aren't equal)

		// Make sure we got the create player message.
		if (hostcontext.dpnidHost == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting app desc with NULL buffer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwExpectedSize = sizeof (DPN_APPLICATION_DESC);

		tr = pDP8Peer->DP8P_GetApplicationDesc(NULL, &dwSize, 0);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Getting app desc with NULL buffer didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get app desc)

		if (dwSize != dwExpectedSize)
		{
			DPTEST_FAIL(hLog, "Size returned was unexpected (%u != %u)!", 2, dwSize, dwExpectedSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (size is not expected)



		LOCALALLOC_OR_THROW(PDPN_APPLICATION_DESC, pdpnad,
							dwSize + BUFFERPADDING_SIZE);

/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting app desc using buffer with app desc size of 0");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		FillWithDWord((((PBYTE) pdpnad) + sizeof (DWORD)),
						(dwSize - sizeof (DWORD) + BUFFERPADDING_SIZE),
						DONT_TOUCH_MEMORY_PATTERN);

		pdpnad->dwSize = 0;


		tr = pDP8Peer->DP8P_GetApplicationDesc(pdpnad, &dwSize, 0);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Getting app desc using buffer with app desc size of 0 didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get app desc)

		if (dwSize != dwExpectedSize)
		{
			DPTEST_FAIL(hLog, "Size returned was unexpected (%u != %u)!", 2, dwSize, dwExpectedSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (size is not expected)

		// Make sure the buffer was not modified or overrun.
		if ((pdpnad->dwSize != 0) ||
			(! IsFilledWithDWord((((PBYTE) pdpnad) + sizeof (DWORD)), (dwSize - sizeof (DWORD) + BUFFERPADDING_SIZE), DONT_TOUCH_MEMORY_PATTERN)))
		{
			DPTEST_FAIL(hLog, "The %u byte app desc buffer (at %x) was modified or overrun!",
				2, dwSize, pdpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (buffer was overrun)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting app desc using buffer with app desc size too large");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		FillWithDWord((((PBYTE) pdpnad) + sizeof (DWORD)),
						(dwSize - sizeof (DWORD) + BUFFERPADDING_SIZE),
						DONT_TOUCH_MEMORY_PATTERN);

		pdpnad->dwSize = sizeof (DPN_APPLICATION_DESC) + 1;


		tr = pDP8Peer->DP8P_GetApplicationDesc(pdpnad, &dwSize, 0);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Getting app desc using buffer with app desc size too large didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get app desc)

		if (dwSize != dwExpectedSize)
		{
			DPTEST_FAIL(hLog, "Size returned was unexpected (%u != %u)!", 2, dwSize, dwExpectedSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (size is not expected)

		// Make sure the buffer was not modified or overrun.
		if ((pdpnad->dwSize != (sizeof (DPN_APPLICATION_DESC) + 1)) ||
			(! IsFilledWithDWord((((PBYTE) pdpnad) + sizeof (DWORD)), (dwSize - sizeof (DWORD) + BUFFERPADDING_SIZE), DONT_TOUCH_MEMORY_PATTERN)))
		{
			DPTEST_FAIL(hLog, "The %u byte app desc buffer (at %x) was modified or overrun!",
				2, dwSize, pdpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (buffer was overrun)
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting app desc");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pdpnad->dwSize = sizeof (DPN_APPLICATION_DESC);

		dpnad.dwCurrentPlayers = 1; // there will be one player when the app desc is retrieved


		FillWithDWord(((PBYTE) pdpnad) + dwSize, BUFFERPADDING_SIZE,
						DONT_TOUCH_MEMORY_PATTERN);

		tr = pDP8Peer->DP8P_GetApplicationDesc(pdpnad, &dwSize, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting app desc failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get app desc)

		if (dwSize != dwExpectedSize)
		{
			DPTEST_FAIL(hLog, "Size returned was unexpected (%u != %u)!", 2, dwSize, dwExpectedSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (size is not expected)


		// Make sure the structure returned was expected.
		tr = ParmVCompareAppDesc(hLog, pdpnad, &dpnad);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Comparing application desc buffer %x with expected %x failed!",
				2, pdpnad, &dpnad);
			THROW_TESTRESULT;
		} // end if (failed comparison)


		// Check for buffer overrun.
		if (! IsFilledWithDWord(((PBYTE) pdpnad) + dwSize, BUFFERPADDING_SIZE, DONT_TOUCH_MEMORY_PATTERN))
		{
			DPTEST_FAIL(hLog, "The %u byte app desc buffer (at %x) was overrun!",
				2, dwSize, pdpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (buffer was overrun)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting app desc with extra buffer size");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		FillWithDWord(((PBYTE) pdpnad) + dwSize, BUFFERPADDING_SIZE,
						DONT_TOUCH_MEMORY_PATTERN);

		dwSize += BUFFERPADDING_SIZE;

		tr = pDP8Peer->DP8P_GetApplicationDesc(pdpnad, &dwSize, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting app desc failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get app desc)

		if (dwSize != dwExpectedSize)
		{
			DPTEST_FAIL(hLog, "Size returned was unexpected (%u != %u)!", 2, dwSize, dwExpectedSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (size is not expected)


		// Make sure the structure returned was expected.
		tr = ParmVCompareAppDesc(hLog, pdpnad, &dpnad);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Comparing application desc buffer %x with expected %x failed!",
				2, pdpnad, &dpnad);
			THROW_TESTRESULT;
		} // end if (failed comparison)


		// Check for buffer overrun.
		if (! IsFilledWithDWord(((PBYTE) pdpnad) + dwSize, BUFFERPADDING_SIZE, DONT_TOUCH_MEMORY_PATTERN))
		{
			DPTEST_FAIL(hLog, "The %u byte app desc buffer (at %x) was overrun!",
				2, dwSize, pdpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (buffer was overrun)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing peer object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure we got the destroy player message.
		if (hostcontext.dpnidHost != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Re-initializing peer object with nonhost context");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		nonhostcontext.hLog = hLog;

		tr = pDP8Peer->DP8P_Initialize(&nonhostcontext,
										ParmVPSetAppDescDPNMessageHandler,
										0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Re-initializing peer object with context, 0 flags failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating new peer host object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Address->Release();
		pDP8Address = NULL;

		hostcontext.hLog = hLog;

		tr = ParmVCreatePeerHost(hLog, ParmVPSetAppDescDPNMessageHandler,
								&hostcontext,
								&dpnad,
								&hostcontext.dpnidHost,
								&pDP8PeerHost,
								&pDP8Address);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Creating peer host failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't create peer host)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Connecting peer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

// XBOX - Had to make connection asynchronous

		// Host should get the create player now.
		CREATEEVENT_OR_THROW(hostcontext.hClientCreatedEvent, NULL, FALSE, FALSE, NULL);
		SAFE_CLOSEHANDLE(hAsyncOpComplete);
		CREATEEVENT_OR_THROW(hAsyncOpComplete, NULL, FALSE, FALSE, NULL);

		// Save what we're passing in to make sure it's not touched.
		CopyMemory(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC));

		// Even though it's synchronous, we'll still get a completion.  The async op
		// handle will be NULL, though.
		nonhostcontext.fConnectCanComplete = TRUE;

		tr = pDP8Peer->DP8P_Connect(&dpnad,
									pDP8Address,
									NULL,
									NULL,
									NULL,
									NULL,
									0,
									&(nonhostcontext.dpnidClient),
									hAsyncOpComplete,
									&hAsyncOp,
									0);

		if((tr != DPNSUCCESS_PENDING) && (tr != DPN_OK))
		{
			DPTEST_FAIL(hLog, "Couldn't connect! (error 0x%08x)", 1, tr);
			THROW_TESTRESULT;
		} // end if (couldn't connect)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for connect to complete on non-host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hAsyncOpComplete))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird connects from completing.
		nonhostcontext.fConnectCanComplete = FALSE;

		// Make sure we saw the connect completion indication.
		if (! nonhostcontext.fConnectCompleted)
		{
			DPTEST_FAIL(hLog, "Didn't get connect complete indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (connect didn't complete)

		// Reset the context.
		nonhostcontext.fConnectCompleted = FALSE;

		// Make sure we got the create player messages.
		if (nonhostcontext.dpnidHost == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication for host on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player)

		if (nonhostcontext.dpnidClient == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication for client on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for create player to be indicated on host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hostcontext.hClientCreatedEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting app desc on client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pdpnad->dwSize = sizeof (DPN_APPLICATION_DESC);

		dpnad.dwCurrentPlayers = 2; // there will be two players when the app desc is retrieved


		FillWithDWord(((PBYTE) pdpnad) + dwSize, BUFFERPADDING_SIZE,
						DONT_TOUCH_MEMORY_PATTERN);

		tr = pDP8Peer->DP8P_GetApplicationDesc(pdpnad, &dwSize, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting app desc on client failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get app desc)

		if (dwSize != dwExpectedSize)
		{
			DPTEST_FAIL(hLog, "Size returned was unexpected (%u != %u)!", 2, dwSize, dwExpectedSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (size is not expected)


		// Make sure the structure returned was expected.
		tr = ParmVCompareAppDesc(hLog, pdpnad, &dpnad);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Comparing application desc buffer %x with expected %x failed!",
				2, pdpnad, &dpnad);
			THROW_TESTRESULT;
		} // end if (failed comparison)


		// Check for buffer overrun.
		if (! IsFilledWithDWord(((PBYTE) pdpnad) + dwSize, BUFFERPADDING_SIZE, DONT_TOUCH_MEMORY_PATTERN))
		{
			DPTEST_FAIL(hLog, "The %u byte app desc buffer (at %x) was overrun!",
				2, dwSize, pdpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (buffer was overrun)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing peer client object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing peer client object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure we got the destroy player messages.
		if (nonhostcontext.dpnidHost != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for host on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)

		if (nonhostcontext.dpnidClient != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for client on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)


		// Technically we should wait to make sure the host saw the client go away
		// as expected but that's more hassle than it's worth.  Just make sure he's
		// gone after Close() has returned.





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing host object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8PeerHost->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing host object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure we got the destroy player messages.
		if (hostcontext.dpnidHost != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for host on host!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)

		if (hostcontext.dpnidClient != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for client on host!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing hosting DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8PeerHost->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release hosting DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8PeerHost);
		pDP8PeerHost = NULL;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Peer);
		pDP8Peer = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE



	if (pDP8Peer != NULL)
	{
		delete (pDP8Peer);
		pDP8Peer = NULL;
	} // end if (have peer object)

	if (pDP8PeerHost != NULL)
	{
		delete (pDP8PeerHost);
		pDP8PeerHost = NULL;
	} // end if (have peer object)

	SAFE_LOCALFREE(pdpnad);
	SAFE_RELEASE(pDP8Address);
	SAFE_RELEASE(pDP8AddressCompare);
	SAFE_CLOSEHANDLE(hostcontext.hClientCreatedEvent);
	ClearDoWorkList(&DoWorkList);
	SAFE_CLOSEHANDLE(hAsyncOpComplete);

	return (sr);
} // ParmVPeerExec_GetAppDesc
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVPeerExec_SetAppDesc()"
//==================================================================================
// ParmVPeerExec_SetAppDesc
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.1.10 - Peer SetApplicationDesc parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVPeerExec_SetAppDesc(HANDLE hLog)
{
	CTNSystemResult				sr;
	CTNTestResult				tr;
	PWRAPDP8PEER				pDP8Peer = NULL;
	PWRAPDP8PEER				pDP8PeerHost = NULL;
	PDIRECTPLAY8ADDRESS			pDP8Address = NULL;
	DPN_APPLICATION_DESC		dpnad;
	DPN_APPLICATION_DESC		dpnadCompare;
	PARMVPSETAPPDESCCONTEXT		hostcontext;
	PARMVPSETAPPDESCCONTEXT		nonhostcontext;
	PVOID						pvTooLargeAppReservedData = NULL;
	DWORD						dwTooLargeAppReservedDataSize;
	DP_DOWORKLIST				DoWorkList;
	DPNHANDLE					hAsyncOp;
	HANDLE						hAsyncOpComplete = NULL;

	ZeroMemory(&DoWorkList, sizeof(DP_DOWORKLIST));
	ZeroMemory(&hostcontext, sizeof (PARMVPSETAPPDESCCONTEXT));
	hostcontext.fHost = TRUE;

	ZeroMemory(&nonhostcontext, sizeof (PARMVPSETAPPDESCCONTEXT));
	//nonhostcontext.fHost = FALSE;



	BEGIN_TESTCASE
	{
		CREATEEVENT_OR_THROW(hostcontext.hGotAppDescUpdateEvent,
							NULL, FALSE, FALSE, NULL);
		CREATEEVENT_OR_THROW(nonhostcontext.hGotAppDescUpdateEvent,
							NULL, FALSE, FALSE, NULL);

		// Allocate a buffer larger than the maximum allowable size for the IP
		// service provider.
		dwTooLargeAppReservedDataSize = 984;
		LOCALALLOC_OR_THROW(PVOID, pvTooLargeAppReservedData,
							dwTooLargeAppReservedDataSize);



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Peer = new CWrapDP8Peer(hLog);
		if (pDP8Peer == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8Peer->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (LPVOID *) &pDP8Address, NULL);
		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't create DirectPlay8Address object!", 0);
			THROW_SYSTEMRESULT;
		} // end if (create failed)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting address object's SP to TCP/IP");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->SetSP(&CLSID_DP8SP_TCPIP);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting address object's SP to TCP/IP failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set SP)





/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting app desc with NULL and 0 flags using C++ macro");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = IDirectPlay8Peer_SetApplicationDesc(pDP8Peer->m_pDP8Peer, NULL, 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Setting app desc with NULL and 0 flags using C++ macro didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set app desc)
*/




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting app desc with NULL and 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_SetApplicationDesc(NULL, 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Setting app desc with NULL and 0 flags didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set app desc)
*/

		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		//dpnad.dwFlags = 0;
		//dpnad.guidInstance = GUID_NULL;
		dpnad.guidApplication = GUID_PARMV_PEER_SETAPPDESC;
		//dpnad.dwMaxPlayers = 0;
		//dpnad.dwCurrentPlayers = 0;
		//dpnad.pwszSessionName = NULL;
		//dpnad.pwszPassword = NULL;
		//dpnad.pvReservedData = NULL;
		//dpnad.dwReservedDataSize = 0;
		//dpnad.pvApplicationReservedData = NULL;
		//dpnad.dwApplicationReservedDataSize = 0;

		// Save what we're passing in to make sure it's not touched.
		CopyMemory(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC));

/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting app desc with invalid flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_SetApplicationDesc(&dpnad, 0x666);
		if (tr != DPNERR_INVALIDFLAGS)
		{
			DPTEST_FAIL(hLog, "Setting app desc with invalid flags didn't return expected error INVALIDFLAGS!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set app desc)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting app desc before init");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_SetApplicationDesc(&dpnad, 0);
		if (tr != DPNERR_UNINITIALIZED)
		{
			DPTEST_FAIL(hLog, "Setting app desc before init didn't return expected error UNINITIALIZED!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set app desc)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Initializing peer object with host context");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		hostcontext.hLog = hLog;

		tr = pDP8Peer->DP8P_Initialize(&hostcontext,
										ParmVPSetAppDescDPNMessageHandler,
										0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Initializing peer object with host context failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting app desc without a connection");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_SetApplicationDesc(&dpnad, 0);
		if (tr != DPNERR_NOTHOST)
		{
			DPTEST_FAIL(hLog, "Setting app desc without a connection didn't return expected error NOTHOST!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set app desc)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Hosting session");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		//dpnad.dwFlags = 0;
		//dpnad.guidInstance = GUID_NULL;
		dpnad.guidApplication = GUID_PARMV_PEER_GETAPPDESC;
		//dpnad.dwMaxPlayers = 0;
		//dpnad.dwCurrentPlayers = 0;
		//dpnad.pwszSessionName = NULL;
		//dpnad.pwszPassword = NULL;
		//dpnad.pvReservedData = NULL;
		//dpnad.dwReservedDataSize = 0;
		//dpnad.pvApplicationReservedData = NULL;
		//dpnad.dwApplicationReservedDataSize = 0;

		// Save what we're passing in to make sure it's not touched.
		CopyMemory(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC));

		tr = pDP8Peer->DP8P_Host(&dpnad,
								&pDP8Address,
								1,
								NULL,
								NULL,
								&(hostcontext.dpnidHost),
								0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't start hosting session!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't host)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		// Make sure we got the create player message.
		if (hostcontext.dpnidHost == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting app desc with app reserved data too large");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		//dpnad.dwFlags = 0;
		//dpnad.guidInstance = GUID_NULL;
		dpnad.guidApplication = GUID_PARMV_PEER_SETAPPDESC;
		//dpnad.dwMaxPlayers = 0;
		//dpnad.dwCurrentPlayers = 0;
		//dpnad.pwszSessionName = NULL;
		//dpnad.pwszPassword = NULL;
		//dpnad.pvReservedData = NULL;
		//dpnad.dwReservedDataSize = 0;
		dpnad.pvApplicationReservedData = pvTooLargeAppReservedData;
		dpnad.dwApplicationReservedDataSize = dwTooLargeAppReservedDataSize;

		// Save what we're passing in to make sure it's not touched.
		CopyMemory(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC));

		tr = pDP8Peer->DP8P_SetApplicationDesc(&dpnad, 0);
		if (tr != DPNERR_DATATOOLARGE)
		{
			DPTEST_FAIL(hLog, "Setting app desc with app reserved data too large didn't return expected error DATATOOLARGE!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set app desc)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting app desc");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		//dpnad.dwFlags = 0;
		//dpnad.guidInstance = GUID_NULL;
		dpnad.guidApplication = GUID_PARMV_PEER_SETAPPDESC;
		//dpnad.dwMaxPlayers = 0;
		//dpnad.dwCurrentPlayers = 0;
		//dpnad.pwszSessionName = NULL;
		//dpnad.pwszPassword = NULL;
		//dpnad.pvReservedData = NULL;
		//dpnad.dwReservedDataSize = 0;
		//dpnad.pvApplicationReservedData = NULL;
		//dpnad.dwApplicationReservedDataSize = 0;

		// Expect the update message.
		hostcontext.fCanGetAppDescUpdate = TRUE;

		// Save what we're passing in to make sure it's not touched.
		CopyMemory(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC));

		tr = pDP8Peer->DP8P_SetApplicationDesc(&dpnad, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting app desc failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set app desc)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for app desc update to be indicated on host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 1;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hostcontext.hGotAppDescUpdateEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird update indications.
		hostcontext.fCanGetAppDescUpdate = FALSE;

#ifdef DEBUG
		// Make sure we got the update (how else would we get here?).
		if (! hostcontext.fGotAppDescUpdate)
		{
			DPTEST_FAIL(hLog, "Didn't get app desc update!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (didn't get update)
#endif // DEBUG

		// Reset the context.
		hostcontext.fGotAppDescUpdate = FALSE;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing peer object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure we got the destroy player message.
		if (hostcontext.dpnidHost != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Re-initializing peer object with nonhost context");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		nonhostcontext.hLog = hLog;

		tr = pDP8Peer->DP8P_Initialize(&nonhostcontext,
										ParmVPSetAppDescDPNMessageHandler,
										0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Re-initializing peer object with context, 0 flags failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating new peer host object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Address->Release();
		pDP8Address = NULL;

		hostcontext.hLog = hLog;

		tr = ParmVCreatePeerHost(hLog, ParmVPSetAppDescDPNMessageHandler,
								&hostcontext,
								&dpnad,
								&hostcontext.dpnidHost,
								&pDP8PeerHost,
								&pDP8Address);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Creating peer host failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't create peer host)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Connecting peer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

// XBOX - Had to make connection asynchronous

		// Host should get the create player now.
		CREATEEVENT_OR_THROW(hostcontext.hClientCreatedEvent, NULL, FALSE, FALSE, NULL);
		SAFE_CLOSEHANDLE(hAsyncOpComplete);
		CREATEEVENT_OR_THROW(hAsyncOpComplete, NULL, FALSE, FALSE, NULL);

		// Even though it's synchronous, we'll still get a completion.  The async op
		// handle will be NULL, though.
		nonhostcontext.fConnectCanComplete = TRUE;

		tr = pDP8Peer->DP8P_Connect(&dpnad,
									pDP8Address,
									NULL,
									NULL,
									NULL,
									NULL,
									0,
									&(nonhostcontext.dpnidClient),
									hAsyncOpComplete,
									&hAsyncOp,
									0);

		if((tr != DPNSUCCESS_PENDING) && (tr != DPN_OK))
		{
			DPTEST_FAIL(hLog, "Couldn't connect! (error 0x%08x)", 1, tr);
			THROW_TESTRESULT;
		} // end if (couldn't connect)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for connect to complete on non-host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hAsyncOpComplete))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird connects from completing.
		nonhostcontext.fConnectCanComplete = FALSE;

		// Make sure we saw the connect completion indication.
		if (! nonhostcontext.fConnectCompleted)
		{
			DPTEST_FAIL(hLog, "Didn't get connect complete indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (connect didn't complete)

		// Reset the context.
		nonhostcontext.fConnectCompleted = FALSE;

		// Make sure we got the create player messages.
		if (nonhostcontext.dpnidHost == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication for host on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player)

		if (nonhostcontext.dpnidClient == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication for client on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player)


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for create player to be indicated on host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hostcontext.hClientCreatedEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting app desc on peer non-host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_SetApplicationDesc(&dpnad, 0);
		if (tr != DPNERR_NOTHOST)
		{
			DPTEST_FAIL(hLog, "Setting app desc didn't return expected error NOTHOST!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set app desc)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting app desc on peer host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Expect the update message on both interfaces.
		hostcontext.fCanGetAppDescUpdate = TRUE;
		nonhostcontext.fCanGetAppDescUpdate = TRUE;

		tr = pDP8PeerHost->DP8P_SetApplicationDesc(&dpnad, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting app desc failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set app desc)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for app desc update to be indicated on host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hostcontext.hGotAppDescUpdateEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird update indications.
		hostcontext.fCanGetAppDescUpdate = FALSE;

#ifdef DEBUG
		// Make sure we got the update (how else would we get here?).
		if (! hostcontext.fGotAppDescUpdate)
		{
			DPTEST_FAIL(hLog, "Didn't get app desc update!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (didn't get update)
#endif // DEBUG

		// Reset the context.
		hostcontext.fGotAppDescUpdate = FALSE;



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for app desc update to be indicated on nonhost");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, nonhostcontext.hGotAppDescUpdateEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird update indications.
		nonhostcontext.fCanGetAppDescUpdate = FALSE;

#ifdef DEBUG
		// Make sure we got the update (how else would we get here?).
		if (! nonhostcontext.fGotAppDescUpdate)
		{
			DPTEST_FAIL(hLog, "Didn't get app desc update!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (didn't get update)
#endif // DEBUG

		// Reset the context.
		nonhostcontext.fGotAppDescUpdate = FALSE;






		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing peer client object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing peer client object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure we got the destroy player messages.
		if (nonhostcontext.dpnidHost != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for host on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)

		if (nonhostcontext.dpnidClient != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for client on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)


		// Technically we should wait to make sure the host saw the client go away
		// as expected but that's more hassle than it's worth.  Just make sure he's
		// gone after Close() has returned.





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing host object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8PeerHost->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing host object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure we got the destroy player messages.
		if (hostcontext.dpnidHost != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for host on host!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)

		if (hostcontext.dpnidClient != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for client on host!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing hosting DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8PeerHost->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release hosting DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8PeerHost);
		pDP8PeerHost = NULL;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Peer);
		pDP8Peer = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE



	if (pDP8Peer != NULL)
	{
		delete (pDP8Peer);
		pDP8Peer = NULL;
	} // end if (have peer object)

	if (pDP8PeerHost != NULL)
	{
		delete (pDP8PeerHost);
		pDP8PeerHost = NULL;
	} // end if (have peer object)

	SAFE_CLOSEHANDLE(hostcontext.hGotAppDescUpdateEvent);
	SAFE_CLOSEHANDLE(nonhostcontext.hGotAppDescUpdateEvent);
	SAFE_CLOSEHANDLE(hostcontext.hClientCreatedEvent);
	SAFE_LOCALFREE(pvTooLargeAppReservedData);
	SAFE_RELEASE(pDP8Address);
	ClearDoWorkList(&DoWorkList);
	SAFE_CLOSEHANDLE(hAsyncOpComplete);

	return (sr);
} // ParmVPeerExec_SetAppDesc
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVPeerExec_CreateGroup()"
//==================================================================================
// ParmVPeerExec_CreateGroup
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.1.11 - Peer CreateGroup parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVPeerExec_CreateGroup(HANDLE hLog)
{
	CTNSystemResult				sr;
	CTNTestResult				tr;
	PWRAPDP8PEER				pDP8Peer = NULL;
	PWRAPDP8PEER				pDP8PeerHost = NULL;
	PDIRECTPLAY8ADDRESS			pDP8Address = NULL;
	DPN_GROUP_INFO				dpngi;
	DPN_GROUP_INFO				dpngiCompare;
	DPN_APPLICATION_DESC		dpnad;
	DPN_APPLICATION_DESC		dpnadCompare;
	PARMVPCREATEGROUPCONTEXT	hostcontext;
	PARMVPCREATEGROUPCONTEXT	nonhostcontext;
	DPNID						dpnidGroup;
	DPNHANDLE					dpnhCreateGroup;
	DP_DOWORKLIST				DoWorkList;
	DPNHANDLE					hAsyncOp;
	HANDLE						hAsyncOpComplete = NULL;

	ZeroMemory(&DoWorkList, sizeof(DP_DOWORKLIST));
	ZeroMemory(&hostcontext, sizeof (PARMVPCREATEGROUPCONTEXT));
	hostcontext.fHost = TRUE;

	ZeroMemory(&nonhostcontext, sizeof (PARMVPCREATEGROUPCONTEXT));
	//nonhostcontext.fHost = FALSE;


	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Peer = new CWrapDP8Peer(hLog);
		if (pDP8Peer == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8Peer->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (LPVOID *) &pDP8Address, NULL);
		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't create DirectPlay8Address object!", 0);
			THROW_SYSTEMRESULT;
		} // end if (create failed)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting address object's SP to TCP/IP");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->SetSP(&CLSID_DP8SP_TCPIP);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting address object's SP to TCP/IP failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set SP)





/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating group with all NULLs and 0 flags using C++ macro");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = IDirectPlay8Peer_CreateGroup(pDP8Peer->m_pDP8Peer, NULL, NULL, NULL,
										NULL, 0);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Creating group with all NULLs and 0 flags using C++ macro didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't create group)
*/




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating group with all NULLs and 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_CreateGroup(NULL, NULL, NULL, NULL, 0);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Creating group with all NULLs and 0 flags didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't create group)
*/

		dpnhCreateGroup = (DPNHANDLE) 0x666;

/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating group with NULL group info");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_CreateGroup(NULL, NULL, NULL, &dpnhCreateGroup, 0);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Creating group group with NULL group info didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't create group)

		if (dpnhCreateGroup != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async handle was changed (%x != 0x666)!",
				1, dpnhCreateGroup);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (async handle was changed)
*/

		ZeroMemory(&dpngi, sizeof (DPN_GROUP_INFO));
		dpngi.dwSize = sizeof (DPN_GROUP_INFO);
		//dpngi.dwInfoFlags = 0;
		//dpngi.pwszName = NULL;
		//dpngi.pvData = NULL;
		//dpngi.dwDataSize = 0;
		//dpngi.dwGroupFlags = 0;

		CopyMemory(&dpngiCompare, &dpngi, sizeof (DPN_GROUP_INFO));

/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating group with NULL async handle");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_CreateGroup(&dpngi, NULL, NULL, NULL, 0);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Creating group with NULL async handle didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't create group)

		if (memcmp(&dpngiCompare, &dpngi, sizeof (DPN_GROUP_INFO)) != 0)
		{
			DPTEST_FAIL(hLog, "Group info structure was modified (structure at %x != structure at %x)!",
				2, &dpngiCompare, &dpngi);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (group info changed)
*/




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating group with invalid flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_CreateGroup(&dpngi, NULL, NULL, &dpnhCreateGroup, 0x666);
		if (tr != DPNERR_INVALIDFLAGS)
		{
			DPTEST_FAIL(hLog, "Creating group with invalid flags didn't return expected error INVALIDFLAGS!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't create group)

		if (memcmp(&dpngiCompare, &dpngi, sizeof (DPN_GROUP_INFO)) != 0)
		{
			DPTEST_FAIL(hLog, "Group info structure was modified (structure at %x != structure at %x)!",
				2, &dpngiCompare, &dpngi);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (group info changed)

		if (dpnhCreateGroup != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async handle was changed (%x != 0x666)!",
				1, dpnhCreateGroup);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (async handle was changed)
*/




/* XBOX - SYNC operations not supported
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating group synchronously with async handle");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_CreateGroup(&dpngi, NULL, NULL, &dpnhCreateGroup,
										DPNCREATEGROUP_SYNC);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Creating group synchronously with async handle didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't create group)

		if (memcmp(&dpngiCompare, &dpngi, sizeof (DPN_GROUP_INFO)) != 0)
		{
			DPTEST_FAIL(hLog, "Group info structure was modified (structure at %x != structure at %x)!",
				2, &dpngiCompare, &dpngi);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (group info changed)

		if (dpnhCreateGroup != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async handle was changed (%x != 0x666)!",
				1, dpnhCreateGroup);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (async handle was changed)
*/




/* XBOX - SYNC operations not supported
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating group before initialization");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_CreateGroup(&dpngi, NULL, NULL, &dpnhCreateGroup, 0);
		if (tr != DPNERR_UNINITIALIZED)
		{
			DPTEST_FAIL(hLog, "Creating group before initialization didn't return expected error UNINITIALIZED!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't create group)

		if (memcmp(&dpngiCompare, &dpngi, sizeof (DPN_GROUP_INFO)) != 0)
		{
			DPTEST_FAIL(hLog, "Group info structure was modified (structure at %x != structure at %x)!",
				2, &dpngiCompare, &dpngi);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (group info changed)

		if (dpnhCreateGroup != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async handle was changed (%x != 0x666)!",
				1, dpnhCreateGroup);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (async handle was changed)
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Initializing peer object with host context");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		hostcontext.hLog = hLog;

		tr = pDP8Peer->DP8P_Initialize(&hostcontext,
										ParmVPCreateGroupDPNMessageHandler, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Initializing peer object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating group without a connection");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_CreateGroup(&dpngi, NULL, NULL, &dpnhCreateGroup, 0);
		if (tr != DPNERR_NOCONNECTION)
		{
			DPTEST_FAIL(hLog, "Creating group without a connection didn't return expected error NOCONNECTION!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't create group)

		if (memcmp(&dpngiCompare, &dpngi, sizeof (DPN_GROUP_INFO)) != 0)
		{
			DPTEST_FAIL(hLog, "Group info structure was modified (structure at %x != structure at %x)!",
				2, &dpngiCompare, &dpngi);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (group info changed)

		if (dpnhCreateGroup != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async handle was changed (%x != 0x666)!",
				1, dpnhCreateGroup);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (async handle was changed)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Hosting session");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		//dpnad.dwFlags = 0;
		//dpnad.guidInstance = GUID_NULL;
		dpnad.guidApplication = GUID_PARMV_PEER_GETAPPDESC;
		//dpnad.dwMaxPlayers = 0;
		//dpnad.dwCurrentPlayers = 0;
		//dpnad.pwszSessionName = NULL;
		//dpnad.pwszPassword = NULL;
		//dpnad.pvReservedData = NULL;
		//dpnad.dwReservedDataSize = 0;
		//dpnad.pvApplicationReservedData = NULL;
		//dpnad.dwApplicationReservedDataSize = 0;

		// Save what we're passing in to make sure it's not touched.
		CopyMemory(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC));

		tr = pDP8Peer->DP8P_Host(&dpnad,
								&pDP8Address,
								1,
								NULL,
								NULL,
								&(hostcontext.dpnidHost),
								0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't start hosting session!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't host)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		// Make sure we got the create player message.
		if (hostcontext.dpnidHost == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating group");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Expect the create group message and async op completion.
		//hostcontext.dpnidExpectedGroupOwner = 0;
		hostcontext.fCanGetCreateGroup = TRUE;
		CREATEEVENT_OR_THROW(hostcontext.hAsyncOpCompletedEvent,
							NULL, FALSE, FALSE, NULL);
		hostcontext.fAsyncOpCanComplete = TRUE;

		tr = pDP8Peer->DP8P_CreateGroup(&dpngi, NULL, NULL, &dpnhCreateGroup, 0);
		if (tr != (HRESULT) DPNSUCCESS_PENDING)
		{
			DPTEST_FAIL(hLog, "Creating group didn't return expected PENDING success code!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't create group)

		if (memcmp(&dpngiCompare, &dpngi, sizeof (DPN_GROUP_INFO)) != 0)
		{
			DPTEST_FAIL(hLog, "Group info structure was modified (structure at %x != structure at %x)!",
				2, &dpngiCompare, &dpngi);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (group info changed)

		if (dpnhCreateGroup == (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "No async operation handle was returned!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (handle was not set)

		if (dpnhCreateGroup == NULL)
		{
			DPTEST_FAIL(hLog, "Async operation handle returned is NULL!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (handle was set to NULL)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for async op to complete");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 1;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hostcontext.hAsyncOpCompletedEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// The create group message should have arrived by now.
		hostcontext.fCanGetCreateGroup = FALSE;

		// Prevent any weird async op completions.
		hostcontext.fAsyncOpCanComplete = FALSE;


#ifdef DEBUG
		// Make sure we got the indication (how else would we get here?).
		if (! hostcontext.fAsyncOpCompleted)
		{
			DPTEST_FAIL(hLog, "Didn't get async op completion!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (didn't get async op completion)
#endif // DEBUG

		// Make sure the completion indicated the same op handle that we were
		// returned.
		if (hostcontext.dpnhCompletedAsyncOp != dpnhCreateGroup)
		{
			DPTEST_FAIL(hLog, "Create group completed with different async op handle (%x != %x)!",
				2, hostcontext.dpnhCompletedAsyncOp, dpnhCreateGroup);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (async op handle is wrong)

		// Reset the context.
		hostcontext.fAsyncOpCompleted = FALSE;
		CloseHandle(hostcontext.hAsyncOpCompletedEvent);
		hostcontext.hAsyncOpCompletedEvent = NULL;


		// Make sure we got the create group message.
		if (hostcontext.dpnidGroupCreated == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get create group message!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create group)

		// Save the group ID and reset the context.
		dpnidGroup = hostcontext.dpnidGroupCreated;
		hostcontext.dpnidGroupCreated = 0;




/* XBOX - SYNC operations not supported
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating second group synchronously");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Expect the create group message.
		//hostcontext.dpnidExpectedGroupOwner = 0;
		hostcontext.fCanGetCreateGroup = TRUE;

		tr = pDP8Peer->DP8P_CreateGroup(&dpngi, NULL, NULL, NULL, DPNCREATEGROUP_SYNC);

		// Prevent any weird create groups.
		hostcontext.fCanGetCreateGroup = FALSE;

		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Creating second group synchronously failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't create group)

		if (memcmp(&dpngiCompare, &dpngi, sizeof (DPN_GROUP_INFO)) != 0)
		{
			DPTEST_FAIL(hLog, "Group info structure was modified (structure at %x != structure at %x)!",
				2, &dpngiCompare, &dpngi);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (group info changed)

		// Make sure we got the create group message.
		if (hostcontext.dpnidGroupCreated == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get create group message!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create group)

		// Make sure this second ID is different from the first.
		if (hostcontext.dpnidGroupCreated == dpnidGroup)
		{
			DPTEST_FAIL(hLog, "Both groups received same ID (%u/%x)!",
				2, dpnidGroup, dpnidGroup);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (group IDs are same)

		// Reset the context.
		hostcontext.dpnidGroupCreated = 0;
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing peer object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure we got the destroy player message.
		if (hostcontext.dpnidHost != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)

#pragma TODO(vanceo, "Validate destroy group nametable unwind")




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Re-initializing peer object with nonhost context");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		nonhostcontext.hLog = hLog;

		tr = pDP8Peer->DP8P_Initialize(&nonhostcontext,
										ParmVPCreateGroupDPNMessageHandler, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Re-initializing peer object with context, 0 flags failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating new peer host object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Address->Release();
		pDP8Address = NULL;

		hostcontext.hLog = hLog;

		tr = ParmVCreatePeerHost(hLog, ParmVPCreateGroupDPNMessageHandler,
								&hostcontext,
								&dpnad,
								&(hostcontext.dpnidHost),
								&pDP8PeerHost,
								&pDP8Address);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Creating peer host failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't create peer host)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Connecting peer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

// XBOX - Had to make connection asynchronous

		// Host should get the create player now.
		CREATEEVENT_OR_THROW(hostcontext.hClientCreatedEvent, NULL, FALSE, FALSE, NULL);
		SAFE_CLOSEHANDLE(hAsyncOpComplete);
		CREATEEVENT_OR_THROW(hAsyncOpComplete, NULL, FALSE, FALSE, NULL);

		// Even though it's synchronous, we'll still get a completion.  The async op
		// handle will be NULL, though.
		nonhostcontext.fConnectCanComplete = TRUE;

		tr = pDP8Peer->DP8P_Connect(&dpnad,
									pDP8Address,
									NULL,
									NULL,
									NULL,
									NULL,
									0,
									&(nonhostcontext.dpnidClient),
									hAsyncOpComplete,
									&hAsyncOp,
									0);

		if((tr != DPNSUCCESS_PENDING) && (tr != DPN_OK))
		{
			DPTEST_FAIL(hLog, "Couldn't connect! (error 0x%08x)", 1, tr);
			THROW_TESTRESULT;
		} // end if (couldn't connect)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for connect to complete on non-host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hAsyncOpComplete))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird connects from completing.
		nonhostcontext.fConnectCanComplete = FALSE;

		// Make sure we saw the connect completion indication.
		if (! nonhostcontext.fConnectCompleted)
		{
			DPTEST_FAIL(hLog, "Didn't get connect complete indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (connect didn't complete)

		// Reset the context.
		nonhostcontext.fConnectCompleted = FALSE;

		// Make sure we got the create player messages.
		if (nonhostcontext.dpnidHost == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication for host on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player)

		if (nonhostcontext.dpnidClient == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication for client on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for create player to be indicated on host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hostcontext.hClientCreatedEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating group on host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dpnhCreateGroup = (DPNHANDLE) 0x666;

		// Expect the create group message and async op completion on the host.
		//hostcontext.dpnidExpectedGroupOwner = 0;
		hostcontext.fCanGetCreateGroup = TRUE;
		CREATEEVENT_OR_THROW(hostcontext.hAsyncOpCompletedEvent,
							NULL, FALSE, FALSE, NULL);
		hostcontext.fAsyncOpCanComplete = TRUE;

		// Expect the create group message on the client.
		//nonhostcontext.dpnidExpectedGroupOwner = 0;
		CREATEEVENT_OR_THROW(nonhostcontext.hGotCreateGroupEvent,
							NULL, FALSE, FALSE, NULL);
		nonhostcontext.fCanGetCreateGroup = TRUE;

		tr = pDP8PeerHost->DP8P_CreateGroup(&dpngi, NULL, NULL, &dpnhCreateGroup, 0);
		if (tr != (HRESULT) DPNSUCCESS_PENDING)
		{
			DPTEST_FAIL(hLog, "Creating group on host didn't return expected PENDING success code!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't create group)

		if (memcmp(&dpngiCompare, &dpngi, sizeof (DPN_GROUP_INFO)) != 0)
		{
			DPTEST_FAIL(hLog, "Group info structure was modified (structure at %x != structure at %x)!",
				2, &dpngiCompare, &dpngi);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (group info changed)

		if (dpnhCreateGroup == (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "No async operation handle was returned!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (handle was not set)

		if (dpnhCreateGroup == NULL)
		{
			DPTEST_FAIL(hLog, "Async operation handle returned is NULL!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (handle was set to NULL)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for async op to complete");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hostcontext.hAsyncOpCompletedEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// The create group message should have arrived by now.
		hostcontext.fCanGetCreateGroup = FALSE;

		// Prevent any weird async op completions.
		hostcontext.fAsyncOpCanComplete = FALSE;


#ifdef DEBUG
		// Make sure we got the indication (how else would we get here?).
		if (! hostcontext.fAsyncOpCompleted)
		{
			DPTEST_FAIL(hLog, "Didn't get async op completion!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (didn't get async op completion)
#endif // DEBUG

		// Make sure the completion indicated the same op handle that we were
		// returned.
		if (hostcontext.dpnhCompletedAsyncOp != dpnhCreateGroup)
		{
			DPTEST_FAIL(hLog, "Create group completed with different async op handle (%x != %x)!",
				2, hostcontext.dpnhCompletedAsyncOp, dpnhCreateGroup);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (async op handle is wrong)

		// Reset the context.
		hostcontext.fAsyncOpCompleted = FALSE;
		CloseHandle(hostcontext.hAsyncOpCompletedEvent);
		hostcontext.hAsyncOpCompletedEvent = NULL;


		// Make sure we got the create group message.
		if (hostcontext.dpnidGroupCreated == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get create group message!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create group)

		// Reset the context.
		hostcontext.dpnidGroupCreated = 0;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for group creation to be indicated on client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, nonhostcontext.hGotCreateGroupEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird group creations.
		nonhostcontext.fCanGetCreateGroup = FALSE;

#ifdef DEBUG
		// Make sure we got the create group message (how else would we get here?).
		if (nonhostcontext.dpnidGroupCreated == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get create group message!  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (didn't get create group)
#endif // DEBUG

		// Reset the context.
		CloseHandle(nonhostcontext.hGotCreateGroupEvent);
		nonhostcontext.hGotCreateGroupEvent = NULL;
		nonhostcontext.dpnidGroupCreated = 0;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating group on client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dpnhCreateGroup = (DPNHANDLE) 0x666;

		// Expect the create group message on the host.
		//hostcontext.dpnidExpectedGroupOwner = 0;
		CREATEEVENT_OR_THROW(hostcontext.hGotCreateGroupEvent,
							NULL, FALSE, FALSE, NULL);
		hostcontext.fCanGetCreateGroup = TRUE;

		// Expect the create group message and async op completion on the client.
		//nonhostcontext.dpnidExpectedGroupOwner = 0;
		nonhostcontext.fCanGetCreateGroup = TRUE;
		CREATEEVENT_OR_THROW(nonhostcontext.hAsyncOpCompletedEvent,
							NULL, FALSE, FALSE, NULL);
		nonhostcontext.fAsyncOpCanComplete = TRUE;

		tr = pDP8Peer->DP8P_CreateGroup(&dpngi, NULL, NULL, &dpnhCreateGroup, 0);
		if (tr != (HRESULT) DPNSUCCESS_PENDING)
		{
			DPTEST_FAIL(hLog, "Creating group on client didn't return expected PENDING success code!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't create group)

		if (memcmp(&dpngiCompare, &dpngi, sizeof (DPN_GROUP_INFO)) != 0)
		{
			DPTEST_FAIL(hLog, "Group info structure was modified (structure at %x != structure at %x)!",
				2, &dpngiCompare, &dpngi);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (group info changed)

		if (dpnhCreateGroup == (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "No async operation handle was returned!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (handle was not set)

		if (dpnhCreateGroup == NULL)
		{
			DPTEST_FAIL(hLog, "Async operation handle returned is NULL!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (handle was set to NULL)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for async op to complete");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, nonhostcontext.hAsyncOpCompletedEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// The create group message should have arrived by now.
		nonhostcontext.fCanGetCreateGroup = FALSE;

		// Prevent any weird async op completions.
		nonhostcontext.fAsyncOpCanComplete = FALSE;


#ifdef DEBUG
		// Make sure we got the indication (how else would we get here?).
		if (! nonhostcontext.fAsyncOpCompleted)
		{
			DPTEST_FAIL(hLog, "Didn't get async op completion!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (didn't get async op completion)
#endif // DEBUG

		// Make sure the completion indicated the same op handle that we were
		// returned.
		if (nonhostcontext.dpnhCompletedAsyncOp != dpnhCreateGroup)
		{
			DPTEST_FAIL(hLog, "Create group completed with different async op handle (%x != %x)!",
				2, nonhostcontext.dpnhCompletedAsyncOp, dpnhCreateGroup);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (async op handle is wrong)

		// Reset the context.
		nonhostcontext.fAsyncOpCompleted = FALSE;
		CloseHandle(nonhostcontext.hAsyncOpCompletedEvent);
		nonhostcontext.hAsyncOpCompletedEvent = NULL;


		// Make sure we got the create group message.
		if (nonhostcontext.dpnidGroupCreated == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get create group message!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create group)

		// Reset the context.
		nonhostcontext.dpnidGroupCreated = 0;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for group creation to be indicated on host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hostcontext.hGotCreateGroupEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird group creations.
		hostcontext.fCanGetCreateGroup = FALSE;

#ifdef DEBUG
		// Make sure we got the create group message (how else would we get here?).
		if (hostcontext.dpnidGroupCreated == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get create group message!  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (didn't get create group)
#endif // DEBUG

		// Reset the context.
		CloseHandle(hostcontext.hGotCreateGroupEvent);
		hostcontext.hGotCreateGroupEvent = NULL;
		hostcontext.dpnidGroupCreated = 0;





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing peer client object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing peer client object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure we got the destroy player messages.
		if (nonhostcontext.dpnidHost != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for host on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)

		if (nonhostcontext.dpnidClient != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for client on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)


		// Technically we should wait to make sure the host saw the client go away
		// as expected but that's more hassle than it's worth.  Just make sure he's
		// gone after Close() has returned.



#pragma TODO(vanceo, "Validate destroy group nametable unwind on both interfaces")


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing host object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8PeerHost->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing host object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure we got the destroy player messages.
		if (hostcontext.dpnidHost != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for host on host!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)

		if (hostcontext.dpnidClient != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for client on host!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing hosting DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8PeerHost->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release hosting DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8PeerHost);
		pDP8PeerHost = NULL;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Peer);
		pDP8Peer = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE


	if (pDP8Peer != NULL)
	{
		delete (pDP8Peer);
		pDP8Peer = NULL;
	} // end if (have peer object)

	if (pDP8PeerHost != NULL)
	{
		delete (pDP8PeerHost);
		pDP8PeerHost = NULL;
	} // end if (have peer object)

	SAFE_CLOSEHANDLE(hostcontext.hGotCreateGroupEvent);
	SAFE_CLOSEHANDLE(nonhostcontext.hGotCreateGroupEvent);
	SAFE_CLOSEHANDLE(hostcontext.hAsyncOpCompletedEvent);
	SAFE_CLOSEHANDLE(nonhostcontext.hAsyncOpCompletedEvent);
	SAFE_CLOSEHANDLE(hostcontext.hClientCreatedEvent);
	SAFE_RELEASE(pDP8Address);
	ClearDoWorkList(&DoWorkList);
	SAFE_CLOSEHANDLE(hAsyncOpComplete);

	return (sr);
} // ParmVPeerExec_CreateGroup
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVPeerExec_DestroyGroup()"
//==================================================================================
// ParmVPeerExec_DestroyGroup
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.1.12 - Peer DestroyGroup parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVPeerExec_DestroyGroup(HANDLE hLog)
{
	CTNSystemResult				sr;
	CTNTestResult				tr;
	PWRAPDP8PEER				pDP8Peer = NULL;
	PWRAPDP8PEER				pDP8PeerHost = NULL;
	PDIRECTPLAY8ADDRESS			pDP8Address = NULL;
	PARMVPDESTROYGROUPCONTEXT	hostcontext;
	PARMVPDESTROYGROUPCONTEXT	nonhostcontext;
	DPN_APPLICATION_DESC		dpnad;
	DPN_APPLICATION_DESC		dpnadCompare;
	DPN_GROUP_INFO				dpngi;
	DPN_GROUP_INFO				dpngiCompare;
	DPNID						dpnidGroup;
	DPNHANDLE					dpnhDestroyGroup;
	DP_DOWORKLIST				DoWorkList;
	DPNHANDLE					hAsyncOp;
	HANDLE						hAsyncOpComplete = NULL;

	ZeroMemory(&DoWorkList, sizeof(DP_DOWORKLIST));
	ZeroMemory(&hostcontext, sizeof (PARMVPDESTROYGROUPCONTEXT));
	hostcontext.fHost = TRUE;

	ZeroMemory(&nonhostcontext, sizeof (PARMVPDESTROYGROUPCONTEXT));
	//nonhostcontext.fHost = FALSE;


	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Peer = new CWrapDP8Peer(hLog);
		if (pDP8Peer == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8Peer->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (LPVOID *) &pDP8Address, NULL);
		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't create DirectPlay8Address object!", 0);
			THROW_SYSTEMRESULT;
		} // end if (create failed)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting address object's SP to TCP/IP");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->SetSP(&CLSID_DP8SP_TCPIP);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting address object's SP to TCP/IP failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set SP)





/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Destroying group 0 (DPNID_ALL_PLAYERS_GROUP) using C++ macro");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = IDirectPlay8Peer_DestroyGroup(pDP8Peer->m_pDP8Peer, 0, NULL, NULL, 0);
		if (tr != DPNERR_INVALIDGROUP)
		{
			DPTEST_FAIL(hLog, "Destroying group 0 with NULL async handle using C++ macro didn't return expected error INVALIDGROUP!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't destroy group)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Destroying group 0 (DPNID_ALL_PLAYERS_GROUP)");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_DestroyGroup(0, NULL, NULL, 0);
		if (tr != DPNERR_INVALIDGROUP)
		{
			DPTEST_FAIL(hLog, "Destroying group 0 with NULL async handle didn't return expected error INVALIDGROUP!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't destroy group)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Destroying group with NULL async handle");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Use 0x666 to avoid DPlay's group ID == 0 check.
		tr = pDP8Peer->DP8P_DestroyGroup((DPNID) 0x666, NULL, NULL, 0);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Destroying group with NULL async handle didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't destroy group)
*/

		dpnhDestroyGroup = (DPNHANDLE) 0x666;

/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Destroying group with invalid flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_DestroyGroup((DPNID) 0x666, NULL, &dpnhDestroyGroup, 0x666);
		if (tr != DPNERR_INVALIDFLAGS)
		{
			DPTEST_FAIL(hLog, "Destroying group with invalid flags didn't return expected error INVALIDFLAGS!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't destroy group)

		if (dpnhDestroyGroup != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async handle was modified (%x != 0x666)!",
				1, dpnhDestroyGroup);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (handle was set)
*/



/* XBOX - SYNC operations not supported
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Destroying group synchronously with async op handle");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_DestroyGroup((DPNID) 0x666, NULL, &dpnhDestroyGroup,
										DPNDESTROYGROUP_SYNC);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Destroying group synchronously with async op handle didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't destroy group)

		if (dpnhDestroyGroup != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async handle was modified (%x != 0x666)!",
				1, dpnhDestroyGroup);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (handle was set)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Destroying group before initialization");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_DestroyGroup((DPNID) 0x666, NULL, &dpnhDestroyGroup, 0);
		if (tr != DPNERR_UNINITIALIZED)
		{
			DPTEST_FAIL(hLog, "Destroying group before initialization didn't return expected error UNINITIALIZED!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't destroy group)

		if (dpnhDestroyGroup != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async handle was modified (%x != 0x666)!",
				1, dpnhDestroyGroup);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (handle was set)
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Initializing peer object with host context");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		hostcontext.hLog = hLog;

		tr = pDP8Peer->DP8P_Initialize(&hostcontext,
										ParmVPDestroyGroupDPNMessageHandler, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Initializing peer object with host context failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Destroying group without a connection");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_DestroyGroup((DPNID) 0x666, NULL, &dpnhDestroyGroup, 0);
		if (tr != DPNERR_NOCONNECTION)
		{
			DPTEST_FAIL(hLog, "Destroying group without a connection didn't return expected error NOCONNECTION!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't destroy group)

		if (dpnhDestroyGroup != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async handle was modified (%x != 0x666)!",
				1, dpnhDestroyGroup);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (handle was set)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Hosting session");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		//dpnad.dwFlags = 0;
		//dpnad.guidInstance = GUID_NULL;
		dpnad.guidApplication = GUID_PARMV_PEER_GETAPPDESC;
		//dpnad.dwMaxPlayers = 0;
		//dpnad.dwCurrentPlayers = 0;
		//dpnad.pwszSessionName = NULL;
		//dpnad.pwszPassword = NULL;
		//dpnad.pvReservedData = NULL;
		//dpnad.dwReservedDataSize = 0;
		//dpnad.pvApplicationReservedData = NULL;
		//dpnad.dwApplicationReservedDataSize = 0;

		// Save what we're passing in to make sure it's not touched.
		CopyMemory(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC));

		tr = pDP8Peer->DP8P_Host(&dpnad,
								&pDP8Address,
								1,
								NULL,
								NULL,
								&(hostcontext.dpnidHost),
								0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't start hosting session!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't host)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		// Make sure we got the create player message.
		if (hostcontext.dpnidHost == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Destroying invalid group");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_DestroyGroup((DPNID) 0x666, NULL, &dpnhDestroyGroup, 0);
		if (tr != DPNERR_INVALIDGROUP)
		{
			DPTEST_FAIL(hLog, "Destroying invalid group didn't return expected error INVALIDGROUP!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't destroy group)

		if (dpnhDestroyGroup != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async handle was modified (%x != 0x666)!",
				1, dpnhDestroyGroup);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (handle was set)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating group asynchronously");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		SAFE_CLOSEHANDLE(hAsyncOpComplete);
		CREATEEVENT_OR_THROW(hAsyncOpComplete, NULL, FALSE, FALSE, NULL);

		ZeroMemory(&dpngi, sizeof (DPN_GROUP_INFO));
		dpngi.dwSize = sizeof (DPN_GROUP_INFO);
		//dpngi.dwInfoFlags = 0;
		//dpngi.pwszName = NULL;
		//dpngi.pvData = NULL;
		//dpngi.dwDataSize = 0;
		//dpngi.dwGroupFlags = 0;

		CopyMemory(&dpngiCompare, &dpngi, sizeof (DPN_GROUP_INFO));


		// Expect the create group message.
		//hostcontext.dpnidExpectedGroupOwner = 0;
		hostcontext.fCanGetCreateGroup = TRUE;

		// Now that we're completing asynchronously, need to be ready for ASYNC_OP_COMPLETE message
		hostcontext.fAsyncOpCanComplete = TRUE;
		hostcontext.fAsyncOpCompleted = FALSE;
		SAFE_CLOSEHANDLE(hostcontext.hAsyncOpCompletedEvent);
		CREATEEVENT_OR_THROW(hostcontext.hAsyncOpCompletedEvent, NULL, FALSE, FALSE, NULL);

		tr = pDP8Peer->DP8P_CreateGroup(&dpngi, NULL, hAsyncOpComplete, &hAsyncOp, 0);

		if((tr != DPNSUCCESS_PENDING) && (tr != DPN_OK))
		{
			DPTEST_FAIL(hLog, "Creating group failed! (error 0x%08x)", 1, tr);
			THROW_TESTRESULT;
		} // end if (couldn't create group)

		if (memcmp(&dpngiCompare, &dpngi, sizeof (DPN_GROUP_INFO)) != 0)
		{
			DPTEST_FAIL(hLog, "Group info structure was modified (structure at %x != structure at %x)!",
				2, &dpngiCompare, &dpngi);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (group info changed)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for group to be created asynchronously");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 1;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hAsyncOpComplete))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird create groups.
		hostcontext.fCanGetCreateGroup = FALSE;

		// Make sure we got the create group message.
		if (hostcontext.dpnidGroup == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get create group message!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create group)

		// Save the group ID.
		dpnidGroup = hostcontext.dpnidGroup;

		hostcontext.fAsyncOpCanComplete = FALSE;
		hostcontext.fAsyncOpCompleted = FALSE;

		SAFE_CLOSEHANDLE(hostcontext.hAsyncOpCompletedEvent);

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Destroying group");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Expect the destroy group message and async op completion.
		hostcontext.fCanGetDestroyGroup = TRUE;
		CREATEEVENT_OR_THROW(hostcontext.hAsyncOpCompletedEvent,
							NULL, FALSE, FALSE, NULL);
		hostcontext.fAsyncOpCanComplete = TRUE;

		tr = pDP8Peer->DP8P_DestroyGroup(hostcontext.dpnidGroup, NULL,
										&dpnhDestroyGroup, 0);
		if (tr != (HRESULT) DPNSUCCESS_PENDING)
		{
			DPTEST_FAIL(hLog, "Destroying group didn't return expected PENDING success code!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't destroy group)

		if (dpnhDestroyGroup == (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "No async operation handle was returned!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (handle was not set)

		if (dpnhDestroyGroup == NULL)
		{
			DPTEST_FAIL(hLog, "Async operation handle returned is NULL!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (handle was set to NULL)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for async op to complete");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 1;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hostcontext.hAsyncOpCompletedEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// The destroy group message should have arrived by now.
		hostcontext.fCanGetDestroyGroup = FALSE;

		// Prevent any weird async op completions.
		hostcontext.fAsyncOpCanComplete = FALSE;


#ifdef DEBUG
		// Make sure we got the indication (how else would we get here?).
		if (! hostcontext.fAsyncOpCompleted)
		{
			DPTEST_FAIL(hLog, "Didn't get async op completion!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (didn't get async op completion)
#endif // DEBUG

		// Make sure the completion indicated the same op handle that we were
		// returned.
		if (hostcontext.dpnhCompletedAsyncOp != dpnhDestroyGroup)
		{
			DPTEST_FAIL(hLog, "Destroy group completed with different async op handle (%x != %x)!",
				2, hostcontext.dpnhCompletedAsyncOp, dpnhDestroyGroup);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (async op handle is wrong)

		// Reset the context.
		hostcontext.fAsyncOpCompleted = FALSE;
		CloseHandle(hostcontext.hAsyncOpCompletedEvent);
		hostcontext.hAsyncOpCompletedEvent = NULL;


		// Make sure we got the destroy group message.
		if (hostcontext.dpnidGroup != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get destroy group message!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy group)




/* XBOX - SYNC operations not supported
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating group synchronously");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Expect the create group message.
		//hostcontext.dpnidExpectedGroupOwner = 0;
		hostcontext.fCanGetCreateGroup = TRUE;

		tr = pDP8Peer->DP8P_CreateGroup(&dpngi, NULL, NULL, NULL, DPNCREATEGROUP_SYNC);

		// Prevent any weird create groups.
		hostcontext.fCanGetCreateGroup = FALSE;

		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Creating group synchronously failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't create group)

		if (memcmp(&dpngiCompare, &dpngi, sizeof (DPN_GROUP_INFO)) != 0)
		{
			DPTEST_FAIL(hLog, "Group info structure was modified (structure at %x != structure at %x)!",
				2, &dpngiCompare, &dpngi);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (group info changed)

		// Make sure we got the create group message.
		if (hostcontext.dpnidGroup == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get create group message!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create group)

		// Make sure the ID is different from the other group we created and
		// destroyed.
		if (hostcontext.dpnidGroup == dpnidGroup)
		{
			DPTEST_FAIL(hLog, "Second group created has same ID as previously created and destroyed group (%u/%x)!",
				2, dpnidGroup, dpnidGroup);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create group)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Destroying group synchronously");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Expect the destroy group message and async op completion.
		hostcontext.fCanGetDestroyGroup = TRUE;

		tr = pDP8Peer->DP8P_DestroyGroup(hostcontext.dpnidGroup, NULL, NULL,
										DPNDESTROYGROUP_SYNC);

		// Prevent any weird destroy groups.
		hostcontext.fCanGetDestroyGroup = FALSE;

		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Destroying group synchronously failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't destroy group)


		// Make sure we got the destroy group message.
		if (hostcontext.dpnidGroup != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get destroy group message!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy group)
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing peer object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure we got the destroy player message.
		if (hostcontext.dpnidHost != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)

#pragma TODO(vanceo, "Validate destroy group nametable unwind")




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Re-initializing peer object with nonhost context");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		nonhostcontext.hLog = hLog;

		tr = pDP8Peer->DP8P_Initialize(&nonhostcontext,
										ParmVPDestroyGroupDPNMessageHandler, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Re-initializing peer object with context, 0 flags failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating new peer host object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Address->Release();
		pDP8Address = NULL;

		hostcontext.hLog = hLog;

		tr = ParmVCreatePeerHost(hLog, ParmVPDestroyGroupDPNMessageHandler,
								&hostcontext,
								&dpnad,
								&(hostcontext.dpnidHost),
								&pDP8PeerHost,
								&pDP8Address);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Creating peer host failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't create peer host)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Connecting peer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

// XBOX - Had to make connection asynchronous

		// Host should get the create player now.
		CREATEEVENT_OR_THROW(hostcontext.hClientCreatedEvent, NULL, FALSE, FALSE, NULL);
		SAFE_CLOSEHANDLE(hAsyncOpComplete);
		CREATEEVENT_OR_THROW(hAsyncOpComplete, NULL, FALSE, FALSE, NULL);

		// Even though it's synchronous, we'll still get a completion.  The async op
		// handle will be NULL, though.
		nonhostcontext.fConnectCanComplete = TRUE;

		tr = pDP8Peer->DP8P_Connect(&dpnad,
									pDP8Address,
									NULL,
									NULL,
									NULL,
									NULL,
									0,
									&(nonhostcontext.dpnidClient),
									hAsyncOpComplete,
									&hAsyncOp,
									0);

		if((tr != DPNSUCCESS_PENDING) && (tr != DPN_OK))
		{
			DPTEST_FAIL(hLog, "Couldn't connect! (error 0x%08x)", 1, tr);
			THROW_TESTRESULT;
		} // end if (couldn't connect)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for connect to complete on non-host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hAsyncOpComplete))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird connects from completing.
		nonhostcontext.fConnectCanComplete = FALSE;

		// Make sure we saw the connect completion indication.
		if (! nonhostcontext.fConnectCompleted)
		{
			DPTEST_FAIL(hLog, "Didn't get connect complete indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (connect didn't complete)

		// Reset the context.
		nonhostcontext.fConnectCompleted = FALSE;

		// Make sure we got the create player messages.
		if (nonhostcontext.dpnidHost == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication for host on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player)

		if (nonhostcontext.dpnidClient == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication for client on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating group on client asynchronously");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		SAFE_CLOSEHANDLE(hAsyncOpComplete);
		CREATEEVENT_OR_THROW(hAsyncOpComplete, NULL, FALSE, FALSE, NULL);

		ZeroMemory(&dpngi, sizeof (DPN_GROUP_INFO));
		dpngi.dwSize = sizeof (DPN_GROUP_INFO);
		//dpngi.dwInfoFlags = 0;
		//dpngi.pwszName = NULL;
		//dpngi.pvData = NULL;
		//dpngi.dwDataSize = 0;
		//dpngi.dwGroupFlags = 0;

		CopyMemory(&dpngiCompare, &dpngi, sizeof (DPN_GROUP_INFO));

		// Expect the create group message on the host.
		//hostcontext.dpnidExpectedGroupOwner = 0;

		CREATEEVENT_OR_THROW(hostcontext.hGotGroupMsgEvent, NULL, FALSE, FALSE, NULL);
		hostcontext.fCanGetCreateGroup = TRUE;

		// Now that we're completing asynchronously, need to be ready for ASYNC_OP_COMPLETE message
		nonhostcontext.fAsyncOpCanComplete = TRUE;
		nonhostcontext.fAsyncOpCompleted = FALSE;
		SAFE_CLOSEHANDLE(nonhostcontext.hAsyncOpCompletedEvent);
		CREATEEVENT_OR_THROW(nonhostcontext.hAsyncOpCompletedEvent, NULL, FALSE, FALSE, NULL);

		// Expect the create group message on the client.
		//nonhostcontext.dpnidExpectedGroupOwner = 0;
		nonhostcontext.fCanGetCreateGroup = TRUE;

		tr = pDP8Peer->DP8P_CreateGroup(&dpngi, NULL, hAsyncOpComplete, &hAsyncOp, 0);

		if((tr != DPNSUCCESS_PENDING) && (tr != DPN_OK))
		{
			DPTEST_FAIL(hLog, "Creating group failed! (error 0x%08x)", 1, tr);
			THROW_TESTRESULT;
		} // end if (couldn't create group)

		if (memcmp(&dpngiCompare, &dpngi, sizeof (DPN_GROUP_INFO)) != 0)
		{
			DPTEST_FAIL(hLog, "Group info structure was modified (structure at %x != structure at %x)!",
				2, &dpngiCompare, &dpngi);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (group info changed)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for group to be created asynchronously");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hAsyncOpComplete))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird create groups.
		nonhostcontext.fCanGetCreateGroup = FALSE;

		// Make sure we got the create group message.
		if (nonhostcontext.dpnidGroup == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get create group message!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create group)

		nonhostcontext.fAsyncOpCanComplete = FALSE;
		nonhostcontext.fAsyncOpCompleted = FALSE;

		SAFE_CLOSEHANDLE(nonhostcontext.hAsyncOpCompletedEvent);

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for group to be created on host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hostcontext.hGotGroupMsgEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird create group indications.
		hostcontext.fCanGetCreateGroup = FALSE;

#ifdef DEBUG
		// Make sure we got the indication (how else would we get here?).
		if (hostcontext.dpnidGroup == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get create group indication!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (didn't get create group indication)
#endif // DEBUG

		// Reset the context.
		CloseHandle(hostcontext.hGotGroupMsgEvent);
		hostcontext.hGotGroupMsgEvent = NULL;






		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Destroying group on client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dpnhDestroyGroup = (DPNHANDLE) 0x666;

		// Expect the destroy group message on the host.
		hostcontext.fCanGetDestroyGroup = TRUE;
		CREATEEVENT_OR_THROW(hostcontext.hGotGroupMsgEvent,
							NULL, FALSE, FALSE, NULL);

		// Expect the destroy group message and async op completion on the client.
		nonhostcontext.fCanGetDestroyGroup = TRUE;
		CREATEEVENT_OR_THROW(nonhostcontext.hAsyncOpCompletedEvent,
							NULL, FALSE, FALSE, NULL);
		nonhostcontext.fAsyncOpCanComplete = TRUE;

		tr = pDP8Peer->DP8P_DestroyGroup(nonhostcontext.dpnidGroup, NULL,
										&dpnhDestroyGroup, 0);
		if (tr != (HRESULT) DPNSUCCESS_PENDING)
		{
			DPTEST_FAIL(hLog, "Destroying group on client didn't return expected PENDING success code!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't destroy group)

		if (dpnhDestroyGroup == (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "No async operation handle was returned!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (handle was not set)

		if (dpnhDestroyGroup == NULL)
		{
			DPTEST_FAIL(hLog, "Async operation handle returned is NULL!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (handle was set to NULL)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for async op to complete on client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, nonhostcontext.hAsyncOpCompletedEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// The destroy group message should have arrived by now.
		nonhostcontext.fCanGetDestroyGroup = FALSE;

		// Prevent any weird async op completions.
		nonhostcontext.fAsyncOpCanComplete = FALSE;


#ifdef DEBUG
		// Make sure we got the indication (how else would we get here?).
		if (! nonhostcontext.fAsyncOpCompleted)
		{
			DPTEST_FAIL(hLog, "Didn't get async op completion!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (didn't get async op completion)
#endif // DEBUG

		// Make sure the completion indicated the same op handle that we were
		// returned.
		if (nonhostcontext.dpnhCompletedAsyncOp != dpnhDestroyGroup)
		{
			DPTEST_FAIL(hLog, "Destroy group completed with different async op handle (%x != %x)!",
				2, nonhostcontext.dpnhCompletedAsyncOp, dpnhDestroyGroup);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (async op handle is wrong)

		// Reset the context.
		nonhostcontext.fAsyncOpCompleted = FALSE;
		CloseHandle(nonhostcontext.hAsyncOpCompletedEvent);
		nonhostcontext.hAsyncOpCompletedEvent = NULL;


		// Make sure we got the destroy group message.
		if (nonhostcontext.dpnidGroup != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get destroy group message on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy group)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for destroy group message on host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hostcontext.hGotGroupMsgEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird completions.
		hostcontext.fCanGetDestroyGroup = FALSE;

		// Make sure we got the destroy group message.
		if (hostcontext.dpnidGroup != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get destroy group message on host!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy group)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing peer client object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing peer client object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure we got the destroy player messages.
		if (nonhostcontext.dpnidHost != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for host on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)

		if (nonhostcontext.dpnidClient != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for client on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)


		// Technically we should wait to make sure the host saw the client go away
		// as expected but that's more hassle than it's worth.  Just make sure he's
		// gone after Close() has returned.



#pragma TODO(vanceo, "Validate destroy group nametable unwind on both interfaces")


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing host object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8PeerHost->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing host object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure we got the destroy player messages.
		if (hostcontext.dpnidHost != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for host on host!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)

		if (hostcontext.dpnidClient != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for client on host!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing hosting DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8PeerHost->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release hosting DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8PeerHost);
		pDP8PeerHost = NULL;






		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Peer);
		pDP8Peer = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE


	if (pDP8Peer != NULL)
	{
		delete (pDP8Peer);
		pDP8Peer = NULL;
	} // end if (have peer object)

	if (pDP8PeerHost != NULL)
	{
		delete (pDP8PeerHost);
		pDP8PeerHost = NULL;
	} // end if (have peer object)

	SAFE_CLOSEHANDLE(hostcontext.hGotGroupMsgEvent);
	SAFE_CLOSEHANDLE(nonhostcontext.hGotGroupMsgEvent);
	SAFE_CLOSEHANDLE(hostcontext.hAsyncOpCompletedEvent);
	SAFE_CLOSEHANDLE(nonhostcontext.hAsyncOpCompletedEvent);
	SAFE_CLOSEHANDLE(hostcontext.hClientCreatedEvent);
	SAFE_RELEASE(pDP8Address);
	ClearDoWorkList(&DoWorkList);
	SAFE_CLOSEHANDLE(hAsyncOpComplete);

	return (sr);
} // ParmVPeerExec_DestroyGroup
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVPeerExec_AddToGroup()"
//==================================================================================
// ParmVPeerExec_AddToGroup
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.1.13 - Peer AddToGroup parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVPeerExec_AddToGroup(HANDLE hLog)
{
	CTNSystemResult				sr;
	CTNTestResult				tr;
	PWRAPDP8PEER				pDP8Peer = NULL;
	PWRAPDP8PEER				pDP8PeerHost = NULL;
	PDIRECTPLAY8ADDRESS			pDP8Address = NULL;
	PARMVPADDTOGROUPCONTEXT		hostcontext;
	PARMVPADDTOGROUPCONTEXT		nonhostcontext;
	DPN_APPLICATION_DESC		dpnad;
	DPN_APPLICATION_DESC		dpnadCompare;
	DPN_GROUP_INFO				dpngi;
	DPN_GROUP_INFO				dpngiCompare;
	DPNHANDLE					dpnhAddPlayer;
	DP_DOWORKLIST				DoWorkList;
	DPNHANDLE					hAsyncOp;
	HANDLE						hAsyncOpComplete = NULL;

	ZeroMemory(&DoWorkList, sizeof(DP_DOWORKLIST));
	ZeroMemory(&hostcontext, sizeof (PARMVPADDTOGROUPCONTEXT));
	hostcontext.fHost = TRUE;

	ZeroMemory(&nonhostcontext, sizeof (PARMVPADDTOGROUPCONTEXT));
	//nonhostcontext.fHost = FALSE;


	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Peer = new CWrapDP8Peer(hLog);
		if (pDP8Peer == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8Peer->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (LPVOID *) &pDP8Address, NULL);
		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't create DirectPlay8Address object!", 0);
			THROW_SYSTEMRESULT;
		} // end if (create failed)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting address object's SP to TCP/IP");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->SetSP(&CLSID_DP8SP_TCPIP);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting address object's SP to TCP/IP failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set SP)





/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Adding player 0 to group 0 (DPNID_ALL_PLAYERS_GROUP) with NULLs and 0s using C++ macro");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = IDirectPlay8Peer_AddPlayerToGroup(pDP8Peer->m_pDP8Peer, 0,  0, NULL,
												NULL, 0);
		if (tr != DPNERR_INVALIDGROUP)
		{
			DPTEST_FAIL(hLog, "Adding player 0 to group 0 (DPNID_ALL_PLAYERS_GROUP) with NULLs and 0s using C++ macro didn't return expected error INVALIDGROUP!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't add player to group)
*/




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Adding player 0 to group 0 (DPNID_ALL_PLAYERS_GROUP) with NULLs and 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_AddPlayerToGroup(0,  0, NULL, NULL, 0);
		if (tr != DPNERR_INVALIDGROUP)
		{
			DPTEST_FAIL(hLog, "Adding player 0 to group 0 (DPNID_ALL_PLAYERS_GROUP) with NULLs and 0 flags didn't return expected error INVALIDGROUP!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't add player to group)
*/

		dpnhAddPlayer = (DPNHANDLE) 0x666;

/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Adding player to group with invalid flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Use 0x666 to avoid DPlay's group ID == 0 and player ID == 0 checks.
		tr = pDP8Peer->DP8P_AddPlayerToGroup((DPNID) 0x666, (DPNID) 0x666, NULL,
											&dpnhAddPlayer, 0x666);
		if (tr != DPNERR_INVALIDFLAGS)
		{
			DPTEST_FAIL(hLog, "Adding player to group with invalid flags didn't return expected error INVALIDFLAGS!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't add player to group)

		if (dpnhAddPlayer != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async handle was modified (%x != 0x666)!",
				1, dpnhAddPlayer);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (handle was set)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Adding player to group before initialization");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_AddPlayerToGroup((DPNID) 0x666, (DPNID) 0x666, NULL,
											&dpnhAddPlayer, 0);
		if (tr != DPNERR_UNINITIALIZED)
		{
			DPTEST_FAIL(hLog, "Adding player to group before initialization didn't return expected error UNINITIALIZED!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't add player to group)

		if (dpnhAddPlayer != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async handle was modified (%x != 0x666)!",
				1, dpnhAddPlayer);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (handle was set)
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Initializing peer object with host context");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		hostcontext.hLog = hLog;

		tr = pDP8Peer->DP8P_Initialize(&hostcontext,
										ParmVPAddToGroupDPNMessageHandler, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Initializing peer object with host context failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Adding player to group without a connection");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_AddPlayerToGroup((DPNID) 0x666, (DPNID) 0x666, NULL,
											&dpnhAddPlayer, 0);
		if (tr != DPNERR_NOCONNECTION)
		{
			DPTEST_FAIL(hLog, "Adding player to group without a connection didn't return expected error NOCONNECTION!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't add player to group)

		if (dpnhAddPlayer != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async handle was modified (%x != 0x666)!",
				1, dpnhAddPlayer);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (handle was set)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Hosting session");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		//dpnad.dwFlags = 0;
		//dpnad.guidInstance = GUID_NULL;
		dpnad.guidApplication = GUID_PARMV_PEER_GETAPPDESC;
		//dpnad.dwMaxPlayers = 0;
		//dpnad.dwCurrentPlayers = 0;
		//dpnad.pwszSessionName = NULL;
		//dpnad.pwszPassword = NULL;
		//dpnad.pvReservedData = NULL;
		//dpnad.dwReservedDataSize = 0;
		//dpnad.pvApplicationReservedData = NULL;
		//dpnad.dwApplicationReservedDataSize = 0;

		// Save what we're passing in to make sure it's not touched.
		CopyMemory(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC));

		tr = pDP8Peer->DP8P_Host(&dpnad,
								&pDP8Address,
								1,
								NULL,
								NULL,
								&(hostcontext.dpnidHost),
								0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't start hosting session!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't host)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		// Make sure we got the create player message.
		if (hostcontext.dpnidHost == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Adding self player to invalid group");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_AddPlayerToGroup((DPNID) 0x666, hostcontext.dpnidHost,
											NULL, &dpnhAddPlayer, 0);
		if (tr != DPNERR_INVALIDGROUP)
		{
			DPTEST_FAIL(hLog, "Adding self player to invalid group didn't return expected error INVALIDGROUP!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't add player to group)

		if (dpnhAddPlayer != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async handle was modified (%x != 0x666)!",
				1, dpnhAddPlayer);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (handle was set)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating group on host asynchronously");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		SAFE_CLOSEHANDLE(hAsyncOpComplete);
		CREATEEVENT_OR_THROW(hAsyncOpComplete, NULL, FALSE, FALSE, NULL);

		ZeroMemory(&dpngi, sizeof (DPN_GROUP_INFO));
		dpngi.dwSize = sizeof (DPN_GROUP_INFO);
		//dpngi.dwInfoFlags = 0;
		//dpngi.pwszName = NULL;
		//dpngi.pvData = NULL;
		//dpngi.dwDataSize = 0;
		//dpngi.dwGroupFlags = 0;

		CopyMemory(&dpngiCompare, &dpngi, sizeof (DPN_GROUP_INFO));

		// Expect the create group message.
		//hostcontext.dpnidExpectedGroupOwner = 0;
		hostcontext.fCanGetCreateGroup = TRUE;

		// Now that we're completing asynchronously, need to be ready for ASYNC_OP_COMPLETE message
		hostcontext.fAsyncOpCanComplete = TRUE;
		hostcontext.fAsyncOpCompleted = FALSE;
		SAFE_CLOSEHANDLE(hostcontext.hAsyncOpCompletedEvent);
		CREATEEVENT_OR_THROW(hostcontext.hAsyncOpCompletedEvent, NULL, FALSE, FALSE, NULL);

		tr = pDP8Peer->DP8P_CreateGroup(&dpngi, NULL, hAsyncOpComplete, &hAsyncOp, 0);

		if((tr != DPNSUCCESS_PENDING) && (tr != DPN_OK))
		{
			DPTEST_FAIL(hLog, "Creating group failed! (error 0x%08x)", 1, tr);
			THROW_TESTRESULT;
		} // end if (couldn't create group)

		if (memcmp(&dpngiCompare, &dpngi, sizeof (DPN_GROUP_INFO)) != 0)
		{
			DPTEST_FAIL(hLog, "Group info structure was modified (structure at %x != structure at %x)!",
				2, &dpngiCompare, &dpngi);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (group info changed)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for group to be created asynchronously");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 1;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hAsyncOpComplete))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird create groups.
		hostcontext.fCanGetCreateGroup = FALSE;

		// Make sure we got the create group message.
		if (hostcontext.dpnidGroup == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get create group message!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create group)

		hostcontext.fAsyncOpCanComplete = FALSE;
		hostcontext.fAsyncOpCompleted = FALSE;

		SAFE_CLOSEHANDLE(hostcontext.hAsyncOpCompletedEvent);

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Adding invalid player to valid group");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_AddPlayerToGroup(hostcontext.dpnidGroup, (DPNID) 0x666,
											NULL, &dpnhAddPlayer, 0);
		if (tr != DPNERR_INVALIDPLAYER)
		{
			DPTEST_FAIL(hLog, "Adding invalid player to valid group didn't return expected error INVALIDPLAYER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't add player to group)

		if (dpnhAddPlayer != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async handle was modified (%x != 0x666)!",
				1, dpnhAddPlayer);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (handle was set)






		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Adding self player to group");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Expect the add player to group message and async op completion.
		hostcontext.dpnidExpectedPlayer = hostcontext.dpnidHost;
		hostcontext.pvExpectedPlayerContext= &(hostcontext.dpnidHost);
		hostcontext.fCanGetAddToGroup = TRUE;
		CREATEEVENT_OR_THROW(hostcontext.hAsyncOpCompletedEvent,
							NULL, FALSE, FALSE, NULL);
		hostcontext.fAsyncOpCanComplete = TRUE;

		tr = pDP8Peer->DP8P_AddPlayerToGroup(hostcontext.dpnidGroup,
											hostcontext.dpnidHost,
											NULL,
											&dpnhAddPlayer,
											0);
		if (tr != (HRESULT) DPNSUCCESS_PENDING)
		{
			DPTEST_FAIL(hLog, "Adding self player to group didn't return expected PENDING success code!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't add player to group)

		if (dpnhAddPlayer == (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "No async operation handle was returned!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (handle was not set)

		if (dpnhAddPlayer == NULL)
		{
			DPTEST_FAIL(hLog, "Async operation handle returned is NULL!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (handle was set to NULL)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for async op to complete");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 1;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hostcontext.hAsyncOpCompletedEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// The add player to group message should have arrived by now.
		hostcontext.fCanGetAddToGroup = FALSE;

		// Prevent any weird async op completions.
		hostcontext.fAsyncOpCanComplete = FALSE;


#ifdef DEBUG
		// Make sure we got the indication (how else would we get here?).
		if (! hostcontext.fAsyncOpCompleted)
		{
			DPTEST_FAIL(hLog, "Didn't get async op completion!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (didn't get async op completion)
#endif // DEBUG

		// Make sure the completion indicated the same op handle that we were
		// returned.
		if (hostcontext.dpnhCompletedAsyncOp != dpnhAddPlayer)
		{
			DPTEST_FAIL(hLog, "Add player completed with different async op handle (%x != %x)!",
				2, hostcontext.dpnhCompletedAsyncOp, dpnhAddPlayer);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (async op handle is wrong)

		// Reset the context.
		hostcontext.fAsyncOpCompleted = FALSE;
		CloseHandle(hostcontext.hAsyncOpCompletedEvent);
		hostcontext.hAsyncOpCompletedEvent = NULL;


		// Make sure we got the add to group message.
		if (! hostcontext.fGotAddToGroup)
		{
			DPTEST_FAIL(hLog, "Didn't get add player to group message!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get add player to group)

		// Reset the context.
		hostcontext.fGotAddToGroup = FALSE;





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Adding self player to group again");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dpnhAddPlayer = (DPNHANDLE) 0x666;

		tr = pDP8Peer->DP8P_AddPlayerToGroup(hostcontext.dpnidGroup,
											hostcontext.dpnidHost,
											NULL,
											&dpnhAddPlayer,
											0);
		if (tr != DPNERR_PLAYERALREADYINGROUP)
		{
			DPTEST_FAIL(hLog, "Adding self player to group again didn't return expected error PLAYERALREADYINGROUP!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't destroy group)

		if (dpnhAddPlayer != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async handle was modified (%x != 0x666)!",
				1, dpnhAddPlayer);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (handle was set)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Removing self player from group asynchronously");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		SAFE_CLOSEHANDLE(hAsyncOpComplete);
		CREATEEVENT_OR_THROW(hAsyncOpComplete, NULL, FALSE, FALSE, NULL);

		// Now that we're completing asynchronously, need to be ready for ASYNC_OP_COMPLETE message
		hostcontext.fAsyncOpCanComplete = TRUE;
		hostcontext.fAsyncOpCompleted = FALSE;
		SAFE_CLOSEHANDLE(hostcontext.hAsyncOpCompletedEvent);
		CREATEEVENT_OR_THROW(hostcontext.hAsyncOpCompletedEvent, NULL, FALSE, FALSE, NULL);

		tr = pDP8Peer->DP8P_RemovePlayerFromGroup(hostcontext.dpnidGroup,
												hostcontext.dpnidHost,
												hAsyncOpComplete,
												&hAsyncOp,
												0);

		if((tr != DPNSUCCESS_PENDING) && (tr != DPN_OK))
		{
			DPTEST_FAIL(hLog, "Removing self player from group failed! (error 0x%08x)", 1, tr);
			THROW_TESTRESULT;
		} // end if (couldn't remove self from group)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for self player to be removed from group");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 1;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hAsyncOpComplete))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		hostcontext.fAsyncOpCanComplete = FALSE;
		hostcontext.fAsyncOpCompleted = FALSE;

		SAFE_CLOSEHANDLE(hostcontext.hAsyncOpCompletedEvent);

/* XBOX - SYNC operations not supported
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Adding self player to group synchronously");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Expect the add player to group message.
		hostcontext.dpnidExpectedPlayer = hostcontext.dpnidHost;
		hostcontext.pvExpectedPlayerContext= &(hostcontext.dpnidHost);
		hostcontext.fCanGetAddToGroup = TRUE;

		tr = pDP8Peer->DP8P_AddPlayerToGroup(hostcontext.dpnidGroup,
											hostcontext.dpnidHost,
											NULL,
											NULL,
											DPNADDPLAYERTOGROUP_SYNC);

		// Prevent any weird add player to group messages.
		hostcontext.fCanGetAddToGroup = FALSE;
		
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Adding self player to group synchronously failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't add player to group)

		// Make sure we got the add to group message.
		if (! hostcontext.fGotAddToGroup)
		{
			DPTEST_FAIL(hLog, "Didn't get add player to group message!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get add player to group)

		// Reset the context.
		hostcontext.fGotAddToGroup = FALSE;
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing peer object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure we got the destroy player message.
		if (hostcontext.dpnidHost != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)

#pragma TODO(vanceo, "Validate destroy group nametable unwind")

		// Reset group ID.
		hostcontext.dpnidGroup = 0;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Re-initializing peer object with nonhost context");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		nonhostcontext.hLog = hLog;

		tr = pDP8Peer->DP8P_Initialize(&nonhostcontext,
										ParmVPAddToGroupDPNMessageHandler, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Re-initializing peer object with context, 0 flags failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating new peer host object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Address->Release();
		pDP8Address = NULL;

		hostcontext.hLog = hLog;

		tr = ParmVCreatePeerHost(hLog, ParmVPAddToGroupDPNMessageHandler,
								&hostcontext,
								&dpnad,
								&(hostcontext.dpnidHost),
								&pDP8PeerHost,
								&pDP8Address);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Creating peer host failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't create peer host)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Connecting peer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

// XBOX - Had to make connection asynchronous

		// Host should get the create player now.
		CREATEEVENT_OR_THROW(hostcontext.hClientCreatedEvent, NULL, FALSE, FALSE, NULL);
		SAFE_CLOSEHANDLE(hAsyncOpComplete);
		CREATEEVENT_OR_THROW(hAsyncOpComplete, NULL, FALSE, FALSE, NULL);

		// Even though it's synchronous, we'll still get a completion.  The async op
		// handle will be NULL, though.
		nonhostcontext.fConnectCanComplete = TRUE;

		tr = pDP8Peer->DP8P_Connect(&dpnad,
									pDP8Address,
									NULL,
									NULL,
									NULL,
									NULL,
									0,
									&(nonhostcontext.dpnidClient),
									hAsyncOpComplete,
									&hAsyncOp,
									0);

		if((tr != DPNSUCCESS_PENDING) && (tr != DPN_OK))
		{
			DPTEST_FAIL(hLog, "Couldn't connect! (error 0x%08x)", 1, tr);
			THROW_TESTRESULT;
		} // end if (couldn't connect)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for connect to complete on non-host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hAsyncOpComplete))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird connects from completing.
		nonhostcontext.fConnectCanComplete = FALSE;

		// Make sure we saw the connect completion indication.
		if (! nonhostcontext.fConnectCompleted)
		{
			DPTEST_FAIL(hLog, "Didn't get connect complete indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (connect didn't complete)

		// Reset the context.
		nonhostcontext.fConnectCompleted = FALSE;

		// Make sure we got the create player messages.
		if (nonhostcontext.dpnidHost == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication for host on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player)

		if (nonhostcontext.dpnidClient == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication for client on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for create player to be indicated on host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hostcontext.hClientCreatedEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating group on client asynchronously");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		SAFE_CLOSEHANDLE(hAsyncOpComplete);
		CREATEEVENT_OR_THROW(hAsyncOpComplete, NULL, FALSE, FALSE, NULL);

		ZeroMemory(&dpngi, sizeof (DPN_GROUP_INFO));
		dpngi.dwSize = sizeof (DPN_GROUP_INFO);
		//dpngi.dwInfoFlags = 0;
		//dpngi.pwszName = NULL;
		//dpngi.pvData = NULL;
		//dpngi.dwDataSize = 0;
		//dpngi.dwGroupFlags = 0;

		CopyMemory(&dpngiCompare, &dpngi, sizeof (DPN_GROUP_INFO));


		// Expect the create group message on the host.
		//hostcontext.dpnidExpectedGroupOwner = 0;

		CREATEEVENT_OR_THROW(hostcontext.hGotGroupMsgEvent, NULL, FALSE, FALSE, NULL);
		hostcontext.fCanGetCreateGroup = TRUE;

		// Expect the create group message on the client.
		//nonhostcontext.dpnidExpectedGroupOwner = 0;
		nonhostcontext.fCanGetCreateGroup = TRUE;

		// Now that we're completing asynchronously, need to be ready for ASYNC_OP_COMPLETE message
		nonhostcontext.fAsyncOpCanComplete = TRUE;
		nonhostcontext.fAsyncOpCompleted = FALSE;
		SAFE_CLOSEHANDLE(nonhostcontext.hAsyncOpCompletedEvent);
		CREATEEVENT_OR_THROW(nonhostcontext.hAsyncOpCompletedEvent, NULL, FALSE, FALSE, NULL);

		tr = pDP8Peer->DP8P_CreateGroup(&dpngi, NULL, hAsyncOpComplete, &hAsyncOp, 0);

		if((tr != DPNSUCCESS_PENDING) && (tr != DPN_OK))
		{
			DPTEST_FAIL(hLog, "Creating group failed! (error 0x%08x)", 1, tr);
			THROW_TESTRESULT;
		} // end if (couldn't create group)

		if (memcmp(&dpngiCompare, &dpngi, sizeof (DPN_GROUP_INFO)) != 0)
		{
			DPTEST_FAIL(hLog, "Group info structure was modified (structure at %x != structure at %x)!",
				2, &dpngiCompare, &dpngi);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (group info changed)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for group to be created asynchronously");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hAsyncOpComplete))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird create groups.
		nonhostcontext.fCanGetCreateGroup = FALSE;

		// Make sure we got the create group message.
		if (nonhostcontext.dpnidGroup == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get create group message!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create group)

		nonhostcontext.fAsyncOpCanComplete = FALSE;
		nonhostcontext.fAsyncOpCompleted = FALSE;

		SAFE_CLOSEHANDLE(nonhostcontext.hAsyncOpCompletedEvent);

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for group to be created on host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hostcontext.hGotGroupMsgEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird create group indications.
		hostcontext.fCanGetCreateGroup = FALSE;

#ifdef DEBUG
		// Make sure we got the indication (how else would we get here?).
		if (hostcontext.dpnidGroup == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get create group indication!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (didn't get create group indication)
#endif // DEBUG

		// Reset the context.
		CloseHandle(hostcontext.hGotGroupMsgEvent);
		hostcontext.hGotGroupMsgEvent = NULL;






		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Adding self player to group on client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Expect the add player to group message on the host.
		hostcontext.dpnidExpectedPlayer = hostcontext.dpnidClient;
		hostcontext.pvExpectedPlayerContext = &(hostcontext.dpnidClient);
		hostcontext.fCanGetAddToGroup = TRUE;
		CREATEEVENT_OR_THROW(hostcontext.hGotGroupMsgEvent,
							NULL, FALSE, FALSE, NULL);

		// Expect the add player to group message and async op completion on the client.
		nonhostcontext.dpnidExpectedPlayer = nonhostcontext.dpnidClient;
		nonhostcontext.pvExpectedPlayerContext = &(nonhostcontext.dpnidClient);
		nonhostcontext.fCanGetAddToGroup = TRUE;
		CREATEEVENT_OR_THROW(nonhostcontext.hAsyncOpCompletedEvent,
							NULL, FALSE, FALSE, NULL);
		nonhostcontext.fAsyncOpCanComplete = TRUE;

		tr = pDP8Peer->DP8P_AddPlayerToGroup(nonhostcontext.dpnidGroup,
											nonhostcontext.dpnidClient,
											NULL,
											&dpnhAddPlayer,
											0);
		if (tr != (HRESULT) DPNSUCCESS_PENDING)
		{
			DPTEST_FAIL(hLog, "Adding self player to group on client didn't return expected PENDING success code!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't add player to group)

		if (dpnhAddPlayer == (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "No async operation handle was returned!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (handle was not set)

		if (dpnhAddPlayer == NULL)
		{
			DPTEST_FAIL(hLog, "Async operation handle returned is NULL!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (handle was set to NULL)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for async op to complete on client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, nonhostcontext.hAsyncOpCompletedEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// The add player to group message should have arrived by now.
		nonhostcontext.fCanGetAddToGroup = FALSE;

		// Prevent any weird async op completions.
		nonhostcontext.fAsyncOpCanComplete = FALSE;


#ifdef DEBUG
		// Make sure we got the indication (how else would we get here?).
		if (! nonhostcontext.fAsyncOpCompleted)
		{
			DPTEST_FAIL(hLog, "Didn't get async op completion!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (didn't get async op completion)
#endif // DEBUG

		// Make sure the completion indicated the same op handle that we were
		// returned.
		if (nonhostcontext.dpnhCompletedAsyncOp != dpnhAddPlayer)
		{
			DPTEST_FAIL(hLog, "Add player completed with different async op handle (%x != %x)!",
				2, nonhostcontext.dpnhCompletedAsyncOp, dpnhAddPlayer);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (async op handle is wrong)

		// Reset the context.
		nonhostcontext.fAsyncOpCompleted = FALSE;
		CloseHandle(nonhostcontext.hAsyncOpCompletedEvent);
		nonhostcontext.hAsyncOpCompletedEvent = NULL;


		// Make sure we got the add to group message.
		if (! nonhostcontext.fGotAddToGroup)
		{
			DPTEST_FAIL(hLog, "Didn't get add player to group message on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get add player to group)

		// Reset the context.
		nonhostcontext.fGotAddToGroup = FALSE;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for add player to group to be indicated on host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hostcontext.hGotGroupMsgEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird add to group indications.
		hostcontext.fCanGetAddToGroup = FALSE;


#ifdef DEBUG
		// Make sure we got the indication (how else would we get here?).
		if (! hostcontext.fGotAddToGroup)
		{
			DPTEST_FAIL(hLog, "Didn't get add to group indication!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (didn't get add to group indication)
#endif // DEBUG

		// Reset the context.
		CloseHandle(hostcontext.hGotGroupMsgEvent);
		hostcontext.hGotGroupMsgEvent = NULL;
		hostcontext.fGotAddToGroup = FALSE;






/* XBOX - SYNC operations not supported
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Adding host player to group synchronously on client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Expect the add player to group message on the host and client.
		hostcontext.dpnidExpectedPlayer = hostcontext.dpnidHost;
		hostcontext.pvExpectedPlayerContext = &(hostcontext.dpnidHost);
		CREATEEVENT_OR_THROW(hostcontext.hGotGroupMsgEvent,
							NULL, FALSE, FALSE, NULL);
		hostcontext.fCanGetAddToGroup = TRUE;

		nonhostcontext.dpnidExpectedPlayer = nonhostcontext.dpnidHost;
		nonhostcontext.pvExpectedPlayerContext = &(nonhostcontext.dpnidHost);
		nonhostcontext.fCanGetAddToGroup = TRUE;

		tr = pDP8Peer->DP8P_AddPlayerToGroup(nonhostcontext.dpnidGroup,
											nonhostcontext.dpnidHost,
											NULL,
											NULL,
											DPNADDPLAYERTOGROUP_SYNC);

		// Prevent any weird add player to group messages.
		nonhostcontext.fCanGetAddToGroup = FALSE;
		
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Adding host player to group synchronously on client failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't add player to group)

		// Make sure we got the add to group message.
		if (! nonhostcontext.fGotAddToGroup)
		{
			DPTEST_FAIL(hLog, "Didn't get add player to group message!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get add player to group)

		// Reset the context.
		nonhostcontext.fGotAddToGroup = FALSE;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for add player to group to be indicated on host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hostcontext.hGotGroupMsgEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird add to group indications.
		hostcontext.fCanGetAddToGroup = FALSE;


#ifdef DEBUG
		// Make sure we got the indication (how else would we get here?).
		if (! hostcontext.fGotAddToGroup)
		{
			DPTEST_FAIL(hLog, "Didn't get add to group indication!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (didn't get add to group indication)
#endif // DEBUG

		// Reset the context.
		CloseHandle(hostcontext.hGotGroupMsgEvent);
		hostcontext.hGotGroupMsgEvent = NULL;
		hostcontext.fGotAddToGroup = FALSE;
*/





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing peer client object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing peer client object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure we got the destroy player messages.
		if (nonhostcontext.dpnidHost != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for host on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)

		if (nonhostcontext.dpnidClient != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for client on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)


		// Technically we should wait to make sure the host saw the client go away
		// as expected but that's more hassle than it's worth.  Just make sure he's
		// gone after Close() has returned.



#pragma TODO(vanceo, "Validate destroy group nametable unwind on both interfaces")


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing host object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8PeerHost->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing host object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure we got the destroy player messages.
		if (hostcontext.dpnidHost != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for host on host!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)

		if (hostcontext.dpnidClient != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for client on host!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing hosting DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8PeerHost->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release hosting DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8PeerHost);
		pDP8PeerHost = NULL;





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Peer);
		pDP8Peer = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE


	if (pDP8Peer != NULL)
	{
		delete (pDP8Peer);
		pDP8Peer = NULL;
	} // end if (have peer object)

	if (pDP8PeerHost != NULL)
	{
		delete (pDP8PeerHost);
		pDP8PeerHost = NULL;
	} // end if (have peer object)

	SAFE_RELEASE(pDP8Address);
	SAFE_CLOSEHANDLE(hostcontext.hGotGroupMsgEvent);
	SAFE_CLOSEHANDLE(nonhostcontext.hGotGroupMsgEvent);
	SAFE_CLOSEHANDLE(hostcontext.hAsyncOpCompletedEvent);
	SAFE_CLOSEHANDLE(nonhostcontext.hAsyncOpCompletedEvent);
	SAFE_CLOSEHANDLE(hostcontext.hClientCreatedEvent);
	ClearDoWorkList(&DoWorkList);
	SAFE_CLOSEHANDLE(hAsyncOpComplete);

	return (sr);
} // ParmVPeerExec_AddToGroup
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVPeerExec_RemoveFromGroup()"
//==================================================================================
// ParmVPeerExec_RemoveFromGroup
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.1.14 - Peer RemoveFromGroup parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVPeerExec_RemoveFromGroup(HANDLE hLog)
{
	CTNSystemResult					sr;
	CTNTestResult					tr;
	PWRAPDP8PEER					pDP8Peer = NULL;
	PWRAPDP8PEER					pDP8PeerHost = NULL;
	PDIRECTPLAY8ADDRESS				pDP8Address = NULL;
	PARMVPREMOVEFROMGROUPCONTEXT	hostcontext;
	PARMVPREMOVEFROMGROUPCONTEXT	nonhostcontext;
	DPN_APPLICATION_DESC			dpnad;
	DPN_APPLICATION_DESC			dpnadCompare;
	DPN_GROUP_INFO					dpngi;
	DPN_GROUP_INFO					dpngiCompare;
	DPNHANDLE						dpnhRemovePlayer;
	DP_DOWORKLIST					DoWorkList;
	DPNHANDLE						hAsyncOp;
	HANDLE							hAsyncOpComplete = NULL;

	ZeroMemory(&DoWorkList, sizeof(DP_DOWORKLIST));
	ZeroMemory(&hostcontext, sizeof (PARMVPREMOVEFROMGROUPCONTEXT));
	hostcontext.fHost = TRUE;

	ZeroMemory(&nonhostcontext, sizeof (PARMVPREMOVEFROMGROUPCONTEXT));
	//nonhostcontext.fHost = FALSE;


	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Peer = new CWrapDP8Peer(hLog);
		if (pDP8Peer == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8Peer->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (LPVOID *) &pDP8Address, NULL);
		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't create DirectPlay8Address object!", 0);
			THROW_SYSTEMRESULT;
		} // end if (create failed)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting address object's SP to TCP/IP");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->SetSP(&CLSID_DP8SP_TCPIP);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting address object's SP to TCP/IP failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set SP)





/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Removing player 0 from group 0 (DPNID_ALL_PLAYERS_GROUP) with NULLs and 0s using C++ macro");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = IDirectPlay8Peer_RemovePlayerFromGroup(pDP8Peer->m_pDP8Peer, 0,  0,
													NULL, NULL, 0);
		if (tr != DPNERR_INVALIDGROUP)
		{
			DPTEST_FAIL(hLog, "Removing player 0 from group 0 (DPNID_ALL_PLAYERS_GROUP) with NULLs and 0s using C++ macro didn't return expected error INVALIDGROUP!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't remove player from group)
*/




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Removing player 0 from group (DPNID_ALL_PLAYERS_GROUP) 0 with NULLs and 0s");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_RemovePlayerFromGroup(0, 0, NULL, NULL, 0);
		if (tr != DPNERR_INVALIDGROUP)
		{
			DPTEST_FAIL(hLog, "Removing player 0 from group 0 (DPNID_ALL_PLAYERS_GROUP) with NULLs and 0s didn't return expected error INVALIDGROUP!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't remove player from group)
*/

		dpnhRemovePlayer = (DPNHANDLE) 0x666;

/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Removing player from group with invalid flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


		// Use 0x666 to avoid DPlay's group ID == 0 and player ID == 0 checks.
		tr = pDP8Peer->DP8P_RemovePlayerFromGroup((DPNID) 0x666, (DPNID) 0x666, NULL,
												&dpnhRemovePlayer, 0x666);
		if (tr != DPNERR_INVALIDFLAGS)
		{
			DPTEST_FAIL(hLog, "Removing player from group with invalid flags didn't return expected error INVALIDFLAGS!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't remove player from group)

		if (dpnhRemovePlayer != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async handle was modified (%x != 0x666)!",
				1, dpnhRemovePlayer);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (handle was set)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Removing player from group before initialization");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_RemovePlayerFromGroup((DPNID) 0x666, (DPNID) 0x666, NULL,
												&dpnhRemovePlayer, 0);
		if (tr != DPNERR_UNINITIALIZED)
		{
			DPTEST_FAIL(hLog, "Removing player from group before initialization didn't return expected error UNINITIALIZED!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't remove player from group)

		if (dpnhRemovePlayer != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async handle was modified (%x != 0x666)!",
				1, dpnhRemovePlayer);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (handle was set)
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Initializing peer object with host context");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		hostcontext.hLog = hLog;

		tr = pDP8Peer->DP8P_Initialize(&hostcontext,
										ParmVPRemoveFromGroupDPNMessageHandler, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Initializing peer object with host context failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Removing player from group without a connection");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_RemovePlayerFromGroup((DPNID) 0x666, (DPNID) 0x666, NULL,
												&dpnhRemovePlayer, 0);
		if (tr != DPNERR_NOCONNECTION)
		{
			DPTEST_FAIL(hLog, "Removing player from group without a connection didn't return expected error NOCONNECTION!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't remove player from group)

		if (dpnhRemovePlayer != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async handle was modified (%x != 0x666)!",
				1, dpnhRemovePlayer);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (handle was set)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Hosting session");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		//dpnad.dwFlags = 0;
		//dpnad.guidInstance = GUID_NULL;
		dpnad.guidApplication = GUID_PARMV_PEER_GETAPPDESC;
		//dpnad.dwMaxPlayers = 0;
		//dpnad.dwCurrentPlayers = 0;
		//dpnad.pwszSessionName = NULL;
		//dpnad.pwszPassword = NULL;
		//dpnad.pvReservedData = NULL;
		//dpnad.dwReservedDataSize = 0;
		//dpnad.pvApplicationReservedData = NULL;
		//dpnad.dwApplicationReservedDataSize = 0;

		// Save what we're passing in to make sure it's not touched.
		CopyMemory(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC));

		tr = pDP8Peer->DP8P_Host(&dpnad,
								&pDP8Address,
								1,
								NULL,
								NULL,
								&(hostcontext.dpnidHost),
								0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't start hosting session!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't host)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		// Make sure we got the create player message.
		if (hostcontext.dpnidHost == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Removing self player from invalid group");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_RemovePlayerFromGroup((DPNID) 0x666, hostcontext.dpnidHost,
												NULL,
												&dpnhRemovePlayer, 0);
		if (tr != DPNERR_INVALIDGROUP)
		{
			DPTEST_FAIL(hLog, "Removing self player from invalid group didn't return expected error INVALIDGROUP!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't remove player from group)

		if (dpnhRemovePlayer != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async handle was modified (%x != 0x666)!",
				1, dpnhRemovePlayer);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (handle was set)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating group on client asynchronously");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		SAFE_CLOSEHANDLE(hAsyncOpComplete);
		CREATEEVENT_OR_THROW(hAsyncOpComplete, NULL, FALSE, FALSE, NULL);

		ZeroMemory(&dpngi, sizeof (DPN_GROUP_INFO));
		dpngi.dwSize = sizeof (DPN_GROUP_INFO);
		//dpngi.dwInfoFlags = 0;
		//dpngi.pwszName = NULL;
		//dpngi.pvData = NULL;
		//dpngi.dwDataSize = 0;
		//dpngi.dwGroupFlags = 0;

		CopyMemory(&dpngiCompare, &dpngi, sizeof (DPN_GROUP_INFO));


		// Expect the create group message.
		//hostcontext.dpnidExpectedGroupOwner = 0;
		hostcontext.fCanGetCreateGroup = TRUE;

		// Now that we're completing asynchronously, need to be ready for ASYNC_OP_COMPLETE message
		hostcontext.fAsyncOpCanComplete = TRUE;
		hostcontext.fAsyncOpCompleted = FALSE;
		SAFE_CLOSEHANDLE(hostcontext.hAsyncOpCompletedEvent);
		CREATEEVENT_OR_THROW(hostcontext.hAsyncOpCompletedEvent, NULL, FALSE, FALSE, NULL);

		tr = pDP8Peer->DP8P_CreateGroup(&dpngi, NULL, hAsyncOpComplete, &hAsyncOp, 0);

		if((tr != DPNSUCCESS_PENDING) && (tr != DPN_OK))
		{
			DPTEST_FAIL(hLog, "Creating group failed! (error 0x%08x)", 1, tr);
			THROW_TESTRESULT;
		} // end if (couldn't create group)

		if (memcmp(&dpngiCompare, &dpngi, sizeof (DPN_GROUP_INFO)) != 0)
		{
			DPTEST_FAIL(hLog, "Group info structure was modified (structure at %x != structure at %x)!",
				2, &dpngiCompare, &dpngi);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (group info changed)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for group to be created asynchronously");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 1;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hAsyncOpComplete))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird create groups.
		hostcontext.fCanGetCreateGroup = FALSE;

		// Make sure we got the create group message.
		if (hostcontext.dpnidGroup == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get create group message!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create group)

		hostcontext.fAsyncOpCanComplete = FALSE;
		hostcontext.fAsyncOpCompleted = FALSE;

		SAFE_CLOSEHANDLE(hostcontext.hAsyncOpCompletedEvent);

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Removing invalid player from group");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_RemovePlayerFromGroup(hostcontext.dpnidGroup,
												(DPNID) 0x666, NULL,
												&dpnhRemovePlayer, 0);
		if (tr != DPNERR_INVALIDPLAYER)
		{
			DPTEST_FAIL(hLog, "Removing invalid player from group didn't return expected error INVALIDPLAYER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't remove player from group)

		if (dpnhRemovePlayer != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async handle was modified (%x != 0x666)!",
				1, dpnhRemovePlayer);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (handle was set)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Removing player not in group");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_RemovePlayerFromGroup(hostcontext.dpnidGroup,
												hostcontext.dpnidHost, NULL,
												&dpnhRemovePlayer, 0);
		if (tr != DPNERR_PLAYERNOTINGROUP)
		{
			DPTEST_FAIL(hLog, "Removing player not in group didn't return expected error PLAYERNOTINGROUP!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't remove player from group)

		if (dpnhRemovePlayer != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async handle was modified (%x != 0x666)!",
				1, dpnhRemovePlayer);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (handle was set)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Adding self player to group asynchronously");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		SAFE_CLOSEHANDLE(hAsyncOpComplete);
		CREATEEVENT_OR_THROW(hAsyncOpComplete, NULL, FALSE, FALSE, NULL);

		// Expect the add player to group message.
		hostcontext.dpnidExpectedPlayer = hostcontext.dpnidHost;
		hostcontext.pvExpectedPlayerContext = &(hostcontext.dpnidHost);
		hostcontext.fCanGetAddToGroup = TRUE;

		// Now that we're completing asynchronously, need to be ready for ASYNC_OP_COMPLETE message
		hostcontext.fAsyncOpCanComplete = TRUE;
		hostcontext.fAsyncOpCompleted = FALSE;
		SAFE_CLOSEHANDLE(hostcontext.hAsyncOpCompletedEvent);
		CREATEEVENT_OR_THROW(hostcontext.hAsyncOpCompletedEvent, NULL, FALSE, FALSE, NULL);

		tr = pDP8Peer->DP8P_AddPlayerToGroup(hostcontext.dpnidGroup,
											hostcontext.dpnidHost,
											hAsyncOpComplete,
											&hAsyncOp,
											0);

		
		if((tr != DPNSUCCESS_PENDING) && (tr != DPN_OK))
		{
			DPTEST_FAIL(hLog, "Adding self player to group synchronously failed! (error 0x%08x)", 1, tr);
			THROW_TESTRESULT;
		} // end if (couldn't create group)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for self player to be added to group asynchronously");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 1;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hAsyncOpComplete))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		hostcontext.fCanGetAddToGroup = FALSE;

		// Make sure we got the add to group message.
		if (!hostcontext.fGotAddToGroup)
		{
			DPTEST_FAIL(hLog, "Didn't get add player to group message!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get add player to group)

		// Reset the context.
		hostcontext.fGotAddToGroup = FALSE;

		hostcontext.fAsyncOpCanComplete = FALSE;
		hostcontext.fAsyncOpCompleted = FALSE;

		SAFE_CLOSEHANDLE(hostcontext.hAsyncOpCompletedEvent);

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Removing self player from group");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Expect the remove player from group message and async op completion.
		hostcontext.dpnidExpectedPlayer = hostcontext.dpnidHost;
		hostcontext.pvExpectedPlayerContext = &(hostcontext.dpnidHost);
		hostcontext.fCanGetRemoveFromGroup = TRUE;
		CREATEEVENT_OR_THROW(hostcontext.hAsyncOpCompletedEvent, NULL, FALSE, FALSE, NULL);
		hostcontext.fAsyncOpCanComplete = TRUE;

		tr = pDP8Peer->DP8P_RemovePlayerFromGroup(hostcontext.dpnidGroup,
												hostcontext.dpnidHost,
												NULL,
												&dpnhRemovePlayer,
												0);
		if (tr != (HRESULT) DPNSUCCESS_PENDING)
		{
			DPTEST_FAIL(hLog, "Removing self player from group didn't return expected PENDING success code!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't emove player from group)

		if (dpnhRemovePlayer == (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "No async operation handle was returned!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (handle was not set)

		if (dpnhRemovePlayer == NULL)
		{
			DPTEST_FAIL(hLog, "Async operation handle returned is NULL!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (handle was set to NULL)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for async op to complete");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 1;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hostcontext.hAsyncOpCompletedEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// The remove player from group message should have arrived by now.
		hostcontext.fCanGetRemoveFromGroup = FALSE;

		// Prevent any weird async op completions.
		hostcontext.fAsyncOpCanComplete = FALSE;


#ifdef DEBUG
		// Make sure we got the indication (how else would we get here?).
		if (! hostcontext.fAsyncOpCompleted)
		{
			DPTEST_FAIL(hLog, "Didn't get async op completion!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (didn't get async op completion)
#endif // DEBUG

		// Make sure the completion indicated the same op handle that we were
		// returned.
		if (hostcontext.dpnhCompletedAsyncOp != dpnhRemovePlayer)
		{
			DPTEST_FAIL(hLog, "Remove player completed with different async op handle (%x != %x)!",
				2, hostcontext.dpnhCompletedAsyncOp, dpnhRemovePlayer);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (async op handle is wrong)

		// Reset the context.
		hostcontext.fAsyncOpCompleted = FALSE;
		CloseHandle(hostcontext.hAsyncOpCompletedEvent);
		hostcontext.hAsyncOpCompletedEvent = NULL;


		// Make sure we got the remove from group message.
		if (! hostcontext.fGotRemoveFromGroup)
		{
			DPTEST_FAIL(hLog, "Didn't get remove player from group message!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get remove player from group)

		// Reset the context.
		hostcontext.fGotRemoveFromGroup = FALSE;

/* XBOX - SYNC operations not supported

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Adding self player to group asynchronously");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		SAFE_CLOSEHANDLE(hAsyncOpComplete);
		CREATEEVENT_OR_THROW(hAsyncOpComplete, NULL, FALSE, FALSE, NULL);

		// Expect the add player to group message.
		hostcontext.dpnidExpectedPlayer = hostcontext.dpnidHost;
		hostcontext.pvExpectedPlayerContext = &(hostcontext.dpnidHost);
		hostcontext.fCanGetAddToGroup = TRUE;

		tr = pDP8Peer->DP8P_AddPlayerToGroup(hostcontext.dpnidGroup,
											hostcontext.dpnidHost,
											hAsyncOpComplete,
											&hAsyncOp,
											0);

		
		if((tr != DPNSUCCESS_PENDING) && (tr != DPN_OK))
		{
			DPTEST_FAIL(hLog, "Adding self player to group synchronously failed! (error 0x%08x)", 1, tr);
			THROW_TESTRESULT;
		} // end if (couldn't create group)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for self player to be added to group asynchronously");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 1;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hAsyncOpComplete))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Make sure we got the add to group message.
		if (!hostcontext.fGotAddToGroup)
		{
			DPTEST_FAIL(hLog, "Didn't get add player to group message!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get add player to group)

		// Reset the context.
		hostcontext.fGotAddToGroup = FALSE;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Removing self player from group synchronously");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Expect the remove player from group message.
		hostcontext.fCanGetRemoveFromGroup = TRUE;

		tr = pDP8Peer->DP8P_RemovePlayerFromGroup(hostcontext.dpnidGroup,
												hostcontext.dpnidExpectedPlayer,
												NULL,
												NULL,
												DPNADDPLAYERTOGROUP_SYNC);

		// Prevent any weird remove player from group messages.
		hostcontext.fCanGetRemoveFromGroup = FALSE;
		
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Removing self player from group synchronously failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't remove from group)

		// Make sure we got the remove from group message.
		if (! hostcontext.fGotRemoveFromGroup)
		{
			DPTEST_FAIL(hLog, "Didn't get remove player from group message!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get remove player from group)

		// Reset the context.
		hostcontext.fGotRemoveFromGroup = FALSE;

*/


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing peer object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure we got the destroy player message.
		if (hostcontext.dpnidHost != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)

#pragma TODO(vanceo, "Validate destroy group nametable unwind")

		// Reset group ID.
		hostcontext.dpnidGroup = 0;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Re-initializing peer object with nonhost context");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		nonhostcontext.hLog = hLog;

		tr = pDP8Peer->DP8P_Initialize(&nonhostcontext,
										ParmVPRemoveFromGroupDPNMessageHandler,
										0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Re-initializing peer object with context, 0 flags failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating new peer host object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Address->Release();
		pDP8Address = NULL;

		hostcontext.hLog = hLog;

		tr = ParmVCreatePeerHost(hLog, ParmVPRemoveFromGroupDPNMessageHandler,
								&hostcontext,
								&dpnad,
								&(hostcontext.dpnidHost),
								&pDP8PeerHost,
								&pDP8Address);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Creating peer host failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't create peer host)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Connecting peer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

// XBOX - Had to make connection asynchronous

		// Host should get the create player now.
		CREATEEVENT_OR_THROW(hostcontext.hClientCreatedEvent, NULL, FALSE, FALSE, NULL);
		SAFE_CLOSEHANDLE(hAsyncOpComplete);
		CREATEEVENT_OR_THROW(hAsyncOpComplete, NULL, FALSE, FALSE, NULL);

		// Even though it's synchronous, we'll still get a completion.  The async op
		// handle will be NULL, though.
		nonhostcontext.fConnectCanComplete = TRUE;

		tr = pDP8Peer->DP8P_Connect(&dpnad,
									pDP8Address,
									NULL,
									NULL,
									NULL,
									NULL,
									0,
									&(nonhostcontext.dpnidClient),
									hAsyncOpComplete,
									&hAsyncOp,
									0);

		if((tr != DPNSUCCESS_PENDING) && (tr != DPN_OK))
		{
			DPTEST_FAIL(hLog, "Couldn't connect! (error 0x%08x)", 1, tr);
			THROW_TESTRESULT;
		} // end if (couldn't connect)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for connect to complete on non-host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hAsyncOpComplete))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird connects from completing.
		nonhostcontext.fConnectCanComplete = FALSE;

		// Make sure we saw the connect completion indication.
		if (! nonhostcontext.fConnectCompleted)
		{
			DPTEST_FAIL(hLog, "Didn't get connect complete indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (connect didn't complete)

		// Reset the context.
		nonhostcontext.fConnectCompleted = FALSE;

		// Make sure we got the create player messages.
		if (nonhostcontext.dpnidHost == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication for host on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player)

		if (nonhostcontext.dpnidClient == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication for client on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for create player to be indicated on host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hostcontext.hClientCreatedEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating group on client asynchronously");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		SAFE_CLOSEHANDLE(hAsyncOpComplete);
		CREATEEVENT_OR_THROW(hAsyncOpComplete, NULL, FALSE, FALSE, NULL);
		SAFE_CLOSEHANDLE(hostcontext.hGotGroupMsgEvent);
		CREATEEVENT_OR_THROW(hostcontext.hGotGroupMsgEvent, NULL, FALSE, FALSE, NULL);

		hostcontext.fCanGetCreateGroup = TRUE;

		ZeroMemory(&dpngi, sizeof (DPN_GROUP_INFO));
		dpngi.dwSize = sizeof (DPN_GROUP_INFO);
		//dpngi.dwInfoFlags = 0;
		//dpngi.pwszName = NULL;
		//dpngi.pvData = NULL;
		//dpngi.dwDataSize = 0;
		//dpngi.dwGroupFlags = 0;

		CopyMemory(&dpngiCompare, &dpngi, sizeof (DPN_GROUP_INFO));


		// Expect the create group message.
		//hostcontext.dpnidExpectedGroupOwner = 0;
		nonhostcontext.fCanGetCreateGroup = TRUE;

		// Now that we're completing asynchronously, need to be ready for ASYNC_OP_COMPLETE message
		nonhostcontext.fAsyncOpCanComplete = TRUE;
		nonhostcontext.fAsyncOpCompleted = FALSE;
		SAFE_CLOSEHANDLE(nonhostcontext.hAsyncOpCompletedEvent);
		CREATEEVENT_OR_THROW(nonhostcontext.hAsyncOpCompletedEvent, NULL, FALSE, FALSE, NULL);

		tr = pDP8Peer->DP8P_CreateGroup(&dpngi, NULL, hAsyncOpComplete, &hAsyncOp, 0);

		if((tr != DPNSUCCESS_PENDING) && (tr != DPN_OK))
		{
			DPTEST_FAIL(hLog, "Creating group failed! (error 0x%08x)", 1, tr);
			THROW_TESTRESULT;
		} // end if (couldn't create group)

		if (memcmp(&dpngiCompare, &dpngi, sizeof (DPN_GROUP_INFO)) != 0)
		{
			DPTEST_FAIL(hLog, "Group info structure was modified (structure at %x != structure at %x)!",
				2, &dpngiCompare, &dpngi);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (group info changed)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for group to be created asynchronously");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hAsyncOpComplete))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird create groups.
		nonhostcontext.fCanGetCreateGroup = FALSE;

		// Make sure we got the create group message.
		if (nonhostcontext.dpnidGroup == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get create group message!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create group)

		nonhostcontext.fAsyncOpCanComplete = FALSE;
		nonhostcontext.fAsyncOpCompleted = FALSE;
		SAFE_CLOSEHANDLE(nonhostcontext.hAsyncOpCompletedEvent);

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for group to be created on host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hostcontext.hGotGroupMsgEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird create group indications.
		hostcontext.fCanGetCreateGroup = FALSE;

#ifdef DEBUG
		// Make sure we got the indication (how else would we get here?).
		if (hostcontext.dpnidGroup == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get create group indication!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (didn't get create group indication)
#endif // DEBUG

		// Reset the context.
		SAFE_CLOSEHANDLE(hostcontext.hGotGroupMsgEvent);

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Adding self player to group asynchronously");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		SAFE_CLOSEHANDLE(hAsyncOpComplete);
		CREATEEVENT_OR_THROW(hAsyncOpComplete, NULL, FALSE, FALSE, NULL);

		// Expect the add player to group message on the host and client.
		hostcontext.dpnidExpectedPlayer = hostcontext.dpnidClient;
		hostcontext.pvExpectedPlayerContext = &(hostcontext.dpnidClient);
		CREATEEVENT_OR_THROW(hostcontext.hGotGroupMsgEvent, NULL, FALSE, FALSE, NULL);
		hostcontext.fCanGetAddToGroup = TRUE;

		nonhostcontext.dpnidExpectedPlayer = nonhostcontext.dpnidClient;
		nonhostcontext.pvExpectedPlayerContext = &(nonhostcontext.dpnidClient);
		nonhostcontext.fCanGetAddToGroup = TRUE;

		// Now that we're completing asynchronously, need to be ready for ASYNC_OP_COMPLETE message
		nonhostcontext.fAsyncOpCanComplete = TRUE;
		nonhostcontext.fAsyncOpCompleted = FALSE;
		SAFE_CLOSEHANDLE(nonhostcontext.hAsyncOpCompletedEvent);
		CREATEEVENT_OR_THROW(nonhostcontext.hAsyncOpCompletedEvent, NULL, FALSE, FALSE, NULL);

		tr = pDP8Peer->DP8P_AddPlayerToGroup(nonhostcontext.dpnidGroup,
											nonhostcontext.dpnidClient,
											hAsyncOpComplete,
											&hAsyncOp,
											0);

		
		if((tr != DPNSUCCESS_PENDING) && (tr != DPN_OK))
		{
			DPTEST_FAIL(hLog, "Adding self player to group synchronously failed! (error 0x%08x)", 1, tr);
			THROW_TESTRESULT;
		} // end if (couldn't create group)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for self player to be added to group asynchronously");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hAsyncOpComplete))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird add player to group messages.
		nonhostcontext.fCanGetAddToGroup = FALSE;

		// Make sure we got the add to group message.
		if (! nonhostcontext.fGotAddToGroup)
		{
			DPTEST_FAIL(hLog, "Didn't get add player to group message!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get add player to group)

		// Reset the context.
		nonhostcontext.fGotAddToGroup = FALSE;

		nonhostcontext.fAsyncOpCanComplete = FALSE;
		nonhostcontext.fAsyncOpCompleted = FALSE;

		SAFE_CLOSEHANDLE(nonhostcontext.hAsyncOpCompletedEvent);

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for add player to group to be indicated on host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hostcontext.hGotGroupMsgEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird add to group indications.
		hostcontext.fCanGetAddToGroup = FALSE;


#ifdef DEBUG
		// Make sure we got the indication (how else would we get here?).
		if (! hostcontext.fGotAddToGroup)
		{
			DPTEST_FAIL(hLog, "Didn't get add to group indication!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (didn't get add to group indication)
#endif // DEBUG

		// Reset the context.
		CloseHandle(hostcontext.hGotGroupMsgEvent);
		hostcontext.hGotGroupMsgEvent = NULL;
		hostcontext.fGotAddToGroup = FALSE;






		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Removing self player from group on client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dpnhRemovePlayer = (DPNHANDLE) 0x666;

		// Expect the remove player from group message on the host.
		hostcontext.dpnidExpectedPlayer = hostcontext.dpnidClient;
		hostcontext.pvExpectedPlayerContext = &(hostcontext.dpnidClient);
		hostcontext.fCanGetRemoveFromGroup = TRUE;
		CREATEEVENT_OR_THROW(hostcontext.hGotGroupMsgEvent,
							NULL, FALSE, FALSE, NULL);

		// Expect the remove player from group message and async op completion on the client.
		nonhostcontext.dpnidExpectedPlayer = nonhostcontext.dpnidClient;
		nonhostcontext.pvExpectedPlayerContext = &(nonhostcontext.dpnidClient);
		nonhostcontext.fCanGetRemoveFromGroup = TRUE;
		CREATEEVENT_OR_THROW(nonhostcontext.hAsyncOpCompletedEvent,
							NULL, FALSE, FALSE, NULL);
		nonhostcontext.fAsyncOpCanComplete = TRUE;

		tr = pDP8Peer->DP8P_RemovePlayerFromGroup(nonhostcontext.dpnidGroup,
													nonhostcontext.dpnidClient,
													NULL,
													&dpnhRemovePlayer,
													0);
		if (tr != (HRESULT) DPNSUCCESS_PENDING)
		{
			DPTEST_FAIL(hLog, "Removing self player from group on client didn't return expected PENDING sucess code!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't remove player from group)

		if (dpnhRemovePlayer == (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "No async operation handle was returned!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (handle was not set)

		if (dpnhRemovePlayer == NULL)
		{
			DPTEST_FAIL(hLog, "Async operation handle returned is NULL!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (handle was set to NULL)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for async op to complete on client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, nonhostcontext.hAsyncOpCompletedEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// The add player to group message should have arrived by now.
		nonhostcontext.fCanGetAddToGroup = FALSE;

		// Prevent any weird async op completions.
		nonhostcontext.fAsyncOpCanComplete = FALSE;


#ifdef DEBUG
		// Make sure we got the indication (how else would we get here?).
		if (! nonhostcontext.fAsyncOpCompleted)
		{
			DPTEST_FAIL(hLog, "Didn't get async op completion!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (didn't get async op completion)
#endif // DEBUG

		// Make sure the completion indicated the same op handle that we were
		// returned.
		if (nonhostcontext.dpnhCompletedAsyncOp != dpnhRemovePlayer)
		{
			DPTEST_FAIL(hLog, "Remove player completed with different async op handle (%x != %x)!",
				2, nonhostcontext.dpnhCompletedAsyncOp, dpnhRemovePlayer);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (async op handle is wrong)

		// Reset the context.
		nonhostcontext.fAsyncOpCompleted = FALSE;
		CloseHandle(nonhostcontext.hAsyncOpCompletedEvent);
		nonhostcontext.hAsyncOpCompletedEvent = NULL;


		// Make sure we got the remove from group message.
		if (! nonhostcontext.fGotRemoveFromGroup)
		{
			DPTEST_FAIL(hLog, "Didn't get remove player from group message on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get remove player from group)

		// Reset the context.
		nonhostcontext.fGotRemoveFromGroup = FALSE;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for remove player from group to be indicated on host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hostcontext.hGotGroupMsgEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird remove from group indications.
		hostcontext.fCanGetRemoveFromGroup = FALSE;


#ifdef DEBUG
		// Make sure we got the indication (how else would we get here?).
		if (! hostcontext.fGotRemoveFromGroup)
		{
			DPTEST_FAIL(hLog, "Didn't get remove from group indication!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (didn't get remove from group indication)
#endif // DEBUG

		// Reset the context.
		CloseHandle(hostcontext.hGotGroupMsgEvent);
		hostcontext.hGotGroupMsgEvent = NULL;
		hostcontext.fGotRemoveFromGroup = FALSE;






/* XBOX - SYNC operations not supported
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Adding host player to group synchronously on client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Expect the add player to group message on the host and client.
		hostcontext.dpnidExpectedPlayer = hostcontext.dpnidHost;
		hostcontext.pvExpectedPlayerContext = &(hostcontext.dpnidHost);
		CREATEEVENT_OR_THROW(hostcontext.hGotGroupMsgEvent,
							NULL, FALSE, FALSE, NULL);
		hostcontext.fCanGetAddToGroup = TRUE;

		nonhostcontext.dpnidExpectedPlayer = nonhostcontext.dpnidHost;
		nonhostcontext.pvExpectedPlayerContext = &(nonhostcontext.dpnidHost);
		nonhostcontext.fCanGetAddToGroup = TRUE;

		tr = pDP8Peer->DP8P_AddPlayerToGroup(nonhostcontext.dpnidGroup,
											nonhostcontext.dpnidHost,
											NULL,
											NULL,
											DPNADDPLAYERTOGROUP_SYNC);

		// Prevent any weird add player to group messages.
		nonhostcontext.fCanGetAddToGroup = FALSE;
		
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Adding host player to group synchronously on client failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't add player to group)

		// Make sure we got the add to group message.
		if (! nonhostcontext.fGotAddToGroup)
		{
			DPTEST_FAIL(hLog, "Didn't get add player to group message!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get add player to group)

		// Reset the context.
		nonhostcontext.fGotAddToGroup = FALSE;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for add player to group to be indicated on host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hostcontext.hGotGroupMsgEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird add to group indications.
		hostcontext.fCanGetAddToGroup = FALSE;


#ifdef DEBUG
		// Make sure we got the indication (how else would we get here?).
		if (! hostcontext.fGotAddToGroup)
		{
			DPTEST_FAIL(hLog, "Didn't get add to group indication!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (didn't get add to group indication)
#endif // DEBUG

		// Reset the context.
		CloseHandle(hostcontext.hGotGroupMsgEvent);
		hostcontext.hGotGroupMsgEvent = NULL;
		hostcontext.fGotAddToGroup = FALSE;






		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Removing host player from group synchronously on client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Expect the remove player from group message on the host and client.
		hostcontext.dpnidExpectedPlayer = hostcontext.dpnidHost;
		hostcontext.pvExpectedPlayerContext = &(hostcontext.dpnidHost);
		CREATEEVENT_OR_THROW(hostcontext.hGotGroupMsgEvent,
							NULL, FALSE, FALSE, NULL);
		hostcontext.fCanGetRemoveFromGroup = TRUE;

		nonhostcontext.dpnidExpectedPlayer = nonhostcontext.dpnidHost;
		nonhostcontext.pvExpectedPlayerContext = &(nonhostcontext.dpnidHost);
		nonhostcontext.fCanGetRemoveFromGroup = TRUE;

		tr = pDP8Peer->DP8P_RemovePlayerFromGroup(nonhostcontext.dpnidGroup,
												nonhostcontext.dpnidHost,
												NULL,
												NULL,
												DPNADDPLAYERTOGROUP_SYNC);

		// Prevent any weird remove player from group messages.
		nonhostcontext.fCanGetRemoveFromGroup = FALSE;
		
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Removing host player from group synchronously on client failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't remove player from group)

		// Make sure we got the remove from group message.
		if (! nonhostcontext.fGotRemoveFromGroup)
		{
			DPTEST_FAIL(hLog, "Didn't get remove player from group message!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get remove player from group)

		// Reset the context.
		nonhostcontext.fGotRemoveFromGroup = FALSE;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for remove player from group to be indicated on host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hostcontext.hGotGroupMsgEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird remove from group indications.
		hostcontext.fCanGetRemoveFromGroup = FALSE;


#ifdef DEBUG
		// Make sure we got the indication (how else would we get here?).
		if (! hostcontext.fGotRemoveFromGroup)
		{
			DPTEST_FAIL(hLog, "Didn't get remove from group indication!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (didn't get remove from group indication)
#endif // DEBUG

		// Reset the context.
		CloseHandle(hostcontext.hGotGroupMsgEvent);
		hostcontext.hGotGroupMsgEvent = NULL;
		hostcontext.fGotRemoveFromGroup = FALSE;

*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing peer client object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing peer client object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure we got the destroy player messages.
		if (nonhostcontext.dpnidHost != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for host on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)

		if (nonhostcontext.dpnidClient != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for client on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)


		// Technically we should wait to make sure the host saw the client go away
		// as expected but that's more hassle than it's worth.  Just make sure he's
		// gone after Close() has returned.



#pragma TODO(vanceo, "Validate destroy group nametable unwind on both interfaces")


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing host object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8PeerHost->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing host object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure we got the destroy player messages.
		if (hostcontext.dpnidHost != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for host on host!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)

		if (hostcontext.dpnidClient != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for client on host!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing hosting DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8PeerHost->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release hosting DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8PeerHost);
		pDP8PeerHost = NULL;





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Peer);
		pDP8Peer = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE


	if (pDP8Peer != NULL)
	{
		delete (pDP8Peer);
		pDP8Peer = NULL;
	} // end if (have peer object)

	if (pDP8PeerHost != NULL)
	{
		delete (pDP8PeerHost);
		pDP8PeerHost = NULL;
	} // end if (have peer object)

	SAFE_RELEASE(pDP8Address);
	SAFE_CLOSEHANDLE(hostcontext.hGotGroupMsgEvent);
	SAFE_CLOSEHANDLE(nonhostcontext.hGotGroupMsgEvent);
	SAFE_CLOSEHANDLE(hostcontext.hAsyncOpCompletedEvent);
	SAFE_CLOSEHANDLE(nonhostcontext.hAsyncOpCompletedEvent);
	SAFE_CLOSEHANDLE(hostcontext.hClientCreatedEvent);
	ClearDoWorkList(&DoWorkList);
	SAFE_CLOSEHANDLE(hAsyncOpComplete);

	return (sr);
} // ParmVPeerExec_RemoveFromGroup
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVPeerExec_SetGroupInfo()"
//==================================================================================
// ParmVPeerExec_SetGroupInfo
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.1.15 - Peer SetGroupInfo parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVPeerExec_SetGroupInfo(HANDLE hLog)
{
	CTNSystemResult				sr;
	CTNTestResult				tr;
	PWRAPDP8PEER				pDP8Peer = NULL;
	PWRAPDP8PEER				pDP8PeerHost = NULL;
	PDIRECTPLAY8ADDRESS			pDP8Address = NULL;
	PARMVPSETGROUPINFOCONTEXT	hostcontext;
	PARMVPSETGROUPINFOCONTEXT	nonhostcontext;
	DPN_APPLICATION_DESC		dpnad;
	DPN_APPLICATION_DESC		dpnadCompare;
	DPN_GROUP_INFO				dpngi;
	DPN_GROUP_INFO				dpngiCompare;
	DPNHANDLE					dpnhSetGroupInfo;
	DP_DOWORKLIST				DoWorkList;
	DPNHANDLE					hAsyncOp;
	HANDLE						hAsyncOpComplete = NULL;

	ZeroMemory(&DoWorkList, sizeof(DP_DOWORKLIST));
	ZeroMemory(&hostcontext, sizeof (PARMVPSETGROUPINFOCONTEXT));
	hostcontext.fHost = TRUE;

	ZeroMemory(&nonhostcontext, sizeof (PARMVPSETGROUPINFOCONTEXT));
	//nonhostcontext.fHost = FALSE;


	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Peer = new CWrapDP8Peer(hLog);
		if (pDP8Peer == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8Peer->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (LPVOID *) &pDP8Address, NULL);
		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't create DirectPlay8Address object!", 0);
			THROW_SYSTEMRESULT;
		} // end if (create failed)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting address object's SP to TCP/IP");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->SetSP(&CLSID_DP8SP_TCPIP);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting address object's SP to TCP/IP failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set SP)





/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting group 0 (DPNID_ALL_PLAYERS_GROUP) info with all NULLs and 0s using C++ macro");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = IDirectPlay8Peer_SetGroupInfo(pDP8Peer->m_pDP8Peer, 0, NULL, NULL,
											NULL, 0);
		if (tr != DPNERR_INVALIDGROUP)
		{
			DPTEST_FAIL(hLog, "Setting group 0 (DPNID_ALL_PLAYERS_GROUP) info with all NULLs and 0s using C++ macro didn't return expected error INVALIDGROUP!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set group info)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting group 0 (DPNID_ALL_PLAYERS_GROUP) info with all NULLs and 0s");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_SetGroupInfo(0, NULL, NULL, NULL, 0);
		if (tr != DPNERR_INVALIDGROUP)
		{
			DPTEST_FAIL(hLog, "Setting group 0 (DPNID_ALL_PLAYERS_GROUP) info with all NULLs and 0s didn't return expected error INVALIDGROUP!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set group info)
*/

		dpnhSetGroupInfo = (DPNHANDLE) 0x666;

/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting group info with NULL info");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Use 0x666 to avoid DPlay's group ID == 0 check.
		tr = pDP8Peer->DP8P_SetGroupInfo((DPNID) 0x666, NULL, NULL,
										&dpnhSetGroupInfo, 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Setting group info with NULL info didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set group info)

		if (dpnhSetGroupInfo != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async handle was modified (%x != 0x666)!",
				1, dpnhSetGroupInfo);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (handle was set)
*/

		ZeroMemory(&dpngi, sizeof (DPN_GROUP_INFO));
		dpngi.dwSize = sizeof (DPN_GROUP_INFO);
		//dpngi.dwInfoFlags = 0;
		//dpngi.pwszName = NULL;
		//dpngi.pvData = NULL;
		//dpngi.dwDataSize = 0;
		//dpngi.dwGroupFlags = 0;

		CopyMemory(&dpngiCompare, &dpngi, sizeof (DPN_GROUP_INFO));

/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting group info with invalid flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_SetGroupInfo((DPNID) 0x666, &dpngi, NULL,
										&dpnhSetGroupInfo, 0x666);
		if (tr != DPNERR_INVALIDFLAGS)
		{
			DPTEST_FAIL(hLog, "Setting group info with invalid flags didn't return expected error INVALIDFLAGS!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set group info)

		if (memcmp(&dpngiCompare, &dpngi, sizeof (DPN_GROUP_INFO)) != 0)
		{
			DPTEST_FAIL(hLog, "Group info structure was modified (structure at %x != structure at %x)!",
				2, &dpngiCompare, &dpngi);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (group info changed)

		if (dpnhSetGroupInfo != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async handle was modified (%x != 0x666)!",
				1, dpnhSetGroupInfo);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (handle was set)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting group info before initialization");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_SetGroupInfo((DPNID) 0x666, &dpngi, NULL,
										&dpnhSetGroupInfo, 0);
		if (tr != DPNERR_UNINITIALIZED)
		{
			DPTEST_FAIL(hLog, "Setting group info before initialization didn't return expected error UNINITIALIZED!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set group info)

		if (memcmp(&dpngiCompare, &dpngi, sizeof (DPN_GROUP_INFO)) != 0)
		{
			DPTEST_FAIL(hLog, "Group info structure was modified (structure at %x != structure at %x)!",
				2, &dpngiCompare, &dpngi);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (group info changed)

		if (dpnhSetGroupInfo != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async handle was modified (%x != 0x666)!",
				1, dpnhSetGroupInfo);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (handle was set)
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Initializing peer object with host context");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		hostcontext.hLog = hLog;

		tr = pDP8Peer->DP8P_Initialize(&hostcontext,
										ParmVPSetGroupInfoDPNMessageHandler, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Initializing peer object with host context failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting group info without a connection");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_SetGroupInfo((DPNID) 0x666, &dpngi, NULL,
										&dpnhSetGroupInfo, 0);
		if (tr != DPNERR_NOCONNECTION)
		{
			DPTEST_FAIL(hLog, "Setting group info without a connection didn't return expected error NOCONNECTION!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set group info)

		if (memcmp(&dpngiCompare, &dpngi, sizeof (DPN_GROUP_INFO)) != 0)
		{
			DPTEST_FAIL(hLog, "Group info structure was modified (structure at %x != structure at %x)!",
				2, &dpngiCompare, &dpngi);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (group info changed)

		if (dpnhSetGroupInfo != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async handle was modified (%x != 0x666)!",
				1, dpnhSetGroupInfo);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (handle was set)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Hosting session");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		//dpnad.dwFlags = 0;
		//dpnad.guidInstance = GUID_NULL;
		dpnad.guidApplication = GUID_PARMV_PEER_GETAPPDESC;
		//dpnad.dwMaxPlayers = 0;
		//dpnad.dwCurrentPlayers = 0;
		//dpnad.pwszSessionName = NULL;
		//dpnad.pwszPassword = NULL;
		//dpnad.pvReservedData = NULL;
		//dpnad.dwReservedDataSize = 0;
		//dpnad.pvApplicationReservedData = NULL;
		//dpnad.dwApplicationReservedDataSize = 0;

		// Save what we're passing in to make sure it's not touched.
		CopyMemory(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC));

		tr = pDP8Peer->DP8P_Host(&dpnad,
								&pDP8Address,
								1,
								NULL,
								NULL,
								&(hostcontext.dpnidHost),
								0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't start hosting session!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't host)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		// Make sure we got the create player message.
		if (hostcontext.dpnidHost == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting group info for invalid group");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_SetGroupInfo((DPNID) 0x666, &dpngi, NULL,
										&dpnhSetGroupInfo, 0);
		if (tr != DPNERR_INVALIDGROUP)
		{
			DPTEST_FAIL(hLog, "Setting group info for invalid group didn't return expected error INVALIDGROUP!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set group info)

		if (memcmp(&dpngiCompare, &dpngi, sizeof (DPN_GROUP_INFO)) != 0)
		{
			DPTEST_FAIL(hLog, "Group info structure was modified (structure at %x != structure at %x)!",
				2, &dpngiCompare, &dpngi);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (group info changed)

		if (dpnhSetGroupInfo != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async handle was modified (%x != 0x666)!",
				1, dpnhSetGroupInfo);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (handle was set)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating group on client asynchronously");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		SAFE_CLOSEHANDLE(hAsyncOpComplete);
		CREATEEVENT_OR_THROW(hAsyncOpComplete, NULL, FALSE, FALSE, NULL);

		// Expect the create group message.
		//hostcontext.dpnidExpectedGroupOwner = 0;
		hostcontext.fCanGetCreateGroup = TRUE;

		// Now that we're completing asynchronously, need to be ready for ASYNC_OP_COMPLETE message
		hostcontext.fAsyncOpCanComplete = TRUE;
		hostcontext.fAsyncOpCompleted = FALSE;
		SAFE_CLOSEHANDLE(hostcontext.hAsyncOpCompletedEvent);
		CREATEEVENT_OR_THROW(hostcontext.hAsyncOpCompletedEvent, NULL, FALSE, FALSE, NULL);

		tr = pDP8Peer->DP8P_CreateGroup(&dpngi, NULL, hAsyncOpComplete, &hAsyncOp, 0);

		if((tr != DPNSUCCESS_PENDING) && (tr != DPN_OK))
		{
			DPTEST_FAIL(hLog, "Creating group failed! (error 0x%08x)", 1, tr);
			THROW_TESTRESULT;
		} // end if (couldn't create group)

		if (memcmp(&dpngiCompare, &dpngi, sizeof (DPN_GROUP_INFO)) != 0)
		{
			DPTEST_FAIL(hLog, "Group info structure was modified (structure at %x != structure at %x)!",
				2, &dpngiCompare, &dpngi);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (group info changed)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for group to be created asynchronously");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 1;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hAsyncOpComplete))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird create groups.
		hostcontext.fCanGetCreateGroup = FALSE;

		// Make sure we got the create group message.
		if (hostcontext.dpnidGroup == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get create group message!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create group)

		hostcontext.fAsyncOpCanComplete = TRUE;
		hostcontext.fAsyncOpCompleted = FALSE;
		SAFE_CLOSEHANDLE(hostcontext.hAsyncOpCompletedEvent);

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting group info");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Expect the group info message and async op completion.
		hostcontext.fCanGetGroupInfo = TRUE;
		CREATEEVENT_OR_THROW(hostcontext.hAsyncOpCompletedEvent,
							NULL, FALSE, FALSE, NULL);
		hostcontext.fAsyncOpCanComplete = TRUE;

		tr = pDP8Peer->DP8P_SetGroupInfo(hostcontext.dpnidGroup, &dpngi, NULL,
										&dpnhSetGroupInfo, 0);
		if (tr != (HRESULT) DPNSUCCESS_PENDING)
		{
			DPTEST_FAIL(hLog, "Setting group info didn't return expected PENDING success code!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set group info)

		if (memcmp(&dpngiCompare, &dpngi, sizeof (DPN_GROUP_INFO)) != 0)
		{
			DPTEST_FAIL(hLog, "Group info structure was modified (structure at %x != structure at %x)!",
				2, &dpngiCompare, &dpngi);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (group info changed)

		if (dpnhSetGroupInfo == (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "No async operation handle was returned!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (handle was not set)

		if (dpnhSetGroupInfo == NULL)
		{
			DPTEST_FAIL(hLog, "Async operation handle returned is NULL!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (handle was set to NULL)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for async op to complete");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 1;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hostcontext.hAsyncOpCompletedEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// The remove player from group message should have arrived by now.
		hostcontext.fCanGetGroupInfo = FALSE;

		// Prevent any weird async op completions.
		hostcontext.fAsyncOpCanComplete = FALSE;


#ifdef DEBUG
		// Make sure we got the indication (how else would we get here?).
		if (! hostcontext.fAsyncOpCompleted)
		{
			DPTEST_FAIL(hLog, "Didn't get async op completion!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (didn't get async op completion)
#endif // DEBUG

		// Make sure the completion indicated the same op handle that we were
		// returned.
		if (hostcontext.dpnhCompletedAsyncOp != dpnhSetGroupInfo)
		{
			DPTEST_FAIL(hLog, "Set group info completed with different async op handle (%x != %x)!",
				2, hostcontext.dpnhCompletedAsyncOp, dpnhSetGroupInfo);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (async op handle is wrong)


		// Reset the context.
		hostcontext.fAsyncOpCompleted = FALSE;
		CloseHandle(hostcontext.hAsyncOpCompletedEvent);
		hostcontext.hAsyncOpCompletedEvent = NULL;


		// Make sure we got the group info message.
		if (! hostcontext.fGotGroupInfo)
		{
			DPTEST_FAIL(hLog, "Didn't get group info message!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get group info)

		// Reset the context.
		hostcontext.fGotGroupInfo = FALSE;





/* XBOX - SYNC operations not supported
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting group info synchronously");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Expect the add player to group message.
		hostcontext.fCanGetGroupInfo = TRUE;

		tr = pDP8Peer->DP8P_SetGroupInfo(hostcontext.dpnidGroup, &dpngi, NULL,
										NULL, DPNADDPLAYERTOGROUP_SYNC);

		// Prevent any weird group info messages.
		hostcontext.fCanGetGroupInfo = FALSE;
		
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting group info synchronously failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set group info)

		// Make sure we got the group info message.
		if (! hostcontext.fGotGroupInfo)
		{
			DPTEST_FAIL(hLog, "Didn't get group info message!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get group info)

		// Reset the context.
		hostcontext.fGotGroupInfo= FALSE;
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing peer object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure we got the destroy player message.
		if (hostcontext.dpnidHost != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)

#pragma TODO(vanceo, "Validate destroy group nametable unwind")

		// Reset group ID.
		hostcontext.dpnidGroup = 0;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Re-initializing peer object with nonhost context");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		nonhostcontext.hLog = hLog;

		tr = pDP8Peer->DP8P_Initialize(&nonhostcontext,
										ParmVPSetGroupInfoDPNMessageHandler,
										0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Re-initializing peer object with context, 0 flags failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating new peer host object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Address->Release();
		pDP8Address = NULL;

		hostcontext.hLog = hLog;

		tr = ParmVCreatePeerHost(hLog, ParmVPSetGroupInfoDPNMessageHandler,
								&hostcontext,
								&dpnad,
								&(hostcontext.dpnidHost),
								&pDP8PeerHost,
								&pDP8Address);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Creating peer host failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't create peer host)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Connecting peer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

// XBOX - Had to make connection asynchronous

		// Host should get the create player now.
		CREATEEVENT_OR_THROW(hostcontext.hClientCreatedEvent, NULL, FALSE, FALSE, NULL);
		SAFE_CLOSEHANDLE(hAsyncOpComplete);
		CREATEEVENT_OR_THROW(hAsyncOpComplete, NULL, FALSE, FALSE, NULL);

		// Even though it's synchronous, we'll still get a completion.  The async op
		// handle will be NULL, though.
		nonhostcontext.fConnectCanComplete = TRUE;

		tr = pDP8Peer->DP8P_Connect(&dpnad,
									pDP8Address,
									NULL,
									NULL,
									NULL,
									NULL,
									0,
									&(nonhostcontext.dpnidClient),
									hAsyncOpComplete,
									&hAsyncOp,
									0);

		if((tr != DPNSUCCESS_PENDING) && (tr != DPN_OK))
		{
			DPTEST_FAIL(hLog, "Couldn't connect! (error 0x%08x)", 1, tr);
			THROW_TESTRESULT;
		} // end if (couldn't connect)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for connect to complete on non-host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hAsyncOpComplete))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird connects from completing.
		nonhostcontext.fConnectCanComplete = FALSE;

		// Make sure we saw the connect completion indication.
		if (! nonhostcontext.fConnectCompleted)
		{
			DPTEST_FAIL(hLog, "Didn't get connect complete indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (connect didn't complete)

		// Reset the context.
		nonhostcontext.fConnectCompleted = FALSE;

		// Make sure we got the create player messages.
		if (nonhostcontext.dpnidHost == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication for host on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player)

		if (nonhostcontext.dpnidClient == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication for client on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for create player to be indicated on host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hostcontext.hClientCreatedEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating group on client asynchronously");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		SAFE_CLOSEHANDLE(hAsyncOpComplete);
		CREATEEVENT_OR_THROW(hAsyncOpComplete, NULL, FALSE, FALSE, NULL);

		SAFE_CLOSEHANDLE(hostcontext.hGotGroupMsgEvent);
		CREATEEVENT_OR_THROW(hostcontext.hGotGroupMsgEvent, NULL, FALSE, FALSE, NULL);
		hostcontext.fCanGetCreateGroup = TRUE;

		// Expect the create group message on the client.
		//nonhostcontext.dpnidExpectedGroupOwner = 0;
		nonhostcontext.fCanGetCreateGroup = TRUE;

		// Now that we're completing asynchronously, need to be ready for ASYNC_OP_COMPLETE message
		nonhostcontext.fAsyncOpCanComplete = TRUE;
		nonhostcontext.fAsyncOpCompleted = FALSE;
		SAFE_CLOSEHANDLE(nonhostcontext.hAsyncOpCompletedEvent);
		CREATEEVENT_OR_THROW(nonhostcontext.hAsyncOpCompletedEvent, NULL, FALSE, FALSE, NULL);

		tr = pDP8Peer->DP8P_CreateGroup(&dpngi, NULL, hAsyncOpComplete, &hAsyncOp, 0);

		if((tr != DPNSUCCESS_PENDING) && (tr != DPN_OK))
		{
			DPTEST_FAIL(hLog, "Creating group failed! (error 0x%08x)", 1, tr);
			THROW_TESTRESULT;
		} // end if (couldn't create group)

		if (memcmp(&dpngiCompare, &dpngi, sizeof (DPN_GROUP_INFO)) != 0)
		{
			DPTEST_FAIL(hLog, "Group info structure was modified (structure at %x != structure at %x)!",
				2, &dpngiCompare, &dpngi);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (group info changed)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for group to be created asynchronously");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hAsyncOpComplete))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird create groups.
		nonhostcontext.fCanGetCreateGroup = FALSE;

		// Make sure we got the create group message.
		if (nonhostcontext.dpnidGroup == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get create group message!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create group)

		nonhostcontext.fAsyncOpCanComplete = FALSE;
		nonhostcontext.fAsyncOpCompleted = FALSE;
		SAFE_CLOSEHANDLE(nonhostcontext.hAsyncOpCompletedEvent);

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for group to be created on host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hostcontext.hGotGroupMsgEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird create group indications.
		hostcontext.fCanGetCreateGroup = FALSE;

#ifdef DEBUG
		// Make sure we got the indication (how else would we get here?).
		if (hostcontext.dpnidGroup == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get create group indication!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (didn't get create group indication)
#endif // DEBUG

		// Reset the context.
		CloseHandle(hostcontext.hGotGroupMsgEvent);
		hostcontext.hGotGroupMsgEvent = NULL;





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting group info on client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dpnhSetGroupInfo = (DPNHANDLE) 0x666;

		// Expect the group info message on the host.
		hostcontext.fCanGetGroupInfo = TRUE;
		CREATEEVENT_OR_THROW(hostcontext.hGotGroupMsgEvent,
							NULL, FALSE, FALSE, NULL);

		// Expect the group info message and async op completion on the client.
		nonhostcontext.fCanGetGroupInfo = TRUE;
		CREATEEVENT_OR_THROW(nonhostcontext.hAsyncOpCompletedEvent,
							NULL, FALSE, FALSE, NULL);
		nonhostcontext.fAsyncOpCanComplete = TRUE;

		tr = pDP8Peer->DP8P_SetGroupInfo(nonhostcontext.dpnidGroup, &dpngi, NULL,
										&dpnhSetGroupInfo, 0);
		if (tr != (HRESULT) DPNSUCCESS_PENDING)
		{
			DPTEST_FAIL(hLog, "Setting group info on client didn't return expected PENDING success code!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set group info)

		if (dpnhSetGroupInfo == (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "No async operation handle was returned!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (handle was not set)

		if (dpnhSetGroupInfo == NULL)
		{
			DPTEST_FAIL(hLog, "Async operation handle returned is NULL!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (handle was set to NULL)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for async op to complete on client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, nonhostcontext.hAsyncOpCompletedEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// The group info message should have arrived by now.
		nonhostcontext.fCanGetGroupInfo = FALSE;

		// Prevent any weird async op completions.
		nonhostcontext.fAsyncOpCanComplete = FALSE;


#ifdef DEBUG
		// Make sure we got the indication (how else would we get here?).
		if (! nonhostcontext.fAsyncOpCompleted)
		{
			DPTEST_FAIL(hLog, "Didn't get async op completion!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (didn't get async op completion)
#endif // DEBUG

		// Make sure the completion indicated the same op handle that we were
		// returned.
		if (nonhostcontext.dpnhCompletedAsyncOp != dpnhSetGroupInfo)
		{
			DPTEST_FAIL(hLog, "Set group info completed with different async op handle (%x != %x)!",
				2, nonhostcontext.dpnhCompletedAsyncOp, dpnhSetGroupInfo);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (async op handle is wrong)

		// Reset the context.
		nonhostcontext.fAsyncOpCompleted = FALSE;
		CloseHandle(nonhostcontext.hAsyncOpCompletedEvent);
		nonhostcontext.hAsyncOpCompletedEvent = NULL;


		// Make sure we got the group info message.
		if (! nonhostcontext.fGotGroupInfo)
		{
			DPTEST_FAIL(hLog, "Didn't get group info message on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get group info)

		// Reset the context.
		nonhostcontext.fGotGroupInfo = FALSE;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for group info to be indicated on host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hostcontext.hGotGroupMsgEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird group info indications.
		hostcontext.fCanGetGroupInfo = FALSE;


#ifdef DEBUG
		// Make sure we got the indication (how else would we get here?).
		if (! hostcontext.fGotGroupInfo)
		{
			DPTEST_FAIL(hLog, "Didn't get group info indication!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (didn't get group info indication)
#endif // DEBUG

		// Reset the context.
		CloseHandle(hostcontext.hGotGroupMsgEvent);
		hostcontext.hGotGroupMsgEvent = NULL;
		hostcontext.fGotGroupInfo = FALSE;






		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing peer client object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing peer client object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure we got the destroy player messages.
		if (nonhostcontext.dpnidHost != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for host on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)

		if (nonhostcontext.dpnidClient != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for client on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)


		// Technically we should wait to make sure the host saw the client go away
		// as expected but that's more hassle than it's worth.  Just make sure he's
		// gone after Close() has returned.



#pragma TODO(vanceo, "Validate destroy group nametable unwind on both interfaces")


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing host object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8PeerHost->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing host object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure we got the destroy player messages.
		if (hostcontext.dpnidHost != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for host on host!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)

		if (hostcontext.dpnidClient != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for client on host!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing hosting DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8PeerHost->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release hosting DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8PeerHost);
		pDP8PeerHost = NULL;





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Peer);
		pDP8Peer = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE


	if (pDP8Peer != NULL)
	{
		delete (pDP8Peer);
		pDP8Peer = NULL;
	} // end if (have peer object)

	if (pDP8PeerHost != NULL)
	{
		delete (pDP8PeerHost);
		pDP8PeerHost = NULL;
	} // end if (have peer object)

	SAFE_RELEASE(pDP8Address);
	SAFE_CLOSEHANDLE(hostcontext.hAsyncOpCompletedEvent);
	SAFE_CLOSEHANDLE(nonhostcontext.hAsyncOpCompletedEvent);
	SAFE_CLOSEHANDLE(hostcontext.hClientCreatedEvent);
	ClearDoWorkList(&DoWorkList);
	SAFE_CLOSEHANDLE(hAsyncOpComplete);

	return (sr);
} // ParmVPeerExec_SetGroupInfo
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVPeerExec_GetGroupInfo()"
//==================================================================================
// ParmVPeerExec_GetGroupInfo
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.1.16 - Peer GetGroupInfo parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVPeerExec_GetGroupInfo(HANDLE hLog)
{
	CTNSystemResult				sr;
	CTNTestResult				tr;
	PWRAPDP8PEER				pDP8Peer = NULL;
	PWRAPDP8PEER				pDP8PeerHost = NULL;
	PDIRECTPLAY8ADDRESS			pDP8Address = NULL;
	PARMVPGETGROUPINFOCONTEXT	hostcontext;
	PARMVPGETGROUPINFOCONTEXT	nonhostcontext;
	DPN_APPLICATION_DESC		dpnad;
	DPN_APPLICATION_DESC		dpnadCompare;
	DPN_GROUP_INFO				dpngi;
	DPN_GROUP_INFO				dpngiCompare;
	PDPN_GROUP_INFO				pdpngi = NULL;
	DWORD						dwSize;
	DWORD						dwExpectedSize;
	DP_DOWORKLIST				DoWorkList;
	DPNHANDLE					hAsyncOp;
	HANDLE						hAsyncOpComplete = NULL;

	ZeroMemory(&DoWorkList, sizeof(DP_DOWORKLIST));
	ZeroMemory(&hostcontext, sizeof (PARMVPGETGROUPINFOCONTEXT));
	hostcontext.fHost = TRUE;

	ZeroMemory(&nonhostcontext, sizeof (PARMVPGETGROUPINFOCONTEXT));
	//nonhostcontext.fHost = FALSE;


	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Peer = new CWrapDP8Peer(hLog);
		if (pDP8Peer == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8Peer->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (LPVOID *) &pDP8Address, NULL);
		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't create DirectPlay8Address object!", 0);
			THROW_SYSTEMRESULT;
		} // end if (create failed)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting address object's SP to TCP/IP");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->SetSP(&CLSID_DP8SP_TCPIP);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting address object's SP to TCP/IP failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set SP)





/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting group 0 (DPNID_ALL_PLAYERS_GROUP) info with all NULLs and 0s using C++ macro");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = IDirectPlay8Peer_GetGroupInfo(pDP8Peer->m_pDP8Peer, 0, NULL, NULL, 0);
		if (tr != DPNERR_INVALIDGROUP)
		{
			DPTEST_FAIL(hLog, "Getting group 0 (DPNID_ALL_PLAYERS_GROUP) info with all NULLs and 0s using C++ macro didn't return expected error INVALIDGROUP!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set group info)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting group 0 (DPNID_ALL_PLAYERS_GROUP) info with all NULLs and 0s");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_GetGroupInfo(0, NULL, NULL, 0);
		if (tr != DPNERR_INVALIDGROUP)
		{
			DPTEST_FAIL(hLog, "Getting group 0 (DPNID_ALL_PLAYERS_GROUP) info with all NULLs and 0s didn't return expected error INVALIDGROUP!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set group info)
*/




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting group info with NULL size");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Use 0x666 to avoid DPlay's group ID == 0 check.
		tr = pDP8Peer->DP8P_GetGroupInfo((DPNID) 0x666, NULL, NULL, 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Getting group info with NULL size didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get group info)
*/




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting group info with NULL buffer and non-zero size");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwSize = 666;

		tr = pDP8Peer->DP8P_GetGroupInfo((DPNID) 0x666, NULL, &dwSize, 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Getting group info with NULL buffer and non-zero size didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get group info)

		if (dwSize != 666)
		{
			DPTEST_FAIL(hLog, "Size was changed (%u != 666)!", 1, dwSize);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (size is not 0)
*/


		dwSize = 0;

/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting group info with invalid flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_GetGroupInfo((DPNID) 0x666, NULL, &dwSize, 0x666);
		if (tr != DPNERR_INVALIDFLAGS)
		{
			DPTEST_FAIL(hLog, "Getting group info with invalid flags didn't return expected error INVALIDFLAGS!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get group info)

		if (dwSize != 0)
		{
			DPTEST_FAIL(hLog, "Size was changed (%u != 0)!", 1, dwSize);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (size is not 0)
*/




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting group info before initialization");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_GetGroupInfo((DPNID) 0x666, NULL, &dwSize, 0);
		if (tr != DPNERR_UNINITIALIZED)
		{
			DPTEST_FAIL(hLog, "Getting group info before initialization didn't return expected error UNINITIALIZED!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get group info)

		if (dwSize != 0)
		{
			DPTEST_FAIL(hLog, "Size was changed (%u != 0)!", 1, dwSize);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (size is not 0)
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Initializing peer object with host context");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		hostcontext.hLog = hLog;

		tr = pDP8Peer->DP8P_Initialize(&hostcontext,
										ParmVPGetGroupInfoDPNMessageHandler, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Initializing peer object with host context failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting group info without a connection");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_GetGroupInfo((DPNID) 0x666, NULL, &dwSize, 0);
		if (tr != DPNERR_NOCONNECTION)
		{
			DPTEST_FAIL(hLog, "Getting group info without a connection didn't return expected error NOCONNECTION!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get group info)

		if (dwSize != 0)
		{
			DPTEST_FAIL(hLog, "Size was changed (%u != 0)!", 1, dwSize);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (size is not 0)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Hosting session");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		//dpnad.dwFlags = 0;
		//dpnad.guidInstance = GUID_NULL;
		dpnad.guidApplication = GUID_PARMV_PEER_GETAPPDESC;
		//dpnad.dwMaxPlayers = 0;
		//dpnad.dwCurrentPlayers = 0;
		//dpnad.pwszSessionName = NULL;
		//dpnad.pwszPassword = NULL;
		//dpnad.pvReservedData = NULL;
		//dpnad.dwReservedDataSize = 0;
		//dpnad.pvApplicationReservedData = NULL;
		//dpnad.dwApplicationReservedDataSize = 0;

		// Save what we're passing in to make sure it's not touched.
		CopyMemory(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC));

		tr = pDP8Peer->DP8P_Host(&dpnad,
								&pDP8Address,
								1,
								NULL,
								NULL,
								&(hostcontext.dpnidHost),
								0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't start hosting session!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't host)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		// Make sure we got the create player message.
		if (hostcontext.dpnidHost == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting group info for invalid group");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_GetGroupInfo((DPNID) 0x666, NULL, &dwSize, 0);
		if (tr != DPNERR_INVALIDGROUP)
		{
			DPTEST_FAIL(hLog, "Getting group info for invalid group didn't return expected error INVALIDGROUP!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get group info)

		if (dwSize != 0)
		{
			DPTEST_FAIL(hLog, "Size was changed (%u != 0)!", 1, dwSize);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (size is not 0)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating group on host asynchronously");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		SAFE_CLOSEHANDLE(hAsyncOpComplete);
		CREATEEVENT_OR_THROW(hAsyncOpComplete, NULL, FALSE, FALSE, NULL);

		ZeroMemory(&dpngi, sizeof (DPN_GROUP_INFO));
		dpngi.dwSize = sizeof (DPN_GROUP_INFO);
		dpngi.dwInfoFlags = DPNINFO_DATA;
		//dpngi.pwszName = NULL;
		dpngi.pvData = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
		dpngi.dwDataSize = strlen("ABCDEFGHIJKLMNOPQRSTUVWXYZ") + 1;
		//dpngi.dwGroupFlags = 0;

		CopyMemory(&dpngiCompare, &dpngi, sizeof (DPN_GROUP_INFO));


		// Expect the create group message.
		//hostcontext.dpnidExpectedGroupOwner = 0;
		hostcontext.fCanGetCreateGroup = TRUE;

		tr = pDP8Peer->DP8P_CreateGroup(&dpngi, NULL, hAsyncOpComplete, &hAsyncOp, 0);

		if((tr != DPNSUCCESS_PENDING) && (tr != DPN_OK))
		{
			DPTEST_FAIL(hLog, "Creating group failed! (error 0x%08x)", 1, tr);
			THROW_TESTRESULT;
		} // end if (couldn't create group)

		if (memcmp(&dpngiCompare, &dpngi, sizeof (DPN_GROUP_INFO)) != 0)
		{
			DPTEST_FAIL(hLog, "Group info structure was modified (structure at %x != structure at %x)!",
				2, &dpngiCompare, &dpngi);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (group info changed)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for group to be created asynchronously");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 1;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hAsyncOpComplete))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird create groups.
		hostcontext.fCanGetCreateGroup = FALSE;

		// Make sure we got the create group message.
		if (hostcontext.dpnidGroup == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get create group message!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create group)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting group info with NULL buffer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwExpectedSize = sizeof (DPN_GROUP_INFO)
						+ strlen("ABCDEFGHIJKLMNOPQRSTUVWXYZ") + 1;

		tr = pDP8Peer->DP8P_GetGroupInfo(hostcontext.dpnidGroup, NULL, &dwSize, 0);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Getting group info with NULL buffer didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get group info)

		if (dwSize != dwExpectedSize)
		{
			DPTEST_FAIL(hLog, "Size was not expected (%u != %u)!", 2, dwSize, dwExpectedSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (size is not expected)



		LOCALALLOC_OR_THROW(PDPN_GROUP_INFO, pdpngi, dwSize + BUFFERPADDING_SIZE);

		FillWithDWord((((PBYTE) pdpngi) + sizeof (DWORD)),
						(dwSize - sizeof (DWORD) + BUFFERPADDING_SIZE),
						DONT_TOUCH_MEMORY_PATTERN);

		pdpngi->dwSize = 0;

/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting group info with group info size of 0");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_GetGroupInfo(hostcontext.dpnidGroup, pdpngi, &dwSize, 0);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Getting group info using buffer with group info size of 0 didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get group info)

		if (dwSize != dwExpectedSize)
		{
			DPTEST_FAIL(hLog, "Size returned was unexpected (%u != %u)!", 2, dwSize, dwExpectedSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (size is not expected)

		// Make sure the buffer was not modified or overrun.
		if ((pdpngi->dwSize != 0) ||
			(! IsFilledWithDWord((((PBYTE) pdpngi) + sizeof (DWORD)), (dwSize - sizeof (DWORD) + BUFFERPADDING_SIZE), DONT_TOUCH_MEMORY_PATTERN)))
		{
			DPTEST_FAIL(hLog, "The %u byte group info buffer (at %x) was modified or overrun!",
				2, dwSize, pdpngi);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (buffer was overrun)
*/

		pdpngi->dwSize = sizeof (DPN_GROUP_INFO) + 1;

/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting group info with group info size too large");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_GetGroupInfo(hostcontext.dpnidGroup, pdpngi, &dwSize, 0);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Getting group info using buffer with group info size too large didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get group info)

		if (dwSize != dwExpectedSize)
		{
			DPTEST_FAIL(hLog, "Size returned was unexpected (%u != %u)!", 2, dwSize, dwExpectedSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (size is not expected)

		// Make sure the buffer was not modified or overrun.
		if ((pdpngi->dwSize != (sizeof (DPN_GROUP_INFO) + 1)) ||
			(! IsFilledWithDWord((((PBYTE) pdpngi) + sizeof (DWORD)), (dwSize - sizeof (DWORD) + BUFFERPADDING_SIZE), DONT_TOUCH_MEMORY_PATTERN)))
		{
			DPTEST_FAIL(hLog, "The %u byte group info buffer (at %x) was modified or overrun!",
				2, dwSize, pdpngi);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (buffer was overrun)
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting group info");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pdpngi->dwSize = sizeof (DPN_GROUP_INFO);

		tr = pDP8Peer->DP8P_GetGroupInfo(hostcontext.dpnidGroup, pdpngi, &dwSize, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting group info failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get group info)

		if (dwSize != dwExpectedSize)
		{
			DPTEST_FAIL(hLog, "Size returned was unexpected (%u != %u)!", 2, dwSize, dwExpectedSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (size is not expected)


		// Make sure the structure returned was expected.
		// When we retrieve the data, the name (or rather non-existence of the name)
		// is known.
		dpngiCompare.dwInfoFlags |= DPNINFO_NAME;

		tr = ParmVCompareGroupInfo(hLog, pdpngi, &dpngiCompare);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Comparing group info buffer %x with expected %x failed!",
				2, pdpngi, &dpngi);
			THROW_TESTRESULT;
		} // end if (failed comparison)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing peer object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure we got the destroy player message.
		if (hostcontext.dpnidHost != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)

#pragma TODO(vanceo, "Validate destroy group nametable unwind")

		// Reset group ID.
		hostcontext.dpnidGroup = 0;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Re-initializing peer object with nonhost context");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		nonhostcontext.hLog = hLog;

		tr = pDP8Peer->DP8P_Initialize(&nonhostcontext,
										ParmVPGetGroupInfoDPNMessageHandler,
										0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Re-initializing peer object with context, 0 flags failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating new peer host object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Address->Release();
		pDP8Address = NULL;

		hostcontext.hLog = hLog;

		tr = ParmVCreatePeerHost(hLog, ParmVPGetGroupInfoDPNMessageHandler,
								&hostcontext,
								&dpnad,
								&(hostcontext.dpnidHost),
								&pDP8PeerHost,
								&pDP8Address);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Creating peer host failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't create peer host)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Connecting peer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

// XBOX - Had to make connection asynchronous

		// Host should get the create player now.
		CREATEEVENT_OR_THROW(hostcontext.hClientCreatedEvent, NULL, FALSE, FALSE, NULL);
		SAFE_CLOSEHANDLE(hAsyncOpComplete);
		CREATEEVENT_OR_THROW(hAsyncOpComplete, NULL, FALSE, FALSE, NULL);

		// Even though it's synchronous, we'll still get a completion.  The async op
		// handle will be NULL, though.
		nonhostcontext.fConnectCanComplete = TRUE;

		tr = pDP8Peer->DP8P_Connect(&dpnad,
									pDP8Address,
									NULL,
									NULL,
									NULL,
									NULL,
									0,
									&(nonhostcontext.dpnidClient),
									hAsyncOpComplete,
									&hAsyncOp,
									0);

		if((tr != DPNSUCCESS_PENDING) && (tr != DPN_OK))
		{
			DPTEST_FAIL(hLog, "Couldn't connect! (error 0x%08x)", 1, tr);
			THROW_TESTRESULT;
		} // end if (couldn't connect)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for connect to complete on non-host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hAsyncOpComplete))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird connects from completing.
		nonhostcontext.fConnectCanComplete = FALSE;

		// Make sure we saw the connect completion indication.
		if (! nonhostcontext.fConnectCompleted)
		{
			DPTEST_FAIL(hLog, "Didn't get connect complete indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (connect didn't complete)

		// Reset the context.
		nonhostcontext.fConnectCompleted = FALSE;

		// Make sure we got the create player messages.
		if (nonhostcontext.dpnidHost == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication for host on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player)

		if (nonhostcontext.dpnidClient == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication for client on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for create player to be indicated on host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hostcontext.hClientCreatedEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating group on host asynchronously");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		SAFE_CLOSEHANDLE(hAsyncOpComplete);
		CREATEEVENT_OR_THROW(hAsyncOpComplete, NULL, FALSE, FALSE, NULL);

		// Restore the comparison buffer.
		CopyMemory(&dpngiCompare, &dpngi, sizeof (DPN_GROUP_INFO));

		// Expect the create group message on the host.
		//hostcontext.dpnidExpectedGroupOwner = 0;
		hostcontext.fCanGetCreateGroup = TRUE;

		// Expect the create group message on the client.
		//nonhostcontext.dpnidExpectedGroupOwner = 0;

		CREATEEVENT_OR_THROW(nonhostcontext.hGotGroupMsgEvent,
							NULL, FALSE, FALSE, NULL);
		nonhostcontext.fCanGetCreateGroup = TRUE;

		tr = pDP8PeerHost->DP8P_CreateGroup(&dpngi, NULL, hAsyncOpComplete, &hAsyncOp, 0);

		if((tr != DPNSUCCESS_PENDING) && (tr != DPN_OK))
		{
			DPTEST_FAIL(hLog, "Creating group failed! (error 0x%08x)", 1, tr);
			THROW_TESTRESULT;
		} // end if (couldn't create group)

		if (memcmp(&dpngiCompare, &dpngi, sizeof (DPN_GROUP_INFO)) != 0)
		{
			DPTEST_FAIL(hLog, "Group info structure was modified (structure at %x != structure at %x)!",
				2, &dpngiCompare, &dpngi);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (group info changed)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for group to be created asynchronously");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8PeerHost->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hAsyncOpComplete))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird create groups.
		hostcontext.fCanGetCreateGroup = FALSE;

		// Make sure we got the create group message.
		if (hostcontext.dpnidGroup == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get create group message!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create group)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for group to be created on client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, nonhostcontext.hGotGroupMsgEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird create group indications.
		nonhostcontext.fCanGetCreateGroup = FALSE;

#ifdef DEBUG
		// Make sure we got the indication (how else would we get here?).
		if (nonhostcontext.dpnidGroup == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get create group indication!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (didn't get create group indication)
#endif // DEBUG

		// Reset the context.
		CloseHandle(nonhostcontext.hGotGroupMsgEvent);
		nonhostcontext.hGotGroupMsgEvent = NULL;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting group info with NULL buffer on client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwSize = 0;

		tr = pDP8Peer->DP8P_GetGroupInfo(nonhostcontext.dpnidGroup, NULL, &dwSize, 0);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Getting group info with NULL buffer on client didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get group info)

		if (dwSize != dwExpectedSize)
		{
			DPTEST_FAIL(hLog, "Size was not expected (%u != %u)!", 2, dwSize, dwExpectedSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (size is not expected)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting group info on client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		FillWithDWord((((PBYTE) pdpngi) + sizeof (DWORD)),
						(dwSize - sizeof (DWORD) + BUFFERPADDING_SIZE),
						DONT_TOUCH_MEMORY_PATTERN);

		pdpngi->dwSize = sizeof (DPN_GROUP_INFO);

		tr = pDP8Peer->DP8P_GetGroupInfo(nonhostcontext.dpnidGroup, pdpngi, &dwSize, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting group info on client failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get group info)

		if (dwSize != dwExpectedSize)
		{
			DPTEST_FAIL(hLog, "Size returned was unexpected (%u != %u)!", 2, dwSize, dwExpectedSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (size is not expected)


		// Make sure the structure returned was expected.
		// When we retrieve the data, the name (or rather non-existence of the name)
		// is known.
		dpngiCompare.dwInfoFlags |= DPNINFO_NAME;

		tr = ParmVCompareGroupInfo(hLog, pdpngi, &dpngiCompare);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Comparing group info buffer %x with expected %x failed!",
				2, pdpngi, &dpngi);
			THROW_TESTRESULT;
		} // end if (failed comparison)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing peer client object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing peer client object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure we got the destroy player messages.
		if (nonhostcontext.dpnidHost != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for host on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)

		if (nonhostcontext.dpnidClient != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for client on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)


		// Technically we should wait to make sure the host saw the client go away
		// as expected but that's more hassle than it's worth.  Just make sure he's
		// gone after Close() has returned.



#pragma TODO(vanceo, "Validate destroy group nametable unwind on both interfaces")


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing host object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8PeerHost->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing host object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure we got the destroy player messages.
		if (hostcontext.dpnidHost != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for host on host!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)

		if (hostcontext.dpnidClient != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for client on host!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing hosting DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8PeerHost->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release hosting DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8PeerHost);
		pDP8PeerHost = NULL;





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Peer);
		pDP8Peer = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE


	if (pDP8Peer != NULL)
	{
		delete (pDP8Peer);
		pDP8Peer = NULL;
	} // end if (have peer object)

	if (pDP8PeerHost != NULL)
	{
		delete (pDP8PeerHost);
		pDP8PeerHost = NULL;
	} // end if (have peer object)

	SAFE_LOCALFREE(pdpngi);
	SAFE_RELEASE(pDP8Address);
	SAFE_CLOSEHANDLE(hostcontext.hGotGroupMsgEvent);
	SAFE_CLOSEHANDLE(nonhostcontext.hGotGroupMsgEvent);
	SAFE_CLOSEHANDLE(hostcontext.hClientCreatedEvent);
	ClearDoWorkList(&DoWorkList);
	SAFE_CLOSEHANDLE(hAsyncOpComplete);

	return (sr);
} // ParmVPeerExec_GetGroupInfo
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVPeerExec_EnumPAndG()"
//==================================================================================
// ParmVPeerExec_EnumPAndG
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.1.17 - Peer EnumPlayersAndGroups parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVPeerExec_EnumPAndG(HANDLE hLog)
{
	CTNSystemResult			sr;
	CTNTestResult			tr;
	PWRAPDP8PEER			pDP8Peer = NULL;
	PWRAPDP8PEER			pDP8PeerHost = NULL;
	PDIRECTPLAY8ADDRESS		pDP8Address = NULL;
	PARMVPENUMPANDGCONTEXT	hostcontext;
	PARMVPENUMPANDGCONTEXT	nonhostcontext;
	DPN_APPLICATION_DESC	dpnad;
	DPN_APPLICATION_DESC	dpnadCompare;
	DPN_GROUP_INFO			dpngi;
	DPN_GROUP_INFO			dpngiCompare;
	DPNID					adpnidIDs[4];
	DWORD					dwNumIDs;
	DP_DOWORKLIST			DoWorkList;
	DPNHANDLE				hAsyncOp;
	HANDLE					hAsyncOpComplete = NULL;

	ZeroMemory(&DoWorkList, sizeof(DP_DOWORKLIST));
	ZeroMemory(&hostcontext, sizeof (PARMVPENUMPANDGCONTEXT));
	hostcontext.fHost = TRUE;

	ZeroMemory(&nonhostcontext, sizeof (PARMVPENUMPANDGCONTEXT));
	//nonhostcontext.fHost = FALSE;


	BEGIN_TESTCASE
	{
		adpnidIDs[0] = 0x666;
		adpnidIDs[1] = 0x666;
		adpnidIDs[2] = 0x666;
		adpnidIDs[3] = 0x666;



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Peer = new CWrapDP8Peer(hLog);
		if (pDP8Peer == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8Peer->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (LPVOID *) &pDP8Address, NULL);
		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't create DirectPlay8Address object!", 0);
			THROW_SYSTEMRESULT;
		} // end if (create failed)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting address object's SP to TCP/IP");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->SetSP(&CLSID_DP8SP_TCPIP);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting address object's SP to TCP/IP failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set SP)





/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("EnumP&G-ing with NULLs and 0 flags using C++ macro");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = IDirectPlay8Peer_EnumPlayersAndGroups(pDP8Peer->m_pDP8Peer, NULL, NULL, 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "EnumP&G-ing with NULLs and 0 flags using C++ macro didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum players and groups)
*/




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("EnumP&G-ing with NULLs and 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_EnumPlayersAndGroups(NULL, NULL, 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "EnumP&G-ing with NULLs and 0 flags didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum players and groups)
*/




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("EnumP&G-ing with non-0 count");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwNumIDs = 666;

		tr = pDP8Peer->DP8P_EnumPlayersAndGroups(NULL, &dwNumIDs, 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "EnumP&G-ing with 0 flags didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum players and groups)

		if (dwNumIDs != 666)
		{
			DPTEST_FAIL(hLog, "Number of IDs was modified (%u != 666)!", 1, dwNumIDs);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num IDs changed)
*/

		dwNumIDs = 0;

/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("EnumP&G-ing with 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_EnumPlayersAndGroups(NULL, &dwNumIDs, 0);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "EnumP&G-ing with 0 flags didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum players and groups)

		if (dwNumIDs != 0)
		{
			DPTEST_FAIL(hLog, "Number of IDs was modified (%u != 0)!", 1, dwNumIDs);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num IDs changed)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("EnumP&G-ing with invalid flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_EnumPlayersAndGroups(NULL, &dwNumIDs, 0x666);
		if (tr != DPNERR_INVALIDFLAGS)
		{
			DPTEST_FAIL(hLog, "EnumP&G-ing with invalid flags didn't return expected error INVALIDFLAGS!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum players and groups)

		if (dwNumIDs != 0)
		{
			DPTEST_FAIL(hLog, "Number of IDs was modified (%u != 0)!", 1, dwNumIDs);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num IDs changed)
*/




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enuming players before initialization");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_EnumPlayersAndGroups(NULL, &dwNumIDs, DPNENUM_PLAYERS);
		if (tr != DPNERR_UNINITIALIZED)
		{
			DPTEST_FAIL(hLog, "Enuming players before initialization didn't return expected error UNINITIALIZED!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum players and groups)

		if (dwNumIDs != 0)
		{
			DPTEST_FAIL(hLog, "Number of IDs was modified (%u != 0)!", 1, dwNumIDs);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num IDs changed)
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Initializing peer object with host context");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		hostcontext.hLog = hLog;

		tr = pDP8Peer->DP8P_Initialize(&hostcontext,
										ParmVPEnumPAndGDPNMessageHandler, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Initializing peer object with host context failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enuming players without a connection");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_EnumPlayersAndGroups(NULL, &dwNumIDs, DPNENUM_PLAYERS);
		if (tr != DPNERR_NOCONNECTION)
		{
			DPTEST_FAIL(hLog, "Enuming players without a connection didn't return expected error NOCONNECTION!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum players and groups)

		if (dwNumIDs != 0)
		{
			DPTEST_FAIL(hLog, "Number of IDs was modified (%u != 0)!", 1, dwNumIDs);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num IDs changed)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Hosting session");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		//dpnad.dwFlags = 0;
		//dpnad.guidInstance = GUID_NULL;
		dpnad.guidApplication = GUID_PARMV_PEER_GETAPPDESC;
		//dpnad.dwMaxPlayers = 0;
		//dpnad.dwCurrentPlayers = 0;
		//dpnad.pwszSessionName = NULL;
		//dpnad.pwszPassword = NULL;
		//dpnad.pvReservedData = NULL;
		//dpnad.dwReservedDataSize = 0;
		//dpnad.pvApplicationReservedData = NULL;
		//dpnad.dwApplicationReservedDataSize = 0;

		// Save what we're passing in to make sure it's not touched.
		CopyMemory(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC));

		tr = pDP8Peer->DP8P_Host(&dpnad,
								&pDP8Address,
								1,
								NULL,
								NULL,
								&(hostcontext.dpnidHost),
								0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't start hosting session!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't host)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		// Make sure we got the create player message.
		if (hostcontext.dpnidHost == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enuming players with NULL buffer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_EnumPlayersAndGroups(NULL, &dwNumIDs, DPNENUM_PLAYERS);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Enuming players with NULL buffer didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum players and groups)

		if (dwNumIDs != 1)
		{
			DPTEST_FAIL(hLog, "Number of IDs was not expected (%u != 1)!", 1, dwNumIDs);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (num IDs not expected)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enuming players");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_EnumPlayersAndGroups(adpnidIDs, &dwNumIDs, DPNENUM_PLAYERS);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Enuming players failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum players and groups)

		if (dwNumIDs != 1)
		{
			DPTEST_FAIL(hLog, "Number of IDs was not expected (%u != 1)!", 1, dwNumIDs);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (num IDs not expected)

		if (adpnidIDs[0] != hostcontext.dpnidHost)
		{
			DPTEST_FAIL(hLog, "Player ID returned was not expected ([0] %u/%x != %u/%x)!",
				4, adpnidIDs[0], adpnidIDs[0],
				hostcontext.dpnidHost, hostcontext.dpnidHost);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (player ID wrong)

		if ((adpnidIDs[1] != (DPNID) 0x666) ||
			(adpnidIDs[2] != (DPNID) 0x666) ||
			(adpnidIDs[3] != (DPNID) 0x666))
		{
			DPTEST_FAIL(hLog, "Player ID buffer was overrun ([1] %u/%x, [2] %u/%x or [3] %u/%x != 0x666)!",
				6, adpnidIDs[1], adpnidIDs[1],
				adpnidIDs[2], adpnidIDs[2],
				adpnidIDs[3], adpnidIDs[3]);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (buffer overrun)

		// Reset the entry.
		adpnidIDs[0] = 0x666;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enuming players & groups with NULL buffer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwNumIDs = 0;

		tr = pDP8Peer->DP8P_EnumPlayersAndGroups(NULL, &dwNumIDs,
												(DPNENUM_PLAYERS | DPNENUM_GROUPS));
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Enuming players & groups with NULL buffer didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum players and groups)

		if (dwNumIDs != 1)
		{
			DPTEST_FAIL(hLog, "Number of IDs was not expected (%u != 1)!", 1, dwNumIDs);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (num IDs not expected)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enuming players & groups");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_EnumPlayersAndGroups(adpnidIDs, &dwNumIDs, (DPNENUM_PLAYERS | DPNENUM_GROUPS));
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Enuming players & groups failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum players and groups)

		if (dwNumIDs != 1)
		{
			DPTEST_FAIL(hLog, "Number of IDs was not expected (%u != 1)!", 1, dwNumIDs);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (num IDs not expected)

		if (adpnidIDs[0] != hostcontext.dpnidHost)
		{
			DPTEST_FAIL(hLog, "Player ID returned was not expected ([0] %u/%x != %u/%x)!",
				4, adpnidIDs[0], adpnidIDs[0],
				hostcontext.dpnidHost, hostcontext.dpnidHost);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (player ID wrong)

		if ((adpnidIDs[1] != (DPNID) 0x666) ||
			(adpnidIDs[2] != (DPNID) 0x666) ||
			(adpnidIDs[3] != (DPNID) 0x666))
		{
			DPTEST_FAIL(hLog, "Player ID buffer was overrun ([1] %u/%x, [2] %u/%x or [3] %u/%x != 0x666)!",
				6, adpnidIDs[1], adpnidIDs[1],
				adpnidIDs[2], adpnidIDs[2],
				adpnidIDs[3], adpnidIDs[3]);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (buffer overrun)

		// Reset the entry.
		adpnidIDs[0] = 0x666;





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enuming groups with NULL buffer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwNumIDs = 0;

		tr = pDP8Peer->DP8P_EnumPlayersAndGroups(NULL, &dwNumIDs, DPNENUM_GROUPS);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Enuming groups with NULL buffer failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum players and groups)

		if (dwNumIDs != 0)
		{
			DPTEST_FAIL(hLog, "Number of IDs was not expected (%u != 0)!", 1, dwNumIDs);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (num IDs not expected)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enuming groups");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_EnumPlayersAndGroups(adpnidIDs, &dwNumIDs, DPNENUM_GROUPS);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Enuming groups failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum players and groups)

		if (dwNumIDs != 0)
		{
			DPTEST_FAIL(hLog, "Number of IDs was not expected (%u != 0)!", 1, dwNumIDs);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (num IDs not expected)

		if ((adpnidIDs[0] != (DPNID) 0x666) ||
			(adpnidIDs[1] != (DPNID) 0x666) ||
			(adpnidIDs[2] != (DPNID) 0x666) ||
			(adpnidIDs[3] != (DPNID) 0x666))
		{
			DPTEST_FAIL(hLog, "Player ID buffer was modified ([0] %u/%x, [1] %u/%x, [2] %u/%x or [3] %u/%x != 0x666)!",
				8, adpnidIDs[0], adpnidIDs[0],
				adpnidIDs[1], adpnidIDs[1],
				adpnidIDs[2], adpnidIDs[2],
				adpnidIDs[3], adpnidIDs[3]);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (buffer modified)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating group on client asynchronously");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		SAFE_CLOSEHANDLE(hAsyncOpComplete);
		CREATEEVENT_OR_THROW(hAsyncOpComplete, NULL, FALSE, FALSE, NULL);

		ZeroMemory(&dpngi, sizeof (DPN_GROUP_INFO));
		dpngi.dwSize = sizeof (DPN_GROUP_INFO);
		//dpngi.dwInfoFlags = 0;
		//dpngi.pwszName = NULL;
		//dpngi.pvData = NULL;
		//dpngi.dwDataSize = 0;
		//dpngi.dwGroupFlags = 0;

		CopyMemory(&dpngiCompare, &dpngi, sizeof (DPN_GROUP_INFO));


		// Expect the create group message.
		//hostcontext.dpnidExpectedGroupOwner = 0;
		hostcontext.fCanGetCreateGroup = TRUE;

		tr = pDP8Peer->DP8P_CreateGroup(&dpngi, NULL, hAsyncOpComplete, &hAsyncOp, 0);

		if((tr != DPNSUCCESS_PENDING) && (tr != DPN_OK))
		{
			DPTEST_FAIL(hLog, "Creating group failed! (error 0x%08x)", 1, tr);
			THROW_TESTRESULT;
		} // end if (couldn't create group)

		if (memcmp(&dpngiCompare, &dpngi, sizeof (DPN_GROUP_INFO)) != 0)
		{
			DPTEST_FAIL(hLog, "Group info structure was modified (structure at %x != structure at %x)!",
				2, &dpngiCompare, &dpngi);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (group info changed)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for group to be created asynchronously");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 1;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hAsyncOpComplete))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird create groups.
		hostcontext.fCanGetCreateGroup = FALSE;

		// Make sure we got the create group message.
		if (hostcontext.dpnidGroup == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get create group message!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create group)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enuming groups");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwNumIDs = 1;

		tr = pDP8Peer->DP8P_EnumPlayersAndGroups(adpnidIDs, &dwNumIDs, DPNENUM_GROUPS);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Enuming groups failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum players and groups)

		if (dwNumIDs != 1)
		{
			DPTEST_FAIL(hLog, "Number of IDs was not expected (%u != 1)!", 1, dwNumIDs);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (num IDs not expected)

		if (adpnidIDs[0] != hostcontext.dpnidGroup)
		{
			DPTEST_FAIL(hLog, "Group ID returned was not expected ([0] %u/%x != %u/%x)!",
				4, adpnidIDs[0], adpnidIDs[0],
				hostcontext.dpnidGroup, hostcontext.dpnidGroup);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (player ID wrong)

		if ((adpnidIDs[1] != (DPNID) 0x666) ||
			(adpnidIDs[2] != (DPNID) 0x666) ||
			(adpnidIDs[3] != (DPNID) 0x666))
		{
			DPTEST_FAIL(hLog, "Player ID buffer was overrun ([1] %u/%x, [2] %u/%x or [3] %u/%x != 0x666)!",
				6, adpnidIDs[1], adpnidIDs[1],
				adpnidIDs[2], adpnidIDs[2],
				adpnidIDs[3], adpnidIDs[3]);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (buffer overrun)

		// Reset the entry.
		adpnidIDs[0] = 0x666;





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enuming players & groups");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwNumIDs = 2;

		tr = pDP8Peer->DP8P_EnumPlayersAndGroups(adpnidIDs, &dwNumIDs,
												(DPNENUM_PLAYERS | DPNENUM_GROUPS));
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Enuming players & groups failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum players and groups)

		if (dwNumIDs != 2)
		{
			DPTEST_FAIL(hLog, "Number of IDs was not expected (%u != 2)!", 1, dwNumIDs);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (num IDs not expected)

		// NOTE: This test assumes they'll be returned in this order.
		if (adpnidIDs[0] != hostcontext.dpnidHost)
		{
			DPTEST_FAIL(hLog, "Player ID returned was not expected ([0] %u/%x != %u/%x)!",
				4, adpnidIDs[0], adpnidIDs[0],
				hostcontext.dpnidHost, hostcontext.dpnidHost);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (player ID wrong)

		if (adpnidIDs[1] != hostcontext.dpnidGroup)
		{
			DPTEST_FAIL(hLog, "Group ID returned was not expected ([1] %u/%x != %u/%x )!",
				4, adpnidIDs[1], adpnidIDs[1],
				hostcontext.dpnidGroup, hostcontext.dpnidGroup);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (buffer overrun)

		if ((adpnidIDs[2] != (DPNID) 0x666) ||
			(adpnidIDs[3] != (DPNID) 0x666))
		{
			DPTEST_FAIL(hLog, "Player ID buffer was overrun ([2] %u/%x or [3] %u/%x != 0x666)!",
				4, adpnidIDs[2], adpnidIDs[2],
				adpnidIDs[3], adpnidIDs[3]);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (buffer overrun)

		// Reset the entries.
		adpnidIDs[0] = 0x666;
		adpnidIDs[1] = 0x666;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing peer object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure we got the destroy player message.
		if (hostcontext.dpnidHost != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)

#pragma TODO(vanceo, "Validate destroy group nametable unwind")

		// Reset group ID.
		hostcontext.dpnidGroup = 0;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Re-initializing peer object with nonhost context");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		nonhostcontext.hLog = hLog;

		tr = pDP8Peer->DP8P_Initialize(&nonhostcontext,
										ParmVPEnumPAndGDPNMessageHandler,
										0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Re-initializing peer object with context, 0 flags failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating new peer host object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Address->Release();
		pDP8Address = NULL;

		hostcontext.hLog = hLog;

		tr = ParmVCreatePeerHost(hLog, ParmVPEnumPAndGDPNMessageHandler,
								&hostcontext,
								&dpnad,
								&(hostcontext.dpnidHost),
								&pDP8PeerHost,
								&pDP8Address);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Creating peer host failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't create peer host)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Connecting peer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

// XBOX - Had to make connection asynchronous

		// Host should get the create player now.
		CREATEEVENT_OR_THROW(hostcontext.hClientCreatedEvent, NULL, FALSE, FALSE, NULL);
		SAFE_CLOSEHANDLE(hAsyncOpComplete);
		CREATEEVENT_OR_THROW(hAsyncOpComplete, NULL, FALSE, FALSE, NULL);

		// Even though it's synchronous, we'll still get a completion.  The async op
		// handle will be NULL, though.
		nonhostcontext.fConnectCanComplete = TRUE;

		tr = pDP8Peer->DP8P_Connect(&dpnad,
									pDP8Address,
									NULL,
									NULL,
									NULL,
									NULL,
									0,
									&(nonhostcontext.dpnidClient),
									hAsyncOpComplete,
									&hAsyncOp,
									0);

		if((tr != DPNSUCCESS_PENDING) && (tr != DPN_OK))
		{
			DPTEST_FAIL(hLog, "Couldn't connect! (error 0x%08x)", 1, tr);
			THROW_TESTRESULT;
		} // end if (couldn't connect)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for connect to complete on non-host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hAsyncOpComplete))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird connects from completing.
		nonhostcontext.fConnectCanComplete = FALSE;

		// Make sure we saw the connect completion indication.
		if (! nonhostcontext.fConnectCompleted)
		{
			DPTEST_FAIL(hLog, "Didn't get connect complete indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (connect didn't complete)

		// Reset the context.
		nonhostcontext.fConnectCompleted = FALSE;

		// Make sure we got the create player messages.
		if (nonhostcontext.dpnidHost == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication for host on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player)

		if (nonhostcontext.dpnidClient == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication for client on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for create player to be indicated on host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hostcontext.hClientCreatedEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating group on host asynchronously");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		SAFE_CLOSEHANDLE(hAsyncOpComplete);
		CREATEEVENT_OR_THROW(hAsyncOpComplete, NULL, FALSE, FALSE, NULL);

		// Expect the create group message on the host.
		//hostcontext.dpnidExpectedGroupOwner = 0;
		hostcontext.fCanGetCreateGroup = TRUE;

		// Expect the create group message on the client.
		//nonhostcontext.dpnidExpectedGroupOwner = 0;

		CREATEEVENT_OR_THROW(nonhostcontext.hGotGroupMsgEvent,
							NULL, FALSE, FALSE, NULL);
		nonhostcontext.fCanGetCreateGroup = TRUE;

		tr = pDP8PeerHost->DP8P_CreateGroup(&dpngi, NULL, hAsyncOpComplete, &hAsyncOp, 0);

		if((tr != DPNSUCCESS_PENDING) && (tr != DPN_OK))
		{
			DPTEST_FAIL(hLog, "Creating group failed! (error 0x%08x)", 1, tr);
			THROW_TESTRESULT;
		} // end if (couldn't create group)

		if (memcmp(&dpngiCompare, &dpngi, sizeof (DPN_GROUP_INFO)) != 0)
		{
			DPTEST_FAIL(hLog, "Group info structure was modified (structure at %x != structure at %x)!",
				2, &dpngiCompare, &dpngi);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (group info changed)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for group to be created asynchronously");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8PeerHost->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8Peer->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hAsyncOpComplete))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird create groups.
		hostcontext.fCanGetCreateGroup = FALSE;

		// Make sure we got the create group message.
		if (hostcontext.dpnidGroup == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get create group message!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create group)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for group to be created on client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, nonhostcontext.hGotGroupMsgEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird create group indications.
		nonhostcontext.fCanGetCreateGroup = FALSE;

#ifdef DEBUG
		// Make sure we got the indication (how else would we get here?).
		if (nonhostcontext.dpnidGroup == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get create group indication!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (didn't get create group indication)
#endif // DEBUG

		// Reset the context.
		CloseHandle(nonhostcontext.hGotGroupMsgEvent);
		nonhostcontext.hGotGroupMsgEvent = NULL;





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enuming players & groups on client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwNumIDs = 3;

		tr = pDP8Peer->DP8P_EnumPlayersAndGroups(adpnidIDs, &dwNumIDs,
												(DPNENUM_PLAYERS | DPNENUM_GROUPS));
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Enuming players & groups on client failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum players and groups)

		if (dwNumIDs != 3)
		{
			DPTEST_FAIL(hLog, "Number of IDs was not expected (%u != 3)!", 1, dwNumIDs);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (num IDs not expected)

		// NOTE: This test assumes they'll be returned in this order.
		if (adpnidIDs[0] != nonhostcontext.dpnidHost)
		{
			DPTEST_FAIL(hLog, "Host player ID returned was not expected ([0] %u/%x != %u/%x)!",
				4, adpnidIDs[0], adpnidIDs[0],
				nonhostcontext.dpnidHost, nonhostcontext.dpnidHost);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (player ID wrong)

		if (adpnidIDs[1] != nonhostcontext.dpnidClient)
		{
			DPTEST_FAIL(hLog, "Client player ID returned was not expected ([1] %u/%x != %u/%x)!",
				4, adpnidIDs[1], adpnidIDs[1],
				nonhostcontext.dpnidClient, nonhostcontext.dpnidClient);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (player ID wrong)

		if (adpnidIDs[2] != hostcontext.dpnidGroup)
		{
			DPTEST_FAIL(hLog, "Group ID returned was not expected ([2] %u/%x != %u/%x )!",
				4, adpnidIDs[2], adpnidIDs[2],
				hostcontext.dpnidGroup, hostcontext.dpnidGroup);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (buffer overrun)

		if (adpnidIDs[3] != (DPNID) 0x666)
		{
			DPTEST_FAIL(hLog, "Player ID buffer was overrun ([3] %u/%x != 0x666)!",
				2, adpnidIDs[3], adpnidIDs[3]);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (buffer overrun)

		// Reset the entries.
		adpnidIDs[0] = 0x666;
		adpnidIDs[1] = 0x666;
		adpnidIDs[2] = 0x666;

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating second group on host asynchronously");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		SAFE_CLOSEHANDLE(hAsyncOpComplete);
		CREATEEVENT_OR_THROW(hAsyncOpComplete, NULL, FALSE, FALSE, NULL);

		ZeroMemory(&dpngi, sizeof (DPN_GROUP_INFO));
		dpngi.dwSize = sizeof (DPN_GROUP_INFO);
		dpngi.dwInfoFlags = DPNINFO_NAME;
		dpngi.pwszName = L"Group name";
		//dpngi.pvData = NULL;
		//dpngi.dwDataSize = 0;
		//dpngi.dwGroupFlags = 0;

		CopyMemory(&dpngiCompare, &dpngi, sizeof (DPN_GROUP_INFO));


		// Expect the create group message on the host.
		//hostcontext.dpnidExpectedGroupOwner = 0;
		hostcontext.fCanGetCreateGroup2 = TRUE;

		// Expect the create group message on the client.
		//nonhostcontext.dpnidExpectedGroupOwner = 0;

		CREATEEVENT_OR_THROW(nonhostcontext.hGotGroupMsgEvent,
							NULL, FALSE, FALSE, NULL);
		nonhostcontext.fCanGetCreateGroup2 = TRUE;

		tr = pDP8PeerHost->DP8P_CreateGroup(&dpngi, NULL, hAsyncOpComplete, &hAsyncOp, 0);

		if((tr != DPNSUCCESS_PENDING) && (tr != DPN_OK))
		{
			DPTEST_FAIL(hLog, "Creating group failed! (error 0x%08x)", 1, tr);
			THROW_TESTRESULT;
		} // end if (couldn't create group)

		if (memcmp(&dpngiCompare, &dpngi, sizeof (DPN_GROUP_INFO)) != 0)
		{
			DPTEST_FAIL(hLog, "Group info structure was modified (structure at %x != structure at %x)!",
				2, &dpngiCompare, &dpngi);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (group info changed)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for second group to be created asynchronously");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8PeerHost->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8Peer->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hAsyncOpComplete))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird create groups.
		hostcontext.fCanGetCreateGroup = FALSE;

		// Make sure we got the create group message.
		if (hostcontext.dpnidGroup2 == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get create group message!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create group)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for second group to be created on client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, nonhostcontext.hGotGroupMsgEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird create group indications.
		nonhostcontext.fCanGetCreateGroup2 = FALSE;

#ifdef DEBUG
		// Make sure we got the indication (how else would we get here?).
		if (nonhostcontext.dpnidGroup2 == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get create group indication!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (didn't get create group indication)
#endif // DEBUG

		// Reset the context.
		CloseHandle(nonhostcontext.hGotGroupMsgEvent);
		nonhostcontext.hGotGroupMsgEvent = NULL;





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enuming groups on client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwNumIDs = 2;

		tr = pDP8Peer->DP8P_EnumPlayersAndGroups(adpnidIDs, &dwNumIDs, DPNENUM_GROUPS);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Enuming players & groups on client failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum players and groups)

		if (dwNumIDs != 2)
		{
			DPTEST_FAIL(hLog, "Number of IDs was not expected (%u != 2)!", 1, dwNumIDs);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (num IDs not expected)

		// NOTE: This test assumes they'll be returned in this order.
		if (adpnidIDs[0] != hostcontext.dpnidGroup)
		{
			DPTEST_FAIL(hLog, "Group ID returned was not expected ([0] %u/%x != %u/%x )!",
				4, adpnidIDs[0], adpnidIDs[0],
				hostcontext.dpnidGroup, hostcontext.dpnidGroup);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (player ID wrong)

		if (adpnidIDs[1] != hostcontext.dpnidGroup2)
		{
			DPTEST_FAIL(hLog, "Group ID returned was not expected ([1] %u/%x != %u/%x )!",
				4, adpnidIDs[1], adpnidIDs[1],
				hostcontext.dpnidGroup2, hostcontext.dpnidGroup2);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (player ID wrong)

		if ((adpnidIDs[2] != (DPNID) 0x666) ||
			(adpnidIDs[3] != (DPNID) 0x666))
		{
			DPTEST_FAIL(hLog, "Player ID buffer was overrun ([2] %u/%x or [3] %u/%x != 0x666)!",
				4, adpnidIDs[2], adpnidIDs[2],
				adpnidIDs[3], adpnidIDs[3]);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (buffer overrun)

		// Reset the entries.
		adpnidIDs[0] = 0x666;
		adpnidIDs[1] = 0x666;





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing peer client object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing peer client object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure we got the destroy player messages.
		if (nonhostcontext.dpnidHost != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for host on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)

		if (nonhostcontext.dpnidClient != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for client on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)


		// Technically we should wait to make sure the host saw the client go away
		// as expected but that's more hassle than it's worth.  Just make sure he's
		// gone after Close() has returned.



#pragma TODO(vanceo, "Validate destroy group nametable unwind on both interfaces")


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing host object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8PeerHost->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing host object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure we got the destroy player messages.
		if (hostcontext.dpnidHost != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for host on host!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)

		if (hostcontext.dpnidClient != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for client on host!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing hosting DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8PeerHost->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release hosting DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8PeerHost);
		pDP8PeerHost = NULL;






		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Peer);
		pDP8Peer = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE


	if (pDP8Peer != NULL)
	{
		delete (pDP8Peer);
		pDP8Peer = NULL;
	} // end if (have peer object)

	if (pDP8PeerHost != NULL)
	{
		delete (pDP8PeerHost);
		pDP8PeerHost = NULL;
	} // end if (have peer object)

	SAFE_RELEASE(pDP8Address);
	SAFE_CLOSEHANDLE(hostcontext.hGotGroupMsgEvent);
	SAFE_CLOSEHANDLE(nonhostcontext.hGotGroupMsgEvent);
	SAFE_CLOSEHANDLE(hostcontext.hClientCreatedEvent);
	ClearDoWorkList(&DoWorkList);
	SAFE_CLOSEHANDLE(hAsyncOpComplete);

	return (sr);
} // ParmVPeerExec_EnumPAndG
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVPeerExec_EnumGroupMembers()"
//==================================================================================
// ParmVPeerExec_EnumGroupMembers
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.1.18 - Peer EnumGroupMembers parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVPeerExec_EnumGroupMembers(HANDLE hLog)
{
	CTNSystemResult					sr;
	CTNTestResult					tr;
	PWRAPDP8PEER					pDP8Peer = NULL;
	PWRAPDP8PEER					pDP8PeerHost = NULL;
	PDIRECTPLAY8ADDRESS				pDP8Address = NULL;
	PARMVPENUMGROUPMEMBERSCONTEXT	hostcontext;
	PARMVPENUMGROUPMEMBERSCONTEXT	nonhostcontext;
	DPN_APPLICATION_DESC			dpnad;
	DPN_APPLICATION_DESC			dpnadCompare;
	DPN_GROUP_INFO					dpngi;
	DPN_GROUP_INFO					dpngiCompare;
	DPNID							adpnidIDs[3];
	DWORD							dwNumIDs;
	DP_DOWORKLIST					DoWorkList;
	DPNHANDLE						hAsyncOp;
	HANDLE							hAsyncOpComplete = NULL;

	ZeroMemory(&DoWorkList, sizeof(DP_DOWORKLIST));
	ZeroMemory(&hostcontext, sizeof (PARMVPENUMGROUPMEMBERSCONTEXT));
	hostcontext.fHost = TRUE;

	ZeroMemory(&nonhostcontext, sizeof (PARMVPENUMGROUPMEMBERSCONTEXT));
	//nonhostcontext.fHost = FALSE;


	BEGIN_TESTCASE
	{
		adpnidIDs[0] = 0x666;
		adpnidIDs[1] = 0x666;
		adpnidIDs[2] = 0x666;
		

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Peer = new CWrapDP8Peer(hLog);
		if (pDP8Peer == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8Peer->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (LPVOID *) &pDP8Address, NULL);
		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't create DirectPlay8Address object!", 0);
			THROW_SYSTEMRESULT;
		} // end if (create failed)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting address object's SP to TCP/IP");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->SetSP(&CLSID_DP8SP_TCPIP);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting address object's SP to TCP/IP failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set SP)




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enuming group 0 (DPNID_ALL_PLAYERS_GROUP) members with NULLs and 0 flags using C++ macro");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = IDirectPlay8Peer_EnumGroupMembers(pDP8Peer->m_pDP8Peer, 0, NULL, NULL, 0);
		if (tr != DPNERR_INVALIDGROUP)
		{
			DPTEST_FAIL(hLog, "Enuming group 0 (DPNID_ALL_PLAYERS_GROUP) members with NULLs and 0 flags using C++ macro didn't return expected error INVALIDGROUP!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum group members)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enuming group 0 (DPNID_ALL_PLAYERS_GROUP) members with NULLs and 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_EnumGroupMembers(0, NULL, NULL, 0);
		if (tr != DPNERR_INVALIDGROUP)
		{
			DPTEST_FAIL(hLog, "Enuming group 0 (DPNID_ALL_PLAYERS_GROUP) members with NULLs and 0 flags didn't return expected error INVALIDGROUP!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum group members)
*/





/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enuming group members with NULL size");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Use 0x666 to avoid DPlay's group ID == 0 check.
		tr = pDP8Peer->DP8P_EnumGroupMembers((DPNID) 0x666, NULL, NULL, 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Enuming group members with NULL size didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum group members)
*/




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enuming group members with NULL buffer and non-zero size");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwNumIDs = 666;

		tr = pDP8Peer->DP8P_EnumGroupMembers((DPNID) 0x666, NULL, &dwNumIDs, 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Enuming group members with NULL buffer and non-zero size didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum group members)

		if (dwNumIDs != 666)
		{
			DPTEST_FAIL(hLog, "Number of IDs was modified (%u != 666)!", 1, dwNumIDs);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num IDs changed)
*/

		dwNumIDs = 0;

/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enuming group members with invalid flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_EnumGroupMembers((DPNID) 0x666, NULL, &dwNumIDs, 0x666);
		if (tr != DPNERR_INVALIDFLAGS)
		{
			DPTEST_FAIL(hLog, "Enuming group members with invalid flags didn't return expected error INVALIDFLAGS!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum group members)

		if (dwNumIDs != 0)
		{
			DPTEST_FAIL(hLog, "Number of IDs was modified (%u != 0)!", 1, dwNumIDs);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num IDs changed)
*/




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enuming group members before initialization");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_EnumGroupMembers((DPNID) 0x666, NULL, &dwNumIDs, 0);
		if (tr != DPNERR_UNINITIALIZED)
		{
			DPTEST_FAIL(hLog, "Enuming group members before initialization didn't return expected error UNINITIALIZED!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum group members)

		if (dwNumIDs != 0)
		{
			DPTEST_FAIL(hLog, "Number of IDs was modified (%u != 0)!", 1, dwNumIDs);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num IDs changed)
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Initializing peer object with host context");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		hostcontext.hLog = hLog;

		tr = pDP8Peer->DP8P_Initialize(&hostcontext,
										ParmVPEnumGroupMembersDPNMessageHandler, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Initializing peer object with host context failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enuming group members without a connection");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_EnumGroupMembers((DPNID) 0x666, NULL, &dwNumIDs, 0);
		if (tr != DPNERR_NOCONNECTION)
		{
			DPTEST_FAIL(hLog, "Enuming group members without a connection didn't return expected error NOCONNECTION!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum group members)

		if (dwNumIDs != 0)
		{
			DPTEST_FAIL(hLog, "Number of IDs was modified (%u != 0)!", 1, dwNumIDs);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num IDs changed)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Hosting session");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		//dpnad.dwFlags = 0;
		//dpnad.guidInstance = GUID_NULL;
		dpnad.guidApplication = GUID_PARMV_PEER_GETAPPDESC;
		//dpnad.dwMaxPlayers = 0;
		//dpnad.dwCurrentPlayers = 0;
		//dpnad.pwszSessionName = NULL;
		//dpnad.pwszPassword = NULL;
		//dpnad.pvReservedData = NULL;
		//dpnad.dwReservedDataSize = 0;
		//dpnad.pvApplicationReservedData = NULL;
		//dpnad.dwApplicationReservedDataSize = 0;

		// Save what we're passing in to make sure it's not touched.
		CopyMemory(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC));

		tr = pDP8Peer->DP8P_Host(&dpnad,
								&pDP8Address,
								1,
								NULL,
								NULL,
								&(hostcontext.dpnidHost),
								0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't start hosting session!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't host)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		// Make sure we got the create player message.
		if (hostcontext.dpnidHost == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enuming group members with invalid group");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_EnumGroupMembers((DPNID) 0x666, NULL, &dwNumIDs, 0);
		if (tr != DPNERR_INVALIDGROUP)
		{
			DPTEST_FAIL(hLog, "Enuming group members with invalid group didn't return expected error INVALIDGROUP!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum group members)

		if (dwNumIDs != 0)
		{
			DPTEST_FAIL(hLog, "Number of IDs was modified (%u != 0)!", 1, dwNumIDs);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num IDs changed)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating group asynchronously");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		SAFE_CLOSEHANDLE(hAsyncOpComplete);
		CREATEEVENT_OR_THROW(hAsyncOpComplete, NULL, FALSE, FALSE, NULL);

		ZeroMemory(&dpngi, sizeof (DPN_GROUP_INFO));
		dpngi.dwSize = sizeof (DPN_GROUP_INFO);
		//dpngi.dwInfoFlags = 0;
		//dpngi.pwszName = NULL;
		//dpngi.pvData = NULL;
		//dpngi.dwDataSize = 0;
		//dpngi.dwGroupFlags = 0;

		CopyMemory(&dpngiCompare, &dpngi, sizeof (DPN_GROUP_INFO));


		// Expect the create group message.
		//hostcontext.dpnidExpectedGroupOwner = 0;
		hostcontext.fCanGetCreateGroup = TRUE;

		tr = pDP8Peer->DP8P_CreateGroup(&dpngi, NULL, hAsyncOpComplete, &hAsyncOp, 0);

		if((tr != DPNSUCCESS_PENDING) && (tr != DPN_OK))
		{
			DPTEST_FAIL(hLog, "Creating group failed! (error 0x%08x)", 1, tr);
			THROW_TESTRESULT;
		} // end if (couldn't create group)

		if (memcmp(&dpngiCompare, &dpngi, sizeof (DPN_GROUP_INFO)) != 0)
		{
			DPTEST_FAIL(hLog, "Group info structure was modified (structure at %x != structure at %x)!",
				2, &dpngiCompare, &dpngi);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (group info changed)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for group to be created asynchronously");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 1;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hAsyncOpComplete))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird create groups.
		hostcontext.fCanGetCreateGroup = FALSE;

		// Make sure we got the create group message.
		if (hostcontext.dpnidGroup == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get create group message!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create group)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enuming group members of empty group with NULL buffer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_EnumGroupMembers(hostcontext.dpnidGroup, NULL,
											&dwNumIDs, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Enuming group members of empty group with NULL buffer failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum group members)

		if (dwNumIDs != 0)
		{
			DPTEST_FAIL(hLog, "Number of IDs was not expected (%u != 0)!", 1, dwNumIDs);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (num IDs not expected)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enuming group members of empty group");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_EnumGroupMembers(hostcontext.dpnidGroup, adpnidIDs,
											&dwNumIDs, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Enuming group members of empty group failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum group members)

		if (dwNumIDs != 0)
		{
			DPTEST_FAIL(hLog, "Number of IDs was not expected (%u != 0)!", 1, dwNumIDs);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (num IDs not expected)

		if ((adpnidIDs[0] != (DPNID) 0x666) ||
			(adpnidIDs[1] != (DPNID) 0x666) ||
			(adpnidIDs[2] != (DPNID) 0x666))
		{
			DPTEST_FAIL(hLog, "Player ID buffer was modified ([0] %u/%x, [1] %u/%x, or [2] %u/%x != 0x666)!",
				6, adpnidIDs[0], adpnidIDs[0],
				adpnidIDs[1], adpnidIDs[1],
				adpnidIDs[2], adpnidIDs[2]);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (buffer modified)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Adding self player to group asynchronously");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		SAFE_CLOSEHANDLE(hAsyncOpComplete);
		CREATEEVENT_OR_THROW(hAsyncOpComplete, NULL, FALSE, FALSE, NULL);

		// Expect the add player to group message.
		hostcontext.dpnidExpectedPlayer = hostcontext.dpnidHost;
		hostcontext.pvExpectedPlayerContext = &(hostcontext.dpnidHost);
		hostcontext.fCanGetAddToGroup = TRUE;

		tr = pDP8Peer->DP8P_AddPlayerToGroup(hostcontext.dpnidGroup,
											hostcontext.dpnidHost,
											hAsyncOpComplete,
											&hAsyncOp,
											0);

		
		if((tr != DPNSUCCESS_PENDING) && (tr != DPN_OK))
		{
			DPTEST_FAIL(hLog, "Adding self player to group synchronously failed! (error 0x%08x)", 1, tr);
			THROW_TESTRESULT;
		} // end if (couldn't create group)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for self player to be added to group asynchronously");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 1;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hAsyncOpComplete))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird add player to group messages.
		hostcontext.fCanGetAddToGroup = FALSE;

		// Make sure we got the add to group message.
		if (! hostcontext.fGotAddToGroup)
		{
			DPTEST_FAIL(hLog, "Didn't get add player to group message!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get add player to group)

		// Reset the context.
		hostcontext.fGotAddToGroup = FALSE;

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enuming group members with NULL buffer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_EnumGroupMembers(hostcontext.dpnidGroup, NULL,
											&dwNumIDs, 0);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Enuming group members with NULL buffer didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum group members)

		if (dwNumIDs != 1)
		{
			DPTEST_FAIL(hLog, "Number of IDs was not expected (%u != 1)!", 1, dwNumIDs);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (num IDs not expected)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enuming group members");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_EnumGroupMembers(hostcontext.dpnidGroup, adpnidIDs,
											&dwNumIDs, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Enuming group members failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum group members)

		if (dwNumIDs != 1)
		{
			DPTEST_FAIL(hLog, "Number of IDs was not expected (%u != 0)!", 1, dwNumIDs);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (num IDs not expected)

		if (adpnidIDs[0] != hostcontext.dpnidHost)
		{
			DPTEST_FAIL(hLog, "Player ID returned was not expected ([0] %u/%x != %u/%x)!",
				4, adpnidIDs[0], adpnidIDs[0],
				hostcontext.dpnidHost, hostcontext.dpnidHost);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (player ID wrong)

		if ((adpnidIDs[1] != (DPNID) 0x666) ||
			(adpnidIDs[2] != (DPNID) 0x666))
		{
			DPTEST_FAIL(hLog, "Player ID buffer was overrun ([1] %u/%x, or [2] %u/%x!= 0x666)!",
				4, adpnidIDs[1], adpnidIDs[1],
				adpnidIDs[2], adpnidIDs[2]);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (buffer overrun)

		// Reset the entry.
		adpnidIDs[0] = 0x666;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing peer object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure we got the destroy player message.
		if (hostcontext.dpnidHost != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)

#pragma TODO(vanceo, "Validate destroy group nametable unwind")

		// Reset group ID.
		hostcontext.dpnidGroup = 0;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Re-initializing peer object with nonhost context");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		nonhostcontext.hLog = hLog;

		tr = pDP8Peer->DP8P_Initialize(&nonhostcontext,
										ParmVPEnumGroupMembersDPNMessageHandler,
										0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Re-initializing peer object with context, 0 flags failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating new peer host object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Address->Release();
		pDP8Address = NULL;

		hostcontext.hLog = hLog;

		tr = ParmVCreatePeerHost(hLog, ParmVPEnumGroupMembersDPNMessageHandler,
								&hostcontext,
								&dpnad,
								&(hostcontext.dpnidHost),
								&pDP8PeerHost,
								&pDP8Address);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Creating peer host failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't create peer host)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Connecting peer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

// XBOX - Had to make connection asynchronous

		// Host should get the create player now.
		CREATEEVENT_OR_THROW(hostcontext.hClientCreatedEvent, NULL, FALSE, FALSE, NULL);
		SAFE_CLOSEHANDLE(hAsyncOpComplete);
		CREATEEVENT_OR_THROW(hAsyncOpComplete, NULL, FALSE, FALSE, NULL);

		// Even though it's synchronous, we'll still get a completion.  The async op
		// handle will be NULL, though.
		nonhostcontext.fConnectCanComplete = TRUE;

		tr = pDP8Peer->DP8P_Connect(&dpnad,
									pDP8Address,
									NULL,
									NULL,
									NULL,
									NULL,
									0,
									&(nonhostcontext.dpnidClient),
									hAsyncOpComplete,
									&hAsyncOp,
									0);

		if((tr != DPNSUCCESS_PENDING) && (tr != DPN_OK))
		{
			DPTEST_FAIL(hLog, "Couldn't connect! (error 0x%08x)", 1, tr);
			THROW_TESTRESULT;
		} // end if (couldn't connect)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for connect to complete on non-host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hAsyncOpComplete))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird connects from completing.
		nonhostcontext.fConnectCanComplete = FALSE;

		// Make sure we saw the connect completion indication.
		if (! nonhostcontext.fConnectCompleted)
		{
			DPTEST_FAIL(hLog, "Didn't get connect complete indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (connect didn't complete)

		// Reset the context.
		nonhostcontext.fConnectCompleted = FALSE;

		// Make sure we got the create player messages.
		if (nonhostcontext.dpnidHost == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication for host on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player)

		if (nonhostcontext.dpnidClient == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication for client on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for create player to be indicated on host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hostcontext.hClientCreatedEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating group on host asynchronously");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		SAFE_CLOSEHANDLE(hAsyncOpComplete);
		CREATEEVENT_OR_THROW(hAsyncOpComplete, NULL, FALSE, FALSE, NULL);

		// Expect the create group message on the host.
		//hostcontext.dpnidExpectedGroupOwner = 0;
		hostcontext.fCanGetCreateGroup = TRUE;

		// Expect the create group message on the client.
		//nonhostcontext.dpnidExpectedGroupOwner = 0;

		CREATEEVENT_OR_THROW(nonhostcontext.hGotGroupMsgEvent,
							NULL, FALSE, FALSE, NULL);
		nonhostcontext.fCanGetCreateGroup = TRUE;

		tr = pDP8PeerHost->DP8P_CreateGroup(&dpngi, NULL, hAsyncOpComplete, &hAsyncOp, 0);

		if((tr != DPNSUCCESS_PENDING) && (tr != DPN_OK))
		{
			DPTEST_FAIL(hLog, "Creating group failed! (error 0x%08x)", 1, tr);
			THROW_TESTRESULT;
		} // end if (couldn't create group)

		if (memcmp(&dpngiCompare, &dpngi, sizeof (DPN_GROUP_INFO)) != 0)
		{
			DPTEST_FAIL(hLog, "Group info structure was modified (structure at %x != structure at %x)!",
				2, &dpngiCompare, &dpngi);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (group info changed)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for group to be created asynchronously");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8PeerHost->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8Peer->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hAsyncOpComplete))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird create groups.
		hostcontext.fCanGetCreateGroup = FALSE;

		// Make sure we got the create group message.
		if (hostcontext.dpnidGroup == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get create group message!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create group)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for group to be created on client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, nonhostcontext.hGotGroupMsgEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird create group indications.
		nonhostcontext.fCanGetCreateGroup = FALSE;

#ifdef DEBUG
		// Make sure we got the indication (how else would we get here?).
		if (nonhostcontext.dpnidGroup == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get create group indication!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (didn't get create group indication)
#endif // DEBUG

		// Reset the context.
		CloseHandle(nonhostcontext.hGotGroupMsgEvent);
		nonhostcontext.hGotGroupMsgEvent = NULL;

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Adding self player to group asynchronously on host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		SAFE_CLOSEHANDLE(hAsyncOpComplete);
		CREATEEVENT_OR_THROW(hAsyncOpComplete, NULL, FALSE, FALSE, NULL);

		// Expect the add player to group message on the host and client.
		hostcontext.dpnidExpectedPlayer = hostcontext.dpnidHost;
		hostcontext.pvExpectedPlayerContext = &(hostcontext.dpnidHost);
		hostcontext.fCanGetAddToGroup = TRUE;

		nonhostcontext.dpnidExpectedPlayer = nonhostcontext.dpnidHost;
		nonhostcontext.pvExpectedPlayerContext = &(nonhostcontext.dpnidHost);
		CREATEEVENT_OR_THROW(nonhostcontext.hGotGroupMsgEvent,
							NULL, FALSE, FALSE, NULL);
		nonhostcontext.fCanGetAddToGroup = TRUE;

		tr = pDP8PeerHost->DP8P_AddPlayerToGroup(hostcontext.dpnidGroup,
											hostcontext.dpnidHost,
											hAsyncOpComplete,
											&hAsyncOp,
											0);

		
		if((tr != DPNSUCCESS_PENDING) && (tr != DPN_OK))
		{
			DPTEST_FAIL(hLog, "Adding self player to group synchronously failed! (error 0x%08x)", 1, tr);
			THROW_TESTRESULT;
		} // end if (couldn't create group)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for self player to be added to group asynchronously");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 1;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apDP8Peers[0] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hAsyncOpComplete))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird add player to group messages.
		hostcontext.fCanGetAddToGroup = FALSE;

		// Make sure we got the add to group message.
		if (! hostcontext.fGotAddToGroup)
		{
			DPTEST_FAIL(hLog, "Didn't get add player to group message!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get add player to group)

		// Reset the context.
		hostcontext.fGotAddToGroup = FALSE;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for add player to group to be indicated on client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, nonhostcontext.hGotGroupMsgEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird add to group indications.
		nonhostcontext.fCanGetAddToGroup = FALSE;


#ifdef DEBUG
		// Make sure we got the indication (how else would we get here?).
		if (! nonhostcontext.fGotAddToGroup)
		{
			DPTEST_FAIL(hLog, "Didn't get add to group indication!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (didn't get add to group indication)
#endif // DEBUG

		// Reset the context.
		CloseHandle(nonhostcontext.hGotGroupMsgEvent);
		nonhostcontext.hGotGroupMsgEvent = NULL;
		nonhostcontext.fGotAddToGroup = FALSE;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enuming group members with NULL buffer on client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwNumIDs = 0;

		tr = pDP8Peer->DP8P_EnumGroupMembers(nonhostcontext.dpnidGroup, NULL,
											&dwNumIDs, 0);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Enuming group members with NULL buffer on client didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum group members)

		if (dwNumIDs != 1)
		{
			DPTEST_FAIL(hLog, "Number of IDs was not expected (%u != 1)!", 1, dwNumIDs);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (num IDs not expected)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enuming group members on client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_EnumGroupMembers(nonhostcontext.dpnidGroup, adpnidIDs,
											&dwNumIDs, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Enuming group members on client failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum group members)

		if (dwNumIDs != 1)
		{
			DPTEST_FAIL(hLog, "Number of IDs was not expected (%u != 0)!", 1, dwNumIDs);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (num IDs not expected)

		if (adpnidIDs[0] != nonhostcontext.dpnidHost)
		{
			DPTEST_FAIL(hLog, "Player ID returned was not expected ([0] %u/%x != %u/%x)!",
				4, adpnidIDs[0], adpnidIDs[0],
				nonhostcontext.dpnidHost, nonhostcontext.dpnidHost);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (player ID wrong)

		if ((adpnidIDs[1] != (DPNID) 0x666) ||
			(adpnidIDs[2] != (DPNID) 0x666))
		{
			DPTEST_FAIL(hLog, "Player ID buffer was overrun ([1] %u/%x, or [2] %u/%x!= 0x666)!",
				4, adpnidIDs[1], adpnidIDs[1],
				adpnidIDs[2], adpnidIDs[2]);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (buffer overrun)






		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing peer client object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing peer client object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure we got the destroy player messages.
		if (nonhostcontext.dpnidHost != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for host on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)

		if (nonhostcontext.dpnidClient != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for client on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)


		// Technically we should wait to make sure the host saw the client go away
		// as expected but that's more hassle than it's worth.  Just make sure he's
		// gone after Close() has returned.



#pragma TODO(vanceo, "Validate destroy group nametable unwind on both interfaces")


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing host object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8PeerHost->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing host object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure we got the destroy player messages.
		if (hostcontext.dpnidHost != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for host on host!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)

		if (hostcontext.dpnidClient != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for client on host!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing hosting DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8PeerHost->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release hosting DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8PeerHost);
		pDP8PeerHost = NULL;





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Peer);
		pDP8Peer = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE


	if (pDP8Peer != NULL)
	{
		delete (pDP8Peer);
		pDP8Peer = NULL;
	} // end if (have peer object)

	if (pDP8PeerHost != NULL)
	{
		delete (pDP8PeerHost);
		pDP8PeerHost = NULL;
	} // end if (have peer object)

	SAFE_RELEASE(pDP8Address);
	SAFE_CLOSEHANDLE(hostcontext.hGotGroupMsgEvent);
	SAFE_CLOSEHANDLE(nonhostcontext.hGotGroupMsgEvent);
	SAFE_CLOSEHANDLE(hostcontext.hClientCreatedEvent);
	ClearDoWorkList(&DoWorkList);
	SAFE_CLOSEHANDLE(hAsyncOpComplete);

	return (sr);
} // ParmVPeerExec_EnumGroupMembers
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVPeerExec_SetPeerInfo()"
//==================================================================================
// ParmVPeerExec_SetPeerInfo
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.1.19 - Peer SetPeerInfo parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVPeerExec_SetPeerInfo(HANDLE hLog)
{
	CTNSystemResult				sr;
	CTNTestResult				tr;
	PDIRECTPLAY8ADDRESS			pDP8Address = NULL;
	PARMVPSETPEERINFOCONTEXT	hostcontext;
	PARMVPSETPEERINFOCONTEXT	nonhostcontext;
	DPN_APPLICATION_DESC		dpnad;
	DPN_APPLICATION_DESC		dpnadCompare;
	DPN_PLAYER_INFO				dpnpi;
	DPN_PLAYER_INFO				dpnpiCompare;
	DPNHANDLE					dpnhSetPeerInfo;
	DP_DOWORKLIST				DoWorkList;
	DPNHANDLE					hAsyncOp;
	HANDLE						hAsyncOpComplete = NULL;

	ZeroMemory(&DoWorkList, sizeof(DP_DOWORKLIST));
	ZeroMemory(&hostcontext, sizeof (PARMVPSETPEERINFOCONTEXT));
	hostcontext.fHost = TRUE;

	ZeroMemory(&nonhostcontext, sizeof (PARMVPSETPEERINFOCONTEXT));
	//nonhostcontext.fHost = FALSE;


	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		hostcontext.pDP8Peer = new CWrapDP8Peer(hLog);
		if (hostcontext.pDP8Peer == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = hostcontext.pDP8Peer->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (LPVOID *) &pDP8Address, NULL);
		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't create DirectPlay8Address object!", 0);
			THROW_SYSTEMRESULT;
		} // end if (create failed)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting address object's SP to TCP/IP");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->SetSP(&CLSID_DP8SP_TCPIP);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting address object's SP to TCP/IP failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set SP)





/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting peer info with all NULLs and 0 flags using C++ macro");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = IDirectPlay8Peer_SetPeerInfo(hostcontext.pDP8Peer->m_pDP8Peer,
										NULL, NULL, NULL, 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Setting peer info with all NULLs and 0 flags using C++ macro didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set peer info)
*/


/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting peer info with all NULLs and 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = hostcontext.pDP8Peer->DP8P_SetPeerInfo(NULL, NULL, NULL, 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Setting peer info with all NULLs and 0 flags didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set peer info)
*/

		dpnhSetPeerInfo = (DPNHANDLE) 0x666;

/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting peer info with NULL player info structure");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = hostcontext.pDP8Peer->DP8P_SetPeerInfo(NULL, NULL, &dpnhSetPeerInfo, 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Setting peer info with NULL player info structure didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set peer info)

		if (dpnhSetPeerInfo != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async handle was modified (%x != 0x666)!",
				1, dpnhSetPeerInfo);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (handle was set)
*/

		ZeroMemory(&dpnpi, sizeof (DPN_PLAYER_INFO));
		dpnpi.dwSize = sizeof (DPN_PLAYER_INFO);
		//dpnpi.dwInfoFlags = 0;
		//dpnpi.pwszName = NULL;
		//dpnpi.pvData = NULL;
		//dpnpi.dwDataSize = 0;
		//dpnpi.dwPlayerFlags = 0;

		CopyMemory(&dpnpiCompare, &dpnpi, sizeof (DPN_PLAYER_INFO));

/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting peer info with NULL async op handle");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = hostcontext.pDP8Peer->DP8P_SetPeerInfo(&dpnpi, NULL, NULL, 0);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Setting peer info with NULL async op handle didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set peer info)

		if (memcmp(&dpnpiCompare, &dpnpi, sizeof (DPN_PLAYER_INFO)) != 0)
		{
			DPTEST_FAIL(hLog, "Player info structure was modified (structure at %x != structure at %x)!",
				2, &dpnpiCompare, &dpnpi);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (player info changed)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting peer info with invalid flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = hostcontext.pDP8Peer->DP8P_SetPeerInfo(&dpnpi, NULL, &dpnhSetPeerInfo,
													0x666);
		if (tr != DPNERR_INVALIDFLAGS)
		{
			DPTEST_FAIL(hLog, "Setting peer info with invalid flags structure didn't return expected error INVALIDFLAGS!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set peer info)

		if (memcmp(&dpnpiCompare, &dpnpi, sizeof (DPN_PLAYER_INFO)) != 0)
		{
			DPTEST_FAIL(hLog, "Player info structure was modified (structure at %x != structure at %x)!",
				2, &dpnpiCompare, &dpnpi);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (player info changed)

		if (dpnhSetPeerInfo != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async handle was modified (%x != 0x666)!",
				1, dpnhSetPeerInfo);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (handle was set)
*/



/* XBOX - SYNC operations not supported
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting peer info synchronously with async op handle");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = hostcontext.pDP8Peer->DP8P_SetPeerInfo(&dpnpi, NULL, &dpnhSetPeerInfo,
													DPNSETPEERINFO_SYNC);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Setting peer info synchronously with async op handle didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set peer info)

		if (memcmp(&dpnpiCompare, &dpnpi, sizeof (DPN_PLAYER_INFO)) != 0)
		{
			DPTEST_FAIL(hLog, "Player info structure was modified (structure at %x != structure at %x)!",
				2, &dpnpiCompare, &dpnpi);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (player info changed)

		if (dpnhSetPeerInfo != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async handle was modified (%x != 0x666)!",
				1, dpnhSetPeerInfo);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (handle was set)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting peer info before initialization");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = hostcontext.pDP8Peer->DP8P_SetPeerInfo(&dpnpi, NULL, &dpnhSetPeerInfo, 0);
		if (tr != DPNERR_UNINITIALIZED)
		{
			DPTEST_FAIL(hLog, "Setting peer info before initialization didn't return expected error UNINITIALIZED!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set peer info)

		if (memcmp(&dpnpiCompare, &dpnpi, sizeof (DPN_PLAYER_INFO)) != 0)
		{
			DPTEST_FAIL(hLog, "Player info structure was modified (structure at %x != structure at %x)!",
				2, &dpnpiCompare, &dpnpi);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (player info changed)

		if (dpnhSetPeerInfo != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async handle was modified (%x != 0x666)!",
				1, dpnhSetPeerInfo);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (handle was set)
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Initializing peer object with host context");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		hostcontext.hLog = hLog;

		tr = hostcontext.pDP8Peer->DP8P_Initialize(&hostcontext,
													ParmVPSetPeerInfoDPNMessageHandler,
													0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Initializing peer object with host context failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting peer info prior to connection");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = hostcontext.pDP8Peer->DP8P_SetPeerInfo(&dpnpi, NULL, &dpnhSetPeerInfo, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting peer info prior to connection failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set peer info)

		if (memcmp(&dpnpiCompare, &dpnpi, sizeof (DPN_PLAYER_INFO)) != 0)
		{
			DPTEST_FAIL(hLog, "Player info structure was modified (structure at %x != structure at %x)!",
				2, &dpnpiCompare, &dpnpi);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (player info changed)

		if (dpnhSetPeerInfo != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async handle was modified (%x != 0x666)!",
				1, dpnhSetPeerInfo);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (handle was set)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Hosting session");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		//dpnad.dwFlags = 0;
		//dpnad.guidInstance = GUID_NULL;
		dpnad.guidApplication = GUID_PARMV_PEER_GETAPPDESC;
		//dpnad.dwMaxPlayers = 0;
		//dpnad.dwCurrentPlayers = 0;
		//dpnad.pwszSessionName = NULL;
		//dpnad.pwszPassword = NULL;
		//dpnad.pvReservedData = NULL;
		//dpnad.dwReservedDataSize = 0;
		//dpnad.pvApplicationReservedData = NULL;
		//dpnad.dwApplicationReservedDataSize = 0;

		// Save what we're passing in to make sure it's not touched.
		CopyMemory(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC));

		tr = hostcontext.pDP8Peer->DP8P_Host(&dpnad,
											&pDP8Address,
											1,
											NULL,
											NULL,
											&(hostcontext.dpnidHost),
											0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't start hosting session!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't host)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		// Make sure we got the create player message.
		if (hostcontext.dpnidHost == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting peer info");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Expect the peer info message and async op completion.
		hostcontext.fCanGetPeerInfoUpdate = TRUE;
		CREATEEVENT_OR_THROW(hostcontext.hAsyncOpCompletedEvent,
							NULL, FALSE, FALSE, NULL);
		hostcontext.fAsyncOpCanComplete = TRUE;
		//hostcontext.pwszExpectedPeerInfoName = NULL;
		//hostcontext.pvExpectedPeerInfoData = NULL;
		//hostcontext.dwExpectedPeerInfoDataSize = 0;
		hostcontext.dwExpectedPeerInfoPlayerFlags = DPNPLAYER_LOCAL | DPNPLAYER_HOST;


		tr = hostcontext.pDP8Peer->DP8P_SetPeerInfo(&dpnpi, NULL, &dpnhSetPeerInfo, 0);
		if (tr != (HRESULT) DPNSUCCESS_PENDING)
		{
			DPTEST_FAIL(hLog, "Setting peer info didn't return expected PENDING success code!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set peer info)

		if (memcmp(&dpnpiCompare, &dpnpi, sizeof (DPN_PLAYER_INFO)) != 0)
		{
			DPTEST_FAIL(hLog, "Player info structure was modified (structure at %x != structure at %x)!",
				2, &dpnpiCompare, &dpnpi);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (player info changed)

		if (dpnhSetPeerInfo == (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "No async operation handle was returned!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (handle was not set)

		if (dpnhSetPeerInfo == NULL)
		{
			DPTEST_FAIL(hLog, "Async operation handle returned is NULL!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (handle was set to NULL)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for async op to complete");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 1;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apDP8Peers[0] = hostcontext.pDP8Peer->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hostcontext.hAsyncOpCompletedEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// The peer info message should have arrived by now.
		hostcontext.fCanGetPeerInfoUpdate = FALSE;

		// Prevent any weird async op completions.
		hostcontext.fAsyncOpCanComplete = FALSE;


#ifdef DEBUG
		// Make sure we got the indication (how else would we get here?).
		if (! hostcontext.fAsyncOpCompleted)
		{
			DPTEST_FAIL(hLog, "Didn't get async op completion!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (didn't get async op completion)
#endif // DEBUG

		// Make sure the completion indicated the same op handle that we were
		// returned.
		if (hostcontext.dpnhCompletedAsyncOp != dpnhSetPeerInfo)
		{
			DPTEST_FAIL(hLog, "Set peer info completed with different async op handle (%x != %x)!",
				2, hostcontext.dpnhCompletedAsyncOp, dpnhSetPeerInfo);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (async op handle is wrong)

		// Reset the context.
		hostcontext.fAsyncOpCompleted = FALSE;
		CloseHandle(hostcontext.hAsyncOpCompletedEvent);
		hostcontext.hAsyncOpCompletedEvent = NULL;


		// Make sure we got the peer info message.
		if (! hostcontext.fGotPeerInfoUpdate)
		{
			DPTEST_FAIL(hLog, "Didn't get peer info message!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get peer info)

		// Reset the context.
		hostcontext.fGotPeerInfoUpdate = FALSE;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = hostcontext.pDP8Peer->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing peer object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure we got the destroy player message.
		if (hostcontext.dpnidHost != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)

#pragma TODO(vanceo, "Validate destroy group nametable unwind")




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Re-initializing peer object with nonhost context");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		nonhostcontext.pDP8Peer = hostcontext.pDP8Peer;
		hostcontext.pDP8Peer = NULL;
		nonhostcontext.hLog = hLog;

		tr = nonhostcontext.pDP8Peer->DP8P_Initialize(&nonhostcontext,
													ParmVPSetPeerInfoDPNMessageHandler,
													0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Re-initializing peer object with context, 0 flags failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating new peer host object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Address->Release();
		pDP8Address = NULL;

		hostcontext.hLog = hLog;

		tr = ParmVCreatePeerHost(hLog, ParmVPSetPeerInfoDPNMessageHandler,
								&hostcontext,
								&dpnad,
								&(hostcontext.dpnidHost),
								&(hostcontext.pDP8Peer),
								&pDP8Address);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Creating peer host failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't create peer host)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Connecting peer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

// XBOX - Had to make connection asynchronous

		// Host should get the create player now.
		CREATEEVENT_OR_THROW(hostcontext.hClientCreatedEvent, NULL, FALSE, FALSE, NULL);
		SAFE_CLOSEHANDLE(hAsyncOpComplete);
		CREATEEVENT_OR_THROW(hAsyncOpComplete, NULL, FALSE, FALSE, NULL);

		// Even though it's synchronous, we'll still get a completion.  The async op
		// handle will be NULL, though.
		nonhostcontext.fConnectCanComplete = TRUE;

		tr = nonhostcontext.pDP8Peer->DP8P_Connect(&dpnad,
									pDP8Address,
									NULL,
									NULL,
									NULL,
									NULL,
									0,
									&(nonhostcontext.dpnidClient),
									hAsyncOpComplete,
									&hAsyncOp,
									0);

		if((tr != DPNSUCCESS_PENDING) && (tr != DPN_OK))
		{
			DPTEST_FAIL(hLog, "Couldn't connect! (error 0x%08x)", 1, tr);
			THROW_TESTRESULT;
		} // end if (couldn't connect)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for connect to complete on non-host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = nonhostcontext.pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = hostcontext.pDP8Peer->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hAsyncOpComplete))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird connects from completing.
		nonhostcontext.fConnectCanComplete = FALSE;

		// Make sure we saw the connect completion indication.
		if (! nonhostcontext.fConnectCompleted)
		{
			DPTEST_FAIL(hLog, "Didn't get connect complete indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (connect didn't complete)

		// Reset the context.
		nonhostcontext.fConnectCompleted = FALSE;

		// Make sure we got the create player messages.
		if (nonhostcontext.dpnidHost == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication for host on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player)

		if (nonhostcontext.dpnidClient == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication for client on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for create player to be indicated on host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = nonhostcontext.pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = hostcontext.pDP8Peer->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hostcontext.hClientCreatedEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Expect the peer info message on the host.
		hostcontext.dwExpectedPeerInfoPlayerFlags = 0;

		// Expect the peer info message on the client.
		nonhostcontext.dwExpectedPeerInfoPlayerFlags = DPNPLAYER_LOCAL;

/* XBOX - SYNC operations not supported
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting peer info synchronously on client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = nonhostcontext.pDP8Peer->DP8P_SetPeerInfo(&dpnpi, NULL, NULL,
														DPNSETPEERINFO_SYNC);

		// The peer info message should have arrived by now.
		nonhostcontext.fCanGetPeerInfoUpdate = FALSE;

		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting peer info synchronously on client failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set peer info)

		// Make sure we got the peer info message.
		if (! nonhostcontext.fGotPeerInfoUpdate)
		{
			DPTEST_FAIL(hLog, "Didn't get peer info message on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get peer info)

		// Reset the context.
		nonhostcontext.fGotPeerInfoUpdate = FALSE;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for peer info to be indicated on host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hostcontext.hGotPeerInfoUpdateEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird peer info indications.
		hostcontext.fCanGetPeerInfoUpdate = FALSE;


#ifdef DEBUG
		// Make sure we got the indication (how else would we get here?).
		if (! hostcontext.fGotPeerInfoUpdate)
		{
			DPTEST_FAIL(hLog, "Didn't get peer info indication!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (didn't get peer info indication)
#endif // DEBUG

		// Reset the context.
		CloseHandle(hostcontext.hGotPeerInfoUpdateEvent);
		hostcontext.hGotPeerInfoUpdateEvent = NULL;
		hostcontext.fGotPeerInfoUpdate = FALSE;
*/





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting peer info on client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dpnhSetPeerInfo = (DPNHANDLE) 0x666;

		// Expect the peer info message on the host.
		hostcontext.fCanGetPeerInfoUpdate = TRUE;
		CREATEEVENT_OR_THROW(hostcontext.hGotPeerInfoUpdateEvent,
							NULL, FALSE, FALSE, NULL);
		//hostcontext.pwszExpectedPeerInfoName = NULL;
		//hostcontext.pvExpectedPeerInfoData = NULL;
		//hostcontext.dwExpectedPeerInfoDataSize = 0;
		//hostcontext.dwExpectedPeerInfoPlayerFlags = 0;

		// Expect the peer info message and async op completion on the client.
		nonhostcontext.fCanGetPeerInfoUpdate = TRUE;
		CREATEEVENT_OR_THROW(nonhostcontext.hAsyncOpCompletedEvent,
							NULL, FALSE, FALSE, NULL);
		nonhostcontext.fAsyncOpCanComplete = TRUE;
		//nonhostcontext.pwszExpectedPeerInfoName = NULL;
		//nonhostcontext.pvExpectedPeerInfoData = NULL;
		//nonhostcontext.dwExpectedPeerInfoDataSize = 0;
		//nonhostcontext.dwExpectedPeerInfoPlayerFlags = DPNPLAYER_LOCAL;

		tr = nonhostcontext.pDP8Peer->DP8P_SetPeerInfo(&dpnpi, NULL,
														&dpnhSetPeerInfo, 0);
		if (tr != (HRESULT) DPNSUCCESS_PENDING)
		{
			DPTEST_FAIL(hLog, "Setting peer info on client didn't return expected PENDING success code!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set peer info)

		if (dpnhSetPeerInfo == (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "No async operation handle was returned!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (handle was not set)

		if (dpnhSetPeerInfo == NULL)
		{
			DPTEST_FAIL(hLog, "Async operation handle returned is NULL!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (handle was set to NULL)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for async op to complete on client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = nonhostcontext.pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = hostcontext.pDP8Peer->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, nonhostcontext.hAsyncOpCompletedEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// The peer info message should have arrived by now.
		nonhostcontext.fCanGetPeerInfoUpdate = FALSE;

		// Prevent any weird async op completions.
		nonhostcontext.fAsyncOpCanComplete = FALSE;


#ifdef DEBUG
		// Make sure we got the indication (how else would we get here?).
		if (! nonhostcontext.fAsyncOpCompleted)
		{
			DPTEST_FAIL(hLog, "Didn't get async op completion!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (didn't get async op completion)
#endif // DEBUG

		// Make sure the completion indicated the same op handle that we were
		// returned.
		if (nonhostcontext.dpnhCompletedAsyncOp != dpnhSetPeerInfo)
		{
			DPTEST_FAIL(hLog, "Set peer info completed with different async op handle (%x != %x)!",
				2, nonhostcontext.dpnhCompletedAsyncOp, dpnhSetPeerInfo);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (async op handle is wrong)

		// Reset the context.
		nonhostcontext.fAsyncOpCompleted = FALSE;
		CloseHandle(nonhostcontext.hAsyncOpCompletedEvent);
		nonhostcontext.hAsyncOpCompletedEvent = NULL;


		// Make sure we got the peer info message.
		if (! nonhostcontext.fGotPeerInfoUpdate)
		{
			DPTEST_FAIL(hLog, "Didn't get peer info message on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get peer info)

		// Reset the context.
		nonhostcontext.fGotPeerInfoUpdate = FALSE;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for peer info to be indicated on host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = nonhostcontext.pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = hostcontext.pDP8Peer->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hostcontext.hGotPeerInfoUpdateEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird peer info indications.
		hostcontext.fCanGetPeerInfoUpdate = FALSE;


#ifdef DEBUG
		// Make sure we got the indication (how else would we get here?).
		if (! hostcontext.fGotPeerInfoUpdate)
		{
			DPTEST_FAIL(hLog, "Didn't get peer info indication!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (didn't get peer info indication)
#endif // DEBUG

		// Reset the context.
		CloseHandle(hostcontext.hGotPeerInfoUpdateEvent);
		hostcontext.hGotPeerInfoUpdateEvent = NULL;
		hostcontext.fGotPeerInfoUpdate = FALSE;


		// Expect the peer info message on the host.
		hostcontext.dwExpectedPeerInfoPlayerFlags = DPNPLAYER_LOCAL | DPNPLAYER_HOST;

		// Expect the peer info message on the client.
		nonhostcontext.dwExpectedPeerInfoPlayerFlags = DPNPLAYER_HOST;

/* XBOX - SYNC operations not supported
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting peer info synchronously on host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = hostcontext.pDP8Peer->DP8P_SetPeerInfo(&dpnpi, NULL, NULL,
														DPNSETPEERINFO_SYNC);

		// The peer info message should have arrived by now.
		hostcontext.fCanGetPeerInfoUpdate = FALSE;

		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting peer info synchronously on client failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set peer info)

		// Make sure we got the peer info message.
		if (! hostcontext.fGotPeerInfoUpdate)
		{
			DPTEST_FAIL(hLog, "Didn't get peer info message on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get peer info)

		// Reset the context.
		hostcontext.fGotPeerInfoUpdate = FALSE;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for peer info to be indicated on client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, nonhostcontext.hGotPeerInfoUpdateEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird peer info indications.
		nonhostcontext.fCanGetPeerInfoUpdate = FALSE;


#ifdef DEBUG
		// Make sure we got the indication (how else would we get here?).
		if (! nonhostcontext.fGotPeerInfoUpdate)
		{
			DPTEST_FAIL(hLog, "Didn't get peer info indication!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (didn't get peer info indication)
#endif // DEBUG

		// Reset the context.
		CloseHandle(nonhostcontext.hGotPeerInfoUpdateEvent);
		nonhostcontext.hGotPeerInfoUpdateEvent = NULL;
		nonhostcontext.fGotPeerInfoUpdate = FALSE;
*/





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting peer info on host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dpnhSetPeerInfo = (DPNHANDLE) 0x666;

		// Expect the peer info message on the host.
		hostcontext.fCanGetPeerInfoUpdate = TRUE;
		CREATEEVENT_OR_THROW(hostcontext.hAsyncOpCompletedEvent,
							NULL, FALSE, FALSE, NULL);
		hostcontext.fAsyncOpCanComplete = TRUE;
		//hostcontext.pwszExpectedPeerInfoName = NULL;
		//hostcontext.pvExpectedPeerInfoData = NULL;
		//hostcontext.dwExpectedPeerInfoDataSize = 0;
		//hostcontext.dwExpectedPeerInfoPlayerFlags = DPNPLAYER_LOCAL | DPNPLAYER_HOST;

		// Expect the peer info message and async op completion on the client.
		nonhostcontext.fCanGetPeerInfoUpdate = TRUE;
		CREATEEVENT_OR_THROW(nonhostcontext.hGotPeerInfoUpdateEvent,
							NULL, FALSE, FALSE, NULL);
		//nonhostcontext.pwszExpectedPeerInfoName = NULL;
		//nonhostcontext.pvExpectedPeerInfoData = NULL;
		//nonhostcontext.dwExpectedPeerInfoDataSize = 0;
		//nonhostcontext.dwExpectedPeerInfoPlayerFlags = DPNPLAYER_LOCAL;

		tr = hostcontext.pDP8Peer->DP8P_SetPeerInfo(&dpnpi, NULL,
													&dpnhSetPeerInfo, 0);
		if (tr != (HRESULT) DPNSUCCESS_PENDING)
		{
			DPTEST_FAIL(hLog, "Setting peer info on host didn't return expected PENDING success code!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set peer info)

		if (dpnhSetPeerInfo == (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "No async operation handle was returned!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (handle was not set)

		if (dpnhSetPeerInfo == NULL)
		{
			DPTEST_FAIL(hLog, "Async operation handle returned is NULL!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (handle was set to NULL)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for async op to complete on host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = nonhostcontext.pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = hostcontext.pDP8Peer->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hostcontext.hAsyncOpCompletedEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// The peer info message should have arrived by now.
		hostcontext.fCanGetPeerInfoUpdate = FALSE;

		// Prevent any weird async op completions.
		hostcontext.fAsyncOpCanComplete = FALSE;


#ifdef DEBUG
		// Make sure we got the indication (how else would we get here?).
		if (! hostcontext.fAsyncOpCompleted)
		{
			DPTEST_FAIL(hLog, "Didn't get async op completion!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (didn't get async op completion)
#endif // DEBUG

		// Make sure the completion indicated the same op handle that we were
		// returned.
		if (hostcontext.dpnhCompletedAsyncOp != dpnhSetPeerInfo)
		{
			DPTEST_FAIL(hLog, "Set peer info completed with different async op handle (%x != %x)!",
				2, hostcontext.dpnhCompletedAsyncOp, dpnhSetPeerInfo);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (async op handle is wrong)

		// Reset the context.
		hostcontext.fAsyncOpCompleted = FALSE;
		CloseHandle(hostcontext.hAsyncOpCompletedEvent);
		hostcontext.hAsyncOpCompletedEvent = NULL;


		// Make sure we got the peer info message.
		if (! hostcontext.fGotPeerInfoUpdate)
		{
			DPTEST_FAIL(hLog, "Didn't get peer info message on host!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get peer info)

		// Reset the context.
		hostcontext.fGotPeerInfoUpdate = FALSE;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for peer info to be indicated on client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = nonhostcontext.pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = hostcontext.pDP8Peer->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, nonhostcontext.hGotPeerInfoUpdateEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird peer info indications.
		nonhostcontext.fCanGetPeerInfoUpdate = FALSE;


#ifdef DEBUG
		// Make sure we got the indication (how else would we get here?).
		if (! nonhostcontext.fGotPeerInfoUpdate)
		{
			DPTEST_FAIL(hLog, "Didn't get peer info indication!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (didn't get peer info indication)
#endif // DEBUG

		// Reset the context.
		CloseHandle(nonhostcontext.hGotPeerInfoUpdateEvent);
		nonhostcontext.hGotPeerInfoUpdateEvent = NULL;
		nonhostcontext.fGotPeerInfoUpdate = FALSE;






		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing peer client object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = nonhostcontext.pDP8Peer->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing peer client object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure we got the destroy player messages.
		if (nonhostcontext.dpnidHost != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for host on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)

		if (nonhostcontext.dpnidClient != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for client on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)


		// Technically we should wait to make sure the host saw the client go away
		// as expected but that's more hassle than it's worth.  Just make sure he's
		// gone after Close() has returned.




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing host object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = hostcontext.pDP8Peer->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing host object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure we got the destroy player messages.
		if (hostcontext.dpnidHost != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for host on host!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)

		if (hostcontext.dpnidClient != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for client on host!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing hosting DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = hostcontext.pDP8Peer->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release hosting DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (hostcontext.pDP8Peer);
		hostcontext.pDP8Peer = NULL;






		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = nonhostcontext.pDP8Peer->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (nonhostcontext.pDP8Peer);
		nonhostcontext.pDP8Peer = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE


	if (nonhostcontext.pDP8Peer != NULL)
	{
		delete (nonhostcontext.pDP8Peer);
		nonhostcontext.pDP8Peer = NULL;
	} // end if (have peer object)

	if (hostcontext.pDP8Peer != NULL)
	{
		delete (hostcontext.pDP8Peer);
		hostcontext.pDP8Peer = NULL;
	} // end if (have peer object)

	SAFE_RELEASE(pDP8Address);
	SAFE_CLOSEHANDLE(hostcontext.hAsyncOpCompletedEvent);
	SAFE_CLOSEHANDLE(nonhostcontext.hAsyncOpCompletedEvent);
	SAFE_CLOSEHANDLE(hostcontext.hGotPeerInfoUpdateEvent);
	SAFE_CLOSEHANDLE(nonhostcontext.hGotPeerInfoUpdateEvent);
	SAFE_CLOSEHANDLE(hostcontext.hClientCreatedEvent);
	ClearDoWorkList(&DoWorkList);
	SAFE_CLOSEHANDLE(hAsyncOpComplete);

	return (sr);
} // ParmVPeerExec_SetPeerInfo
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVPeerExec_GetPeerInfo()"
//==================================================================================
// ParmVPeerExec_GetPeerInfo
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.1.20 - Peer GetPeerInfo parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVPeerExec_GetPeerInfo(HANDLE hLog)
{
	CTNSystemResult				sr;
	CTNTestResult				tr;
	PWRAPDP8PEER				pDP8Peer = NULL;
	PWRAPDP8PEER				pDP8PeerHost = NULL;
	PDIRECTPLAY8ADDRESS			pDP8Address = NULL;
	PARMVPGETPEERINFOCONTEXT	hostcontext;
	PARMVPGETPEERINFOCONTEXT	nonhostcontext;
	DPN_APPLICATION_DESC		dpnad;
	DPN_APPLICATION_DESC		dpnadCompare;
	PDPN_PLAYER_INFO			pdpnpi = NULL;
	DPN_PLAYER_INFO				dpnpi;
	DWORD						dwSize;
	DWORD						dwExpectedSize;
	DP_DOWORKLIST				DoWorkList;
	DPNHANDLE					hAsyncOp;
	HANDLE						hAsyncOpComplete = NULL;

	ZeroMemory(&DoWorkList, sizeof(DP_DOWORKLIST));
	ZeroMemory(&hostcontext, sizeof (PARMVPGETPEERINFOCONTEXT));
	hostcontext.fHost = TRUE;

	ZeroMemory(&nonhostcontext, sizeof (PARMVPGETPEERINFOCONTEXT));
	//nonhostcontext.fHost = FALSE;


	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Peer = new CWrapDP8Peer(hLog);
		if (pDP8Peer == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8Peer->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (LPVOID *) &pDP8Address, NULL);
		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't create DirectPlay8Address object!", 0);
			THROW_SYSTEMRESULT;
		} // end if (create failed)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting address object's SP to TCP/IP");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->SetSP(&CLSID_DP8SP_TCPIP);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting address object's SP to TCP/IP failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set SP)




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting peer 0 info with NULLs and 0 flags using C++ macro");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = IDirectPlay8Peer_GetPeerInfo(pDP8Peer->m_pDP8Peer, 0, NULL, NULL, 0);
		if (tr != DPNERR_INVALIDPLAYER)
		{
			DPTEST_FAIL(hLog, "Getting peer 0 info with NULLs and 0 flags using C++ macro didn't return expected error INVALIDPLAYER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get peer info)
*/


/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting peer 0 info with NULLs and 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_GetPeerInfo(0, NULL, NULL, 0);
		if (tr != DPNERR_INVALIDPLAYER)
		{
			DPTEST_FAIL(hLog, "Getting peer 0 info with NULLs and 0 flags didn't return expected error INVALIDPLAYER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get peer info)
*/




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting peer info with NULL buffer and non-zero size");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwSize = 666;

		// Use 0x666 to avoid DPlay's player ID == 0 check.
		tr = pDP8Peer->DP8P_GetPeerInfo((DPNID) 0x666, NULL, &dwSize, 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Getting peer info with NULL buffer and non-zero size didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get peer info)

		if (dwSize != 666)
		{
			DPTEST_FAIL(hLog, "Size was changed (%u != 666)!", 1, dwSize);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (size was touched)
*/

		dwSize = 0;

/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting peer info with invalid flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_GetPeerInfo((DPNID) 0x666, NULL, &dwSize, 0x666);
		if (tr != DPNERR_INVALIDFLAGS)
		{
			DPTEST_FAIL(hLog, "Getting peer info with invalid flags didn't return expected error INVALIDFLAGS!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get peer info)

		if (dwSize != 0)
		{
			DPTEST_FAIL(hLog, "Size was changed (%u != 0)!", 1, dwSize);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (size is not 0)
*/


/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting peer info before initialization");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_GetPeerInfo((DPNID) 0x666, NULL, &dwSize, 0);
		if (tr != DPNERR_UNINITIALIZED)
		{
			DPTEST_FAIL(hLog, "Getting peer info before initialization didn't return expected error UNINITIALIZED!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get peer info)

		if (dwSize != 0)
		{
			DPTEST_FAIL(hLog, "Size was changed (%u != 0)!", 1, dwSize);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (size is not 0)
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Initializing peer object with host context");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		hostcontext.hLog = hLog;

		tr = pDP8Peer->DP8P_Initialize(&hostcontext,
										ParmVPGetPeerInfoDPNMessageHandler, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Initializing peer object with host context failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting peer info prior to connection");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_GetPeerInfo((DPNID) 0x666, NULL, &dwSize, 0);
		if (tr != DPNERR_NOCONNECTION)
		{
			DPTEST_FAIL(hLog, "Getting peer info prior to connection didn't return expected error NOCONNECTION!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get peer info)

		if (dwSize != 0)
		{
			DPTEST_FAIL(hLog, "Size was changed (%u != 0)!", 1, dwSize);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (size is not 0)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Hosting session");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		//dpnad.dwFlags = 0;
		//dpnad.guidInstance = GUID_NULL;
		dpnad.guidApplication = GUID_PARMV_PEER_GETAPPDESC;
		//dpnad.dwMaxPlayers = 0;
		//dpnad.dwCurrentPlayers = 0;
		//dpnad.pwszSessionName = NULL;
		//dpnad.pwszPassword = NULL;
		//dpnad.pvReservedData = NULL;
		//dpnad.dwReservedDataSize = 0;
		//dpnad.pvApplicationReservedData = NULL;
		//dpnad.dwApplicationReservedDataSize = 0;

		// Save what we're passing in to make sure it's not touched.
		CopyMemory(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC));

		tr = pDP8Peer->DP8P_Host(&dpnad,
								&pDP8Address,
								1,
								NULL,
								NULL,
								&(hostcontext.dpnidHost),
								0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't start hosting session!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't host)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		// Make sure we got the create player message.
		if (hostcontext.dpnidHost == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting peer info for invalid player");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_GetPeerInfo((DPNID) 0x666, NULL, &dwSize, 0);
		if (tr != DPNERR_INVALIDPLAYER)
		{
			DPTEST_FAIL(hLog, "Getting peer info for invalid player didn't return expected error INVALIDPLAYER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get peer info)

		if (dwSize != 0)
		{
			DPTEST_FAIL(hLog, "Size was changed (%u != 0)!", 1, dwSize);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (size is not 0)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting peer info with NULL buffer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwExpectedSize = sizeof (DPN_PLAYER_INFO);

		tr = pDP8Peer->DP8P_GetPeerInfo(hostcontext.dpnidHost, NULL, &dwSize, 0);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Getting peer info with NULL buffer didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get peer info)

		if (dwSize != dwExpectedSize)
		{
			DPTEST_FAIL(hLog, "Size was not expected (%u != %u)!", 2, dwSize, dwExpectedSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (size is not expected)


		LOCALALLOC_OR_THROW(PDPN_PLAYER_INFO, pdpnpi, dwSize + BUFFERPADDING_SIZE);

		FillWithDWord((((PBYTE) pdpnpi) + sizeof (DWORD)),
						(dwSize - sizeof (DWORD) + BUFFERPADDING_SIZE),
						DONT_TOUCH_MEMORY_PATTERN);

		pdpnpi->dwSize = 0;

/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting peer info with peer info size of 0");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_GetPeerInfo(hostcontext.dpnidHost, pdpnpi, &dwSize, 0);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Getting peer info using buffer with peer info size of 0 didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get peer info)

		if (dwSize != dwExpectedSize)
		{
			DPTEST_FAIL(hLog, "Size returned was unexpected (%u != %u)!", 2, dwSize, dwExpectedSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (size is not expected)

		// Make sure the buffer was not modified or overrun.
		if ((pdpnpi->dwSize != 0) ||
			(! IsFilledWithDWord((((PBYTE) pdpnpi) + sizeof (DWORD)), (dwSize - sizeof (DWORD) + BUFFERPADDING_SIZE), DONT_TOUCH_MEMORY_PATTERN)))
		{
			DPTEST_FAIL(hLog, "The %u byte player info buffer (at %x) was modified or overrun!",
				2, dwSize, pdpnpi);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (buffer was overrun)
*/

		pdpnpi->dwSize = sizeof (DPN_PLAYER_INFO) + 1;

/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting peer info with peer info size too large");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_GetPeerInfo(hostcontext.dpnidHost, pdpnpi, &dwSize, 0);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Getting peer info using buffer with peer info size too large didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get peer info)

		if (dwSize != dwExpectedSize)
		{
			DPTEST_FAIL(hLog, "Size returned was unexpected (%u != %u)!", 2, dwSize, dwExpectedSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (size is not expected)

		// Make sure the buffer was not modified or overrun.
		if ((pdpnpi->dwSize != (sizeof (DPN_PLAYER_INFO) + 1)) ||
			(! IsFilledWithDWord((((PBYTE) pdpnpi) + sizeof (DWORD)), (dwSize - sizeof (DWORD) + BUFFERPADDING_SIZE), DONT_TOUCH_MEMORY_PATTERN)))
		{
			DPTEST_FAIL(hLog, "The %u byte player info buffer (at %x) was modified or overrun!",
				2, dwSize, pdpnpi);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (buffer was overrun)
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting peer info");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pdpnpi->dwSize = sizeof (DPN_PLAYER_INFO);

		tr = pDP8Peer->DP8P_GetPeerInfo(hostcontext.dpnidHost, pdpnpi, &dwSize, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting peer info failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get peer info)

		if (dwSize != dwExpectedSize)
		{
			DPTEST_FAIL(hLog, "Size returned was unexpected (%u != %u)!", 2, dwSize, dwExpectedSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (size is not expected)


		// Make sure the structure returned was expected.

		ZeroMemory(&dpnpi, sizeof (DPN_PLAYER_INFO));
		dpnpi.dwSize = sizeof (DPN_PLAYER_INFO);
		dpnpi.dwInfoFlags = DPNINFO_NAME | DPNINFO_DATA;
		//dpnpi.pwszName = NULL;
		//dpnpi.pvData = NULL;
		//dpnpi.dwDataSize = 0;
		dpnpi.dwPlayerFlags = DPNPLAYER_LOCAL | DPNPLAYER_HOST;

		tr = ParmVComparePlayerInfo(hLog, pdpnpi, &dpnpi);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Comparing player info buffer %x with expected %x failed!",
				2, pdpnpi, &dpnpi);
			THROW_TESTRESULT;
		} // end if (failed comparison)

		// Make sure the buffer was not overrun.
		if (! IsFilledWithDWord((pdpnpi + 1), BUFFERPADDING_SIZE, DONT_TOUCH_MEMORY_PATTERN))
		{
			DPTEST_FAIL(hLog, "The %u byte player info buffer (at %x) was modified or overrun!",
				2, dwSize, pdpnpi);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (buffer was overrun)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing peer object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure we got the destroy player message.
		if (hostcontext.dpnidHost != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)

#pragma TODO(vanceo, "Validate destroy group nametable unwind")




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Re-initializing peer object with nonhost context");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		nonhostcontext.hLog = hLog;

		tr = pDP8Peer->DP8P_Initialize(&nonhostcontext,
										ParmVPGetPeerInfoDPNMessageHandler,
										0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Re-initializing peer object with context, 0 flags failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating new peer host object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Address->Release();
		pDP8Address = NULL;

		hostcontext.hLog = hLog;

		tr = ParmVCreatePeerHost(hLog, ParmVPGetPeerInfoDPNMessageHandler,
								&hostcontext,
								&dpnad,
								&(hostcontext.dpnidHost),
								&pDP8PeerHost,
								&pDP8Address);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Creating peer host failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't create peer host)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Connecting peer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

// XBOX - Had to make connection asynchronous

		// Host should get the create player now.
		CREATEEVENT_OR_THROW(hostcontext.hClientCreatedEvent, NULL, FALSE, FALSE, NULL);
		SAFE_CLOSEHANDLE(hAsyncOpComplete);
		CREATEEVENT_OR_THROW(hAsyncOpComplete, NULL, FALSE, FALSE, NULL);

		// Even though it's synchronous, we'll still get a completion.  The async op
		// handle will be NULL, though.
		nonhostcontext.fConnectCanComplete = TRUE;

		tr = pDP8Peer->DP8P_Connect(&dpnad,
									pDP8Address,
									NULL,
									NULL,
									NULL,
									NULL,
									0,
									&(nonhostcontext.dpnidClient),
									hAsyncOpComplete,
									&hAsyncOp,
									0);

		if((tr != DPNSUCCESS_PENDING) && (tr != DPN_OK))
		{
			DPTEST_FAIL(hLog, "Couldn't connect! (error 0x%08x)", 1, tr);
			THROW_TESTRESULT;
		} // end if (couldn't connect)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for connect to complete on non-host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hAsyncOpComplete))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird connects from completing.
		nonhostcontext.fConnectCanComplete = FALSE;

		// Make sure we saw the connect completion indication.
		if (! nonhostcontext.fConnectCompleted)
		{
			DPTEST_FAIL(hLog, "Didn't get connect complete indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (connect didn't complete)

		// Reset the context.
		nonhostcontext.fConnectCompleted = FALSE;

		// Make sure we got the create player messages.
		if (nonhostcontext.dpnidHost == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication for host on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player)

		if (nonhostcontext.dpnidClient == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication for client on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for create player to be indicated on host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hostcontext.hClientCreatedEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting host's peer info with NULL buffer on client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwSize = 0;

		tr = pDP8Peer->DP8P_GetPeerInfo(nonhostcontext.dpnidHost, NULL, &dwSize, 0);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Getting host's peer info with NULL buffer on client didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get peer info)

		if (dwSize != dwExpectedSize)
		{
			DPTEST_FAIL(hLog, "Size was not expected (%u != %u)!", 2, dwSize, dwExpectedSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (size is not expected)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting host's peer info on client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		FillWithDWord((((PBYTE) pdpnpi) + sizeof (DWORD)),
						(dwSize - sizeof (DWORD) + BUFFERPADDING_SIZE),
						DONT_TOUCH_MEMORY_PATTERN);

		pdpnpi->dwSize = sizeof (DPN_PLAYER_INFO);

		tr = pDP8Peer->DP8P_GetPeerInfo(nonhostcontext.dpnidHost, pdpnpi, &dwSize, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting host's peer info on client failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get peer info)

		if (dwSize != dwExpectedSize)
		{
			DPTEST_FAIL(hLog, "Size returned was unexpected (%u != %u)!", 2, dwSize, dwExpectedSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (size is not expected)


		// Make sure the structure returned was expected.

		ZeroMemory(&dpnpi, sizeof (DPN_PLAYER_INFO));
		dpnpi.dwSize = sizeof (DPN_PLAYER_INFO);
		dpnpi.dwInfoFlags = DPNINFO_NAME | DPNINFO_DATA;
		//dpnpi.pwszName = NULL;
		//dpnpi.pvData = NULL;
		//dpnpi.dwDataSize = 0;
		dpnpi.dwPlayerFlags = DPNPLAYER_HOST;

		tr = ParmVComparePlayerInfo(hLog, pdpnpi, &dpnpi);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Comparing player info buffer %x with expected %x failed!",
				2, pdpnpi, &dpnpi);
			THROW_TESTRESULT;
		} // end if (failed comparison)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing peer client object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing peer client object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure we got the destroy player messages.
		if (nonhostcontext.dpnidHost != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for host on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)

		if (nonhostcontext.dpnidClient != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for client on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)


		// Technically we should wait to make sure the host saw the client go away
		// as expected but that's more hassle than it's worth.  Just make sure he's
		// gone after Close() has returned.




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing host object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8PeerHost->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing host object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure we got the destroy player messages.
		if (hostcontext.dpnidHost != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for host on host!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)

		if (hostcontext.dpnidClient != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for client on host!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing hosting DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8PeerHost->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release hosting DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8PeerHost);
		pDP8PeerHost = NULL;





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Peer);
		pDP8Peer = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE


	if (pDP8Peer != NULL)
	{
		delete (pDP8Peer);
		pDP8Peer = NULL;
	} // end if (have peer object)

	if (pDP8PeerHost != NULL)
	{
		delete (pDP8PeerHost);
		pDP8PeerHost = NULL;
	} // end if (have peer object)

	SAFE_LOCALFREE(pdpnpi);
	SAFE_RELEASE(pDP8Address);
	SAFE_CLOSEHANDLE(hostcontext.hClientCreatedEvent);
	ClearDoWorkList(&DoWorkList);
	SAFE_CLOSEHANDLE(hAsyncOpComplete);

	return (sr);
} // ParmVPeerExec_GetPeerInfo
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVPeerExec_GetPeerAddress()"
//==================================================================================
// ParmVPeerExec_GetPeerAddress
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.1.21 - Peer GetPeerAddress parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVPeerExec_GetPeerAddress(HANDLE hLog)
{
	CTNSystemResult					sr;
	CTNTestResult					tr;
	PWRAPDP8PEER					pDP8Peer = NULL;
	PWRAPDP8PEER					pDP8PeerHost = NULL;
	PDIRECTPLAY8ADDRESS				pDP8HostAddress = NULL;
	PDIRECTPLAY8ADDRESS				pDP8HostAddressCompare = NULL;
	PDIRECTPLAY8ADDRESS				pDP8ReturnedAddress = NULL;
	PARMVPGETPEERADDRESSCONTEXT		hostcontext;
	PARMVPGETPEERADDRESSCONTEXT		nonhostcontext;
	DPN_APPLICATION_DESC			dpnad;
	DPN_APPLICATION_DESC			dpnadCompare;
	DP_DOWORKLIST					DoWorkList;
	DPNHANDLE						hAsyncOp;
	HANDLE							hAsyncOpComplete = NULL;

	ZeroMemory(&DoWorkList, sizeof(DP_DOWORKLIST));
	ZeroMemory(&hostcontext, sizeof (PARMVPGETPEERADDRESSCONTEXT));
	hostcontext.fHost = TRUE;

	ZeroMemory(&nonhostcontext, sizeof (PARMVPGETPEERADDRESSCONTEXT));
	//nonhostcontext.fHost = FALSE;


	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Peer = new CWrapDP8Peer(hLog);
		if (pDP8Peer == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8Peer->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)




/* BUGBUG - Add back later...
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (LPVOID *) &pDP8HostAddress, NULL);
		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't create DirectPlay8Address object!", 0);
			THROW_SYSTEMRESULT;
		} // end if (create failed)
*/


/* BUGBUG - Add back later...
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting address object's SP to TCP/IP");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8HostAddress->SetSP(&CLSID_DP8SP_TCPIP);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting address object's SP to TCP/IP failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set SP)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting peer 0 address with NULL and 0 flags using C++ macro");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = IDirectPlay8Peer_GetPeerAddress(pDP8Peer->m_pDP8Peer, 0, NULL, 0);
		if (tr != DPNERR_INVALIDPLAYER)
		{
			DPTEST_FAIL(hLog, "Getting peer 0 address with NULL and 0 flags using C++ macro didn't return expected error INVALIDPLAYER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get peer address)
*/


/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting peer 0 address with NULL and 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_GetPeerAddress(0, NULL, 0);
		if (tr != DPNERR_INVALIDPLAYER)
		{
			DPTEST_FAIL(hLog, "Getting peer 0 address with NULL and 0 flags didn't return expected error INVALIDPLAYER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get peer address)
*/




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting peer address with NULL buffer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Use 0x666 to avoid DPlay's player ID == 0 check.
		tr = pDP8Peer->DP8P_GetPeerAddress((DPNID) 0x666, NULL, 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Getting peer address with NULL buffer didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get peer address)
*/




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting peer address with invalid flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_GetPeerAddress((DPNID) 0x666, &pDP8ReturnedAddress, 0x666);
		if (tr != DPNERR_INVALIDFLAGS)
		{
			DPTEST_FAIL(hLog, "Getting peer address with invalid flags didn't return expected error INVALIDFLAGS!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get peer address)

		if (pDP8ReturnedAddress != NULL)
		{
			DPTEST_FAIL(hLog, "Address was changed (%u != NULL)!", 1, pDP8ReturnedAddress);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (address is not NULL)
*/


/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting peer address before initialization");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_GetPeerAddress((DPNID) 0x666, &pDP8ReturnedAddress, 0);
		if (tr != DPNERR_UNINITIALIZED)
		{
			DPTEST_FAIL(hLog, "Getting peer address before initialization didn't return expected error UNINITIALIZED!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get peer address)

		if (pDP8ReturnedAddress != NULL)
		{
			DPTEST_FAIL(hLog, "Address was changed (%u != NULL)!", 1, pDP8ReturnedAddress);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (address is not NULL)
*/



/* BUGBUG - Add back later...
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Initializing peer object with host context");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		hostcontext.hLog = hLog;

		tr = pDP8Peer->DP8P_Initialize(&hostcontext,
										ParmVPGetPeerAddressDPNMessageHandler, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Initializing peer object with host context failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)
*/


/* BUGBUG - Add back later...
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting peer address prior to connection");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_GetPeerAddress((DPNID) 0x666, &pDP8ReturnedAddress, 0);
		if (tr != DPNERR_NOCONNECTION)
		{
			DPTEST_FAIL(hLog, "Getting peer address prior to connection didn't return expected error NOCONNECTION!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get peer address)

		if (pDP8ReturnedAddress != NULL)
		{
			DPTEST_FAIL(hLog, "Address was changed (%u != NULL)!", 1, pDP8ReturnedAddress);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (address is not NULL)
*/



/* BUGBUG - Add back later...
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Saving device address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8HostAddress->Duplicate(&pDP8HostAddressCompare);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't duplicate device address object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't duplicate device address object)
*/

		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		//dpnad.dwFlags = 0;
		//dpnad.guidInstance = GUID_NULL;
		dpnad.guidApplication = GUID_PARMV_PEER_GETAPPDESC;
		//dpnad.dwMaxPlayers = 0;
		//dpnad.dwCurrentPlayers = 0;
		//dpnad.pwszSessionName = NULL;
		//dpnad.pwszPassword = NULL;
		//dpnad.pvReservedData = NULL;
		//dpnad.dwReservedDataSize = 0;
		//dpnad.pvApplicationReservedData = NULL;
		//dpnad.dwApplicationReservedDataSize = 0;

		// Save what we're passing in to make sure it's not touched.
		CopyMemory(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC));

/* BUGBUG - Add back later...
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Hosting session");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Host(&dpnad,
								&pDP8HostAddress,
								1,
								NULL,
								NULL,
								&(hostcontext.dpnidHost),
								0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't start hosting session!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't host)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		tr = pDP8HostAddress->IsEqual(pDP8HostAddressCompare);
		if (tr != DPNSUCCESS_EQUAL)
		{
			DPTEST_FAIL(hLog, "Device address object was modified (0x%08x != 0x%08x)!",
				2, pDP8HostAddress, pDP8HostAddressCompare);
			THROW_TESTRESULT;
		} // end if (addresses aren't equal)

		// Make sure we got the create player message.
		if (hostcontext.dpnidHost == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player)
*/




/* BUGBUG - Add back later...
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting peer address for invalid player");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_GetPeerAddress((DPNID) 0x666, &pDP8ReturnedAddress, 0);
		if (tr != DPNERR_INVALIDPLAYER)
		{
			DPTEST_FAIL(hLog, "Getting peer address for invalid player didn't return expected error INVALIDPLAYER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get peer address)

		if (pDP8ReturnedAddress != NULL)
		{
			DPTEST_FAIL(hLog, "Address was changed (%u != NULL)!", 1, pDP8ReturnedAddress);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (address is not NULL)
*/



/* BUGBUG - Add back later...
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting local hosting peer's address");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_GetPeerAddress(hostcontext.dpnidHost,
										&pDP8ReturnedAddress, 0);
		if (tr != DPNERR_INVALIDPLAYER)
		{
			DPTEST_FAIL(hLog, "Getting local hosting peer's address didn't return expected error INVALIDPLAYER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get peer address)

		if (pDP8ReturnedAddress != NULL)
		{
			DPTEST_FAIL(hLog, "Address was changed (%u != NULL)!", 1, pDP8ReturnedAddress);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (address is not NULL)
*/



/* BUGBUG - Add back later...
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing peer object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure we got the destroy player message.
		if (hostcontext.dpnidHost != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)
*/




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Re-initializing peer object with nonhost context");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		nonhostcontext.hLog = hLog;

		tr = pDP8Peer->DP8P_Initialize(&nonhostcontext,
										ParmVPGetPeerAddressDPNMessageHandler,
										0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Re-initializing peer object with context, 0 flags failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating new peer host object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

/* BUGBUG - Add back later...
		pDP8HostAddress->Release();
		pDP8HostAddress = NULL;
*/

		hostcontext.hLog = hLog;

		tr = ParmVCreatePeerHost(hLog, ParmVPGetPeerAddressDPNMessageHandler,
								&hostcontext,
								&dpnad,
								&(hostcontext.dpnidHost),
								&pDP8PeerHost,
								&pDP8HostAddress);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Creating peer host failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't create peer host)




/* BUGBUG - Add back later...
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Saving new host address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8HostAddressCompare->Release();
		pDP8HostAddressCompare = NULL;

		tr = pDP8HostAddress->Duplicate(&pDP8HostAddressCompare);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't duplicate host address object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't duplicate host address object)
*/

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Connecting peer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

// XBOX - Had to make connection asynchronous

		// Host should get the create player now.
		CREATEEVENT_OR_THROW(hostcontext.hClientCreatedEvent, NULL, FALSE, FALSE, NULL);
		SAFE_CLOSEHANDLE(hAsyncOpComplete);
		CREATEEVENT_OR_THROW(hAsyncOpComplete, NULL, FALSE, FALSE, NULL);

		// Even though it's synchronous, we'll still get a completion.  The async op
		// handle will be NULL, though.
		nonhostcontext.fConnectCanComplete = TRUE;

		tr = pDP8Peer->DP8P_Connect(&dpnad,
									pDP8HostAddress,
									NULL,
									NULL,
									NULL,
									NULL,
									0,
									&(nonhostcontext.dpnidClient),
									hAsyncOpComplete,
									&hAsyncOp,
									0);

		if((tr != DPNSUCCESS_PENDING) && (tr != DPN_OK))
		{
			DPTEST_FAIL(hLog, "Couldn't connect! (error 0x%08x)", 1, tr);
			THROW_TESTRESULT;
		} // end if (couldn't connect)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

/* BUGBUG - Add back later...
		tr = pDP8HostAddress->IsEqual(pDP8HostAddressCompare);
		if (tr != DPNSUCCESS_EQUAL)
		{
			DPTEST_FAIL(hLog, "Host address object was modified (0x%08x != 0x%08x)!",
				2, pDP8HostAddress, pDP8HostAddressCompare);
			THROW_TESTRESULT;
		} // end if (addresses aren't equal)
*/

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for connect to complete on non-host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hAsyncOpComplete))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird connects from completing.
		nonhostcontext.fConnectCanComplete = FALSE;

		// Make sure we saw the connect completion indication.
		if (! nonhostcontext.fConnectCompleted)
		{
			DPTEST_FAIL(hLog, "Didn't get connect complete indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (connect didn't complete)

		// Reset the context.
		nonhostcontext.fConnectCompleted = FALSE;

		// Make sure we got the create player messages.
		if (nonhostcontext.dpnidHost == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication for host on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player)

		if (nonhostcontext.dpnidClient == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication for client on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for create player to be indicated on host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hostcontext.hClientCreatedEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);



/* BUGBUG - Add back later...
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting host's peer address on client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_GetPeerAddress(nonhostcontext.dpnidHost,
											&pDP8ReturnedAddress, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting host's peer address on client failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get peer address)

		if (pDP8ReturnedAddress == NULL)
		{
			DPTEST_FAIL(hLog, "No address was returned!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (no address returned)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Ensuring returned host address is expected");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8ReturnedAddress->IsEqual(pDP8HostAddress);
		if (tr != DPNSUCCESS_EQUAL)
		{
			DPTEST_FAIL(hLog, "Host's address returned doesn't match expected (0x%08x != 0x%08x)!",
				2, pDP8ReturnedAddress, pDP8HostAddress);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (addresses don't match)
*/


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting client's peer address on host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

/* BUGBUG - Add back later...
		pDP8ReturnedAddress->Release();
		pDP8ReturnedAddress = NULL;
*/

		tr = pDP8PeerHost->DP8P_GetPeerAddress(hostcontext.dpnidClient,
												&pDP8ReturnedAddress, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting client's peer address on host failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get peer address)

		if (pDP8ReturnedAddress == NULL)
		{
			DPTEST_FAIL(hLog, "No address was returned)!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (no address returned)


#pragma TODO(vanceo, "Validate the address")
		DPTEST_TRACE(hLog, "Client's peer address = 0x%08x", 1, pDP8ReturnedAddress);

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing peer client object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing peer client object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure we got the destroy player messages.
		if (nonhostcontext.dpnidHost != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for host on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)

		if (nonhostcontext.dpnidClient != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for client on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)


		// Technically we should wait to make sure the host saw the client go away
		// as expected but that's more hassle than it's worth.  Just make sure he's
		// gone after Close() has returned.




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing host object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8PeerHost->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing host object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure we got the destroy player messages.
		if (hostcontext.dpnidHost != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for host on host!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)

		if (hostcontext.dpnidClient != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for client on host!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing hosting DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8PeerHost->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release hosting DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8PeerHost);
		pDP8PeerHost = NULL;





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Peer);
		pDP8Peer = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE


	if (pDP8Peer != NULL)
	{
		delete (pDP8Peer);
		pDP8Peer = NULL;
	} // end if (have peer object)

	if (pDP8PeerHost != NULL)
	{
		delete (pDP8PeerHost);
		pDP8PeerHost = NULL;
	} // end if (have peer object)

	SAFE_RELEASE(pDP8HostAddress);
	SAFE_RELEASE(pDP8HostAddressCompare);
	SAFE_RELEASE(pDP8ReturnedAddress);
	SAFE_CLOSEHANDLE(hostcontext.hClientCreatedEvent);
	ClearDoWorkList(&DoWorkList);
	SAFE_CLOSEHANDLE(hAsyncOpComplete);

	return (sr);
} // ParmVPeerExec_GetPeerAddress
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVPeerExec_GetLHostAddresses()"
//==================================================================================
// ParmVPeerExec_GetLHostAddresses
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.1.22 - Peer GetLocalHostAddresses parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVPeerExec_GetLHostAddresses(HANDLE hLog)
{
	CTNSystemResult					sr;
	CTNTestResult					tr;
	PWRAPDP8PEER					pDP8Peer = NULL;
	PWRAPDP8PEER					pDP8PeerHost = NULL;
	PDIRECTPLAY8ADDRESS				pDP8Address = NULL;
	PARMVPGETLHOSTADDRESSESCONTEXT	hostcontext;
	PARMVPGETLHOSTADDRESSESCONTEXT	nonhostcontext;
	DPN_APPLICATION_DESC			dpnad;
	DPN_APPLICATION_DESC			dpnadCompare;
	DWORD							dwCount;
	DWORD							dwExpectedCount = 0;
	PDIRECTPLAY8ADDRESS*			papDP8Addresses = NULL;
	DP_DOWORKLIST					DoWorkList;
	DPNHANDLE						hAsyncOp;
	HANDLE							hAsyncOpComplete = NULL;

	ZeroMemory(&DoWorkList, sizeof(DP_DOWORKLIST));
	ZeroMemory(&hostcontext, sizeof (PARMVPGETLHOSTADDRESSESCONTEXT));
	hostcontext.fHost = TRUE;

	ZeroMemory(&nonhostcontext, sizeof (PARMVPGETLHOSTADDRESSESCONTEXT));
	//nonhostcontext.fHost = FALSE;


	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Peer = new CWrapDP8Peer(hLog);
		if (pDP8Peer == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8Peer->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (LPVOID *) &pDP8Address, NULL);
		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't create DirectPlay8Address object!", 0);
			THROW_SYSTEMRESULT;
		} // end if (create failed)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting address object's SP to TCP/IP");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->SetSP(&CLSID_DP8SP_TCPIP);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting address object's SP to TCP/IP failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set SP)




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting local host addresses with NULLs and 0 flags using C++ macro");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = IDirectPlay8Peer_GetLocalHostAddresses(pDP8Peer->m_pDP8Peer, NULL, NULL, 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Getting local host addresses with NULLs and 0 flags using C++ macro didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get local host addresses)
*/


/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting local host addresses with NULLs and 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_GetLocalHostAddresses(NULL, NULL, 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Getting local host addresses with NULLs and 0 flags didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get local host addresses)
*/




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting local host addresses with NULL buffer and non-zero count");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwCount = 666;

		tr = pDP8Peer->DP8P_GetLocalHostAddresses(NULL, &dwCount, 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Getting local host addresses with NULL buffer and non-zero count didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get peer info)

		if (dwCount != 666)
		{
			DPTEST_FAIL(hLog, "Count was changed (%u != 666)!", 1, dwCount);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (count was touched)
*/

		dwCount = 0;

/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting local host addresses with invalid flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_GetLocalHostAddresses(NULL, &dwCount, 0x666);
		if (tr != DPNERR_INVALIDFLAGS)
		{
			DPTEST_FAIL(hLog, "Getting local host addresses with invalid flags didn't return expected error INVALIDFLAGS!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get local host addresses)

		if (dwCount != 0)
		{
			DPTEST_FAIL(hLog, "Count was changed (%u != 0)!", 1, dwCount);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (count is not 0)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting local host addresses before initialization");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_GetLocalHostAddresses(NULL, &dwCount, 0);
		if (tr != DPNERR_UNINITIALIZED)
		{
			DPTEST_FAIL(hLog, "Getting local host addresses before initialization didn't return expected error UNINITIALIZED!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get local host addresses)

		if (dwCount != 0)
		{
			DPTEST_FAIL(hLog, "Count was changed (%u != 0)!", 1, dwCount);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (count is not 0)
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Initializing peer object with host context");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		hostcontext.hLog = hLog;

		tr = pDP8Peer->DP8P_Initialize(&hostcontext,
										ParmVPGetLHostAddressesDPNMessageHandler, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Initializing peer object with host context failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting local host addresses prior to connection");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_GetLocalHostAddresses(NULL, &dwCount, 0);
		if (tr != DPNERR_NOCONNECTION)
		{
			DPTEST_FAIL(hLog, "Getting local host addresses prior to connection didn't return expected error NOCONNECTION!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get local host addresses)

		if (dwCount != 0)
		{
			DPTEST_FAIL(hLog, "Count was changed (%u != 0)!", 1, dwCount);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (count is not 0)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Hosting session");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		//dpnad.dwFlags = 0;
		//dpnad.guidInstance = GUID_NULL;
		dpnad.guidApplication = GUID_PARMV_PEER_GETAPPDESC;
		//dpnad.dwMaxPlayers = 0;
		//dpnad.dwCurrentPlayers = 0;
		//dpnad.pwszSessionName = NULL;
		//dpnad.pwszPassword = NULL;
		//dpnad.pvReservedData = NULL;
		//dpnad.dwReservedDataSize = 0;
		//dpnad.pvApplicationReservedData = NULL;
		//dpnad.dwApplicationReservedDataSize = 0;

		// Save what we're passing in to make sure it's not touched.
		CopyMemory(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC));

		tr = pDP8Peer->DP8P_Host(&dpnad,
								&pDP8Address,
								1,
								NULL,
								NULL,
								&(hostcontext.dpnidHost),
								0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't start hosting session!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't host)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		// Make sure we got the create player message.
		if (hostcontext.dpnidHost == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting local host addresses with NULL buffer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#pragma TODO(vanceo, "Figure out expected number of addresses")
		//dwExpectedCount = 1;

		tr = pDP8Peer->DP8P_GetLocalHostAddresses(NULL, &dwCount, 0);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Getting local host addresses with NULL buffer didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get local host addresses)

		dwExpectedCount = dwCount;
		/*
		if (dwCount != dwExpectedCount)
		{
			DPTEST_FAIL(hLog, "Count was not expected (%u != %u)!", 2, dwCount, dwExpectedCount);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (count is not expected)
		*/




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting local host addresses");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		LOCALALLOC_OR_THROW(PDIRECTPLAY8ADDRESS*, papDP8Addresses,
							((dwCount * sizeof (PDIRECTPLAY8ADDRESS)) + BUFFERPADDING_SIZE));

		FillWithDWord((papDP8Addresses + dwCount), BUFFERPADDING_SIZE,
						DONT_TOUCH_MEMORY_PATTERN);


		tr = pDP8Peer->DP8P_GetLocalHostAddresses(papDP8Addresses, &dwCount, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting local host addresses failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get peer info)

		if (dwCount != dwExpectedCount)
		{
			DPTEST_FAIL(hLog, "Count was modified (%u != %u)!", 2, dwCount, dwExpectedCount);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (count was modified)


#pragma TODO(vanceo, "Make sure the addresses returned were expected")

		// Make sure the buffer was not overrun.
		if (! IsFilledWithDWord((papDP8Addresses + dwCount), BUFFERPADDING_SIZE, DONT_TOUCH_MEMORY_PATTERN))
		{
			DPTEST_FAIL(hLog, "The %u entry address array buffer (at %x) was modified or overrun!",
				2, dwCount, papDP8Addresses);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (buffer was overrun)


		// Release all the addresses
		for(dwCount = 0; dwCount < dwExpectedCount; dwCount++)
		{
			papDP8Addresses[dwCount]->Release();
			papDP8Addresses[dwCount] = NULL;
		} // end for (each address)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing peer object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure we got the destroy player message.
		if (hostcontext.dpnidHost != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)

#pragma TODO(vanceo, "Validate destroy group nametable unwind")




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Re-initializing peer object with nonhost context");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		nonhostcontext.hLog = hLog;

		tr = pDP8Peer->DP8P_Initialize(&nonhostcontext,
										ParmVPGetLHostAddressesDPNMessageHandler,
										0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Re-initializing peer object with context, 0 flags failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating new peer host object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Address->Release();
		pDP8Address = NULL;

		hostcontext.hLog = hLog;

		tr = ParmVCreatePeerHost(hLog, ParmVPGetLHostAddressesDPNMessageHandler,
								&hostcontext,
								&dpnad,
								&(hostcontext.dpnidHost),
								&pDP8PeerHost,
								&pDP8Address);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Creating peer host failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't create peer host)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Connecting peer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

// XBOX - Had to make connection asynchronous

		// Host should get the create player now.
		CREATEEVENT_OR_THROW(hostcontext.hClientCreatedEvent, NULL, FALSE, FALSE, NULL);
		SAFE_CLOSEHANDLE(hAsyncOpComplete);
		CREATEEVENT_OR_THROW(hAsyncOpComplete, NULL, FALSE, FALSE, NULL);

		// Even though it's synchronous, we'll still get a completion.  The async op
		// handle will be NULL, though.
		nonhostcontext.fConnectCanComplete = TRUE;

		tr = pDP8Peer->DP8P_Connect(&dpnad,
									pDP8Address,
									NULL,
									NULL,
									NULL,
									NULL,
									0,
									&(nonhostcontext.dpnidClient),
									hAsyncOpComplete,
									&hAsyncOp,
									0);

		if((tr != DPNSUCCESS_PENDING) && (tr != DPN_OK))
		{
			DPTEST_FAIL(hLog, "Couldn't connect! (error 0x%08x)", 1, tr);
			THROW_TESTRESULT;
		} // end if (couldn't connect)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for connect to complete on non-host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hAsyncOpComplete))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird connects from completing.
		nonhostcontext.fConnectCanComplete = FALSE;

		// Make sure we saw the connect completion indication.
		if (! nonhostcontext.fConnectCompleted)
		{
			DPTEST_FAIL(hLog, "Didn't get connect complete indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (connect didn't complete)

		// Reset the context.
		nonhostcontext.fConnectCompleted = FALSE;

		// Make sure we got the create player messages.
		if (nonhostcontext.dpnidHost == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication for host on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player)

		if (nonhostcontext.dpnidClient == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication for client on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for create player to be indicated on host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hostcontext.hClientCreatedEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting local host addresses on client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwCount = 0;

		tr = pDP8Peer->DP8P_GetLocalHostAddresses(NULL, &dwCount, 0);
		if (tr != DPNERR_NOTHOST)
		{
			DPTEST_FAIL(hLog, "Getting local host addresses on client didn't return expected error NOTHOST!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get local host addresses)

		if (dwCount != 0)
		{
			DPTEST_FAIL(hLog, "Count was changed (%u != 0)!", 1, dwCount);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (count is not 0)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting local host addresses on host again");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwCount = dwExpectedCount;

		tr = pDP8PeerHost->DP8P_GetLocalHostAddresses(papDP8Addresses, &dwCount, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting local host addresses failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get peer info)

		if (dwCount != dwExpectedCount)
		{
			DPTEST_FAIL(hLog, "Count was modified (%u != %u)!", 2, dwCount, dwExpectedCount);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (count was modified)


#pragma TODO(vanceo, "Make sure the addresses returned were expected")

		// Make sure the buffer was not overrun.
		if (! IsFilledWithDWord((papDP8Addresses + dwCount), BUFFERPADDING_SIZE, DONT_TOUCH_MEMORY_PATTERN))
		{
			DPTEST_FAIL(hLog, "The %u entry address array buffer (at %x) was modified or overrun!",
				2, dwCount, papDP8Addresses);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (buffer was overrun)


		// Release all the addresses
		for(dwCount = 0; dwCount < dwExpectedCount; dwCount++)
		{
			papDP8Addresses[dwCount]->Release();
			papDP8Addresses[dwCount] = NULL;
		} // end for (each address)






		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing peer client object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing peer client object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure we got the destroy player messages.
		if (nonhostcontext.dpnidHost != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for host on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)

		if (nonhostcontext.dpnidClient != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for client on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)


		// Technically we should wait to make sure the host saw the client go away
		// as expected but that's more hassle than it's worth.  Just make sure he's
		// gone after Close() has returned.




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing host object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8PeerHost->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing host object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure we got the destroy player messages.
		if (hostcontext.dpnidHost != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for host on host!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)

		if (hostcontext.dpnidClient != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for client on host!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing hosting DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8PeerHost->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release hosting DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8PeerHost);
		pDP8PeerHost = NULL;





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Peer);
		pDP8Peer = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE


	if (pDP8Peer != NULL)
	{
		delete (pDP8Peer);
		pDP8Peer = NULL;
	} // end if (have peer object)

	if (pDP8PeerHost != NULL)
	{
		delete (pDP8PeerHost);
		pDP8PeerHost = NULL;
	} // end if (have peer object)

	SAFE_RELEASE(pDP8Address);

	// If still have addresses, release them.
	if (papDP8Addresses != NULL)
	{
		for(dwCount = 0; dwCount < dwExpectedCount; dwCount++)
		{
			if (papDP8Addresses[dwCount] != NULL)
			{
				papDP8Addresses[dwCount]->Release();
				papDP8Addresses[dwCount] = NULL;
			} // end if (have an address object)
		} // end for (each address)

		SAFE_LOCALFREE(papDP8Addresses);
		papDP8Addresses = NULL;
	} // end if (still have addresses)

	SAFE_CLOSEHANDLE(hostcontext.hClientCreatedEvent);
	ClearDoWorkList(&DoWorkList);
	SAFE_CLOSEHANDLE(hAsyncOpComplete);

	return (sr);
} // ParmVPeerExec_GetLHostAddresses
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVPeerExec_Close()"
//==================================================================================
// ParmVPeerExec_Close
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.1.23 - Peer Close parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVPeerExec_Close(HANDLE hLog)
{
	CTNSystemResult			sr;
	CTNTestResult			tr;
	PWRAPDP8PEER			pDP8Peer = NULL;
	PDIRECTPLAY8ADDRESS		pDP8Address = NULL;
	DPN_APPLICATION_DESC	dpnad;
	DPN_APPLICATION_DESC	dpnadCompare;
	PARMVPCLOSECONTEXT		context;
	DPNHANDLE				dpnhEnumHosts;



	ZeroMemory(&context, sizeof (PARMVPCLOSECONTEXT));


	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Peer = new CWrapDP8Peer(hLog);
		if (pDP8Peer == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8Peer->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (LPVOID *) &pDP8Address, NULL);
		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't create DirectPlay8Address object!", 0);
			THROW_SYSTEMRESULT;
		} // end if (create failed)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting address object's SP to TCP/IP");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->SetSP(&CLSID_DP8SP_TCPIP);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting address object's SP to TCP/IP failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set SP)





/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing before initialization using C++ macro");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = IDirectPlay8Peer_Close(pDP8Peer->m_pDP8Peer, 0);
		if (tr != DPNERR_UNINITIALIZED)
		{
			DPTEST_FAIL(hLog, "Closing before initialization using C++ macro didn't return expected error UNINITIALIZED!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get peer info)
*/


/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing before initialization");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Close(0);
		if (tr != DPNERR_UNINITIALIZED)
		{
			DPTEST_FAIL(hLog, "Closing before initialization didn't return expected error UNINITIALIZED!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)
*/


/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing with invalid flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Close(0x666);
		if (tr != DPNERR_INVALIDFLAGS)
		{
			DPTEST_FAIL(hLog, "Closing with invalid flags didn't return expected error INVALIDFLAGS!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)
*/




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Initializing with NULL context, 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Initialize(NULL, ParmVNoMessagesDPNMessageHandler, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Initializing with NULL context, 0 flags failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing with no connections");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing with no connections failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Initializing with 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		context.hLog = hLog;

		tr = pDP8Peer->DP8P_Initialize(&context, ParmVPCloseDPNMessageHandler, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Initializing with 0 flags failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Hosting session");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		//dpnad.dwFlags = 0;
		//dpnad.guidInstance = GUID_NULL;
		dpnad.guidApplication = GUID_PARMV_PEER_HOST;
		//dpnad.dwMaxPlayers = 0;
		//dpnad.dwCurrentPlayers = 0;
		//dpnad.pwszSessionName = NULL;
		//dpnad.pwszPassword = NULL;
		//dpnad.pvReservedData = NULL;
		//dpnad.dwReservedDataSize = 0;
		//dpnad.pvApplicationReservedData = NULL;
		//dpnad.dwApplicationReservedDataSize = 0;

		// Save what we're passing in to make sure it's not touched.
		CopyMemory(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC));

		tr = pDP8Peer->DP8P_Host(&dpnad,
								&pDP8Address,
								1,
								NULL,
								NULL,
								NULL,
								0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't start hosting session!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't host)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing after hosting with no connected clients");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing after hosting with no connected clients failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Initializing with 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		context.hLog = hLog;

		tr = pDP8Peer->DP8P_Initialize(&context, ParmVPCloseDPNMessageHandler, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Initializing with 0 flags failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Beginning asynchronous enumeration");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dpnhEnumHosts = (DPNHANDLE) 0x666;

		// Expect the completion message on the host.
		context.fAsyncOpCanComplete = TRUE;

		tr = pDP8Peer->DP8P_EnumHosts(&dpnad, NULL, pDP8Address, NULL, 0,
									0, 0, 0, NULL, &dpnhEnumHosts, 0);
		if (tr != (HRESULT) DPNSUCCESS_PENDING)
		{
			DPTEST_FAIL(hLog, "Beginning asynchronous enumeration didn't return expected PENDING success code!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum hosts)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		if (dpnhEnumHosts == (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "No async operation handle was returned!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (handle was not set)

		if (dpnhEnumHosts == NULL)
		{
			DPTEST_FAIL(hLog, "Async operation handle returned is NULL!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (handle was set to NULL)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing with enumeration still active");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Close(0);

		// The async operation should have completed by now.
		context.fAsyncOpCanComplete = FALSE;

		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing with enumeration still active failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure the async op completed.
		if (! context.fAsyncOpCompleted)
		{
			DPTEST_FAIL(hLog, "Asynchronous enumeration wasn't completed by Close!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (didn't get async op completion)

		// Make sure the completion indicated the same op handle that we were
		// returned.
		if (context.dpnhCompletedAsyncOp != dpnhEnumHosts)
		{
			DPTEST_FAIL(hLog, "Enumeration completed with different async op handle (%x != %x)!",
				2, context.dpnhCompletedAsyncOp, dpnhEnumHosts);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (async op handle is wrong)







		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Peer);
		pDP8Peer = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE


	if (pDP8Peer != NULL)
	{
		delete (pDP8Peer);
		pDP8Peer = NULL;
	} // end if (have peer object)

	SAFE_RELEASE(pDP8Address);


	return (sr);
} // ParmVPeerExec_Close
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVPeerExec_EnumHosts()"
//==================================================================================
// ParmVPeerExec_EnumHosts
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.1.24 - Peer EnumHosts parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVPeerExec_EnumHosts(HANDLE hLog)
{
	CTNSystemResult				sr;
	CTNTestResult				tr;
	PWRAPDP8PEER				pDP8Peer = NULL;
	PWRAPDP8PEER				pDP8PeerHost = NULL;
	DPN_APPLICATION_DESC		dpnad;
	DPN_APPLICATION_DESC		dpnadCompare;
	PDIRECTPLAY8ADDRESS			pDP8AddressHost = NULL;
	PDIRECTPLAY8ADDRESS			pDP8AddressDevice = NULL;
	PDIRECTPLAY8ADDRESS			pDP8AddressDeviceCompare = NULL;
	PARMVPENUMHOSTSCONTEXT		hostcontext;
	PARMVPENUMHOSTSCONTEXT		nonhostcontext;
	DPNHANDLE					adpnhEnumHosts[2];
	PVOID						pvTooLargeEnumData = NULL;
	DWORD						dwTooLargeEnumDataSize;
	char*						pcCurrentSrc;
	char*						pcCurrentDest;
	DWORD						dwTemp1;
	DWORD						dwTemp2;
	PPARMVPENUMHOSTSCONTEXT		pContext;
	CHAR						szLocalMacAddress[16];
	DP_DOWORKLIST				DoWorkList;
	DPNHANDLE					hAsyncOp;
	HANDLE						hAsyncOpComplete = NULL;

	ZeroMemory(&DoWorkList, sizeof(DP_DOWORKLIST));
	ZeroMemory(&hostcontext, sizeof (PARMVPENUMHOSTSCONTEXT));
	hostcontext.fHost = TRUE;

	ZeroMemory(&nonhostcontext, sizeof (PARMVPENUMHOSTSCONTEXT));
	//nonhostcontext.fHost = FALSE;


	BEGIN_TESTCASE
	{
		// Allocate a buffer larger than the  maximum payload size for the IP
		// service provider.
		dwTooLargeEnumDataSize = 984;
		LOCALALLOC_OR_THROW(PVOID, pvTooLargeEnumData, dwTooLargeEnumDataSize);


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Peer = new CWrapDP8Peer(hLog);
		if (pDP8Peer == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8Peer->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating host DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (LPVOID *) &pDP8AddressHost, NULL);
		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't host create DirectPlay8Address object!", 0);
			THROW_SYSTEMRESULT;
		} // end if (create failed)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating device DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (LPVOID *) &pDP8AddressDevice, NULL);
		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't device create DirectPlay8Address object!", 0);
			THROW_SYSTEMRESULT;
		} // end if (create failed)





/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enuming hosts with all NULLs and 0 flags using C++ macro");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = IDirectPlay8Peer_EnumHosts(pDP8Peer->m_pDP8Peer, NULL, NULL, NULL,
										NULL, 0, 0, 0, 0, NULL, NULL, 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Enuming hosts with all NULLs and 0 flags using C++ macro didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum hosts)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enuming hosts with all NULLs and 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_EnumHosts(NULL, NULL, NULL, NULL, 0, 0, 0, 0,
									NULL, NULL, 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Enuming hosts with all NULLs and 0 flags didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum hosts)
*/


		adpnhEnumHosts[0] = (DPNHANDLE) 0x666;

/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enuming hosts with NULL app desc");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_EnumHosts(NULL, pDP8AddressHost, pDP8AddressDevice,
									NULL, 0, 0, 0, 0, NULL, &(adpnhEnumHosts[0]), 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Enuming hosts with NULL app desc didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum hosts)

		if (adpnhEnumHosts[0] != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async handle was changed (%x != 0x666)!", 1, adpnhEnumHosts[0]);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (async handle was changed)
*/



		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		//dpnad.dwFlags = 0;
		//dpnad.guidInstance = GUID_NULL;


		// Start with the base GUID.
		dpnad.guidApplication = GUID_PARMV_PEER_ENUMHOSTSBASE1;

		// Instead of the machine name, use the mac address string to "personalize" the GUID
		if(gethostname(szLocalMacAddress, sizeof(szLocalMacAddress)))
		{
			xLog(hLog, XLL_FAIL, "Couldn't retrieve local Mac address");
			SETTHROW_TESTRESULT(E_FAIL);
		}

		// Make it unique to our machine.  Stuff the last 8 (or fewer) characters of
		// our machine name into the middle of the GUID
		pcCurrentSrc = szLocalMacAddress + strlen(szLocalMacAddress) - 1;
		pcCurrentDest = ((char*) (&dpnad.guidApplication)) + 2;
		for (dwTemp1 = 0; dwTemp1 < 8; dwTemp1++)
		{
			(*pcCurrentDest) = (*pcCurrentSrc);
			pcCurrentSrc--;
			pcCurrentDest++;

			// If the name isn't even 8 characters, we're done.
			if (pcCurrentDest == szLocalMacAddress)
				break;
		} // end while (still more characters to copy left)

		//dpnad.dwMaxPlayers = 0;
		//dpnad.dwCurrentPlayers = 0;
		//dpnad.pwszSessionName = NULL;
		//dpnad.pwszPassword = NULL;
		//dpnad.pvReservedData = NULL;
		//dpnad.dwReservedDataSize = 0;
		//dpnad.pvApplicationReservedData = NULL;
		//dpnad.dwApplicationReservedDataSize = 0;

		// Save what we're passing in to make sure it's not touched.
		CopyMemory(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC));


/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enuming hosts with NULL host and device addresses");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_EnumHosts(&dpnad, NULL, NULL,
									NULL, 0, 0, 0, 0, NULL, &(adpnhEnumHosts[0]), 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Enuming hosts with NULL host and device addresses didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum hosts)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		if (adpnhEnumHosts[0] != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async handle was changed (%x != 0x666)!", 1, adpnhEnumHosts[0]);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (async handle was changed)
*/



/* XBOX - For now, Xbox doesn't require an SP to be set
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enuming hosts with host address without an SP");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_EnumHosts(&dpnad, pDP8AddressHost, NULL,
									NULL, 0, 0, 0, 0, NULL, &(adpnhEnumHosts[0]), 0);
		if (tr != DPNERR_INVALIDHOSTADDRESS)
		{
			if(tr == DPNERR_INVALIDPOINTER)
			{
				DPTEST_FAIL(hLog, "Xbox bug 2997 occurred!", 0);
				fPassed = FALSE;
			}
			else
			{
				DPTEST_FAIL(hLog, "Enuming hosts with host address without an SP didn't return expected error INVALIDHOSTADDRESS!", 0);
				THROW_TESTRESULT;
			}
		} // end if (couldn't enum hosts)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		if (adpnhEnumHosts[0] != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async handle was changed (%x != 0x666)!", 1, adpnhEnumHosts[0]);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (async handle was changed)
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting host address object's SP to TCP/IP");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressHost->SetSP(&CLSID_DP8SP_TCPIP);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting host address object's SP to TCP/IP failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set SP)




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enuming hosts with NULL device address");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_EnumHosts(&dpnad, pDP8AddressHost, NULL,
									NULL, 0, 0, 0, 0, NULL, &(adpnhEnumHosts[0]), 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Enuming hosts with NULL device address didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum hosts)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		if (adpnhEnumHosts[0] != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async handle was changed (%x != 0x666)!", 1, adpnhEnumHosts[0]);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (async handle was changed)
*/



/* XBOX - IPX not supported
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting device address object's SP to IPX");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressDevice->SetSP(&CLSID_DP8SP_IPX);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting device address object's SP to IPX failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set SP)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enuming hosts with different SPs for host and device addresses");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_EnumHosts(&dpnad, pDP8AddressHost, pDP8AddressDevice,
									NULL, 0, 0, 0, 0, NULL, &(adpnhEnumHosts[0]), 0);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Enuming hosts with different SPs for host and device addresses didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum hosts)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		if (adpnhEnumHosts[0] != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async handle was changed (%x != 0x666)!", 1, adpnhEnumHosts[0]);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (async handle was changed)
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting device address object's SP to TCP/IP");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressDevice->SetSP(&CLSID_DP8SP_TCPIP);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting device address object's SP to TCP/IP failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set SP)




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enuming hosts with NULL data but non-zero size");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_EnumHosts(&dpnad, pDP8AddressHost, pDP8AddressDevice,
									NULL, 666, 0, 0, 0, NULL, &(adpnhEnumHosts[0]), 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			if(tr == DPNERR_INVALIDPARAM)
			{
				DPTEST_FAIL(hLog, "Xbox bug 3054 occurred!\n", 0);
				fPassed = FALSE;
			}
			else
			{
				DPTEST_FAIL(hLog, "Enuming hosts with NULL data but non-zero size didn't return expected error INVALIDPOINTER!", 0);
				THROW_TESTRESULT;
			}
		} // end if (couldn't enum hosts)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		if (adpnhEnumHosts[0] != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async handle was changed (%x != 0x666)!", 1, adpnhEnumHosts[0]);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (async handle was changed)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enuming hosts with NULL async op handle");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_EnumHosts(&dpnad, pDP8AddressHost, pDP8AddressDevice,
									NULL, 0, 0, 0, 0, NULL, NULL, 0);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Enuming hosts with NULL async op handle didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum hosts)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		if (adpnhEnumHosts[0] != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async handle was changed (%x != 0x666)!", 1, adpnhEnumHosts[0]);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (async handle was changed)
*/



/* XBOX - SYNC operations not supported
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enuming hosts synchronously with async op handle");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_EnumHosts(&dpnad, pDP8AddressHost, pDP8AddressDevice,
									NULL, 0, 0, 0, 0, NULL, &(adpnhEnumHosts[0]),
									DPNENUMHOSTS_SYNC);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Enuming hosts synchronously with async op handle didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum hosts)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		if (adpnhEnumHosts[0] != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async handle was changed (%x != 0x666)!", 1, adpnhEnumHosts[0]);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (async handle was changed)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enuming hosts with invalid flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_EnumHosts(&dpnad, pDP8AddressHost, pDP8AddressDevice,
									NULL, 0, 0, 0, 0, NULL, &(adpnhEnumHosts[0]), 0x666);
		if (tr != DPNERR_INVALIDFLAGS)
		{
			if(tr == DPNERR_INVALIDPARAM)
			{
				DPTEST_FAIL(hLog, "Xbox bug 3054 occurred!\n", 0);
				fPassed = FALSE;
			}
			else
			{
				DPTEST_FAIL(hLog, "Enuming hosts with invalid flags didn't return expected error INVALIDFLAGS!", 0);
				THROW_TESTRESULT;
			}
		} // end if (couldn't enum hosts)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		if (adpnhEnumHosts[0] != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async handle was changed (%x != 0x666)!", 1, adpnhEnumHosts[0]);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (async handle was changed)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enuming hosts before initialization");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_EnumHosts(&dpnad, pDP8AddressHost, pDP8AddressDevice,
									NULL, 0, 0, 0, 0, NULL, &(adpnhEnumHosts[0]), 0);
		if (tr != DPNERR_UNINITIALIZED)
		{
			if(tr == DPNERR_INVALIDPARAM)
			{
				DPTEST_FAIL(hLog, "Xbox bug 3054 occurred!\n", 0);
				fPassed = FALSE;
			}
			else
			{
				DPTEST_FAIL(hLog, "Enuming hosts before initialization didn't return expected error UNINITIALIZED!", 0);
				THROW_TESTRESULT;
			}
		} // end if (couldn't enum hosts)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		if (adpnhEnumHosts[0] != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async handle was changed (%x != 0x666)!", 1, adpnhEnumHosts[0]);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (async handle was changed)
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Initializing peer object with host context");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		hostcontext.hLog = hLog;

		tr = pDP8Peer->DP8P_Initialize(&hostcontext, ParmVPEnumHostsDPNMessageHandler, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Initializing peer object with host context failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enuming hosts after initialization");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_EnumHosts(&dpnad, pDP8AddressHost, pDP8AddressDevice,
									pvTooLargeEnumData, dwTooLargeEnumDataSize,
									0, 0, 0, NULL, &(adpnhEnumHosts[0]), 0);
		if (tr != DPNERR_ENUMQUERYTOOLARGE)
		{
			if(tr == DPNERR_INVALIDPARAM)
			{
				DPTEST_FAIL(hLog, "Xbox bug 3054 occurred!\n", 0);
				fPassed = FALSE;
			}
			else
			{
				DPTEST_FAIL(hLog, "Enuming hosts before initialization didn't return expected error UNINITIALIZED!", 0);
				THROW_TESTRESULT;
			}
		} // end if (couldn't enum hosts)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		if (adpnhEnumHosts[0] != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async handle was changed (%x != 0x666)!", 1, adpnhEnumHosts[0]);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (async handle was changed)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enuming hosts");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Expect the completion message on the host.
		hostcontext.ahrExpectedResult[0] = DPN_OK;
		CREATEEVENT_OR_THROW(hostcontext.ahAsyncOpCompletedEvent[0],
							NULL, FALSE, FALSE, NULL);
		hostcontext.afAsyncOpCanComplete[0] = TRUE;

		tr = pDP8Peer->DP8P_EnumHosts(&dpnad, pDP8AddressHost, pDP8AddressDevice,
									NULL, 0, 0, 0, 0, (PVOID) ((DWORD_PTR) 1),
									&(adpnhEnumHosts[0]), 0);
		if (tr != (HRESULT) DPNSUCCESS_PENDING)
		{
			if(tr == DPNERR_INVALIDPARAM)
			{
				DPTEST_FAIL(hLog, "Xbox bug 3054 occurred!\n", 0);
				THROW_TESTRESULT;
			}
			else
			{
				DPTEST_FAIL(hLog, "Enuming hosts didn't return expected PENDING success code!", 0);
				THROW_TESTRESULT;
			}
		} // end if (couldn't enum hosts)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		if (adpnhEnumHosts[0] == (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "No async operation handle was returned!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (handle was not set)

		if (adpnhEnumHosts[0] == NULL)
		{
			DPTEST_FAIL(hLog, "Async operation handle returned is NULL!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (handle was set to NULL)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for async op to complete (may take a little while)");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 1;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hostcontext.ahAsyncOpCompletedEvent[0]))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird async op completions.
		hostcontext.afAsyncOpCanComplete[0] = FALSE;


#ifdef DEBUG
		// Make sure we got the indication (how else would we get here?).
		if (! hostcontext.afAsyncOpCompleted[0])
		{
			DPTEST_FAIL(hLog, "Didn't get async op completion!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (didn't get async op completion)
#endif // DEBUG

		// Make sure the completion indicated the same op handle that we were
		// returned.
		if (hostcontext.adpnhCompletedAsyncOp[0] != adpnhEnumHosts[0])
		{
			DPTEST_FAIL(hLog, "Enum hosts completed with different async op handle (%x != %x)!",
				2, hostcontext.adpnhCompletedAsyncOp[0], adpnhEnumHosts[0]);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (async op handle is wrong)

		// Reset the context.
		hostcontext.afAsyncOpCompleted[0] = FALSE;
		CloseHandle(hostcontext.ahAsyncOpCompletedEvent[0]);
		hostcontext.ahAsyncOpCompletedEvent[0] = NULL;

		adpnhEnumHosts[0] = (DPNHANDLE) 0x666;

/* XBOX - SYNC operations not supported
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enuming hosts synchronously (may take a little while)");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_EnumHosts(&dpnad, pDP8AddressHost, pDP8AddressDevice,
									NULL, 0, 0, 0, 0, (PVOID) ((DWORD_PTR) 1), NULL,
									DPNENUMHOSTS_SYNC);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Enuming hosts synchronously failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum hosts)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)
*/


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Saving device address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressDevice->Duplicate(&pDP8AddressDeviceCompare);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't duplicate device address object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't duplicate device address object)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Hosting session");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Host(&dpnad,
								&pDP8AddressDevice,
								1,
								NULL,
								NULL,
								&(hostcontext.dpnidHost),
								0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't start hosting session!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't host)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		tr = pDP8AddressDevice->IsEqual(pDP8AddressDeviceCompare);
		if (tr != DPNSUCCESS_EQUAL)
		{
			DPTEST_FAIL(hLog, "Device address object was modified (0x%08x != 0x%08x)!",
				2, pDP8AddressDevice, pDP8AddressDeviceCompare);
			THROW_TESTRESULT;
		} // end if (addresses aren't equal)

		// Make sure we got the create player message.
		if (hostcontext.dpnidHost == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enuming hosts after hosting");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_EnumHosts(&dpnad, pDP8AddressHost, pDP8AddressDevice,
									NULL, 0, 0, 0, 0, NULL, &(adpnhEnumHosts[0]), 0);
		if (tr != DPNERR_HOSTING)
		{
			DPTEST_FAIL(hLog, "Enuming hosts after hosting didn't return expected error HOSTING!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum hosts)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		if (adpnhEnumHosts[0] != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async handle was changed (%x != 0x666)!", 1, adpnhEnumHosts[0]);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (async handle was changed)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing peer object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure we got the destroy player message.
		if (hostcontext.dpnidHost != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)

#pragma TODO(vanceo, "Validate destroy group nametable unwind")



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Re-initializing peer object with nonhost context");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		nonhostcontext.hLog = hLog;

		tr = pDP8Peer->DP8P_Initialize(&nonhostcontext,
										ParmVPEnumHostsDPNMessageHandler,
										0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Re-initializing peer object with context, 0 flags failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating new peer host object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		//dpnad.dwFlags = 0;
		//dpnad.guidInstance = GUID_NULL;


		// Start with the base GUID.
		dpnad.guidApplication = GUID_PARMV_PEER_ENUMHOSTSBASE2;

		// Instead of the machine name, use the mac address string to "personalize" the GUID
		if(gethostname(szLocalMacAddress, sizeof(szLocalMacAddress)))
		{
			xLog(hLog, XLL_FAIL, "Couldn't retrieve local Mac address");
			SETTHROW_TESTRESULT(E_FAIL);
		}

		// Make it unique to our machine.  Stuff the last 8 (or fewer) characters of
		// our machine name into the middle of the GUID
		pcCurrentSrc = szLocalMacAddress + strlen(szLocalMacAddress) - 1;
		pcCurrentDest = ((char*) (&dpnad.guidApplication)) + 2;
		for (dwTemp1 = 0; dwTemp1 < 8; dwTemp1++)
		{
			(*pcCurrentDest) = (*pcCurrentSrc);
			pcCurrentSrc--;
			pcCurrentDest++;

			// If the name isn't even 8 characters, we're done.
			if (pcCurrentDest == szLocalMacAddress)
				break;
		} // end while (still more characters to copy left)

		// Remember the GUID we created.
		nonhostcontext.pguidExpectedApplication = &dpnad.guidApplication;


		//dpnad.dwMaxPlayers = 0;
		//dpnad.dwCurrentPlayers = 0;
		//dpnad.pwszSessionName = NULL;
		//dpnad.pwszPassword = NULL;
		//dpnad.pvReservedData = NULL;
		//dpnad.dwReservedDataSize = 0;
		//dpnad.pvApplicationReservedData = NULL;
		//dpnad.dwApplicationReservedDataSize = 0;

		// Save what we're passing in to make sure it's not touched.
		CopyMemory(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC));


		hostcontext.hLog = hLog;

		tr = ParmVCreatePeerHost(hLog, ParmVPEnumHostsDPNMessageHandler,
								&hostcontext,
								&dpnad,
								&(hostcontext.dpnidHost),
								&pDP8PeerHost,
								&nonhostcontext.apExpectedDP8AddressSender[0]);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Creating peer host failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't create peer host)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Duplicating hosts address");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = nonhostcontext.apExpectedDP8AddressSender[0]->Duplicate(&(nonhostcontext.apExpectedDP8AddressSender[1]));
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Duplicating hosts address failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't duplicate)


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enuming hosts on client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Expect responses and the completion message on the client.
		nonhostcontext.adwExpectedCurrentPlayers[0] = 1;
		nonhostcontext.afCanGetResponses[0] = TRUE;
		nonhostcontext.ahrExpectedResult[0] = DPN_OK;
		CREATEEVENT_OR_THROW(nonhostcontext.ahAsyncOpCompletedEvent[0],
							NULL, FALSE, FALSE, NULL);
		nonhostcontext.afAsyncOpCanComplete[0] = TRUE;

		tr = pDP8Peer->DP8P_EnumHosts(&dpnad, nonhostcontext.apExpectedDP8AddressSender[0],
									pDP8AddressDevice, NULL, 0, 0, 0, 0,
									(PVOID) ((DWORD_PTR) 1), &(adpnhEnumHosts[0]), 0);
		if (tr != (HRESULT) DPNSUCCESS_PENDING)
		{
			DPTEST_FAIL(hLog, "Enuming hosts on client didn't return expected PENDING success code!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum hosts)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		if (adpnhEnumHosts[0] == (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "No async operation handle was returned!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (handle was not set)

		if (adpnhEnumHosts[0] == NULL)
		{
			DPTEST_FAIL(hLog, "Async operation handle returned is NULL!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (handle was set to NULL)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enuming more hosts on client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Expect responses and the completion message on the client.
		nonhostcontext.adwExpectedCurrentPlayers[1] = 1;
		nonhostcontext.afCanGetResponses[1] = TRUE;
		nonhostcontext.ahrExpectedResult[1] = DPN_OK;
		CREATEEVENT_OR_THROW(nonhostcontext.ahAsyncOpCompletedEvent[1],
							NULL, FALSE, FALSE, NULL);
		nonhostcontext.afAsyncOpCanComplete[1] = TRUE;

		tr = pDP8Peer->DP8P_EnumHosts(&dpnad, nonhostcontext.apExpectedDP8AddressSender[1],
									pDP8AddressDevice, NULL, 0, 0, 0, 0,
									(PVOID) ((DWORD_PTR) 2), &(adpnhEnumHosts[1]), 0);
		if (tr != (HRESULT) DPNSUCCESS_PENDING)
		{
			DPTEST_FAIL(hLog, "Enuming more hosts on client didn't return expected PENDING success code!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum hosts)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		if (adpnhEnumHosts[1] == (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "No async operation handle was returned!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (handle was not set)

		if (adpnhEnumHosts[1] == NULL)
		{
			DPTEST_FAIL(hLog, "Async operation handle returned is NULL!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (handle was set to NULL)






		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for first async op to complete (may take a little while)");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, nonhostcontext.ahAsyncOpCompletedEvent[0]))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent more responses from coming in.
		nonhostcontext.afCanGetResponses[0] = FALSE;

		// Prevent any weird async op completions.
		nonhostcontext.afAsyncOpCanComplete[0] = FALSE;


#ifdef DEBUG
		// Make sure we got the indication (how else would we get here?).
		if (! nonhostcontext.afAsyncOpCompleted[0])
		{
			DPTEST_FAIL(hLog, "Didn't get first async op completion!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (didn't get async op completion)
#endif // DEBUG

		// Make sure the completion indicated the same op handle that we were
		// returned.
		if (nonhostcontext.adpnhCompletedAsyncOp[0] != adpnhEnumHosts[0])
		{
			DPTEST_FAIL(hLog, "Enum hosts 1 completed with different async op handle (%x != %x)!",
				2, nonhostcontext.adpnhCompletedAsyncOp[0], adpnhEnumHosts[0]);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (async op handle is wrong)

		// Reset the context.
		nonhostcontext.afAsyncOpCompleted[0] = FALSE;
		CloseHandle(nonhostcontext.ahAsyncOpCompletedEvent[0]);
		nonhostcontext.ahAsyncOpCompletedEvent[0] = NULL;

		adpnhEnumHosts[0] = (DPNHANDLE) 0x666;

		nonhostcontext.adwExpectedCurrentPlayers[0] = 0;





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for second async op to complete (may take a little while)");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, nonhostcontext.ahAsyncOpCompletedEvent[1]))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent more responses from coming in.
		nonhostcontext.afCanGetResponses[1] = FALSE;

		// Prevent any weird async op completions.
		nonhostcontext.afAsyncOpCanComplete[1] = FALSE;


#ifdef DEBUG
		// Make sure we got the indication (how else would we get here?).
		if (! nonhostcontext.afAsyncOpCompleted[1])
		{
			DPTEST_FAIL(hLog, "Didn't get second async op completion!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (didn't get async op completion)
#endif // DEBUG

		// Make sure the completion indicated the same op handle that we were
		// returned.
		if (nonhostcontext.adpnhCompletedAsyncOp[1] != adpnhEnumHosts[1])
		{
			DPTEST_FAIL(hLog, "Enum hosts 2 completed with different async op handle (%x != %x)!",
				2, nonhostcontext.adpnhCompletedAsyncOp[1], adpnhEnumHosts[1]);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (async op handle is wrong)

		// Reset the context.
		nonhostcontext.afAsyncOpCompleted[1] = FALSE;
		CloseHandle(nonhostcontext.ahAsyncOpCompletedEvent[1]);
		nonhostcontext.ahAsyncOpCompletedEvent[1] = NULL;

		adpnhEnumHosts[1] = (DPNHANDLE) 0x666;

		nonhostcontext.adwExpectedCurrentPlayers[1] = 0;



#pragma TODO(vanceo, "Perhaps validate number of queries/responses")
		// Make sure some data actually went back and forth.
		if (hostcontext.dwNumQueries == 0)
		{
			DPTEST_FAIL(hLog, "Host didn't get any enum queries!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get any queries)
		else
		{
			DPTEST_TRACE(hLog, "Host got %u queries.", 1, hostcontext.dwNumQueries);
		} // end else (got some queries)

		if (nonhostcontext.adwNumResponses[0] == 0)
		{
			DPTEST_FAIL(hLog, "Client didn't get any responses to enum 1!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get any responses)
		else
		{
			DPTEST_TRACE(hLog, "Client got %u responses to enum 1.", 1, nonhostcontext.adwNumResponses[0]);
		} // end else (got some responses)

		if (nonhostcontext.adwNumResponses[1] == 0)
		{
			DPTEST_FAIL(hLog, "Client didn't get any responses to enum 2!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get any responses)
		else
		{
			DPTEST_TRACE(hLog, "Client got %u responses to enum 2.", 1, nonhostcontext.adwNumResponses[1]);
		} // end else (got some responses)






		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enuming hosts on client with NULL host address");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Expect responses and the completion message on the client.
		nonhostcontext.adwExpectedCurrentPlayers[0] = 1;
		nonhostcontext.afCanGetResponses[0] = TRUE;
		nonhostcontext.ahrExpectedResult[0] = DPN_OK;
		CREATEEVENT_OR_THROW(nonhostcontext.ahAsyncOpCompletedEvent[0],
							NULL, FALSE, FALSE, NULL);
		nonhostcontext.afAsyncOpCanComplete[0] = TRUE;

		tr = pDP8Peer->DP8P_EnumHosts(&dpnad, NULL, pDP8AddressDevice,
									NULL, 0, 0, 0, 0,
									(PVOID) ((DWORD_PTR) 1), &(adpnhEnumHosts[0]), 0);
		if (tr != (HRESULT) DPNSUCCESS_PENDING)
		{
			DPTEST_FAIL(hLog, "Enuming hosts on client with NULL host address didn't return expected PENDING success code!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum hosts)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		if (adpnhEnumHosts[0] == (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "No async operation handle was returned!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (handle was not set)

		if (adpnhEnumHosts[0] == NULL)
		{
			DPTEST_FAIL(hLog, "Async operation handle returned is NULL!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (handle was set to NULL)






		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for async op to complete (may take a little while)");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, nonhostcontext.ahAsyncOpCompletedEvent[0]))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent more responses from coming in.
		nonhostcontext.afCanGetResponses[0] = FALSE;

		// Prevent any weird async op completions.
		nonhostcontext.afAsyncOpCanComplete[0] = FALSE;


#ifdef DEBUG
		// Make sure we got the indication (how else would we get here?).
		if (! nonhostcontext.afAsyncOpCompleted[0])
		{
			DPTEST_FAIL(hLog, "Didn't get async op completion!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (didn't get async op completion)
#endif // DEBUG

		// Make sure the completion indicated the same op handle that we were
		// returned.
		if (nonhostcontext.adpnhCompletedAsyncOp[0] != adpnhEnumHosts[0])
		{
			DPTEST_FAIL(hLog, "Enum hosts 1 completed with different async op handle (%x != %x)!",
				2, nonhostcontext.adpnhCompletedAsyncOp[0], adpnhEnumHosts[0]);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (async op handle is wrong)

		// Reset the context.
		nonhostcontext.afAsyncOpCompleted[0] = FALSE;
		CloseHandle(nonhostcontext.ahAsyncOpCompletedEvent[0]);
		nonhostcontext.ahAsyncOpCompletedEvent[0] = NULL;

		adpnhEnumHosts[0] = (DPNHANDLE) 0x666;

		nonhostcontext.adwExpectedCurrentPlayers[0] = 0;

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Connecting peer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

// XBOX - Had to make connection asynchronous

		// Host should get the create player now.
		CREATEEVENT_OR_THROW(hostcontext.hClientCreatedEvent, NULL, FALSE, FALSE, NULL);
		SAFE_CLOSEHANDLE(hAsyncOpComplete);
		CREATEEVENT_OR_THROW(hAsyncOpComplete, NULL, FALSE, FALSE, NULL);

		// Even though it's synchronous, we'll still get a completion.  The async op
		// handle will be NULL, though.
		nonhostcontext.fConnectCanComplete = TRUE;

		tr = pDP8Peer->DP8P_Connect(&dpnad,
									nonhostcontext.apExpectedDP8AddressSender[0],
									NULL,
									NULL,
									NULL,
									NULL,
									0,
									&(nonhostcontext.dpnidClient),
									hAsyncOpComplete,
									&hAsyncOp,
									0);

		if((tr != DPNSUCCESS_PENDING) && (tr != DPN_OK))
		{
			DPTEST_FAIL(hLog, "Couldn't connect! (error 0x%08x)", 1, tr);
			THROW_TESTRESULT;
		} // end if (couldn't connect)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for connect to complete on non-host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hAsyncOpComplete))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird connects from completing.
		nonhostcontext.fConnectCanComplete = FALSE;

		// Make sure we saw the connect completion indication.
		if (! nonhostcontext.fConnectCompleted)
		{
			DPTEST_FAIL(hLog, "Didn't get connect complete indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (connect didn't complete)

		// Reset the context.
		nonhostcontext.fConnectCompleted = FALSE;

		// Make sure we got the create player messages.
		if (nonhostcontext.dpnidHost == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication for host on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player)

		if (nonhostcontext.dpnidClient == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication for client on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for create player to be indicated on host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hostcontext.hClientCreatedEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enuming hosts after connecting");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Expect responses and the completion message on the client.
		nonhostcontext.adwExpectedCurrentPlayers[0] = 2;
		nonhostcontext.afCanGetResponses[0] = TRUE;
		nonhostcontext.ahrExpectedResult[0] = DPN_OK;
		CREATEEVENT_OR_THROW(nonhostcontext.ahAsyncOpCompletedEvent[0],
							NULL, FALSE, FALSE, NULL);
		nonhostcontext.afAsyncOpCanComplete[0] = TRUE;

		tr = pDP8Peer->DP8P_EnumHosts(&dpnad, nonhostcontext.apExpectedDP8AddressSender[0],
									pDP8AddressDevice, NULL, 0, 0, 0, 0,
									(PVOID) ((DWORD_PTR) 1), &(adpnhEnumHosts[0]), 0);
		if (tr != (HRESULT) DPNSUCCESS_PENDING)
		{
			DPTEST_FAIL(hLog, "Enuming hosts on client didn't return expected PENDING success code!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum hosts)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		if (adpnhEnumHosts[0] == (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "No async operation handle was returned!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (handle was not set)

		if (adpnhEnumHosts[0] == NULL)
		{
			DPTEST_FAIL(hLog, "Async operation handle returned is NULL!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (handle was set to NULL)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for async op to complete (may take a little while)");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, nonhostcontext.ahAsyncOpCompletedEvent[0]))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent more responses from coming in.
		nonhostcontext.afCanGetResponses[0] = FALSE;

		// Prevent any weird async op completions.
		nonhostcontext.afAsyncOpCanComplete[0] = FALSE;


#ifdef DEBUG
		// Make sure we got the indication (how else would we get here?).
		if (! nonhostcontext.afAsyncOpCompleted[0])
		{
			DPTEST_FAIL(hLog, "Didn't get async op completion!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (didn't get async op completion)
#endif // DEBUG

		// Make sure the completion indicated the same op handle that we were
		// returned.
		if (nonhostcontext.adpnhCompletedAsyncOp[0] != adpnhEnumHosts[0])
		{
			DPTEST_FAIL(hLog, "Enum hosts 1 completed with different async op handle (%x != %x)!",
				2, nonhostcontext.adpnhCompletedAsyncOp[0], adpnhEnumHosts[0]);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (async op handle is wrong)

		// Reset the context.
		nonhostcontext.afAsyncOpCompleted[0] = FALSE;
		CloseHandle(nonhostcontext.ahAsyncOpCompletedEvent[0]);
		nonhostcontext.ahAsyncOpCompletedEvent[0] = NULL;

		adpnhEnumHosts[0] = (DPNHANDLE) 0x666;

		nonhostcontext.adwExpectedCurrentPlayers[0] = 0;





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing peer client object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing peer client object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing host object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8PeerHost->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing host object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure we got the destroy player message.
		if (hostcontext.dpnidHost != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing hosting DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8PeerHost->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release hosting DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8PeerHost);
		pDP8PeerHost = NULL;






		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Peer);
		pDP8Peer = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE


	if (pDP8Peer != NULL)
	{
		delete (pDP8Peer);
		pDP8Peer = NULL;
	} // end if (have peer object)

	if (pDP8PeerHost != NULL)
	{
		delete (pDP8PeerHost);
		pDP8PeerHost = NULL;
	} // end if (have peer object)

	SAFE_RELEASE(pDP8AddressHost);
	SAFE_RELEASE(pDP8AddressDevice);
	SAFE_RELEASE(pDP8AddressDeviceCompare);
	for(dwTemp1 = 0; dwTemp1 < 2; dwTemp1++)
	{
		if (dwTemp1 == 0)
			pContext = &hostcontext;
		else
			pContext = &nonhostcontext;

		for (dwTemp2 = 0; dwTemp2 < 2; dwTemp2++)
		{
			SAFE_RELEASE(pContext->apExpectedDP8AddressSender[dwTemp2]);
			SAFE_RELEASE(pContext->apExpectedDP8AddressDevice[dwTemp2]);
			SAFE_CLOSEHANDLE(pContext->ahAsyncOpCompletedEvent[dwTemp2]);
		} // end for (each op)
	} // end for (each op)
	SAFE_LOCALFREE(pvTooLargeEnumData);
	SAFE_CLOSEHANDLE(hostcontext.hClientCreatedEvent);
	ClearDoWorkList(&DoWorkList);
	SAFE_CLOSEHANDLE(hAsyncOpComplete);

	return (sr);
} // ParmVPeerExec_EnumHosts
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVPeerExec_DestroyPeer()"
//==================================================================================
// ParmVPeerExec_DestroyPeer
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.1.25 - Peer DestroyPeer parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVPeerExec_DestroyPeer(HANDLE hLog)
{
	CTNSystemResult				sr;
	CTNTestResult				tr;
	PWRAPDP8PEER				pDP8Peer = NULL;
	PWRAPDP8PEER				pDP8PeerHost = NULL;
	PDIRECTPLAY8ADDRESS			pDP8Address = NULL;
	DPN_BUFFER_DESC				dpnbd;
	DPN_APPLICATION_DESC		dpnad;
	DPN_APPLICATION_DESC		dpnadCompare;
	PARMVPDESTROYPEERCONTEXT	hostcontext;
	PARMVPDESTROYPEERCONTEXT	nonhostcontext;
	DP_DOWORKLIST				DoWorkList;
	DPNHANDLE					hAsyncOp;
	HANDLE						hAsyncOpComplete = NULL;

	ZeroMemory(&DoWorkList, sizeof(DP_DOWORKLIST));
	ZeroMemory(&hostcontext, sizeof (PARMVPDESTROYPEERCONTEXT));
	ZeroMemory(&nonhostcontext, sizeof (PARMVPDESTROYPEERCONTEXT));
	ZeroMemory(&dpnbd, sizeof (DPN_BUFFER_DESC));


	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Peer = new CWrapDP8Peer(hLog);
		if (pDP8Peer == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8Peer->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (LPVOID *) &pDP8Address, NULL);
		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't create DirectPlay8Address object!", 0);
			THROW_SYSTEMRESULT;
		} // end if (create failed)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting address object's SP to TCP/IP");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->SetSP(&CLSID_DP8SP_TCPIP);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting address object's SP to TCP/IP failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set SP)





/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Destroying peer 0 using C++ macro");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = IDirectPlay8Peer_DestroyPeer(pDP8Peer->m_pDP8Peer, 0, NULL, 0, 0);
		if (tr != DPNERR_INVALIDPLAYER)
		{
			DPTEST_FAIL(hLog, "Destroying peer 0 using C++ macro didn't return expected error INVALIDPLAYER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't destroy peer)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Destroying peer 0");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_DestroyPeer(0, NULL, 0, 0);
		if (tr != DPNERR_INVALIDPLAYER)
		{
			DPTEST_FAIL(hLog, "Destroying peer 0 didn't return expected error INVALIDPLAYER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't destroy peer)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Destroying peer before initialization");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Use 0x666 to avoid DPlay's player ID == 0 check.
		tr = pDP8Peer->DP8P_DestroyPeer((DPNID) 0x666, NULL, 0, 0);
		if (tr != DPNERR_UNINITIALIZED)
		{
			DPTEST_FAIL(hLog, "Destroying peer before initialization didn't return expected error UNINITIALIZED!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't destroy peer)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Destroying peer with NULL buffer but non-zero size");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_DestroyPeer((DPNID) 0x666, NULL, 666, 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Destroying peer with NULL buffer but non-zero size return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't destroy peer)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Destroying peer with invalid flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_DestroyPeer((DPNID) 0x666, NULL, 0, 0x666);
		if (tr != DPNERR_INVALIDFLAGS)
		{
			DPTEST_FAIL(hLog, "Destroying peer with invalid flags didn't return expected error INVALIDFLAGS!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't destroy peer)
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Initializing peer object with host context");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		hostcontext.hLog = hLog;

		tr = pDP8Peer->DP8P_Initialize(&hostcontext, ParmVPDestroyPeerDPNMessageHandler, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Initializing peer object with host context failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Destroying peer without a connection");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_DestroyPeer((DPNID) 0x666, NULL, 0, 0);
		if (tr != DPNERR_NOCONNECTION)
		{
			DPTEST_FAIL(hLog, "Destroying peer without a connection didn't return expected error NOCONNECTION!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't destroy peer)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Hosting session");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Expect a create player message for self.
		hostcontext.afExpectCreatePlayer[0] = TRUE;

		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		//dpnad.dwFlags = 0;
		//dpnad.guidInstance = GUID_NULL;
		dpnad.guidApplication = GUID_PARMV_PEER_GETAPPDESC;
		//dpnad.dwMaxPlayers = 0;
		//dpnad.dwCurrentPlayers = 0;
		//dpnad.pwszSessionName = NULL;
		//dpnad.pwszPassword = NULL;
		//dpnad.pvReservedData = NULL;
		//dpnad.dwReservedDataSize = 0;
		//dpnad.pvApplicationReservedData = NULL;
		//dpnad.dwApplicationReservedDataSize = 0;

		// Save what we're passing in to make sure it's not touched.
		CopyMemory(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC));

		tr = pDP8Peer->DP8P_Host(&dpnad,
								&pDP8Address,
								1,
								NULL,
								NULL,
								&(hostcontext.adpnidPlayers[0]),
								0);

		// Prevent any weird create player indications.
		hostcontext.afExpectCreatePlayer[0] = FALSE;

		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't start hosting session!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't host)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		// Make sure the create player indication came in.
		if (hostcontext.adpnidPlayers[0] == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get create player indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player indication)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Destroying peer with invalid player");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_DestroyPeer((DPNID) 0x666, NULL, 0, 0);
		if (tr != DPNERR_INVALIDPLAYER)
		{
			DPTEST_FAIL(hLog, "Destroying peer with invalid player didn't return expected error INVALIDPLAYER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't destroy peer)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Destroying peer with self player");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_DestroyPeer(hostcontext.adpnidPlayers[0], NULL, 0, 0);
		if (tr != DPNERR_INVALIDPLAYER)
		{
			DPTEST_FAIL(hLog, "Destroying peer with self player didn't return expected error INVALIDPLAYER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't destroy peer)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Expect a destroy player message for self.
		hostcontext.dwNumDestroyPlayersRemaining = 1;
		hostcontext.afExpectDestroyPlayer[0] = TRUE;

		tr = pDP8Peer->DP8P_Close(0);

		// Prevent any weird destroy player messages.
		hostcontext.afExpectDestroyPlayer[0] = FALSE;

		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing peer object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure the destroy player indication came in.
		if (hostcontext.adpnidPlayers[0] != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get destroy player indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player indication)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Re-initializing peer object with nonhost context");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		nonhostcontext.hLog = hLog;

		tr = pDP8Peer->DP8P_Initialize(&nonhostcontext,
										ParmVPDestroyPeerDPNMessageHandler,
										0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Re-initializing peer object with context, 0 flags failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating new peer host object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Address->Release();
		pDP8Address = NULL;

		// Expect a create player message for self.
		hostcontext.afExpectCreatePlayer[0] = TRUE;

		hostcontext.hLog = hLog;

		tr = ParmVCreatePeerHost(hLog, ParmVPDestroyPeerDPNMessageHandler,
								&hostcontext,
								&dpnad,
								&(hostcontext.adpnidPlayers[0]),
								&pDP8PeerHost,
								&pDP8Address);

		// Prevent any weird create player indications.
		hostcontext.afExpectCreatePlayer[0] = FALSE;

		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Creating peer host failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't create peer host)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Connecting peer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

// XBOX - Had to make connection asynchronous

		SAFE_CLOSEHANDLE(hAsyncOpComplete);
		CREATEEVENT_OR_THROW(hAsyncOpComplete, NULL, FALSE, FALSE, NULL);

		// Expect a create player message for client on host.
		CREATEEVENT_OR_THROW(hostcontext.hLastPlayerMsgEvent,
							NULL, FALSE, FALSE, NULL);
		hostcontext.afExpectCreatePlayer[1] = TRUE;

		// Expect a create player message for self and host on client.
		nonhostcontext.afExpectCreatePlayer[0] = TRUE;
		nonhostcontext.afExpectCreatePlayer[1] = TRUE;

		// Even though it's synchronous, we'll still get a completion.  The async op
		// handle will be NULL, though.
		nonhostcontext.fConnectCanComplete = TRUE;


		tr = pDP8Peer->DP8P_Connect(&dpnad,
									pDP8Address,
									NULL,
									NULL,
									NULL,
									NULL,
									0,
									&(nonhostcontext.adpnidPlayers[0]),
									hAsyncOpComplete,
									&hAsyncOp,
									0);

		if((tr != DPNSUCCESS_PENDING) && (tr != DPN_OK))
		{
			DPTEST_FAIL(hLog, "Couldn't connect! (error 0x%08x)", 1, tr);
			THROW_TESTRESULT;
		} // end if (couldn't connect)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for connect to complete on non-host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hAsyncOpComplete))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird connects from completing or stray create players.
		nonhostcontext.fConnectCanComplete = FALSE;
		nonhostcontext.afExpectCreatePlayer[0] = FALSE;
		nonhostcontext.afExpectCreatePlayer[1] = FALSE;

		// Make sure we saw the connect completion indication.
		if (! nonhostcontext.fConnectCompleted)
		{
			DPTEST_FAIL(hLog, "Didn't get connect complete indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (connect didn't complete)

		// Reset the context.
		nonhostcontext.fConnectCompleted = FALSE;

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for create player message on host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[0] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hostcontext.hLastPlayerMsgEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird create player messages.
		hostcontext.afExpectCreatePlayer[1] = FALSE;

#ifdef DEBUG
		// Make sure the player was created (how else would we get here?).
		if (hostcontext.adpnidPlayers[1] == 0)
		{
			DPTEST_FAIL(hLog, "Create player didn't arrive!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (create player didn't arrive)
#endif // DEBUG

		// Reset the context.
		CloseHandle(hostcontext.hLastPlayerMsgEvent);
		hostcontext.hLastPlayerMsgEvent = NULL;



		// Make sure the IDs match.
		if (hostcontext.adpnidPlayers[0] != nonhostcontext.adpnidPlayers[1])
		{
			DPTEST_FAIL(hLog, "Host and client disagree on host's player ID (%u/%x != %u/%x)!",
				4, hostcontext.adpnidPlayers[0], hostcontext.adpnidPlayers[0],
				nonhostcontext.adpnidPlayers[1], nonhostcontext.adpnidPlayers[1]);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (host ID doesn't match)

		if (hostcontext.adpnidPlayers[1] != nonhostcontext.adpnidPlayers[0])
		{
			DPTEST_FAIL(hLog, "Host and client disagree on client's player ID (%u/%x != %u/%x)!",
				4, hostcontext.adpnidPlayers[1], hostcontext.adpnidPlayers[1],
				nonhostcontext.adpnidPlayers[0], nonhostcontext.adpnidPlayers[0]);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (client ID doesn't match)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Send 128 bytes from host to non-host with timeout that will expire");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Allocate a 128 byte buffer
		LOCALALLOC_OR_THROW(PBYTE, dpnbd.pBufferData, 128);
		dpnbd.dwBufferSize = 128;

		// It will now be okay for the send to complete.
		CREATEEVENT_OR_THROW(hostcontext.hSendCompleteEvent, NULL, FALSE, FALSE, NULL);
		hostcontext.hrExpectedResult = DPNERR_TIMEDOUT;
		hostcontext.hrActualResult = DPN_OK;
		hostcontext.fSendCanComplete = TRUE;

		tr = pDP8PeerHost->m_pDP8Peer->SendTo(hostcontext.adpnidPlayers[1], &dpnbd, 1, 50, NULL, &hAsyncOp, 0);
		if (tr != (HRESULT) DPNSUCCESS_PENDING)
		{
			DPTEST_FAIL(hLog, "Sending 128 bytes to non-host didn't return expected PENDING success code!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't send to)

		hAsyncOp = NULL;

		Sleep(1000);

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for async send to timeout");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[0] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hostcontext.hSendCompleteEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird sends from completing.
		hostcontext.fSendCanComplete = FALSE;

		// Reset the context.
		SAFE_CLOSEHANDLE(hostcontext.hSendCompleteEvent);
		hostcontext.hSendCompleteEvent = NULL;
		hostcontext.dpnhCompletedAsyncOp = NULL;

		SAFE_LOCALFREE(dpnbd.pBufferData);

		if(hostcontext.hrExpectedResult != hostcontext.hrActualResult)
		{
			DPTEST_FAIL(hLog, "Send with timeout returned unexpected completion value (0x%08x != 0x%08x", 2,
				hostcontext.hrActualResult, hostcontext.hrExpectedResult);
			fPassed = FALSE;
		}



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Destroying host player on client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_DestroyPeer(nonhostcontext.adpnidPlayers[1], NULL, 0, 0);
		if (tr != DPNERR_NOTHOST)
		{
			DPTEST_FAIL(hLog, "Destroying host player on client didn't return expected error NOTHOST!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't destroy peer)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Destroying self player on client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_DestroyPeer(nonhostcontext.adpnidPlayers[0], NULL, 0, 0);
		if (tr != DPNERR_NOTHOST)
		{
			DPTEST_FAIL(hLog, "Destroying self player on client didn't return expected error NOTHOST!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't destroy peer)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Destroying client player on host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Expect the destroy player message on the host.
		CREATEEVENT_OR_THROW(hostcontext.hLastPlayerMsgEvent,
							NULL, FALSE, FALSE, NULL);
		hostcontext.dwNumDestroyPlayersRemaining = 1;
		hostcontext.afExpectDestroyPlayer[1] = TRUE;

		// Expect the 2 destroy player messages and terminate session on the client.
		CREATEEVENT_OR_THROW(nonhostcontext.hLastPlayerMsgEvent,
							NULL, FALSE, FALSE, NULL);
		nonhostcontext.dwNumDestroyPlayersRemaining = 2;
		nonhostcontext.afExpectDestroyPlayer[0] = TRUE;
		nonhostcontext.afExpectDestroyPlayer[1] = TRUE;
		nonhostcontext.fExpectTerminateSession = TRUE;

		tr = pDP8PeerHost->DP8P_DestroyPeer(hostcontext.adpnidPlayers[1], NULL, 0, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Destroying client player on host failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't destroy peer)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for destroy player messages on client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[0] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, nonhostcontext.hLastPlayerMsgEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird destroy player or terminate session messages.
		nonhostcontext.afExpectDestroyPlayer[0] = FALSE;
		nonhostcontext.afExpectDestroyPlayer[1] = FALSE;
		nonhostcontext.fExpectTerminateSession = FALSE;

#ifdef DEBUG
		// Make sure the players were destroyed (how else would we get here?).
		if (nonhostcontext.adpnidPlayers[0] != 0)
		{
			DPTEST_FAIL(hLog, "Destroy player for self didn't arrive!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (destroy player didn't arrive)

		if (nonhostcontext.adpnidPlayers[1] != 0)
		{
			DPTEST_FAIL(hLog, "Destroy player for host didn't arrive!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (destroy player didn't arrive)
#endif // DEBUG

		// Make sure we got the terminate session message.
		if (! nonhostcontext.fGotTerminateSession)
		{
			DPTEST_FAIL(hLog, "Didn't get terminate session indication!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (terminate session didn't arrive)

		// Reset the context.
		CloseHandle(nonhostcontext.hLastPlayerMsgEvent);
		nonhostcontext.hLastPlayerMsgEvent = NULL;
		nonhostcontext.fGotTerminateSession = FALSE;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for destroy player message on host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[0] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hostcontext.hLastPlayerMsgEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird destroy player messages.
		hostcontext.afExpectDestroyPlayer[1] = FALSE;

#ifdef DEBUG
		// Make sure the player was destroyed (how else would we get here?).
		if (hostcontext.adpnidPlayers[1] != 0)
		{
			DPTEST_FAIL(hLog, "Destroy player didn't arrive!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (destroy player didn't arrive)
#endif // DEBUG

		// Reset the context.
		CloseHandle(hostcontext.hLastPlayerMsgEvent);
		hostcontext.hLastPlayerMsgEvent = NULL;





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing peer client object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing peer client object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing host object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Expect a destroy player message for self.
		hostcontext.dwNumDestroyPlayersRemaining = 1;
		hostcontext.afExpectDestroyPlayer[0] = TRUE;

		tr = pDP8PeerHost->DP8P_Close(0);

		// Prevent any weird destroy player messages.
		hostcontext.afExpectDestroyPlayer[0] = FALSE;

		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing host object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure the destroy player indication came in.
		if (hostcontext.adpnidPlayers[0] != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get destroy player indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player indication)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing hosting DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8PeerHost->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release hosting DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8PeerHost);
		pDP8PeerHost = NULL;






		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Peer);
		pDP8Peer = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE


	if (pDP8Peer != NULL)
	{
		delete (pDP8Peer);
		pDP8Peer = NULL;
	} // end if (have peer object)

	if (pDP8PeerHost != NULL)
	{
		delete (pDP8PeerHost);
		pDP8PeerHost = NULL;
	} // end if (have peer object)

	SAFE_RELEASE(pDP8Address);
	SAFE_CLOSEHANDLE(hostcontext.hLastPlayerMsgEvent);
	SAFE_CLOSEHANDLE(nonhostcontext.hLastPlayerMsgEvent);
	ClearDoWorkList(&DoWorkList);
	SAFE_CLOSEHANDLE(hAsyncOpComplete);
	SAFE_LOCALFREE(dpnbd.pBufferData);
	SAFE_CLOSEHANDLE(hostcontext.hSendCompleteEvent);

	return (sr);
} // ParmVPeerExec_DestroyPeer
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVPeerExec_Return()"
//==================================================================================
// ParmVPeerExec_Return
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.1.26 - Peer ReturnBuffer parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVPeerExec_Return(HANDLE hLog)
{
	CTNSystemResult			sr;
	CTNTestResult			tr;
	PWRAPDP8PEER			pDP8Peer = NULL;
	PDIRECTPLAY8ADDRESS		pDP8Address = NULL;
	DPN_APPLICATION_DESC	dpnad;
	DPN_APPLICATION_DESC	dpnadCompare;
	DPN_BUFFER_DESC			dpnbd;
	PARMVPRETURNCONTEXT		context;
	DP_DOWORKLIST			DoWorkList;
	DPNHANDLE				hAsyncOp;

	ZeroMemory(&DoWorkList, sizeof(DP_DOWORKLIST));
	ZeroMemory(&context, sizeof (PARMVPRETURNCONTEXT));


	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Peer = new CWrapDP8Peer(hLog);
		if (pDP8Peer == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8Peer->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (LPVOID *) &pDP8Address, NULL);
		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't create DirectPlay8Address object!", 0);
			THROW_SYSTEMRESULT;
		} // end if (create failed)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting address object's SP to TCP/IP");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->SetSP(&CLSID_DP8SP_TCPIP);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting address object's SP to TCP/IP failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set SP)





/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Returning NULL buffer handle using C++ macro");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = IDirectPlay8Peer_ReturnBuffer(pDP8Peer->m_pDP8Peer, NULL, 0);
		if (tr != DPNERR_INVALIDHANDLE)
		{
			DPTEST_FAIL(hLog, "Returning NULL buffer handle using C++ macro didn't return expected error INVALIDHANDLE!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't return buffer)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Returning NULL buffer handle");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_ReturnBuffer(NULL, 0);
		if (tr != DPNERR_INVALIDHANDLE)
		{
			DPTEST_FAIL(hLog, "Returning NULL buffer handle didn't return expected error INVALIDHANDLE!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't return buffer)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Returning buffer with invalid flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Use 0x666 to get around DPlay's handle == NULL check.
		tr = pDP8Peer->DP8P_ReturnBuffer((DPNHANDLE) 0x666, 0x666);
		if (tr != DPNERR_INVALIDFLAGS)
		{
			DPTEST_FAIL(hLog, "Returning buffer with invalid flags didn't return expected error INVALIDFLAGS!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't return buffer)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Returning buffer before initialization");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_ReturnBuffer((DPNHANDLE) 0x666, 0);
		if (tr != DPNERR_UNINITIALIZED)
		{
			DPTEST_FAIL(hLog, "Returning buffer before initialization didn't return expected error UNINITIALIZED!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't return buffer)
*/




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Initializing with 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		context.hLog = hLog;

		tr = pDP8Peer->DP8P_Initialize(&context, ParmVPReturnDPNMessageHandler, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Initializing with 0 flags failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Returning buffer without a connection");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_ReturnBuffer((DPNHANDLE) 0x666, 0);
		if (tr != DPNERR_NOCONNECTION)
		{
			DPTEST_FAIL(hLog, "Returning buffer without a connection didn't return expected error NOCONNECTION!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't return buffer)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Hosting session");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		//dpnad.dwFlags = 0;
		//dpnad.guidInstance = GUID_NULL;
		dpnad.guidApplication = GUID_PARMV_PEER_HOST;
		//dpnad.dwMaxPlayers = 0;
		//dpnad.dwCurrentPlayers = 0;
		//dpnad.pwszSessionName = NULL;
		//dpnad.pwszPassword = NULL;
		//dpnad.pvReservedData = NULL;
		//dpnad.dwReservedDataSize = 0;
		//dpnad.pvApplicationReservedData = NULL;
		//dpnad.dwApplicationReservedDataSize = 0;

		// Save what we're passing in to make sure it's not touched.
		CopyMemory(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC));

		tr = pDP8Peer->DP8P_Host(&dpnad,
								&pDP8Address,
								1,
								NULL,
								NULL,
								&(context.dpnidPlayer),
								0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't start hosting session!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't host)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		// Make sure we got the create player message.
		if (context.dpnidPlayer == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Sending message to self");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpnbd, sizeof (DPN_BUFFER_DESC));
		dpnbd.pBufferData = (PBYTE) "This is the send string which we will use.";
		dpnbd.dwBufferSize = strlen("This is the send string which we will use.") + 1;


		// Expect the receive to arrive.
		CREATEEVENT_OR_THROW(context.hReceivedMsgEvent, NULL, FALSE, FALSE, NULL);
		context.fExpectReceive = TRUE;

		// BUGBUG - Xbox - Added DPNSEND_NOCOMPLETE so that the message handler won't complain about the SEND_COMPLETE
		tr = pDP8Peer->DP8P_SendTo(context.dpnidPlayer, &dpnbd, 1, 0, NULL, &hAsyncOp, DPNSEND_NOCOMPLETE);
		if((tr != DPN_OK) && (tr != DPNSUCCESS_PENDING))
		{
			DPTEST_FAIL(hLog, "Couldn't send message! (error 0x%08x)", 1, tr);
			THROW_TESTRESULT;
		} // end if (couldn't send message to self)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for receive to arrive");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 1;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, context.hReceivedMsgEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird receives.
		context.fExpectReceive = FALSE;

#ifdef DEBUG
		// Make sure we got the receive indication (how else would we get here?).
		if (context.dpnhBuffer == NULL)
		{
			DPTEST_FAIL(hLog, "Didn't get send buffer!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get buffer)
#endif // DEBUG

		// Reset the context.
		CloseHandle(context.hReceivedMsgEvent);
		context.hReceivedMsgEvent = NULL;






		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Returning kept send buffer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_ReturnBuffer(context.dpnhBuffer, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Returning kept send buffer failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't return buffer)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing peer object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure we got the destroy player message.
		if (context.dpnidPlayer != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Peer);
		pDP8Peer = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE


	if (pDP8Peer != NULL)
	{
		delete (pDP8Peer);
		pDP8Peer = NULL;
	} // end if (have peer object)

	SAFE_RELEASE(pDP8Address);
	SAFE_CLOSEHANDLE(context.hReceivedMsgEvent);
	ClearDoWorkList(&DoWorkList);

	return (sr);
} // ParmVPeerExec_Return
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVPeerExec_GetPlayerContext()"
//==================================================================================
// ParmVPeerExec_GetPlayerContext
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.1.27 - Peer GetPlayerContext parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVPeerExec_GetPlayerContext(HANDLE hLog)
{
	CTNSystemResult					sr;
	CTNTestResult					tr;
	PWRAPDP8PEER					pDP8Peer = NULL;
	PWRAPDP8PEER					pDP8PeerHost = NULL;
	PDIRECTPLAY8ADDRESS				pDP8Address = NULL;
	DPN_APPLICATION_DESC			dpnad;
	DPN_APPLICATION_DESC			dpnadCompare;
	PARMVPGETPLAYERCONTEXTCONTEXT	hostcontext;
	PARMVPGETPLAYERCONTEXTCONTEXT	nonhostcontext;
	PVOID							pvPlayerContext;
	DP_DOWORKLIST					DoWorkList;
	DPNHANDLE						hAsyncOp;
	HANDLE							hAsyncOpComplete = NULL;

	ZeroMemory(&DoWorkList, sizeof(DP_DOWORKLIST));
	ZeroMemory(&hostcontext, sizeof (PARMVPGETPLAYERCONTEXTCONTEXT));
	ZeroMemory(&nonhostcontext, sizeof (PARMVPGETPLAYERCONTEXTCONTEXT));


	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Peer = new CWrapDP8Peer(hLog);
		if (pDP8Peer == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8Peer->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (LPVOID *) &pDP8Address, NULL);
		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't create DirectPlay8Address object!", 0);
			THROW_SYSTEMRESULT;
		} // end if (create failed)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting address object's SP to TCP/IP");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->SetSP(&CLSID_DP8SP_TCPIP);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting address object's SP to TCP/IP failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set SP)





/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting player 0 context using C++ macro");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = IDirectPlay8Peer_GetPlayerContext(pDP8Peer->m_pDP8Peer, 0, NULL, 0);
		if (tr != DPNERR_INVALIDPLAYER)
		{
			DPTEST_FAIL(hLog, "Getting player 0 context using C++ macro didn't return expected error INVALIDPLAYER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get player context)
*/




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting player 0 context");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_GetPlayerContext(0, NULL, 0);
		if (tr != DPNERR_INVALIDPLAYER)
		{
			DPTEST_FAIL(hLog, "Getting player 0 context didn't return expected error INVALIDPLAYER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get player context)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting player context with NULL pointer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Use 0x666 to avoid DPlay's player ID == 0 check.
		tr = pDP8Peer->DP8P_GetPlayerContext((DPNID) 0x666, NULL, 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Getting player context with NULL pointer didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get player context)
*/

		pvPlayerContext = (PVOID) 0x666;

/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting player context with invalid flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_GetPlayerContext((DPNID) 0x666, &pvPlayerContext, 0x666);
		if (tr != DPNERR_INVALIDFLAGS)
		{
			DPTEST_FAIL(hLog, "Getting player context with invalid flags didn't return expected error INVALIDFLAGS!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get player context)

		if (pvPlayerContext != (PVOID) 0x666)
		{
			DPTEST_FAIL(hLog, "Player context was modified (%x != 0x666)!", 1, pvPlayerContext);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (player context was touched)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting player context before initialization");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_GetPlayerContext((DPNID) 0x666, &pvPlayerContext, 0);
		if (tr != DPNERR_UNINITIALIZED)
		{
			DPTEST_FAIL(hLog, "Getting player context before initialization didn't return expected error UNINITIALIZED!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get player context)

		if (pvPlayerContext != (PVOID) 0x666)
		{
			DPTEST_FAIL(hLog, "Player context was modified (%x != 0x666)!", 1, pvPlayerContext);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (player context was touched)
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Initializing peer object with host context");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		hostcontext.hLog = hLog;

		tr = pDP8Peer->DP8P_Initialize(&hostcontext,
										ParmVPGetPlayerContextDPNMessageHandler, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Initializing peer object with host context failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting player context without a connection");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_GetPlayerContext((DPNID) 0x666, &pvPlayerContext, 0);
		if (tr != DPNERR_NOCONNECTION)
		{
			DPTEST_FAIL(hLog, "Getting player context without a connection didn't return expected error NOCONNECTION!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get player context)

		if (pvPlayerContext != (PVOID) 0x666)
		{
			DPTEST_FAIL(hLog, "Player context was modified (%x != 0x666)!", 1, pvPlayerContext);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (player context was touched)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Hosting session");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Expect a create player message for self.
		hostcontext.afExpectCreatePlayer[0] = TRUE;

		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		//dpnad.dwFlags = 0;
		//dpnad.guidInstance = GUID_NULL;
		dpnad.guidApplication = GUID_PARMV_PEER_GETAPPDESC;
		//dpnad.dwMaxPlayers = 0;
		//dpnad.dwCurrentPlayers = 0;
		//dpnad.pwszSessionName = NULL;
		//dpnad.pwszPassword = NULL;
		//dpnad.pvReservedData = NULL;
		//dpnad.dwReservedDataSize = 0;
		//dpnad.pvApplicationReservedData = NULL;
		//dpnad.dwApplicationReservedDataSize = 0;

		// Save what we're passing in to make sure it's not touched.
		CopyMemory(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC));

		tr = pDP8Peer->DP8P_Host(&dpnad,
								&pDP8Address,
								1,
								NULL,
								NULL,
								&(hostcontext.adpnidPlayers[0]),
								0);

		// Prevent any weird create player indications.
		hostcontext.afExpectCreatePlayer[0] = FALSE;

		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't start hosting session!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't host)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		// Make sure the create player indication came in.
		if (hostcontext.adpnidPlayers[0] == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get create player indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player indication)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting player context for invalid player");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_GetPlayerContext((DPNID) 0x666, &pvPlayerContext, 0);
		if (tr != DPNERR_INVALIDPLAYER)
		{
			DPTEST_FAIL(hLog, "Getting player context for invalid player didn't return expected error INVALIDPLAYER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get player context)

		if (pvPlayerContext != (PVOID) 0x666)
		{
			DPTEST_FAIL(hLog, "Player context was modified (%x != 0x666)!", 1, pvPlayerContext);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (player context was touched)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting player context");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_GetPlayerContext(hostcontext.adpnidPlayers[0],
											&pvPlayerContext, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting player context failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get player context)

		if (pvPlayerContext != &(hostcontext.adpnidPlayers[0]))
		{
			DPTEST_FAIL(hLog, "Player context returned was invalid (%x != %x)!",
				2, pvPlayerContext, &(hostcontext.adpnidPlayers[0]));
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (player context was touched)

		pvPlayerContext = (PVOID) 0x666;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Expect a destroy player message for self.
		hostcontext.dwNumDestroyPlayersRemaining = 1;
		hostcontext.afExpectDestroyPlayer[0] = TRUE;

		tr = pDP8Peer->DP8P_Close(0);

		// Prevent any weird destroy player messages.
		hostcontext.afExpectDestroyPlayer[0] = FALSE;

		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing peer object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure the destroy player indication came in.
		if (hostcontext.adpnidPlayers[0] != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get destroy player indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player indication)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Re-initializing peer object with nonhost context");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		nonhostcontext.hLog = hLog;

		tr = pDP8Peer->DP8P_Initialize(&nonhostcontext,
										ParmVPGetPlayerContextDPNMessageHandler,
										0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Re-initializing peer object with context, 0 flags failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating new peer host object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Address->Release();
		pDP8Address = NULL;

		// Expect a create player message for self.
		hostcontext.afExpectCreatePlayer[0] = TRUE;

		hostcontext.hLog = hLog;

		tr = ParmVCreatePeerHost(hLog, ParmVPGetPlayerContextDPNMessageHandler,
								&hostcontext,
								&dpnad,
								&(hostcontext.adpnidPlayers[0]),
								&pDP8PeerHost,
								&pDP8Address);

		// Prevent any weird create player indications.
		hostcontext.afExpectCreatePlayer[0] = FALSE;

		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Creating peer host failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't create peer host)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Connecting peer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

// XBOX - Had to make connection asynchronous

		SAFE_CLOSEHANDLE(hAsyncOpComplete);
		CREATEEVENT_OR_THROW(hAsyncOpComplete, NULL, FALSE, FALSE, NULL);

		// Expect a create player message for client on host.
		CREATEEVENT_OR_THROW(hostcontext.hLastPlayerMsgEvent,
							NULL, FALSE, FALSE, NULL);
		hostcontext.afExpectCreatePlayer[1] = TRUE;

		// Expect a create player message for self and host on client.
		nonhostcontext.afExpectCreatePlayer[0] = TRUE;
		nonhostcontext.afExpectCreatePlayer[1] = TRUE;

		// Even though it's synchronous, we'll still get a completion.  The async op
		// handle will be NULL, though.
		nonhostcontext.fConnectCanComplete = TRUE;

		tr = pDP8Peer->DP8P_Connect(&dpnad,
									pDP8Address,
									NULL,
									NULL,
									NULL,
									NULL,
									0,
									&(nonhostcontext.adpnidPlayers[0]),
									hAsyncOpComplete,
									&hAsyncOp,
									0);

		if((tr != DPNSUCCESS_PENDING) && (tr != DPN_OK))
		{
			DPTEST_FAIL(hLog, "Couldn't connect! (error 0x%08x)", 1, tr);
			THROW_TESTRESULT;
		} // end if (couldn't connect)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for connect to complete on non-host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hAsyncOpComplete))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird connects from completing or stray create players.
		nonhostcontext.fConnectCanComplete = FALSE;
		nonhostcontext.afExpectCreatePlayer[0] = FALSE;
		nonhostcontext.afExpectCreatePlayer[1] = FALSE;

		// Make sure we saw the connect completion indication.
		if (! nonhostcontext.fConnectCompleted)
		{
			DPTEST_FAIL(hLog, "Didn't get connect complete indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (connect didn't complete)

		// Reset the context.
		nonhostcontext.fConnectCompleted = FALSE;



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for create player message on host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hostcontext.hLastPlayerMsgEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird create player messages.
		hostcontext.afExpectCreatePlayer[1] = FALSE;

#ifdef DEBUG
		// Make sure the player was created (how else would we get here?).
		if (hostcontext.adpnidPlayers[1] == 0)
		{
			DPTEST_FAIL(hLog, "Create player didn't arrive!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (create player didn't arrive)
#endif // DEBUG

		// Reset the context.
		CloseHandle(hostcontext.hLastPlayerMsgEvent);
		hostcontext.hLastPlayerMsgEvent = NULL;



		// Make sure the IDs match.
		if (hostcontext.adpnidPlayers[0] != nonhostcontext.adpnidPlayers[1])
		{
			DPTEST_FAIL(hLog, "Host and client disagree on host's player ID (%u/%x != %u/%x)!",
				4, hostcontext.adpnidPlayers[0], hostcontext.adpnidPlayers[0],
				nonhostcontext.adpnidPlayers[1], nonhostcontext.adpnidPlayers[1]);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (host ID doesn't match)

		if (hostcontext.adpnidPlayers[1] != nonhostcontext.adpnidPlayers[0])
		{
			DPTEST_FAIL(hLog, "Host and client disagree on client's player ID (%u/%x != %u/%x)!",
				4, hostcontext.adpnidPlayers[1], hostcontext.adpnidPlayers[1],
				nonhostcontext.adpnidPlayers[0], nonhostcontext.adpnidPlayers[0]);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (client ID doesn't match)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting player context of self on host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8PeerHost->DP8P_GetPlayerContext(hostcontext.adpnidPlayers[0],
												&pvPlayerContext, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting player context of self on host failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get player context)

		if (pvPlayerContext != &(hostcontext.adpnidPlayers[0]))
		{
			DPTEST_FAIL(hLog, "Player context returned was invalid (%x != %x)!",
				2, pvPlayerContext, &(hostcontext.adpnidPlayers[0]));
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (player context was touched)

		pvPlayerContext = (PVOID) 0x666;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting player context of client on host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8PeerHost->DP8P_GetPlayerContext(hostcontext.adpnidPlayers[1],
												&pvPlayerContext, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting player context of client on host failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get player context)

		if (pvPlayerContext != NULL)
		{
			DPTEST_FAIL(hLog, "Player context returned was invalid (%x != NULL)!",
				1, pvPlayerContext);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (player context was touched)

		pvPlayerContext = (PVOID) 0x666;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting player context of host on client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_GetPlayerContext(nonhostcontext.adpnidPlayers[1],
											&pvPlayerContext, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting player context of host on client failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get player context)

		if (pvPlayerContext != NULL)
		{
			DPTEST_FAIL(hLog, "Player context returned was invalid (%x != NULL)!",
				1, pvPlayerContext);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (player context was touched)

		pvPlayerContext = (PVOID) 0x666;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting player context of self on client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_GetPlayerContext(nonhostcontext.adpnidPlayers[0],
											&pvPlayerContext, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting player context of self on client failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get player context)

		if (pvPlayerContext != &(nonhostcontext.adpnidPlayers[0]))
		{
			DPTEST_FAIL(hLog, "Player context returned was invalid (%x != %x)!",
				2, pvPlayerContext, &(nonhostcontext.adpnidPlayers[0]));
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (player context was touched)

		pvPlayerContext = (PVOID) 0x666;



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing peer client object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Expect the destroy player message on the host.
		CREATEEVENT_OR_THROW(hostcontext.hLastPlayerMsgEvent,
							NULL, FALSE, FALSE, NULL);
		hostcontext.dwNumDestroyPlayersRemaining = 1;
		hostcontext.afExpectDestroyPlayer[1] = TRUE;

		// Expect the 2 destroy player messages and terminate session on the client.
		CREATEEVENT_OR_THROW(nonhostcontext.hLastPlayerMsgEvent,
							NULL, FALSE, FALSE, NULL);
		nonhostcontext.dwNumDestroyPlayersRemaining = 2;
		nonhostcontext.afExpectDestroyPlayer[0] = TRUE;
		nonhostcontext.afExpectDestroyPlayer[1] = TRUE;

		tr = pDP8Peer->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing peer client object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for destroy player messages on client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 1;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apDP8Peers[0] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, nonhostcontext.hLastPlayerMsgEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird destroy player or terminate session messages.
		nonhostcontext.afExpectDestroyPlayer[0] = FALSE;
		nonhostcontext.afExpectDestroyPlayer[1] = FALSE;

#ifdef DEBUG
		// Make sure the players were destroyed (how else would we get here?).
		if (nonhostcontext.adpnidPlayers[0] != 0)
		{
			DPTEST_FAIL(hLog, "Destroy player for self didn't arrive!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (destroy player didn't arrive)

		if (nonhostcontext.adpnidPlayers[1] != 0)
		{
			DPTEST_FAIL(hLog, "Destroy player for host didn't arrive!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (destroy player didn't arrive)
#endif // DEBUG

		// Reset the context.
		CloseHandle(nonhostcontext.hLastPlayerMsgEvent);
		nonhostcontext.hLastPlayerMsgEvent = NULL;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for destroy player message on host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 1;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apDP8Peers[0] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hostcontext.hLastPlayerMsgEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird destroy player messages.
		hostcontext.afExpectDestroyPlayer[1] = FALSE;

#ifdef DEBUG
		// Make sure the player was destroyed (how else would we get here?).
		if (hostcontext.adpnidPlayers[1] != 0)
		{
			DPTEST_FAIL(hLog, "Destroy player didn't arrive!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (destroy player didn't arrive)
#endif // DEBUG

		// Reset the context.
		CloseHandle(hostcontext.hLastPlayerMsgEvent);
		hostcontext.hLastPlayerMsgEvent = NULL;






		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing host object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Expect a destroy player message for self.
		hostcontext.dwNumDestroyPlayersRemaining = 1;
		hostcontext.afExpectDestroyPlayer[0] = TRUE;

		tr = pDP8PeerHost->DP8P_Close(0);

		// Prevent any weird destroy player messages.
		hostcontext.afExpectDestroyPlayer[0] = FALSE;

		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing host object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure the destroy player indication came in.
		if (hostcontext.adpnidPlayers[0] != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get destroy player indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player indication)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing hosting DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8PeerHost->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release hosting DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8PeerHost);
		pDP8PeerHost = NULL;





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Peer);
		pDP8Peer = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE


	if (pDP8Peer != NULL)
	{
		delete (pDP8Peer);
		pDP8Peer = NULL;
	} // end if (have peer object)

	if (pDP8PeerHost != NULL)
	{
		delete (pDP8PeerHost);
		pDP8PeerHost = NULL;
	} // end if (have peer object)

	SAFE_RELEASE(pDP8Address);
	ClearDoWorkList(&DoWorkList);
	SAFE_CLOSEHANDLE(hAsyncOpComplete);

	return (sr);
} // ParmVPeerExec_GetPlayerContext
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVPeerExec_GetGroupContext()"
//==================================================================================
// ParmVPeerExec_GetGroupContext
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.1.28 - Peer GetGroupContext parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVPeerExec_GetGroupContext(HANDLE hLog)
{
	CTNSystemResult					sr;
	CTNTestResult					tr;
	PWRAPDP8PEER					pDP8Peer = NULL;
	PWRAPDP8PEER					pDP8PeerHost = NULL;
	PDIRECTPLAY8ADDRESS				pDP8Address = NULL;
	DPN_APPLICATION_DESC			dpnad;
	DPN_APPLICATION_DESC			dpnadCompare;
	PARMVPGETGROUPCONTEXTCONTEXT	hostcontext;
	PARMVPGETGROUPCONTEXTCONTEXT	nonhostcontext;
	DPN_GROUP_INFO					dpngi;
	DPN_GROUP_INFO					dpngiCompare;
	PVOID							pvGroupContext;
	DP_DOWORKLIST					DoWorkList;
	DPNHANDLE						hAsyncOp;
	HANDLE							hAsyncOpComplete = NULL;

	ZeroMemory(&DoWorkList, sizeof(DP_DOWORKLIST));
	ZeroMemory(&hostcontext, sizeof (PARMVPGETGROUPCONTEXTCONTEXT));
	hostcontext.fHost = TRUE;

	ZeroMemory(&nonhostcontext, sizeof (PARMVPGETGROUPCONTEXTCONTEXT));
	//nonhostcontext.fHost = FALSE;


	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Peer = new CWrapDP8Peer(hLog);
		if (pDP8Peer == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8Peer->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (LPVOID *) &pDP8Address, NULL);
		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't create DirectPlay8Address object!", 0);
			THROW_SYSTEMRESULT;
		} // end if (create failed)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting address object's SP to TCP/IP");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->SetSP(&CLSID_DP8SP_TCPIP);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting address object's SP to TCP/IP failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set SP)




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting group 0 context using C++ macro");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = IDirectPlay8Peer_GetGroupContext(pDP8Peer->m_pDP8Peer, 0, NULL, 0);
		if (tr != DPNERR_INVALIDGROUP)
		{
			DPTEST_FAIL(hLog, "Getting group 0 context using C++ macro didn't return expected error INVALIDGROUP!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get player context)
*/


/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting group 0 context");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_GetGroupContext(0, NULL, 0);
		if (tr != DPNERR_INVALIDGROUP)
		{
			DPTEST_FAIL(hLog, "Getting group 0 context didn't return expected error INVALIDGROUP!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get group context)
*/


/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting group context with NULL pointer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Use 0x666 to avoid DPlay's group ID == 0 check.
		tr = pDP8Peer->DP8P_GetGroupContext((DPNID) 0x666, NULL, 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Getting group context with NULL pointer didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get group context)
*/

		pvGroupContext = (PVOID) 0x666;

/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting group context with invalid flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_GetGroupContext((DPNID) 0x666, &pvGroupContext, 0x666);
		if (tr != DPNERR_INVALIDFLAGS)
		{
			DPTEST_FAIL(hLog, "Getting group context with invalid flags didn't return expected error INVALIDFLAGS!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get group context)

		if (pvGroupContext != (PVOID) 0x666)
		{
			DPTEST_FAIL(hLog, "Group context was modified (%x != 0x666)!", 1, pvGroupContext);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (group context was touched)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting group context before initialization");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_GetGroupContext((DPNID) 0x666, &pvGroupContext, 0);
		if (tr != DPNERR_UNINITIALIZED)
		{
			DPTEST_FAIL(hLog, "Getting group context before initialization didn't return expected error UNINITIALIZED!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get group context)

		if (pvGroupContext != (PVOID) 0x666)
		{
			DPTEST_FAIL(hLog, "Group context was modified (%x != 0x666)!", 1, pvGroupContext);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (group context was touched)
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Initializing peer object with host context");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		hostcontext.hLog = hLog;

		tr = pDP8Peer->DP8P_Initialize(&hostcontext,
										ParmVPGetGroupContextDPNMessageHandler, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Initializing peer object with host context failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting group context without a connection");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_GetGroupContext((DPNID) 0x666, &pvGroupContext, 0);
		if (tr != DPNERR_NOCONNECTION)
		{
			DPTEST_FAIL(hLog, "Getting group context without a connection didn't return expected error NOCONNECTION!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get group context)

		if (pvGroupContext != (PVOID) 0x666)
		{
			DPTEST_FAIL(hLog, "Group context was modified (%x != 0x666)!", 1, pvGroupContext);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (group context was touched)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Hosting session");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		//dpnad.dwFlags = 0;
		//dpnad.guidInstance = GUID_NULL;
		dpnad.guidApplication = GUID_PARMV_PEER_HOST;
		//dpnad.dwMaxPlayers = 0;
		//dpnad.dwCurrentPlayers = 0;
		//dpnad.pwszSessionName = NULL;
		//dpnad.pwszPassword = NULL;
		//dpnad.pvReservedData = NULL;
		//dpnad.dwReservedDataSize = 0;
		//dpnad.pvApplicationReservedData = NULL;
		//dpnad.dwApplicationReservedDataSize = 0;

		// Save what we're passing in to make sure it's not touched.
		CopyMemory(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC));

		tr = pDP8Peer->DP8P_Host(&dpnad,
								&pDP8Address,
								1,
								NULL,
								NULL,
								&(hostcontext.dpnidHost),
								0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't start hosting session!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't host)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		// Make sure we got the create player message.
		if (hostcontext.dpnidHost == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting group context with local player ID");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_GetGroupContext(hostcontext.dpnidHost, &pvGroupContext, 0);
		if (tr != DPNERR_INVALIDGROUP)
		{
			DPTEST_FAIL(hLog, "Getting group context with local player ID didn't return expected error INVALIDGROUP!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get group context)

		if (pvGroupContext != (PVOID) 0x666)
		{
			DPTEST_FAIL(hLog, "Group context was modified (%x != 0x666)!", 1, pvGroupContext);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (group context was touched)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating group asynchronously");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		SAFE_CLOSEHANDLE(hAsyncOpComplete);
		CREATEEVENT_OR_THROW(hAsyncOpComplete, NULL, FALSE, FALSE, NULL);

		ZeroMemory(&dpngi, sizeof (DPN_GROUP_INFO));
		dpngi.dwSize = sizeof (DPN_GROUP_INFO);
		//dpngi.dwInfoFlags = 0;
		//dpngi.pwszName = NULL;
		//dpngi.pvData = NULL;
		//dpngi.dwDataSize = 0;
		//dpngi.dwGroupFlags = 0;

		CopyMemory(&dpngiCompare, &dpngi, sizeof (DPN_GROUP_INFO));


		// Expect the create group message.
		//hostcontext.dpnidExpectedGroupOwner = 0;
		hostcontext.fCanGetCreateGroup = TRUE;

		tr = pDP8Peer->DP8P_CreateGroup(&dpngi, &(hostcontext.dpnidGroup), hAsyncOpComplete, &hAsyncOp, 0);

		if((tr != DPNSUCCESS_PENDING) && (tr != DPN_OK))
		{
			DPTEST_FAIL(hLog, "Creating group failed! (error 0x%08x)", 1, tr);
			THROW_TESTRESULT;
		} // end if (couldn't create group)

		if (memcmp(&dpngiCompare, &dpngi, sizeof (DPN_GROUP_INFO)) != 0)
		{
			DPTEST_FAIL(hLog, "Group info structure was modified (structure at %x != structure at %x)!",
				2, &dpngiCompare, &dpngi);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (group info changed)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for group to be created asynchronously");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 1;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hAsyncOpComplete))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird create groups.
		hostcontext.fCanGetCreateGroup = FALSE;

		// Make sure we got the create group message.
		if (hostcontext.dpnidGroup == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get create group message!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create group)






		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting group context");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_GetGroupContext(hostcontext.dpnidGroup, &pvGroupContext, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting group context failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get group context)

		if (pvGroupContext != &(hostcontext.dpnidGroup))
		{
			DPTEST_FAIL(hLog, "Group context was modified (%x != %x)!",
				2, pvGroupContext, &(hostcontext.dpnidGroup));
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (group context was touched)

		pvGroupContext = (PVOID) 0x666;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing peer object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure we got the destroy player message.
		if (hostcontext.dpnidHost != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)

#pragma TODO(vanceo, "Validate destroy group nametable unwind")

		// Reset group ID.
		hostcontext.dpnidGroup = 0;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Re-initializing peer object with nonhost context");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		nonhostcontext.hLog = hLog;

		tr = pDP8Peer->DP8P_Initialize(&nonhostcontext,
										ParmVPGetGroupContextDPNMessageHandler,
										0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Re-initializing peer object with context, 0 flags failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating new peer host object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Address->Release();
		pDP8Address = NULL;

		hostcontext.hLog = hLog;

		tr = ParmVCreatePeerHost(hLog, ParmVPGetGroupContextDPNMessageHandler,
								&hostcontext,
								&dpnad,
								&(hostcontext.dpnidHost),
								&pDP8PeerHost,
								&pDP8Address);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Creating peer host failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't create peer host)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Connecting peer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

// XBOX - Had to make connection asynchronous

		SAFE_CLOSEHANDLE(hAsyncOpComplete);
		CREATEEVENT_OR_THROW(hAsyncOpComplete, NULL, FALSE, FALSE, NULL);

		// Host should get the create player now.
		CREATEEVENT_OR_THROW(hostcontext.hClientCreatedEvent,
							NULL, FALSE, FALSE, NULL);

		// Even though it's synchronous, we'll still get a completion.  The async op
		// handle will be NULL, though.
		nonhostcontext.fConnectCanComplete = TRUE;

		tr = pDP8Peer->DP8P_Connect(&dpnad,
									pDP8Address,
									NULL,
									NULL,
									NULL,
									NULL,
									0,
									&(nonhostcontext.dpnidClient),
									hAsyncOpComplete,
									&hAsyncOp,
									0);

		if((tr != DPNSUCCESS_PENDING) && (tr != DPN_OK))
		{
			DPTEST_FAIL(hLog, "Couldn't connect! (error 0x%08x)", 1, tr);
			THROW_TESTRESULT;
		} // end if (couldn't connect)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for connect to complete on non-host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hAsyncOpComplete))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		// Prevent any weird connects from completing.
		nonhostcontext.fConnectCanComplete = FALSE;

		ClearDoWorkList(&DoWorkList);

		// Make sure we saw the connect completion indication.
		if (! nonhostcontext.fConnectCompleted)
		{
			DPTEST_FAIL(hLog, "Didn't get connect complete indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (connect didn't complete)

		// Make sure we got the create player messages.
		if (nonhostcontext.dpnidHost == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication for host on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player)

		if (nonhostcontext.dpnidClient == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication for client on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player)

		// Reset the context.
		nonhostcontext.fConnectCompleted = FALSE;

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for create player to be indicated on host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hostcontext.hClientCreatedEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating group on host asynchronously");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		SAFE_CLOSEHANDLE(hAsyncOpComplete);
		CREATEEVENT_OR_THROW(hAsyncOpComplete, NULL, FALSE, FALSE, NULL);

		// Expect the create group message on the host.
		//hostcontext.dpnidExpectedGroupOwner = 0;
		hostcontext.fCanGetCreateGroup = TRUE;

		// Expect the create group message on the client.
		//nonhostcontext.dpnidExpectedGroupOwner = 0;

		CREATEEVENT_OR_THROW(nonhostcontext.hGotGroupMsgEvent,
							NULL, FALSE, FALSE, NULL);
		nonhostcontext.fCanGetCreateGroup = TRUE;

		tr = pDP8PeerHost->DP8P_CreateGroup(&dpngi, NULL, hAsyncOpComplete, &hAsyncOp, 0);

		if((tr != DPNSUCCESS_PENDING) && (tr != DPN_OK))
		{
			DPTEST_FAIL(hLog, "Creating group failed! (error 0x%08x)", 1, tr);
			THROW_TESTRESULT;
		} // end if (couldn't create group)

		if (memcmp(&dpngiCompare, &dpngi, sizeof (DPN_GROUP_INFO)) != 0)
		{
			DPTEST_FAIL(hLog, "Group info structure was modified (structure at %x != structure at %x)!",
				2, &dpngiCompare, &dpngi);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (group info changed)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for group to be created asynchronously");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8PeerHost->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8Peer->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hAsyncOpComplete))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird create groups.
		hostcontext.fCanGetCreateGroup = FALSE;

		// Make sure we got the create group message.
		if (hostcontext.dpnidGroup == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get create group message!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create group)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for group to be created on client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, nonhostcontext.hGotGroupMsgEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird create group indications.
		nonhostcontext.fCanGetCreateGroup = FALSE;

#ifdef DEBUG
		// Make sure we got the indication (how else would we get here?).
		if (nonhostcontext.dpnidGroup == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get create group indication!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (didn't get create group indication)
#endif // DEBUG

		// Reset the context.
		CloseHandle(nonhostcontext.hGotGroupMsgEvent);
		nonhostcontext.hGotGroupMsgEvent = NULL;





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting group context on host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8PeerHost->DP8P_GetGroupContext(hostcontext.dpnidGroup, &pvGroupContext, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting group context on host failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get group context)

		if (pvGroupContext != &(hostcontext.dpnidGroup))
		{
			DPTEST_FAIL(hLog, "Group context was modified (%x != %x)!",
				2, pvGroupContext, &(hostcontext.dpnidGroup));
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (group context was touched)

		pvGroupContext = (PVOID) 0x666;





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting group context on client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_GetGroupContext(nonhostcontext.dpnidGroup, &pvGroupContext, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting group context on client failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get group context)

		if (pvGroupContext != &(nonhostcontext.dpnidGroup))
		{
			DPTEST_FAIL(hLog, "Group context was modified (%x != %x)!",
				2, pvGroupContext, &(nonhostcontext.dpnidGroup));
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (group context was touched)

		pvGroupContext = (PVOID) 0x666;






		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing peer client object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing peer client object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure we got the destroy player messages.
		if (nonhostcontext.dpnidHost != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for host on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)

		if (nonhostcontext.dpnidClient != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for client on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)


		// Technically we should wait to make sure the host saw the client go away
		// as expected but that's more hassle than it's worth.  Just make sure he's
		// gone after Close() has returned.



#pragma TODO(vanceo, "Validate destroy group nametable unwind on both interfaces")


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing host object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8PeerHost->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing host object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure we got the destroy player messages.
		if (hostcontext.dpnidHost != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for host on host!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)

		if (hostcontext.dpnidClient != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for client on host!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing hosting DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8PeerHost->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release hosting DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8PeerHost);
		pDP8PeerHost = NULL;





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Peer);
		pDP8Peer = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE


	if (pDP8Peer != NULL)
	{
		delete (pDP8Peer);
		pDP8Peer = NULL;
	} // end if (have peer object)

	if (pDP8PeerHost != NULL)
	{
		delete (pDP8PeerHost);
		pDP8PeerHost = NULL;
	} // end if (have peer object)

	SAFE_RELEASE(pDP8Address);
	SAFE_CLOSEHANDLE(hostcontext.hGotGroupMsgEvent);
	SAFE_CLOSEHANDLE(nonhostcontext.hGotGroupMsgEvent);
	SAFE_CLOSEHANDLE(hostcontext.hClientCreatedEvent);
	ClearDoWorkList(&DoWorkList);
	SAFE_CLOSEHANDLE(hAsyncOpComplete);

	return (sr);
} // ParmVPeerExec_GetGroupContext
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVPeerExec_GetCaps()"
//==================================================================================
// ParmVPeerExec_GetCaps
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.1.29 - Peer GetCaps parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVPeerExec_GetCaps(HANDLE hLog)
{
	CTNSystemResult			sr;
	CTNTestResult			tr;
	PWRAPDP8PEER			pDP8Peer = NULL;
	PDIRECTPLAY8ADDRESS		pDP8Address = NULL;
	DPN_APPLICATION_DESC	dpnad;
	DPN_APPLICATION_DESC	dpnadCompare;
	DPN_CAPS				dpncaps;
	DPN_CAPS				dpncapsCompare;
	PARMVPGENERICCONTEXT	genericcontext;

	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Peer = new CWrapDP8Peer(hLog);
		if (pDP8Peer == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8Peer->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (LPVOID *) &pDP8Address, NULL);
		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't create DirectPlay8Address object!", 0);
			THROW_SYSTEMRESULT;
		} // end if (create failed)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting address object's SP to TCP/IP");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->SetSP(&CLSID_DP8SP_TCPIP);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting address object's SP to TCP/IP failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set SP)




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting caps with NULL pointer using C++ macro");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = IDirectPlay8Peer_GetCaps(pDP8Peer->m_pDP8Peer, NULL, 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Getting caps with NULL pointer using C++ macro didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get caps)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting caps with NULL pointer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_GetCaps(NULL, 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Getting caps with NULL pointer didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get caps)
*/




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting caps with 0 size");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpncaps, sizeof (DPN_CAPS));

		CopyMemory(&dpncapsCompare, &dpncaps, sizeof (DPN_CAPS));

		tr = pDP8Peer->DP8P_GetCaps(&dpncaps, 0);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Getting caps with 0 size didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get caps)

		if (memcmp(&dpncapsCompare, &dpncaps, sizeof (DPN_CAPS)) != 0)
		{
			DPTEST_FAIL(hLog, "Caps structure was modified (structure at %x != structure at %x)!",
				2, &dpncapsCompare, &dpncaps);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (caps changed)
*/




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting caps with too large size");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpncaps, sizeof (DPN_CAPS));
		dpncaps.dwSize = sizeof (DPN_CAPS) + 1;

		CopyMemory(&dpncapsCompare, &dpncaps, sizeof (DPN_CAPS));

		tr = pDP8Peer->DP8P_GetCaps(&dpncaps, 0);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Getting caps with too large size didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get caps)

		if (memcmp(&dpncapsCompare, &dpncaps, sizeof (DPN_CAPS)) != 0)
		{
			DPTEST_FAIL(hLog, "Caps structure was modified (structure at %x != structure at %x)!",
				2, &dpncapsCompare, &dpncaps);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (caps changed)
*/

		ZeroMemory(&dpncaps, sizeof (DPN_CAPS));
		dpncaps.dwSize = sizeof (DPN_CAPS);

		CopyMemory(&dpncapsCompare, &dpncaps, sizeof (DPN_CAPS));

/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting caps with invalid flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_GetCaps(&dpncaps, 0x666);
		if (tr != DPNERR_INVALIDFLAGS)
		{
			DPTEST_FAIL(hLog, "Getting caps with invalid flags didn't return expected error INVALIDFLAGS!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get caps)

		if (memcmp(&dpncapsCompare, &dpncaps, sizeof (DPN_CAPS)) != 0)
		{
			DPTEST_FAIL(hLog, "Caps structure was modified (structure at %x != structure at %x)!",
				2, &dpncapsCompare, &dpncaps);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (caps changed)
*/




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting caps before initialization");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_GetCaps(&dpncaps, 0);
		if (tr != DPNERR_UNINITIALIZED)
		{
			DPTEST_FAIL(hLog, "Getting caps before initialization didn't return expected error UNINITIALIZED!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get caps)

		if (memcmp(&dpncapsCompare, &dpncaps, sizeof (DPN_CAPS)) != 0)
		{
			DPTEST_FAIL(hLog, "Caps structure was modified (structure at %x != structure at %x)!",
				2, &dpncapsCompare, &dpncaps);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (caps changed)
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Initializing peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		genericcontext.hLog = hLog;

		tr = pDP8Peer->DP8P_Initialize(&genericcontext, ParmVPGetCapsDPNMessageHandler, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Initializing peer object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting caps");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_GetCaps(&dpncaps, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting caps failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get caps)

		if (dpncaps.dwSize != sizeof (DPN_CAPS))
		{
			DPTEST_FAIL(hLog, "Caps structure size was modified (%u != %u)!",
				2, dpncaps.dwSize, sizeof (DPN_CAPS));
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (size changed)

		if (dpncaps.dwFlags != 0)
		{
			DPTEST_FAIL(hLog, "Flags returned are wrong (%x != 0)!",
				1, dpncaps.dwFlags);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (flags wrong)

		if (dpncaps.dwConnectTimeout != 200)
		{
			DPTEST_FAIL(hLog, "Connect timeout returned is wrong (%u != 200)!",
				1, dpncaps.dwConnectTimeout);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (connect timeout wrong)

		if (dpncaps.dwConnectRetries != 8)
		{
			DPTEST_FAIL(hLog, "Connect retries returned is wrong (%u != 8)!",
				1, dpncaps.dwConnectRetries);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (connect retries wrong)

		if (dpncaps.dwTimeoutUntilKeepAlive != 60000)
		{
			DPTEST_FAIL(hLog, "Timeout until keepalive returned is wrong (%u != 60000)!",
				1, dpncaps.dwTimeoutUntilKeepAlive);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (timeout until keepalive wrong)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Hosting session");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		//dpnad.dwFlags = 0;
		//dpnad.guidInstance = GUID_NULL;
		dpnad.guidApplication = GUID_PARMV_PEER_GETAPPDESC;
		//dpnad.dwMaxPlayers = 0;
		//dpnad.dwCurrentPlayers = 0;
		//dpnad.pwszSessionName = NULL;
		//dpnad.pwszPassword = NULL;
		//dpnad.pvReservedData = NULL;
		//dpnad.dwReservedDataSize = 0;
		//dpnad.pvApplicationReservedData = NULL;
		//dpnad.dwApplicationReservedDataSize = 0;

		// Save what we're passing in to make sure it's not touched.
		CopyMemory(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC));

		tr = pDP8Peer->DP8P_Host(&dpnad,
								&pDP8Address,
								1,
								NULL,
								NULL,
								//&(context.dpnidPlayer),
								NULL,
								0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't start hosting session!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't host)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

#pragma BUGBUG(vanceo, "Make sure we got the create player message?")
		/*
		// Make sure we got the create player message.
		if (context.dpnidPlayer == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player)
		*/





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting caps");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpncaps, sizeof (DPN_CAPS));
		dpncaps.dwSize = sizeof (DPN_CAPS);

		tr = pDP8Peer->DP8P_GetCaps(&dpncaps, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting caps failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get caps)

		if (dpncaps.dwSize != sizeof (DPN_CAPS))
		{
			DPTEST_FAIL(hLog, "Caps structure size was modified (%u != %u)!",
				2, dpncaps.dwSize, sizeof (DPN_CAPS));
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (size changed)

		if (dpncaps.dwFlags != 0)
		{
			DPTEST_FAIL(hLog, "Flags returned are wrong (%x != 0)!",
				1, dpncaps.dwFlags);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (flags wrong)

		if (dpncaps.dwConnectTimeout != 200)
		{
			DPTEST_FAIL(hLog, "Connect timeout returned is wrong (%u != 200)!",
				1, dpncaps.dwConnectTimeout);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (connect timeout wrong)

		if (dpncaps.dwConnectRetries != 8)
		{
			DPTEST_FAIL(hLog, "Connect retries returned is wrong (%u != 8)!",
				1, dpncaps.dwConnectRetries);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (connect retries wrong)

		if (dpncaps.dwTimeoutUntilKeepAlive != 60000)
		{
			DPTEST_FAIL(hLog, "Timeout until keepalive returned is wrong (%u != 60000)!",
				1, dpncaps.dwTimeoutUntilKeepAlive);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (timeout until keepalive wrong)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing peer object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		/*
		// Make sure we got the destroy player message.
		if (context.dpnidPlayer != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)
		*/





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Peer);
		pDP8Peer = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE


	if (pDP8Peer != NULL)
	{
		delete (pDP8Peer);
		pDP8Peer = NULL;
	} // end if (have peer object)

	SAFE_RELEASE(pDP8Address);


	return (sr);
} // ParmVPeerExec_GetCaps
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVPeerExec_SetCaps()"
//==================================================================================
// ParmVPeerExec_SetCaps
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.1.30 - Peer SetCaps parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVPeerExec_SetCaps(HANDLE hLog)
{
	CTNSystemResult			sr;
	CTNTestResult			tr;
	PWRAPDP8PEER			pDP8Peer = NULL;
	PDIRECTPLAY8ADDRESS		pDP8Address = NULL;
	DPN_APPLICATION_DESC	dpnad;
	DPN_APPLICATION_DESC	dpnadCompare;
	DPN_CAPS				dpncaps;
	DPN_CAPS				dpncapsCompare;
	PARMVPGENERICCONTEXT	genericcontext;

	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Peer = new CWrapDP8Peer(hLog);
		if (pDP8Peer == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8Peer->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (LPVOID *) &pDP8Address, NULL);
		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't create DirectPlay8Address object!", 0);
			THROW_SYSTEMRESULT;
		} // end if (create failed)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting address object's SP to TCP/IP");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->SetSP(&CLSID_DP8SP_TCPIP);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting address object's SP to TCP/IP failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set SP)





/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting caps with NULL pointer and 0 flags using C++ macro");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = IDirectPlay8Peer_SetCaps(pDP8Peer->m_pDP8Peer, NULL, 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Setting caps with NULL pointer and 0 flags using C++ macro didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set caps)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting caps with NULL pointer and 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_SetCaps(NULL, 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Setting caps with NULL pointer and 0 flags didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set caps)
*/

		ZeroMemory(&dpncaps, sizeof (DPN_CAPS));
		//dpncaps.dwFlags = 0;
		//dpncaps.dwConnectTimeout = 0;
		//dpncaps.dwConnectRetries = 0;
		//dpncaps.dwTimeoutUntilKeepAlive = 0;

		CopyMemory(&dpncapsCompare, &dpncaps, sizeof (DPN_CAPS));

/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting caps with 0 size");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_SetCaps(&dpncaps, 0);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Setting caps with 0 size didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set caps)

		if (memcmp(&dpncapsCompare, &dpncaps, sizeof (DPN_CAPS)) != 0)
		{
			DPTEST_FAIL(hLog, "Caps structure was modified (structure at %x != structure at %x)!",
				2, &dpncapsCompare, &dpncaps);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (caps changed)
*/

		ZeroMemory(&dpncaps, sizeof (DPN_CAPS));
		dpncaps.dwSize = sizeof (DPN_CAPS) + 1;
		//dpncaps.dwFlags = 0;
		//dpncaps.dwConnectTimeout = 0;
		//dpncaps.dwConnectRetries = 0;
		//dpncaps.dwTimeoutUntilKeepAlive = 0;

		CopyMemory(&dpncapsCompare, &dpncaps, sizeof (DPN_CAPS));

/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting caps with too-large size");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_SetCaps(&dpncaps, 0);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Setting caps with too-large size didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set caps)

		if (memcmp(&dpncapsCompare, &dpncaps, sizeof (DPN_CAPS)) != 0)
		{
			DPTEST_FAIL(hLog, "Caps structure was modified (structure at %x != structure at %x)!",
				2, &dpncapsCompare, &dpncaps);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (caps changed)
*/


		ZeroMemory(&dpncaps, sizeof (DPN_CAPS));
		dpncaps.dwSize = sizeof (DPN_CAPS);
		//dpncaps.dwFlags = 0;
		//dpncaps.dwConnectTimeout = 0;
		//dpncaps.dwConnectRetries = 0;
		//dpncaps.dwTimeoutUntilKeepAlive = 0;

		CopyMemory(&dpncapsCompare, &dpncaps, sizeof (DPN_CAPS));


/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting caps with invalid flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_SetCaps(&dpncaps, 0x666);
		if (tr != DPNERR_INVALIDFLAGS)
		{
			DPTEST_FAIL(hLog, "Setting caps with invalid flags didn't return expected error INVALIDFLAGS!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set caps)

		if (memcmp(&dpncapsCompare, &dpncaps, sizeof (DPN_CAPS)) != 0)
		{
			DPTEST_FAIL(hLog, "Caps structure was modified (structure at %x != structure at %x)!",
				2, &dpncapsCompare, &dpncaps);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (caps changed)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting caps before initialization");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_SetCaps(&dpncaps, 0);
		if (tr != DPNERR_UNINITIALIZED)
		{
			DPTEST_FAIL(hLog, "Setting caps before initialization didn't return expected error UNINITIALIZED!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set caps)

		if (memcmp(&dpncapsCompare, &dpncaps, sizeof (DPN_CAPS)) != 0)
		{
			DPTEST_FAIL(hLog, "Caps structure was modified (structure at %x != structure at %x)!",
				2, &dpncapsCompare, &dpncaps);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (caps changed)
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Initializing peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		genericcontext.hLog = hLog;

		tr = pDP8Peer->DP8P_Initialize(&genericcontext, ParmVPSetCapsDPNMessageHandler, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Initializing peer object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)



#pragma TODO(vanceo, "Validate these values?")
		/*
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting caps with invalid caps flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpncaps, sizeof (DPN_CAPS));
		dpncaps.dwSize = sizeof (DPN_CAPS);
		dpncaps.dwFlags = 0x666;
		//dpncaps.dwConnectTimeout = 0;
		//dpncaps.dwConnectRetries = 0;
		//dpncaps.dwTimeoutUntilKeepAlive = 0;

		CopyMemory(&dpncapsCompare, &dpncaps, sizeof (DPN_CAPS));

		tr = pDP8Peer->DP8P_SetCaps(&dpncaps, 0);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Setting caps with invalid caps flags didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set caps)

		if (memcmp(&dpncapsCompare, &dpncaps, sizeof (DPN_CAPS)) != 0)
		{
			DPTEST_FAIL(hLog, "Caps structure was modified (structure at %x != structure at %x)!",
				2, &dpncapsCompare, &dpncaps);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (caps changed)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting caps with connect timeout set to 0");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpncaps, sizeof (DPN_CAPS));
		dpncaps.dwSize = sizeof (DPN_CAPS);
		//dpncaps.dwFlags = 0;
		//dpncaps.dwConnectTimeout = 0;
		//dpncaps.dwConnectRetries = 0;
		//dpncaps.dwTimeoutUntilKeepAlive = 0;

		CopyMemory(&dpncapsCompare, &dpncaps, sizeof (DPN_CAPS));

		tr = pDP8Peer->DP8P_SetCaps(&dpncaps, 0);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Setting caps with connect timeout set to 0 didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set caps)

		if (memcmp(&dpncapsCompare, &dpncaps, sizeof (DPN_CAPS)) != 0)
		{
			DPTEST_FAIL(hLog, "Caps structure was modified (structure at %x != structure at %x)!",
				2, &dpncapsCompare, &dpncaps);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (caps changed)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting caps with connect retries set to 0");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpncaps, sizeof (DPN_CAPS));
		dpncaps.dwSize = sizeof (DPN_CAPS);
		//dpncaps.dwFlags = 0;
		dpncaps.dwConnectTimeout = 100;
		//dpncaps.dwConnectRetries = 0;
		//dpncaps.dwTimeoutUntilKeepAlive = 0;

		CopyMemory(&dpncapsCompare, &dpncaps, sizeof (DPN_CAPS));

		tr = pDP8Peer->DP8P_SetCaps(&dpncaps, 0);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Setting caps with connect retries set to 0 didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set caps)

		if (memcmp(&dpncapsCompare, &dpncaps, sizeof (DPN_CAPS)) != 0)
		{
			DPTEST_FAIL(hLog, "Caps structure was modified (structure at %x != structure at %x)!",
				2, &dpncapsCompare, &dpncaps);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (caps changed)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting caps with timeout until keepalive set to 0");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpncaps, sizeof (DPN_CAPS));
		dpncaps.dwSize = sizeof (DPN_CAPS);
		//dpncaps.dwFlags = 0;
		dpncaps.dwConnectTimeout = 100;
		dpncaps.dwConnectRetries = 8;
		//dpncaps.dwTimeoutUntilKeepAlive = 0;

		CopyMemory(&dpncapsCompare, &dpncaps, sizeof (DPN_CAPS));

		tr = pDP8Peer->DP8P_SetCaps(&dpncaps, 0);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Setting caps with timeout until keepalive set to 0 didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set caps)

		if (memcmp(&dpncapsCompare, &dpncaps, sizeof (DPN_CAPS)) != 0)
		{
			DPTEST_FAIL(hLog, "Caps structure was modified (structure at %x != structure at %x)!",
				2, &dpncapsCompare, &dpncaps);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (caps changed)
		*/




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting caps");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpncaps, sizeof (DPN_CAPS));
		dpncaps.dwSize = sizeof (DPN_CAPS);
		//dpncaps.dwFlags = 0;
		dpncaps.dwConnectTimeout = 100;
		dpncaps.dwConnectRetries = 8;
		dpncaps.dwTimeoutUntilKeepAlive = 60000;

		CopyMemory(&dpncapsCompare, &dpncaps, sizeof (DPN_CAPS));

		tr = pDP8Peer->DP8P_SetCaps(&dpncaps, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting caps failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set caps)

		if (memcmp(&dpncapsCompare, &dpncaps, sizeof (DPN_CAPS)) != 0)
		{
			DPTEST_FAIL(hLog, "Caps structure was modified (structure at %x != structure at %x)!",
				2, &dpncapsCompare, &dpncaps);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (caps changed)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Hosting session");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		//dpnad.dwFlags = 0;
		//dpnad.guidInstance = GUID_NULL;
		dpnad.guidApplication = GUID_PARMV_PEER_GETAPPDESC;
		//dpnad.dwMaxPlayers = 0;
		//dpnad.dwCurrentPlayers = 0;
		//dpnad.pwszSessionName = NULL;
		//dpnad.pwszPassword = NULL;
		//dpnad.pvReservedData = NULL;
		//dpnad.dwReservedDataSize = 0;
		//dpnad.pvApplicationReservedData = NULL;
		//dpnad.dwApplicationReservedDataSize = 0;

		// Save what we're passing in to make sure it's not touched.
		CopyMemory(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC));

		tr = pDP8Peer->DP8P_Host(&dpnad,
								&pDP8Address,
								1,
								NULL,
								NULL,
								//&(context.dpnidPlayer),
								NULL,
								0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't start hosting session!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't host)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

#pragma BUGBUG(vanceo, "Make sure we got the create player message?")
		/*
		// Make sure we got the create player message.
		if (context.dpnidPlayer == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player)
		*/




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting caps after hosting");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_SetCaps(&dpncaps, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting caps after hosting failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set caps)

		if (memcmp(&dpncapsCompare, &dpncaps, sizeof (DPN_CAPS)) != 0)
		{
			DPTEST_FAIL(hLog, "Caps structure was modified (structure at %x != structure at %x)!",
				2, &dpncapsCompare, &dpncaps);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (caps changed)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing peer object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		/*
		// Make sure we got the destroy player message.
		if (context.dpnidPlayer != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)
		*/





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Peer);
		pDP8Peer = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE


	if (pDP8Peer != NULL)
	{
		delete (pDP8Peer);
		pDP8Peer = NULL;
	} // end if (have peer object)

	SAFE_RELEASE(pDP8Address);


	return (sr);
} // ParmVPeerExec_SetCaps
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVPeerExec_SetSPCaps()"
//==================================================================================
// ParmVPeerExec_SetSPCaps
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.1.31 - Peer SetSPCaps parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVPeerExec_SetSPCaps(HANDLE hLog)
{
	CTNSystemResult			sr;
	CTNTestResult			tr;
	PWRAPDP8PEER			pDP8Peer = NULL;
	PDIRECTPLAY8ADDRESS		pDP8Address = NULL;
	DPN_APPLICATION_DESC	dpnad;
	DPN_APPLICATION_DESC	dpnadCompare;
	DPN_SP_CAPS				dpnspcaps;
	DPN_SP_CAPS				dpnspcapsCompare;
	PARMVPGENERICCONTEXT	genericcontext;

	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Peer = new CWrapDP8Peer(hLog);
		if (pDP8Peer == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8Peer->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (LPVOID *) &pDP8Address, NULL);
		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't create DirectPlay8Address object!", 0);
			THROW_SYSTEMRESULT;
		} // end if (create failed)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting address object's SP to TCP/IP");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->SetSP(&CLSID_DP8SP_TCPIP);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting address object's SP to TCP/IP failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set SP)





/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting SP caps with NULL pointers and 0 flags using C++ macro");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = IDirectPlay8Peer_SetSPCaps(pDP8Peer->m_pDP8Peer, NULL, NULL, 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Setting SP caps with NULL pointers and 0 flags using C++ macro didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set caps)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting SP caps with NULL pointers and 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_SetSPCaps(NULL, NULL, 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Setting SP caps with NULL pointers and 0 flags didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set caps)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting SP caps with NULL caps pointer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_SetSPCaps(&CLSID_DP8SP_TCPIP, NULL, 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Setting SP caps with NULL caps pointer didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set caps)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting SP caps with 0 size");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpnspcaps, sizeof (DPN_SP_CAPS));
		//dpnspcaps.dwFlags = 0;
		//dpnspcaps.dwNumThreads = 0;
		//dpnspcaps.dwDefaultEnumCount = 0;
		//dpnspcaps.dwDefaultEnumRetryInterval = 0;
		//dpnspcaps.dwDefaultEnumTimeout = 0;
		//dpnspcaps.dwMaxEnumPayloadSize = 0;
		//dpnspcaps.dwBuffersPerThread = 0;
		//dpnspcaps.dwSystemBufferSize = 0;

		CopyMemory(&dpnspcapsCompare, &dpnspcaps, sizeof (DPN_SP_CAPS));

		tr = pDP8Peer->DP8P_SetSPCaps(&CLSID_DP8SP_TCPIP, &dpnspcaps, 0);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Setting SP caps with 0 size didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set caps)

		if (memcmp(&dpnspcapsCompare, &dpnspcaps, sizeof (DPN_SP_CAPS)) != 0)
		{
			DPTEST_FAIL(hLog, "Caps structure was modified (structure at %x != structure at %x)!",
				2, &dpnspcapsCompare, &dpnspcaps);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (caps changed)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting SP caps with too-large size");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpnspcaps, sizeof (DPN_SP_CAPS));
		dpnspcaps.dwSize = sizeof (DPN_SP_CAPS) + 1;
		//dpnspcaps.dwFlags = 0;
		//dpnspcaps.dwNumThreads = 0;
		//dpnspcaps.dwDefaultEnumCount = 0;
		//dpnspcaps.dwDefaultEnumRetryInterval = 0;
		//dpnspcaps.dwDefaultEnumTimeout = 0;
		//dpnspcaps.dwMaxEnumPayloadSize = 0;
		//dpnspcaps.dwBuffersPerThread = 0;
		//dpnspcaps.dwSystemBufferSize = 0;

		CopyMemory(&dpnspcapsCompare, &dpnspcaps, sizeof (DPN_SP_CAPS));

		tr = pDP8Peer->DP8P_SetSPCaps(&CLSID_DP8SP_TCPIP, &dpnspcaps, 0);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Setting SP caps with too-large size didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set caps)

		if (memcmp(&dpnspcapsCompare, &dpnspcaps, sizeof (DPN_SP_CAPS)) != 0)
		{
			DPTEST_FAIL(hLog, "Caps structure was modified (structure at %x != structure at %x)!",
				2, &dpnspcapsCompare, &dpnspcaps);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (caps changed)
*/


#pragma TODO(vanceo, "Validate flags?")
//		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
//		TEST_SECTION("Setting SP caps with invalid caps flags");
//		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
//
//		ZeroMemory(&dpnspcaps, sizeof (DPN_SP_CAPS));
//		dpnspcaps.dwSize = sizeof (DPN_SP_CAPS);
//		dpnspcaps.dwFlags = 0x666;
//		//dpnspcaps.dwNumThreads = 0;
//		//dpnspcaps.dwDefaultEnumCount = 0;
//		//dpnspcaps.dwDefaultEnumRetryInterval = 0;
//		//dpnspcaps.dwDefaultEnumTimeout = 0;
//		//dpnspcaps.dwMaxEnumPayloadSize = 0;
//		//dpnspcaps.dwBuffersPerThread = 0;
//		//dpnspcaps.dwSystemBufferSize = 0;
//
//		CopyMemory(&dpnspcapsCompare, &dpnspcaps, sizeof (DPN_SP_CAPS));
//
//		tr = pDP8Peer->DP8P_SetSPCaps(&CLSID_DP8SP_TCPIP, &dpnspcaps, 0);
//		if (tr != DPNERR_INVALIDPARAM)
//		{
//			DPTEST_FAIL(hLog, "Setting SP caps with invalid caps flags didn't return expected error INVALIDPARAM!", 0);
//			THROW_TESTRESULT;
//		} // end if (couldn't set caps)
//
//		if (memcmp(&dpnspcapsCompare, &dpnspcaps, sizeof (DPN_SP_CAPS)) != 0)
//		{
//			DPTEST_FAIL(hLog, "Caps structure was modified (structure at %x != structure at %x)!",
//				2, &dpnspcapsCompare, &dpnspcaps);
//			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
//		} // end if (caps changed)
//



// BUGBUG - see if this rips when non-zero buffers per thread is provided
/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting SP caps with num threads set to 0");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpnspcaps, sizeof (DPN_SP_CAPS));
		dpnspcaps.dwSize = sizeof (DPN_SP_CAPS);
		//dpnspcaps.dwFlags = 0;
		//dpnspcaps.dwNumThreads = 0;
		//dpnspcaps.dwDefaultEnumCount = 0;
		//dpnspcaps.dwDefaultEnumRetryInterval = 0;
		//dpnspcaps.dwDefaultEnumTimeout = 0;
		//dpnspcaps.dwMaxEnumPayloadSize = 0;
		//dpnspcaps.dwBuffersPerThread = 0;
		//dpnspcaps.dwSystemBufferSize = 0;

		CopyMemory(&dpnspcapsCompare, &dpnspcaps, sizeof (DPN_SP_CAPS));

		tr = pDP8Peer->DP8P_SetSPCaps(&CLSID_DP8SP_TCPIP, &dpnspcaps, 0);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Setting SP caps with num threads set to 0 didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set caps)

		if (memcmp(&dpnspcapsCompare, &dpnspcaps, sizeof (DPN_SP_CAPS)) != 0)
		{
			DPTEST_FAIL(hLog, "Caps structure was modified (structure at %x != structure at %x)!",
				2, &dpnspcapsCompare, &dpnspcaps);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (caps changed)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting SP caps with buffers per thread set to 0");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpnspcaps, sizeof (DPN_SP_CAPS));
		dpnspcaps.dwSize = sizeof (DPN_SP_CAPS);
		//dpnspcaps.dwFlags = 0;
		dpnspcaps.dwNumThreads = 1;
		//dpnspcaps.dwDefaultEnumCount = 0;
		//dpnspcaps.dwDefaultEnumRetryInterval = 0;
		//dpnspcaps.dwDefaultEnumTimeout = 0;
		//dpnspcaps.dwMaxEnumPayloadSize = 0;
		//dpnspcaps.dwBuffersPerThread = 0;
		//dpnspcaps.dwSystemBufferSize = 0;

		CopyMemory(&dpnspcapsCompare, &dpnspcaps, sizeof (DPN_SP_CAPS));

		tr = pDP8Peer->DP8P_SetSPCaps(&CLSID_DP8SP_TCPIP, &dpnspcaps, 0);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Setting SP caps with buffers per thread set to 0 didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set caps)

		if (memcmp(&dpnspcapsCompare, &dpnspcaps, sizeof (DPN_SP_CAPS)) != 0)
		{
			DPTEST_FAIL(hLog, "Caps structure was modified (structure at %x != structure at %x)!",
				2, &dpnspcapsCompare, &dpnspcaps);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (caps changed)
*/




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting SP caps with invalid flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpnspcaps, sizeof (DPN_SP_CAPS));
		dpnspcaps.dwSize = sizeof (DPN_SP_CAPS);
		//dpnspcaps.dwFlags = 0;
		dpnspcaps.dwNumThreads = 1;
		//dpnspcaps.dwDefaultEnumCount = 0;
		//dpnspcaps.dwDefaultEnumRetryInterval = 0;
		//dpnspcaps.dwDefaultEnumTimeout = 0;
		//dpnspcaps.dwMaxEnumPayloadSize = 0;
		dpnspcaps.dwBuffersPerThread = 1;
		dpnspcaps.dwSystemBufferSize = 8192;

		CopyMemory(&dpnspcapsCompare, &dpnspcaps, sizeof (DPN_SP_CAPS));

		tr = pDP8Peer->DP8P_SetSPCaps(&CLSID_DP8SP_TCPIP, &dpnspcaps, 0x666);
		if (tr != DPNERR_INVALIDFLAGS)
		{
			DPTEST_FAIL(hLog, "Setting SP caps with invalid flags didn't return expected error INVALIDFLAGS!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set caps)

		if (memcmp(&dpnspcapsCompare, &dpnspcaps, sizeof (DPN_SP_CAPS)) != 0)
		{
			DPTEST_FAIL(hLog, "Caps structure was modified (structure at %x != structure at %x)!",
				2, &dpnspcapsCompare, &dpnspcaps);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (caps changed)
*/

		ZeroMemory(&dpnspcaps, sizeof (DPN_SP_CAPS));
		dpnspcaps.dwSize = sizeof (DPN_SP_CAPS);
		//dpnspcaps.dwFlags = 0;
		dpnspcaps.dwNumThreads = 1;
		//dpnspcaps.dwDefaultEnumCount = 0;
		//dpnspcaps.dwDefaultEnumRetryInterval = 0;
		//dpnspcaps.dwDefaultEnumTimeout = 0;
		//dpnspcaps.dwMaxEnumPayloadSize = 0;
		dpnspcaps.dwBuffersPerThread = 1;
		dpnspcaps.dwSystemBufferSize = 8192;


/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting SP caps before initialization");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_SetSPCaps(&CLSID_DP8SP_TCPIP, &dpnspcaps, 0);
		if (tr != DPNERR_UNINITIALIZED)
		{
			DPTEST_FAIL(hLog, "Setting SP caps before initialization didn't return expected error UNINITIALIZED!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set caps)

		if (memcmp(&dpnspcapsCompare, &dpnspcaps, sizeof (DPN_SP_CAPS)) != 0)
		{
			DPTEST_FAIL(hLog, "Caps structure was modified (structure at %x != structure at %x)!",
				2, &dpnspcapsCompare, &dpnspcaps);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (caps changed)
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Initializing peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		genericcontext.hLog = hLog;

		tr = pDP8Peer->DP8P_Initialize(&hLog, ParmVPSetSPCapsDPNMessageHandler, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Initializing peer object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting SP caps");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpnspcaps, sizeof (DPN_SP_CAPS));
		dpnspcaps.dwSize = sizeof (DPN_SP_CAPS);
		//dpnspcaps.dwFlags = 0;

		// NT has (2 * num procs) + 2 threads, Win9x always starts with 2.  No real
		// reason to set them to their defaults (especially since the reg key
		// override might be set), but no real reason not to, either.
// XBOX - Xbox uses a work-pump... so there are 0 service provider threads
//		if (pTNecd->pMachineInfo->IsNTBasedOS())
//			dpnspcaps.dwNumThreads = (2 * pTNecd->pMachineInfo->m_dwNumberOfProcessors) + 2;
//		else
//			dpnspcaps.dwNumThreads = 2;

			dpnspcaps.dwNumThreads = 1;


		//dpnspcaps.dwDefaultEnumCount = 0;
		//dpnspcaps.dwDefaultEnumRetryInterval = 0;
		//dpnspcaps.dwDefaultEnumTimeout = 0;
		//dpnspcaps.dwMaxEnumPayloadSize = 0;
		dpnspcaps.dwBuffersPerThread = 1;
		dpnspcaps.dwSystemBufferSize = 8192;

		CopyMemory(&dpnspcapsCompare, &dpnspcaps, sizeof (DPN_SP_CAPS));

		tr = pDP8Peer->DP8P_SetSPCaps(&CLSID_DP8SP_TCPIP, &dpnspcaps, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting SP caps failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set caps)

		if (memcmp(&dpnspcapsCompare, &dpnspcaps, sizeof (DPN_SP_CAPS)) != 0)
		{
			DPTEST_FAIL(hLog, "Caps structure was modified (structure at %x != structure at %x)!",
				2, &dpnspcapsCompare, &dpnspcaps);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (caps changed)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting SP caps for invalid SP GUID");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_SetSPCaps(&GUID_UNKNOWN, &dpnspcaps, 0);
		if (tr != DPNERR_DOESNOTEXIST)
		{
			if(tr == DPN_OK)
			{
				DPTEST_FAIL(hLog, "Xbox bug 3683 occurred!\n", 0);
			}
			else
			{
				DPTEST_FAIL(hLog, "Setting SP caps didn't return expected error DOESNOTEXIST!", 0);
				THROW_TESTRESULT;
			}
		} // end if (couldn't set caps)

		if (memcmp(&dpnspcapsCompare, &dpnspcaps, sizeof (DPN_SP_CAPS)) != 0)
		{
			DPTEST_FAIL(hLog, "Caps structure was modified (structure at %x != structure at %x)!",
				2, &dpnspcapsCompare, &dpnspcaps);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (caps changed)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Hosting session");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		//dpnad.dwFlags = 0;
		//dpnad.guidInstance = GUID_NULL;
		dpnad.guidApplication = GUID_PARMV_PEER_GETAPPDESC;
		//dpnad.dwMaxPlayers = 0;
		//dpnad.dwCurrentPlayers = 0;
		//dpnad.pwszSessionName = NULL;
		//dpnad.pwszPassword = NULL;
		//dpnad.pvReservedData = NULL;
		//dpnad.dwReservedDataSize = 0;
		//dpnad.pvApplicationReservedData = NULL;
		//dpnad.dwApplicationReservedDataSize = 0;

		// Save what we're passing in to make sure it's not touched.
		CopyMemory(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC));

		tr = pDP8Peer->DP8P_Host(&dpnad,
								&pDP8Address,
								1,
								NULL,
								NULL,
								//&(context.dpnidPlayer),
								NULL,
								0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't start hosting session!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't host)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

#pragma BUGBUG(vanceo, "Make sure we got the create player message?")
//		// Make sure we got the create player message.
//		if (context.dpnidPlayer == 0)
//		{
//			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication!", 0);
//			SETTHROW_TESTRESULT(ERROR_NO_DATA);
//		} // end if (didn't get create player)
//




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting SP caps after hosting");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_SetSPCaps(&CLSID_DP8SP_TCPIP, &dpnspcaps, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting SP caps after hosting failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set caps)

		if (memcmp(&dpnspcapsCompare, &dpnspcaps, sizeof (DPN_SP_CAPS)) != 0)
		{
			DPTEST_FAIL(hLog, "Caps structure was modified (structure at %x != structure at %x)!",
				2, &dpnspcapsCompare, &dpnspcaps);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (caps changed)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing peer object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

//		// Make sure we got the destroy player message.
//		if (context.dpnidPlayer != 0)
//		{
//			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication!", 0);
//			SETTHROW_TESTRESULT(ERROR_NO_DATA);
//		} // end if (didn't get destroy player)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Peer);
		pDP8Peer = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE


	if (pDP8Peer != NULL)
	{
		delete (pDP8Peer);
		pDP8Peer = NULL;
	} // end if (have peer object)

	SAFE_RELEASE(pDP8Address);

	return (sr);
} // ParmVPeerExec_SetSPCaps
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVPeerExec_GetSPCaps()"
//==================================================================================
// ParmVPeerExec_GetSPCaps
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.1.32 - Peer GetSPCaps parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVPeerExec_GetSPCaps(HANDLE hLog)
{
	CTNSystemResult			sr;
	CTNTestResult			tr;
	PWRAPDP8PEER			pDP8Peer = NULL;
	PDIRECTPLAY8ADDRESS		pDP8Address = NULL;
	DPN_APPLICATION_DESC	dpnad;
	DPN_APPLICATION_DESC	dpnadCompare;
	DPN_SP_CAPS				dpnspcaps;
	DPN_SP_CAPS				dpnspcapsCompare;
	PARMVPGENERICCONTEXT	genericcontext;

	memset(&genericcontext, 0, sizeof(PARMVPGENERICCONTEXT));

	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Peer = new CWrapDP8Peer(hLog);
		if (pDP8Peer == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8Peer->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (LPVOID *) &pDP8Address, NULL);
		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't cCreate DirectPlay8Address object!", 0);
			THROW_SYSTEMRESULT;
		} // end if (create failed)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting address object's SP to TCP/IP");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->SetSP(&CLSID_DP8SP_TCPIP);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting address object's SP to TCP/IP failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set SP)




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting SP caps with NULL pointers using C++ macro");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = IDirectPlay8Peer_GetSPCaps(pDP8Peer->m_pDP8Peer, NULL, NULL, 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Getting SP caps with NULL pointers using C++ macro didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get caps)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting SP caps with NULL pointers");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_GetSPCaps(NULL, NULL, 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Getting SP caps with NULL pointers didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get caps)
*/




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting SP caps with NULL GUID");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpnspcaps, sizeof (DPN_SP_CAPS));
		dpnspcaps.dwSize = sizeof (DPN_SP_CAPS);

		CopyMemory(&dpnspcapsCompare, &dpnspcaps, sizeof (DPN_SP_CAPS));

		tr = pDP8Peer->DP8P_GetSPCaps(NULL, &dpnspcaps, 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			if(tr == DPNERR_UNINITIALIZED)
			{
				DPTEST_FAIL(hLog, "Xbox bug 2993 occurred", 0);
				fPassed = FALSE;
			}
			else
			{
				DPTEST_FAIL(hLog, "Getting SP caps with NULL GUID didn't return expected error INVALIDPOINTER!", 0);
				THROW_TESTRESULT;
			}
		} // end if (couldn't get caps)

		if (memcmp(&dpnspcapsCompare, &dpnspcaps, sizeof (DPN_SP_CAPS)) != 0)
		{
			if(tr == DPNERR_UNINITIALIZED)
			{
				DPTEST_FAIL(hLog, "Xbox bug 2993 occurred", 0);
				fPassed = FALSE;
			}
			else
			{
				DPTEST_FAIL(hLog, "Caps structure was modified (structure at %x != structure at %x)!",
					2, &dpnspcapsCompare, &dpnspcaps);
				SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
			}
		} // end if (caps changed)
*/




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting SP caps with NULL caps");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_GetSPCaps(&CLSID_DP8SP_TCPIP, NULL, 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Getting SP caps with NULL caps didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get caps)
*/




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting SP caps with 0 size");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpnspcaps, sizeof (DPN_SP_CAPS));

		CopyMemory(&dpnspcapsCompare, &dpnspcaps, sizeof (DPN_SP_CAPS));

		tr = pDP8Peer->DP8P_GetSPCaps(&CLSID_DP8SP_TCPIP, &dpnspcaps, 0);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Getting SP caps with 0 size didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get caps)

		if (memcmp(&dpnspcapsCompare, &dpnspcaps, sizeof (DPN_SP_CAPS)) != 0)
		{
			DPTEST_FAIL(hLog, "Caps structure was modified (structure at %x != structure at %x)!",
				2, &dpnspcapsCompare, &dpnspcaps);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (caps changed)
*/




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting SP caps with too large size");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpnspcaps, sizeof (DPN_SP_CAPS));
		dpnspcaps.dwSize = sizeof (DPN_SP_CAPS) + 1;

		CopyMemory(&dpnspcapsCompare, &dpnspcaps, sizeof (DPN_SP_CAPS));

		tr = pDP8Peer->DP8P_GetSPCaps(&CLSID_DP8SP_TCPIP, &dpnspcaps, 0);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Getting SP caps with too large size didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get caps)

		if (memcmp(&dpnspcapsCompare, &dpnspcaps, sizeof (DPN_SP_CAPS)) != 0)
		{
			DPTEST_FAIL(hLog, "Caps structure was modified (structure at %x != structure at %x)!",
				2, &dpnspcapsCompare, &dpnspcaps);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (caps changed)
*/




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting SP caps with invalid flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpnspcaps, sizeof (DPN_SP_CAPS));
		dpnspcaps.dwSize = sizeof (DPN_SP_CAPS);

		CopyMemory(&dpnspcapsCompare, &dpnspcaps, sizeof (DPN_SP_CAPS));

		tr = pDP8Peer->DP8P_GetSPCaps(&CLSID_DP8SP_TCPIP, &dpnspcaps, 0x666);
		if (tr != DPNERR_INVALIDFLAGS)
		{
			DPTEST_FAIL(hLog, "Getting SP caps with invalid flags didn't return expected error INVALIDFLAGS!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get caps)

		if (memcmp(&dpnspcapsCompare, &dpnspcaps, sizeof (DPN_SP_CAPS)) != 0)
		{
			DPTEST_FAIL(hLog, "Caps structure was modified (structure at %x != structure at %x)!",
				2, &dpnspcapsCompare, &dpnspcaps);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (caps changed)
*/


		ZeroMemory(&dpnspcaps, sizeof (DPN_SP_CAPS));
		dpnspcaps.dwSize = sizeof (DPN_SP_CAPS);


/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting SP caps before initialization");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_GetSPCaps(&CLSID_DP8SP_TCPIP, &dpnspcaps, 0);
		if (tr != DPNERR_UNINITIALIZED)
		{
			DPTEST_FAIL(hLog, "Getting SP caps before initialization didn't return expected error UNINITIALIZED!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get caps)

		if (memcmp(&dpnspcapsCompare, &dpnspcaps, sizeof (DPN_SP_CAPS)) != 0)
		{
			DPTEST_FAIL(hLog, "Caps structure was modified (structure at %x != structure at %x)!",
				2, &dpnspcapsCompare, &dpnspcaps);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (caps changed)
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Initializing peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		genericcontext.hLog = hLog;

		tr = pDP8Peer->DP8P_Initialize(&genericcontext, ParmVPGetSPCapsDPNMessageHandler, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Initializing peer object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting SP caps with invalid SP GUID");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_GetSPCaps(&GUID_UNKNOWN, &dpnspcaps, 0);
		if (tr != DPNERR_DOESNOTEXIST)
		{
			if(tr == DPN_OK)
			{
				DPTEST_FAIL(hLog, "Xbox bug 2993 occurred", 0);
				fPassed = FALSE;
			}
			else
			{
				DPTEST_FAIL(hLog, "Getting SP caps with invalid SP GUID didn't return expected error DOESNOTEXIST!", 0);
				THROW_TESTRESULT;
			}
		} // end if (couldn't get caps)

		if (memcmp(&dpnspcapsCompare, &dpnspcaps, sizeof (DPN_SP_CAPS)) != 0)
		{
			if(tr == DPN_OK)
			{
				DPTEST_FAIL(hLog, "Xbox bug 2993 occurred", 0);
				fPassed = FALSE;
			}
			else
			{
				DPTEST_FAIL(hLog, "Caps structure was modified (structure at %x != structure at %x)!",
					2, &dpnspcapsCompare, &dpnspcaps);
				SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
			}
		} // end if (caps changed)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting SP caps");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_GetSPCaps(&CLSID_DP8SP_TCPIP, &dpnspcaps, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting SP caps failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get caps)

#pragma TODO(vanceo, "Make caps comp function")
		if (dpnspcaps.dwSize != sizeof (DPN_SP_CAPS))
		{
			DPTEST_FAIL(hLog, "Caps structure size was modified (%u != %u)!",
				2, dpnspcaps.dwSize, sizeof (DPN_SP_CAPS));
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (size changed)

		if (dpnspcaps.dwFlags != (DPNSPCAPS_SUPPORTSDPNSRV | DPNSPCAPS_SUPPORTSBROADCAST | DPNSPCAPS_SUPPORTSALLADAPTERS))
		{
			DPTEST_FAIL(hLog, "Flags returned are wrong (%x != %x)!",
				2, dpnspcaps.dwFlags,
				(DPNSPCAPS_SUPPORTSDPNSRV | DPNSPCAPS_SUPPORTSBROADCAST | DPNSPCAPS_SUPPORTSALLADAPTERS));
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (flags wrong)

/* XBOX - Xbox uses a work-pump... so there are 0 service provider threads
		switch (g_dwCurrentDPNWSockEmulMode)
		{
			case DPNWSOCKEMULMODE_WINSOCK1:
			case DPNWSOCKEMULMODE_WINSOCK2:
				if (dpnspcaps.dwNumThreads != 2)
				{
					DPTEST_FAIL(hLog, "Num threads returned is wrong (%u != 2)!",
						1, dpnspcaps.dwNumThreads);
					SETTHROW_TESTRESULT(ERROR_NO_MATCH);
				} // end if (num threads wrong)
			  break;

			default:
				if (pTNecd->pMachineInfo->IsNTBasedOS())
				{
					if (dpnspcaps.dwNumThreads != ((2 * pTNecd->pMachineInfo->m_dwNumberOfProcessors) + 2))
					{
						DPTEST_FAIL(hLog, "Num threads returned is wrong (%u != %u)!",
							2, dpnspcaps.dwNumThreads,
							((2 * pTNecd->pMachineInfo->m_dwNumberOfProcessors) + 2));
						SETTHROW_TESTRESULT(ERROR_NO_MATCH);
					} // end if (num threads wrong)
				} // end if (NT)
				else
				{
					if (dpnspcaps.dwNumThreads != 2)
					{
						DPTEST_FAIL(hLog, "Num threads returned is wrong (%u != 2)!",
							1, dpnspcaps.dwNumThreads);
						SETTHROW_TESTRESULT(ERROR_NO_MATCH);
					} // end if (num threads wrong)
				} // end else (Win9x)
			  break;
		} // end switch (on DPNWSock emulation mode)
*/

		if (dpnspcaps.dwDefaultEnumCount != 5)
		{
			DPTEST_FAIL(hLog, "Default enum count returned is wrong (%u != 5)!",
				1, dpnspcaps.dwDefaultEnumCount);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (default enum count wrong)

		if (dpnspcaps.dwDefaultEnumRetryInterval != 1500)
		{
			DPTEST_FAIL(hLog, "Default enum retry interval returned is wrong (%u != 1500)!",
				1, dpnspcaps.dwDefaultEnumRetryInterval);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (default enum retry interval wrong)

		if (dpnspcaps.dwDefaultEnumTimeout != 1500)
		{
			DPTEST_FAIL(hLog, "Default enum timeout returned is wrong (%u != 1500)!",
				1, dpnspcaps.dwDefaultEnumTimeout);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (default enum timeout wrong)

		if (dpnspcaps.dwMaxEnumPayloadSize != 983)
		{
			DPTEST_FAIL(hLog, "Max enum payload size returned is wrong (%u != 983)!",
				1, dpnspcaps.dwMaxEnumPayloadSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (max enum payload wrong)

#pragma BUGBUG(vanceo, "Doesn't handle regkey override")
		if (dpnspcaps.dwBuffersPerThread != 1)
		{
			DPTEST_FAIL(hLog, "Buffers per thread returned is wrong (%u != 1)!",
				1, dpnspcaps.dwBuffersPerThread);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (buffers per thread wrong)

		if (dpnspcaps.dwSystemBufferSize != 8192)
		{
			if(dpnspcaps.dwSystemBufferSize == 16384)
			{
				DPTEST_FAIL(hLog, "Xbox bug 3046 occurred!", 0);
				fPassed = FALSE;
			}
			else
			{
				DPTEST_FAIL(hLog, "System buffer size returned is wrong (%u != 8192)!",
					1, dpnspcaps.dwSystemBufferSize);
				SETTHROW_TESTRESULT(ERROR_NO_MATCH);
			}
		} // end if (system buffer size wrong)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Hosting session");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		//dpnad.dwFlags = 0;
		//dpnad.guidInstance = GUID_NULL;
		dpnad.guidApplication = GUID_PARMV_PEER_GETAPPDESC;
		//dpnad.dwMaxPlayers = 0;
		//dpnad.dwCurrentPlayers = 0;
		//dpnad.pwszSessionName = NULL;
		//dpnad.pwszPassword = NULL;
		//dpnad.pvReservedData = NULL;
		//dpnad.dwReservedDataSize = 0;
		//dpnad.pvApplicationReservedData = NULL;
		//dpnad.dwApplicationReservedDataSize = 0;

		// Save what we're passing in to make sure it's not touched.
		CopyMemory(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC));

		tr = pDP8Peer->DP8P_Host(&dpnad,
								&pDP8Address,
								1,
								NULL,
								NULL,
								//&(context.dpnidPlayer),
								NULL,
								0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't start hosting session!: (error 0x%08x)", 1, tr);
			THROW_TESTRESULT;
		} // end if (couldn't host)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

#pragma BUGBUG(vanceo, "Make sure we got the create player message?")
		/*
		// Make sure we got the create player message.
		if (context.dpnidPlayer == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player)
		*/





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting SP caps");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpnspcaps, sizeof (DPN_SP_CAPS));
		dpnspcaps.dwSize = sizeof (DPN_SP_CAPS);

		tr = pDP8Peer->DP8P_GetSPCaps(&CLSID_DP8SP_TCPIP, &dpnspcaps, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting SP caps failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get caps)

#pragma TODO(vanceo, "Make caps comp function")
		if (dpnspcaps.dwSize != sizeof (DPN_SP_CAPS))
		{
			DPTEST_FAIL(hLog, "Caps structure size was modified (%u != %u)!",
				2, dpnspcaps.dwSize, sizeof (DPN_SP_CAPS));
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (size changed)

		if (dpnspcaps.dwFlags != (DPNSPCAPS_SUPPORTSDPNSRV | DPNSPCAPS_SUPPORTSBROADCAST | DPNSPCAPS_SUPPORTSALLADAPTERS))
		{
			DPTEST_FAIL(hLog, "Flags returned are wrong (%x != %x)!",
				2, dpnspcaps.dwFlags,
				(DPNSPCAPS_SUPPORTSDPNSRV | DPNSPCAPS_SUPPORTSBROADCAST | DPNSPCAPS_SUPPORTSALLADAPTERS));
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (flags wrong)

/* XBOX - Xbox uses a work-pump... so there are 0 service provider threads
		switch (g_dwCurrentDPNWSockEmulMode)
		{
			case DPNWSOCKEMULMODE_WINSOCK1:
			case DPNWSOCKEMULMODE_WINSOCK2:
				if (dpnspcaps.dwNumThreads != 2)
				{
					DPTEST_FAIL(hLog, "Num threads returned is wrong (%u != 2)!",
						1, dpnspcaps.dwNumThreads);
					SETTHROW_TESTRESULT(ERROR_NO_MATCH);
				} // end if (num threads wrong)
			  break;

			default:
				if (pTNecd->pMachineInfo->IsNTBasedOS())
				{
					if (dpnspcaps.dwNumThreads != ((2 * pTNecd->pMachineInfo->m_dwNumberOfProcessors) + 2))
					{
						DPTEST_FAIL(hLog, "Num threads returned is wrong (%u != %u)!",
							2, dpnspcaps.dwNumThreads,
							((2 * pTNecd->pMachineInfo->m_dwNumberOfProcessors) + 2));
						SETTHROW_TESTRESULT(ERROR_NO_MATCH);
					} // end if (num threads wrong)
				} // end if (NT)
				else
				{
					if (dpnspcaps.dwNumThreads != 2)
					{
						DPTEST_FAIL(hLog, "Num threads returned is wrong (%u != 2)!",
							1, dpnspcaps.dwNumThreads);
						SETTHROW_TESTRESULT(ERROR_NO_MATCH);
					} // end if (num threads wrong)
				} // end else (Win9x)

				if (dpnspcaps.dwNumThreads != 0)
				{
					DPTEST_FAIL(hLog, "Num threads returned is wrong (%u != 0)!",
						1, dpnspcaps.dwNumThreads);
					SETTHROW_TESTRESULT(ERROR_NO_MATCH);
				} // end if (num threads wrong)

			  break;
		} // end switch (on DPNWSock emulation mode)
*/

		if (dpnspcaps.dwDefaultEnumCount != 5)
		{
			DPTEST_FAIL(hLog, "Default enum count returned is wrong (%u != 5)!",
				1, dpnspcaps.dwDefaultEnumCount);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (default enum count wrong)

		if (dpnspcaps.dwDefaultEnumRetryInterval != 1500)
		{
			DPTEST_FAIL(hLog, "Default enum retry interval returned is wrong (%u != 1500)!",
				1, dpnspcaps.dwDefaultEnumRetryInterval);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (default enum retry interval wrong)

		if (dpnspcaps.dwDefaultEnumTimeout != 1500)
		{
			DPTEST_FAIL(hLog, "Default enum timeout returned is wrong (%u != 1500)!",
				1, dpnspcaps.dwDefaultEnumTimeout);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (default enum timeout wrong)

		if (dpnspcaps.dwMaxEnumPayloadSize != 983)
		{
			DPTEST_FAIL(hLog, "Max enum payload size returned is wrong (%u != 983)!",
				1, dpnspcaps.dwMaxEnumPayloadSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (max enum payload wrong)

#pragma BUGBUG(vanceo, "Previous SetSPCaps could mess up this and all global values")
#pragma BUGBUG(vanceo, "Doesn't handle regkey override")
		if (dpnspcaps.dwBuffersPerThread != 1)
		{
			DPTEST_FAIL(hLog, "Buffers per thread returned is wrong (%u != 1)!",
				1, dpnspcaps.dwBuffersPerThread);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (buffers per thread wrong)

		if (dpnspcaps.dwSystemBufferSize != 8192)
		{
			if(dpnspcaps.dwSystemBufferSize == 16384)
			{
				DPTEST_FAIL(hLog, "Xbox bug 3046 occurred!", 0);
				fPassed = FALSE;
			}
			else
			{
				DPTEST_FAIL(hLog, "System buffer size returned is wrong (%u != 8192)!",
					1, dpnspcaps.dwSystemBufferSize);
				SETTHROW_TESTRESULT(ERROR_NO_MATCH);
			}
		} // end if (system buffer size wrong)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing peer object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		/*
		// Make sure we got the destroy player message.
		if (context.dpnidPlayer != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)
		*/





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Peer);
		pDP8Peer = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE


	if (pDP8Peer != NULL)
	{
		delete (pDP8Peer);
		pDP8Peer = NULL;
	} // end if (have peer object)

	SAFE_RELEASE(pDP8Address);


	return (sr);
} // ParmVPeerExec_GetSPCaps
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVPeerExec_GetConnInfo()"
//==================================================================================
// ParmVPeerExec_GetConnInfo
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.1.33 - Peer GetConnectionInfo parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVPeerExec_GetConnInfo(HANDLE hLog)
{
	CTNSystemResult				sr;
	CTNTestResult				tr;
	PWRAPDP8PEER				pDP8Peer = NULL;
	PWRAPDP8PEER				pDP8PeerHost = NULL;
	PDIRECTPLAY8ADDRESS			pDP8Address = NULL;
	DPN_CONNECTION_INFO			dpnci;
	DPN_CONNECTION_INFO			dpnciCompare;
	DPN_APPLICATION_DESC		dpnad;
	DPN_APPLICATION_DESC		dpnadCompare;
	PARMVPGETCONNINFOCONTEXT	hostcontext;
	PARMVPGETCONNINFOCONTEXT	nonhostcontext;
	DP_DOWORKLIST				DoWorkList;
	DPNHANDLE					hAsyncOp;
	HANDLE						hAsyncOpComplete = NULL;

	ZeroMemory(&DoWorkList, sizeof(DP_DOWORKLIST));
	ZeroMemory(&hostcontext, sizeof (PARMVPGETCONNINFOCONTEXT));
	hostcontext.fHost = TRUE;

	ZeroMemory(&nonhostcontext, sizeof (PARMVPGETCONNINFOCONTEXT));
	//nonhostcontext.fHost = FALSE;


	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Peer = new CWrapDP8Peer(hLog);
		if (pDP8Peer == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8Peer->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (LPVOID *) &pDP8Address, NULL);
		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't create DirectPlay8Address object!", 0);
			THROW_SYSTEMRESULT;
		} // end if (create failed)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting address object's SP to TCP/IP");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->SetSP(&CLSID_DP8SP_TCPIP);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting address object's SP to TCP/IP failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set SP)





/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting connection info with NULL pointer using C++ macro");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = IDirectPlay8Peer_GetConnectionInfo(pDP8Peer->m_pDP8Peer, 0, NULL, 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Getting connection info with NULL pointer using C++ macro didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get connection info)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting connection info with NULL pointer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_GetConnectionInfo(0, NULL, 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Getting connection info with NULL pointer didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get connection info)
*/




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting connection info with 0 size");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpnci, sizeof (DPN_CONNECTION_INFO));
		//dpnci.dwSize = 0;

		// Save what we're passing in to make sure it's not touched.
		CopyMemory(&dpnciCompare, &dpnci, sizeof (DPN_CONNECTION_INFO));

		tr = pDP8Peer->DP8P_GetConnectionInfo(0, &dpnci, 0);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Getting connection info with 0 size didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get connection info)

		if (memcmp(&dpnciCompare, &dpnci, sizeof (DPN_CONNECTION_INFO)) != 0)
		{
			DPTEST_FAIL(hLog, "Connection info structure was modified (structure at %x != structure at %x)!",
				2, &dpnciCompare, &dpnci);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (connection info changed)
*/




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting connection info with too-large size");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpnci, sizeof (DPN_CONNECTION_INFO));
		dpnci.dwSize = sizeof (DPN_CONNECTION_INFO) + 1;

		// Save what we're passing in to make sure it's not touched.
		CopyMemory(&dpnciCompare, &dpnci, sizeof (DPN_CONNECTION_INFO));

		tr = pDP8Peer->DP8P_GetConnectionInfo(0, &dpnci, 0);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Getting connection info with too-large size didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get connection info)

		if (memcmp(&dpnciCompare, &dpnci, sizeof (DPN_CONNECTION_INFO)) != 0)
		{
			DPTEST_FAIL(hLog, "Connection info structure was modified (structure at %x != structure at %x)!",
				2, &dpnciCompare, &dpnci);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (connection info changed)
*/




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting connection info with invalid flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpnci, sizeof (DPN_CONNECTION_INFO));
		dpnci.dwSize = sizeof (DPN_CONNECTION_INFO);

		// Save what we're passing in to make sure it's not touched.
		CopyMemory(&dpnciCompare, &dpnci, sizeof (DPN_CONNECTION_INFO));

		tr = pDP8Peer->DP8P_GetConnectionInfo(0, &dpnci, 0x666);
		if (tr != DPNERR_INVALIDFLAGS)
		{
			DPTEST_FAIL(hLog, "Getting connection info with invalid flags didn't return expected error INVALIDFLAGS!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get connection info)

		if (memcmp(&dpnciCompare, &dpnci, sizeof (DPN_CONNECTION_INFO)) != 0)
		{
			DPTEST_FAIL(hLog, "Connection info structure was modified (structure at %x != structure at %x)!",
				2, &dpnciCompare, &dpnci);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (connection info changed)
*/

		ZeroMemory(&dpnci, sizeof (DPN_CONNECTION_INFO));
		dpnci.dwSize = sizeof (DPN_CONNECTION_INFO);

		// Save what we're passing in to make sure it's not touched.
		CopyMemory(&dpnciCompare, &dpnci, sizeof (DPN_CONNECTION_INFO));

/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting connection info before initialization");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_GetConnectionInfo(0, &dpnci, 0);
		if (tr != DPNERR_UNINITIALIZED)
		{
			DPTEST_FAIL(hLog, "Getting connection info before initialization didn't return expected error UNINITIALIZED!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get connection info)

		if (memcmp(&dpnciCompare, &dpnci, sizeof (DPN_CONNECTION_INFO)) != 0)
		{
			DPTEST_FAIL(hLog, "Connection info structure was modified (structure at %x != structure at %x)!",
				2, &dpnciCompare, &dpnci);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (connection info changed)
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Initializing peer object with host context");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		hostcontext.hLog = hLog;

		tr = pDP8Peer->DP8P_Initialize(&hostcontext,
										ParmVPGetConnInfoDPNMessageHandler, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Initializing peer object with host context failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting connection info without a connection");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_GetConnectionInfo(0, &dpnci, 0);
		if (tr != DPNERR_NOCONNECTION)
		{
			DPTEST_FAIL(hLog, "Getting connection info without a connection didn't return expected error NOCONNECTION!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get connection info)

		if (memcmp(&dpnciCompare, &dpnci, sizeof (DPN_CONNECTION_INFO)) != 0)
		{
			DPTEST_FAIL(hLog, "Connection info structure was modified (structure at %x != structure at %x)!",
				2, &dpnciCompare, &dpnci);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (connection info changed)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Hosting session");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		//dpnad.dwFlags = 0;
		//dpnad.guidInstance = GUID_NULL;
		dpnad.guidApplication = GUID_PARMV_PEER_SENDTO;
		//dpnad.dwMaxPlayers = 0;
		//dpnad.dwCurrentPlayers = 0;
		//dpnad.pwszSessionName = NULL;
		//dpnad.pwszPassword = NULL;
		//dpnad.pvReservedData = NULL;
		//dpnad.dwReservedDataSize = 0;
		//dpnad.pvApplicationReservedData = NULL;
		//dpnad.dwApplicationReservedDataSize = 0;

		// Save what we're passing in to make sure it's not touched.
		CopyMemory(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC));

		tr = pDP8Peer->DP8P_Host(&dpnad,
								&pDP8Address,
								1,
								NULL,
								NULL,
								&(hostcontext.dpnidHost),
								0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't start hosting session!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't host)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		// Make sure we got the create player message.
		if (hostcontext.dpnidHost == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting connection info for 0");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_GetConnectionInfo(0, &dpnci, 0);
		if (tr != DPNERR_INVALIDPLAYER)
		{
			DPTEST_FAIL(hLog, "Getting connection info for 0 didn't return expected error INVALIDPLAYER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get connection info)

		if (memcmp(&dpnciCompare, &dpnci, sizeof (DPN_CONNECTION_INFO)) != 0)
		{
			DPTEST_FAIL(hLog, "Connection info structure was modified (structure at %x != structure at %x)!",
				2, &dpnciCompare, &dpnci);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (connection info changed)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting connection info for invalid player ID");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_GetConnectionInfo((DPNID) 0x666, &dpnci, 0);
		if (tr != DPNERR_INVALIDPLAYER)
		{
			DPTEST_FAIL(hLog, "Getting connection info for invalid player ID didn't return expected error INVALIDPLAYER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get connection info)

		if (memcmp(&dpnciCompare, &dpnci, sizeof (DPN_CONNECTION_INFO)) != 0)
		{
			DPTEST_FAIL(hLog, "Connection info structure was modified (structure at %x != structure at %x)!",
				2, &dpnciCompare, &dpnci);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (connection info changed)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting connection info for local player");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_GetConnectionInfo(hostcontext.dpnidHost, &dpnci, 0);
		if (tr != DPNERR_INVALIDPLAYER)
		{
			DPTEST_FAIL(hLog, "Getting connection info for local player didn't return expected error INVALIDPLAYER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get connection info)

		if (memcmp(&dpnciCompare, &dpnci, sizeof (DPN_CONNECTION_INFO)) != 0)
		{
			DPTEST_FAIL(hLog, "Connection info structure was modified (structure at %x != structure at %x)!",
				2, &dpnciCompare, &dpnci);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (connection info changed)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing peer object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Re-initializing peer object with nonhost context");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		nonhostcontext.hLog = hLog;

		tr = pDP8Peer->DP8P_Initialize(&nonhostcontext,
										ParmVPGetConnInfoDPNMessageHandler, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Re-initializing peer object with context, 0 flags failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating new peer host object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Address->Release();
		pDP8Address = NULL;

		hostcontext.hLog = hLog;

		tr = ParmVCreatePeerHost(hLog, ParmVPGetConnInfoDPNMessageHandler,
								&hostcontext,
								&dpnad,
								&(hostcontext.dpnidHost),
								&pDP8PeerHost,
								&pDP8Address);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Creating peer host failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't create peer host)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Connecting peer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

// XBOX - Had to make connection asynchronous

		SAFE_CLOSEHANDLE(hAsyncOpComplete);
		CREATEEVENT_OR_THROW(hAsyncOpComplete, NULL, FALSE, FALSE, NULL);

		// Host should get the create player now.
		CREATEEVENT_OR_THROW(hostcontext.hClientCreatedEvent,
							NULL, FALSE, FALSE, NULL);

		// Even though it's synchronous, we'll still get a completion.  The async op
		// handle will be NULL, though.
		nonhostcontext.fConnectCanComplete = TRUE;

		tr = pDP8Peer->DP8P_Connect(&dpnad,
									pDP8Address,
									NULL,
									NULL,
									NULL,
									NULL,
									0,
									&(nonhostcontext.dpnidClient),
									hAsyncOpComplete,
									&hAsyncOp,
									0);

		if((tr != DPNSUCCESS_PENDING) && (tr != DPN_OK))
		{
			DPTEST_FAIL(hLog, "Couldn't connect! (error 0x%08x)", 1, tr);
			THROW_TESTRESULT;
		} // end if (couldn't connect)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for connect to complete on non-host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hAsyncOpComplete))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		// Prevent any weird connects from completing.
		nonhostcontext.fConnectCanComplete = FALSE;

		ClearDoWorkList(&DoWorkList);

		// Make sure we saw the connect completion indication.
		if (! nonhostcontext.fConnectCompleted)
		{
			DPTEST_FAIL(hLog, "Didn't get connect complete indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (connect didn't complete)

		// Make sure we got the create player messages.
		if (nonhostcontext.dpnidHost == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication for host on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player)

		if (nonhostcontext.dpnidClient == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication for client on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player)

		// Reset the context.
		nonhostcontext.fConnectCompleted = FALSE;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for create player to be indicated on host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hostcontext.hClientCreatedEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting connection info of host on client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_GetConnectionInfo(nonhostcontext.dpnidHost, &dpnci, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting connection info of host on client failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get connection info)

#pragma TODO(vanceo, "Validate returned structure")
		/*
		if (memcmp(&dpnciCompare, &dpnci, sizeof (DPN_CONNECTION_INFO)) != 0)
		{
			DPTEST_FAIL(hLog, "Connection info structure was modified (structure at %x != structure at %x)!",
				2, &dpnciCompare, &dpnci);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (connection info changed)
		*/





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing peer client object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing peer client object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure we got the destroy player messages.
		if (nonhostcontext.dpnidHost != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for host on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)

		if (nonhostcontext.dpnidClient != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for client on client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)


		// Technically we should wait to make sure the host saw the client go away
		// as expected but that's more hassle than it's worth.  Just make sure he's
		// gone after Close() has returned.




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing host object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8PeerHost->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing host object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure we got the destroy player messages.
		if (hostcontext.dpnidHost != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for host on host!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)

		if (hostcontext.dpnidClient != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for client on host!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing hosting DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8PeerHost->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release hosting DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8PeerHost);
		pDP8PeerHost = NULL;





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Peer);
		pDP8Peer = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE


	if (pDP8Peer != NULL)
	{
		delete (pDP8Peer);
		pDP8Peer = NULL;
	} // end if (have peer object)

	if (pDP8PeerHost != NULL)
	{
		delete (pDP8PeerHost);
		pDP8PeerHost = NULL;
	} // end if (have peer object)

	SAFE_RELEASE(pDP8Address);
	SAFE_CLOSEHANDLE(hostcontext.hClientCreatedEvent);
	ClearDoWorkList(&DoWorkList);
	SAFE_CLOSEHANDLE(hAsyncOpComplete);

	return (sr);
} // ParmVPeerExec_GetConnInfo
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





/* XBOX - no support for lobby functions
#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVPeerExec_RegLobby()"
//==================================================================================
// ParmVPeerExec_RegLobby
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.1.34 - Peer RegisterLobby parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVPeerExec_RegLobby(HANDLE hLog)
{
	CTNSystemResult					sr;
	CTNTestResult					tr;
	PWRAPDP8PEER					pDP8Peer = NULL;
	PDIRECTPLAY8LOBBIEDAPPLICATION	pDP8LobbiedApp = NULL;



	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Peer = new CWrapDP8Peer(hLog);
		if (pDP8Peer == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8Peer->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8LobbiedApplication object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = CreateDP8LobbiedAppObject(&pDP8LobbiedApp);
		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't create DirectPlay8LobbiedApplication object!", 0);
			THROW_SYSTEMRESULT;
		} // end if (create failed)






		// We're going to only do minimal testing on this API.  I will leave it up
		// to lobby tests to cover this appropriately.


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Registering lobby with 0 flags using C++ macro");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = IDirectPlay8Peer_RegisterLobby(pDP8Peer->m_pDP8Peer, NULL, NULL, 0);
		if (tr != DPNERR_INVALIDFLAGS)
		{
			DPTEST_FAIL(hLog, "Registering lobby with 0 flags using C++ macro didn't return expected error INVALIDFLAGS!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't register lobby)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Registering lobby with 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_RegisterLobby(NULL, NULL, 0);
		if (tr != DPNERR_INVALIDFLAGS)
		{
			DPTEST_FAIL(hLog, "Registering lobby with 0 flags didn't return expected error INVALIDFLAGS!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't register lobby)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Registering lobby with invalid flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_RegisterLobby(NULL, pDP8LobbiedApp, 0x666);
		if (tr != DPNERR_INVALIDFLAGS)
		{
			DPTEST_FAIL(hLog, "Registering lobby with invalid flags didn't return expected error INVALIDFLAGS!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't register lobby)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Registering lobby with both REGISTER & UNREGISTER");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_RegisterLobby(NULL, pDP8LobbiedApp,
										DPNLOBBY_REGISTER | DPNLOBBY_UNREGISTER);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Registering lobby with both REGISTER & UNREGISTER didn't return expected error INVALIDFLAGS!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't register lobby)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Registering lobby with NULL handle");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_RegisterLobby(NULL, pDP8LobbiedApp, DPNLOBBY_REGISTER);
		if (tr != DPNERR_INVALIDHANDLE)
		{
			DPTEST_FAIL(hLog, "Registering lobby with NULL handle didn't return expected error INVALIDHANDLE!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't register lobby)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Unregistering lobby with non-NULL handle");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_RegisterLobby((DPNHANDLE) 0x666, NULL, DPNLOBBY_UNREGISTER);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Unregistering lobby with non-NULL handle didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't register lobby)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Registering lobby with NULL interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_RegisterLobby((DPNHANDLE) 0x666, NULL, DPNLOBBY_REGISTER);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Registering lobby with NULL interface didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't register lobby)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Unregistering lobby with non-NULL interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_RegisterLobby(NULL, pDP8LobbiedApp, DPNLOBBY_UNREGISTER);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Unregistering lobby with non-NULL interface didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't register lobby)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Registering lobby before initialization");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Use 0x666 to get around handle == NULL check
		tr = pDP8Peer->DP8P_RegisterLobby((DPNHANDLE) 0x666, pDP8LobbiedApp,
											DPNLOBBY_REGISTER);
		if (tr != DPNERR_UNINITIALIZED)
		{
			DPTEST_FAIL(hLog, "Registering lobby before initialization didn't return expected error UNINITIALIZED!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't register lobby)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Unregistering lobby before initialization");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Use 0x666 to get around handle == NULL check
		tr = pDP8Peer->DP8P_RegisterLobby(NULL, NULL, DPNLOBBY_UNREGISTER);
		if (tr != DPNERR_UNINITIALIZED)
		{
			DPTEST_FAIL(hLog, "Unregistering lobby before initialization didn't return expected error UNINITIALIZED!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't register lobby)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Initializing peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Initialize(NULL, ParmVNoMessagesDPNMessageHandler, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Initializing peer object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Unregistering lobby before registering");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_RegisterLobby(NULL, NULL, DPNLOBBY_UNREGISTER);
		if (tr != DPNERR_NOTREGISTERED)
		{
			DPTEST_FAIL(hLog, "Unregistering lobby before registering didn't fail with expected error NOTREGISTERED!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't register lobby)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Registering lobby");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_RegisterLobby((DPNHANDLE) 0x666, pDP8LobbiedApp,
											DPNLOBBY_REGISTER);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Registering lobby failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't register lobby)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Registering lobby again");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_RegisterLobby((DPNHANDLE) 0x666, pDP8LobbiedApp,
										DPNLOBBY_REGISTER);
		if (tr != DPNERR_ALREADYREGISTERED)
		{
			DPTEST_FAIL(hLog, "Registering lobby again didn't fail with expected error ALREADYREGISTERED!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't register lobby)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Unregistering lobby");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_RegisterLobby(NULL, NULL, DPNLOBBY_UNREGISTER);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Unregistering lobby failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't register lobby)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Unregistering lobby again");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_RegisterLobby(NULL, NULL, DPNLOBBY_UNREGISTER);
		if (tr != DPNERR_NOTREGISTERED)
		{
			DPTEST_FAIL(hLog, "Unregistering lobby again didn't fail with expected error NOTREGISTERED!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't register lobby)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing peer object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Peer);
		pDP8Peer = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE


	if (pDP8Peer != NULL)
	{
		delete (pDP8Peer);
		pDP8Peer = NULL;
	} // end if (have peer object)

	SAFE_RELEASE(pDP8LobbiedApp);


	return (sr);
} // ParmVPeerExec_RegLobby
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
*/




#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVPeerExec_Terminate()"
//==================================================================================
// ParmVPeerExec_Terminate
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.1.35 - Peer TerminateSession parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVPeerExec_Terminate(HANDLE hLog)
{
	CTNSystemResult			sr;
	CTNTestResult			tr;
	PWRAPDP8PEER			pDP8Peer = NULL;
	PWRAPDP8PEER			pDP8PeerHost = NULL;
	PDIRECTPLAY8ADDRESS		pDP8Address = NULL;
	DPN_APPLICATION_DESC	dpnad;
	DPN_APPLICATION_DESC	dpnadCompare;
	PARMVPTERMINATECONTEXT	hostcontext;
	PARMVPTERMINATECONTEXT	nonhostcontext;
	DP_DOWORKLIST			DoWorkList;
	DPNHANDLE				hAsyncOp;
	HANDLE					hAsyncOpComplete = NULL;

	ZeroMemory(&DoWorkList, sizeof(DP_DOWORKLIST));
	ZeroMemory(&hostcontext, sizeof (PARMVPTERMINATECONTEXT));
	ZeroMemory(&nonhostcontext, sizeof (PARMVPTERMINATECONTEXT));


	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Peer = new CWrapDP8Peer(hLog);
		if (pDP8Peer == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8Peer->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (LPVOID *) &pDP8Address, NULL);
		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't create DirectPlay8Address object!", 0);
			THROW_SYSTEMRESULT;
		} // end if (create failed)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting address object's SP to TCP/IP");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->SetSP(&CLSID_DP8SP_TCPIP);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting address object's SP to TCP/IP failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set SP)





/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Terminating session before initialization using C++ macro");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = IDirectPlay8Peer_TerminateSession(pDP8Peer->m_pDP8Peer, NULL, 0, 0);
		if (tr != DPNERR_UNINITIALIZED)
		{
			DPTEST_FAIL(hLog, "Terminating session before initialization using C++ macro didn't return expected error UNINITIALIZED!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't terminate session)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Terminating session before initialization");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_TerminateSession(NULL, 0, 0);
		if (tr != DPNERR_UNINITIALIZED)
		{
			DPTEST_FAIL(hLog, "Terminating session before initialization didn't return expected error UNINITIALIZED!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't terminate session)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Terminating session with NULL buffer but non-zero size");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_TerminateSession(NULL, 666, 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Destroying peer with NULL buffer but non-zero size return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't terminate session)
*/




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Terminating session with invalid flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_TerminateSession(NULL, 0, 0x666);
		if (tr != DPNERR_INVALIDFLAGS)
		{
			DPTEST_FAIL(hLog, "Terminating session with invalid flags didn't return expected error INVALIDFLAGS!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't terminate session)
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Initializing peer object with host context");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		hostcontext.hLog = hLog;

		tr = pDP8Peer->DP8P_Initialize(&hostcontext, ParmVPTerminateDPNMessageHandler, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Initializing peer object with host context failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Terminating session without a connection");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_TerminateSession(NULL, 0, 0);
		if (tr != DPNERR_NOCONNECTION)
		{
			DPTEST_FAIL(hLog, "Terminating session without a connection didn't return expected error NOCONNECTION!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't terminate session)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Hosting session");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Expect a create player message for self.
		hostcontext.afExpectCreatePlayer[0] = TRUE;

		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		//dpnad.dwFlags = 0;
		//dpnad.guidInstance = GUID_NULL;
		dpnad.guidApplication = GUID_PARMV_PEER_GETAPPDESC;
		//dpnad.dwMaxPlayers = 0;
		//dpnad.dwCurrentPlayers = 0;
		//dpnad.pwszSessionName = NULL;
		//dpnad.pwszPassword = NULL;
		//dpnad.pvReservedData = NULL;
		//dpnad.dwReservedDataSize = 0;
		//dpnad.pvApplicationReservedData = NULL;
		//dpnad.dwApplicationReservedDataSize = 0;

		// Save what we're passing in to make sure it's not touched.
		CopyMemory(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC));

		tr = pDP8Peer->DP8P_Host(&dpnad,
								&pDP8Address,
								1,
								NULL,
								NULL,
								&(hostcontext.adpnidPlayers[0]),
								0);

		// Prevent any weird create player indications.
		hostcontext.afExpectCreatePlayer[0] = FALSE;

		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't start hosting session!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't host)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		// Make sure the create player indication came in.
		if (hostcontext.adpnidPlayers[0] == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get create player indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player indication)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Terminating session");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Expect a destroy player message for self.
		CREATEEVENT_OR_THROW(hostcontext.hLastPlayerMsgEvent,
							NULL, FALSE, FALSE, NULL);
		hostcontext.dwNumDestroyPlayersRemaining = 1;
		hostcontext.afExpectDestroyPlayer[0] = TRUE;
		hostcontext.fExpectTerminateSession = TRUE;

		tr = pDP8Peer->DP8P_TerminateSession(NULL, 0, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Terminating session failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for destroy player message");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 1;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hostcontext.hLastPlayerMsgEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird destroy player or terminate session messages.
		hostcontext.afExpectDestroyPlayer[0] = FALSE;
		hostcontext.fExpectTerminateSession = FALSE;

#ifdef DEBUG
		// Make sure the player was destroyed (how else would we get here?).
		if (hostcontext.adpnidPlayers[0] != 0)
		{
			DPTEST_FAIL(hLog, "Destroy player for self didn't arrive!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (destroy player didn't arrive)
#endif // DEBUG

		// Make sure the terminate session indication came in.
		if (! hostcontext.fGotTerminateSession)
		{
			DPTEST_FAIL(hLog, "Didn't get terminate session indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get terminate session indication)

		// Reset the context.
		CloseHandle(hostcontext.hLastPlayerMsgEvent);
		hostcontext.hLastPlayerMsgEvent = NULL;
		hostcontext.fGotTerminateSession = FALSE;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing peer object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Re-initializing peer object with nonhost context");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		nonhostcontext.hLog = hLog;

		tr = pDP8Peer->DP8P_Initialize(&nonhostcontext,
										ParmVPTerminateDPNMessageHandler, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Re-initializing peer object with context, 0 flags failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating new peer host object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Address->Release();
		pDP8Address = NULL;

		// Expect a create player message for self.
		hostcontext.afExpectCreatePlayer[0] = TRUE;

		hostcontext.hLog = hLog;

		tr = ParmVCreatePeerHost(hLog, ParmVPTerminateDPNMessageHandler,
								&hostcontext,
								&dpnad,
								&(hostcontext.adpnidPlayers[0]),
								&pDP8PeerHost,
								&pDP8Address);

		// Prevent any weird create player indications.
		hostcontext.afExpectCreatePlayer[0] = FALSE;

		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Creating peer host failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't create peer host)

		// Make sure the create player indication came in.
		if (hostcontext.adpnidPlayers[0] == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get create player indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player indication)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Connecting peer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

// XBOX - Had to make connection asynchronous

		SAFE_CLOSEHANDLE(hAsyncOpComplete);
		CREATEEVENT_OR_THROW(hAsyncOpComplete, NULL, FALSE, FALSE, NULL);

		// Expect a create player message for client on host.
		CREATEEVENT_OR_THROW(hostcontext.hLastPlayerMsgEvent,
							NULL, FALSE, FALSE, NULL);
		hostcontext.afExpectCreatePlayer[1] = TRUE;

		// Expect a create player message for self and host on client.
		nonhostcontext.afExpectCreatePlayer[0] = TRUE;
		nonhostcontext.afExpectCreatePlayer[1] = TRUE;

		// Even though it's synchronous, we'll still get a completion.  The async op
		// handle will be NULL, though.
		nonhostcontext.fConnectCanComplete = TRUE;

		tr = pDP8Peer->DP8P_Connect(&dpnad,
									pDP8Address,
									NULL,
									NULL,
									NULL,
									NULL,
									0,
									&(nonhostcontext.adpnidPlayers[0]),
									hAsyncOpComplete,
									&hAsyncOp,
									0);

		if((tr != DPNSUCCESS_PENDING) && (tr != DPN_OK))
		{
			DPTEST_FAIL(hLog, "Couldn't connect! (error 0x%08x)", 1, tr);
			THROW_TESTRESULT;
		} // end if (couldn't connect)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for connect to complete on non-host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hAsyncOpComplete))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		// Prevent any weird connects from completing or stray create players.
		nonhostcontext.fConnectCanComplete = FALSE;
		nonhostcontext.afExpectCreatePlayer[0] = FALSE;
		nonhostcontext.afExpectCreatePlayer[1] = FALSE;

		ClearDoWorkList(&DoWorkList);

		// Make sure we saw the connect completion indication.
		if (! nonhostcontext.fConnectCompleted)
		{
			DPTEST_FAIL(hLog, "Didn't get connect complete indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (connect didn't complete)

		// Reset the context.
		nonhostcontext.fConnectCompleted = FALSE;

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for create player message on host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hostcontext.hLastPlayerMsgEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird create player messages.
		hostcontext.afExpectCreatePlayer[1] = FALSE;

#ifdef DEBUG
		// Make sure the player was created (how else would we get here?).
		if (hostcontext.adpnidPlayers[1] == 0)
		{
			DPTEST_FAIL(hLog, "Create player didn't arrive!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (create player didn't arrive)
#endif // DEBUG

		// Reset the context.
		CloseHandle(hostcontext.hLastPlayerMsgEvent);
		hostcontext.hLastPlayerMsgEvent = NULL;



		// Make sure the IDs match.
		if (hostcontext.adpnidPlayers[0] != nonhostcontext.adpnidPlayers[1])
		{
			DPTEST_FAIL(hLog, "Host and client disagree on host's player ID (%u/%x != %u/%x)!",
				4, hostcontext.adpnidPlayers[0], hostcontext.adpnidPlayers[0],
				nonhostcontext.adpnidPlayers[1], nonhostcontext.adpnidPlayers[1]);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (host ID doesn't match)

		if (hostcontext.adpnidPlayers[1] != nonhostcontext.adpnidPlayers[0])
		{
			DPTEST_FAIL(hLog, "Host and client disagree on client's player ID (%u/%x != %u/%x)!",
				4, hostcontext.adpnidPlayers[1], hostcontext.adpnidPlayers[1],
				nonhostcontext.adpnidPlayers[0], nonhostcontext.adpnidPlayers[0]);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (client ID doesn't match)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Terminating session on client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_TerminateSession(NULL, 0, 0);
		if (tr != DPNERR_NOTHOST)
		{
			DPTEST_FAIL(hLog, "Terminating session on client didn't return expected error NOTHOST!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't terminate session)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Terminating session on host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Expect the 2 destroy player messages and terminate session on the host.
		CREATEEVENT_OR_THROW(hostcontext.hLastPlayerMsgEvent, NULL, FALSE, FALSE, NULL);
		hostcontext.dwNumDestroyPlayersRemaining = 2;
		hostcontext.afExpectDestroyPlayer[0] = TRUE;
		hostcontext.afExpectDestroyPlayer[1] = TRUE;
		hostcontext.fExpectTerminateSession = TRUE;

		// Expect the 2 destroy player messages and terminate session on the client.
		CREATEEVENT_OR_THROW(nonhostcontext.hLastPlayerMsgEvent, NULL, FALSE, FALSE, NULL);
		nonhostcontext.dwNumDestroyPlayersRemaining = 2;
		nonhostcontext.afExpectDestroyPlayer[0] = TRUE;
		nonhostcontext.afExpectDestroyPlayer[1] = TRUE;
		nonhostcontext.fExpectTerminateSession = TRUE;

		DPTEST_TRACE(hLog, "Host context is 0x%08x", 1, &hostcontext);
		DPTEST_TRACE(hLog, "Non-host context is 0x%08x", 1, &nonhostcontext);

		tr = pDP8PeerHost->DP8P_TerminateSession(NULL, 0, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Terminating session on host failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't terminate session)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for destroy player messages on host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hostcontext.hLastPlayerMsgEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird destroy player or terminate session messages.
		hostcontext.afExpectDestroyPlayer[0] = FALSE;
		hostcontext.afExpectDestroyPlayer[1] = FALSE;
		hostcontext.fExpectTerminateSession = FALSE;

#ifdef DEBUG
		// Make sure the players were destroyed (how else would we get here?).
		if (hostcontext.adpnidPlayers[0] != 0)
		{
			DPTEST_FAIL(hLog, "Destroy player for self didn't arrive!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (destroy player didn't arrive)

		if (hostcontext.adpnidPlayers[1] != 0)
		{
			DPTEST_FAIL(hLog, "Destroy player for host didn't arrive!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (destroy player didn't arrive)
#endif // DEBUG

		// Make sure the terminate session indication came in.
		if (! hostcontext.fGotTerminateSession)
		{
			DPTEST_FAIL(hLog, "Didn't get terminate session indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get terminate session indication)

		// Reset the context.
		CloseHandle(hostcontext.hLastPlayerMsgEvent);
		hostcontext.hLastPlayerMsgEvent = NULL;
		hostcontext.fGotTerminateSession = FALSE;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for destroy player messages on client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, nonhostcontext.hLastPlayerMsgEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird destroy player or terminate session messages.
		nonhostcontext.afExpectDestroyPlayer[0] = FALSE;
		nonhostcontext.afExpectDestroyPlayer[1] = FALSE;
		nonhostcontext.fExpectTerminateSession = FALSE;

#ifdef DEBUG
		// Make sure the players were destroyed (how else would we get here?).
		if (nonhostcontext.adpnidPlayers[0] != 0)
		{
			DPTEST_FAIL(hLog, "Destroy player for self didn't arrive!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (destroy player didn't arrive)

		if (nonhostcontext.adpnidPlayers[1] != 0)
		{
			DPTEST_FAIL(hLog, "Destroy player for host didn't arrive!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (destroy player didn't arrive)
#endif // DEBUG

		// Make sure the terminate session indication came in.
		if (! nonhostcontext.fGotTerminateSession)
		{
			DPTEST_FAIL(hLog, "Didn't get terminate session indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get terminate session indication)

		// Reset the context.
		CloseHandle(nonhostcontext.hLastPlayerMsgEvent);
		nonhostcontext.hLastPlayerMsgEvent = NULL;
		hostcontext.fGotTerminateSession = FALSE;





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing peer client object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing peer client object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)






		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing host object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8PeerHost->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing host object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing hosting DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8PeerHost->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release hosting DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8PeerHost);
		pDP8PeerHost = NULL;






		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Peer);
		pDP8Peer = NULL;




		FINAL_SUCCESS;
	}
	END_TESTCASE


	if (pDP8Peer != NULL)
	{
		delete (pDP8Peer);
		pDP8Peer = NULL;
	} // end if (have peer object)

	if (pDP8PeerHost != NULL)
	{
		delete (pDP8PeerHost);
		pDP8PeerHost = NULL;
	} // end if (have peer object)

	SAFE_RELEASE(pDP8Address);
	SAFE_CLOSEHANDLE(hostcontext.hLastPlayerMsgEvent);
	SAFE_CLOSEHANDLE(nonhostcontext.hLastPlayerMsgEvent);
	ClearDoWorkList(&DoWorkList);
	SAFE_CLOSEHANDLE(hAsyncOpComplete);

	return (sr);
} // ParmVPeerExec_Terminate
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVPCancelDPNMessageHandler()"
//==================================================================================
// ParmVPCancelDPNMessageHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT ParmVPCancelDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT					hr = DPN_OK;
	PPARMVPCANCELCONTEXT	pContext = (PPARMVPCANCELCONTEXT) pvContext;


	switch (dwMsgType)
	{
		case DPN_MSGID_CONNECT_COMPLETE:
			PDPNMSG_CONNECT_COMPLETE	pConnectCompleteMsg;


			pConnectCompleteMsg = (PDPNMSG_CONNECT_COMPLETE) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CONNECT_COMPLETE", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pConnectCompleteMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    hAsyncOp = %x", 1, pConnectCompleteMsg->hAsyncOp);
			DPTEST_TRACE(pContext->hLog, "    pvUserContext = %x", 1, pConnectCompleteMsg->pvUserContext);
			DPTEST_TRACE(pContext->hLog, "    hResultCode = 0x%08x", 1, pConnectCompleteMsg->hResultCode);
			DPTEST_TRACE(pContext->hLog, "    pvApplicationReplyData = %x", 1, pConnectCompleteMsg->pvApplicationReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwApplicationReplyDataSize = %u", 1, pConnectCompleteMsg->dwApplicationReplyDataSize);


			// Make sure we expect the completion
			if (! pContext->fConnectCanComplete)
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_CONNECT_COMPLETE (%x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				break;
			} // end if (message unexpected)


			// Validate the completion
			if (pConnectCompleteMsg->dwSize != sizeof (DPNMSG_CONNECT_COMPLETE))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CONNECT_COMPLETE is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->dwSize, sizeof (DPNMSG_CONNECT_COMPLETE));
				DEBUGBREAK();
				break;
			} // end if (message unexpected)

			if (pConnectCompleteMsg->hAsyncOp != pContext->dpnhExpectedAsyncOp)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with wrong async op handle (%x != %x)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->hAsyncOp, pContext->dpnhExpectedAsyncOp);
				DEBUGBREAK();
				break;
			} // end if (message unexpected)

			if (pConnectCompleteMsg->pvUserContext != pContext->hConnectCompleteEvent)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with wrong context (%x != %x)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->pvUserContext,
					pContext->hConnectCompleteEvent);
				DEBUGBREAK();
				break;
			} // end if (message unexpected)

			if (pConnectCompleteMsg->hResultCode != pContext->hrExpectedResult)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with wrong error code (%x != %x)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->hResultCode, pContext->hrExpectedResult);
				DEBUGBREAK();
				break;
			} // end if (unexpected result code)

			if ((pConnectCompleteMsg->pvApplicationReplyData != NULL) ||
				(pConnectCompleteMsg->dwApplicationReplyDataSize != 0))
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with unexpected reply data (ptr %x != NULL or size %u != 0)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->pvApplicationReplyData,
					pConnectCompleteMsg->dwApplicationReplyDataSize);
				DEBUGBREAK();
				break;
			} // end if (message unexpected)


			// Make sure this isn't a double completion.
			if (pContext->fCompleted)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed twice (msg = %x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				break;
			} // end if (double completion)

			// Alert the test case that the completion came in.
			pContext->fCompleted = TRUE;

			if (! SetEvent(pContext->hConnectCompleteEvent))
			{
				hr = GetLastError();
				DPTEST_TRACE(pContext->hLog, "Couldn't set connect completion event (%x)!  DEBUGBREAK()-ing.",
					1, pContext->hConnectCompleteEvent);

				DEBUGBREAK();

				if (hr == S_OK)
					hr = E_FAIL;

				break;
			} // end if (couldn't set event)
		  break;

		default:
			DPTEST_TRACE(pContext->hLog, "Got unexpected message type %x!  DEBUGBREAK()-ing.",
				1, dwMsgType);
			DEBUGBREAK();
			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)

	return (hr);
} // ParmVPCancelDPNMessageHandler
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVPConnectDPNMessageHandler()"
//==================================================================================
// ParmVPConnectDPNMessageHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT ParmVPConnectDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT					hr = DPN_OK;
	PPARMVPCONNECTCONTEXT	pContext = (PPARMVPCONNECTCONTEXT) pvContext;
	BOOL					fSetEvent = FALSE;


	switch (dwMsgType)
	{
		case DPN_MSGID_CONNECT_COMPLETE:
			PDPNMSG_CONNECT_COMPLETE	pConnectCompleteMsg;


			pConnectCompleteMsg = (PDPNMSG_CONNECT_COMPLETE) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CONNECT_COMPLETE", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pConnectCompleteMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    hAsyncOp = %x", 1, pConnectCompleteMsg->hAsyncOp);
			DPTEST_TRACE(pContext->hLog, "    pvUserContext = %x", 1, pConnectCompleteMsg->pvUserContext);
			DPTEST_TRACE(pContext->hLog, "    hResultCode = 0x%08x", 1, pConnectCompleteMsg->hResultCode);
			DPTEST_TRACE(pContext->hLog, "    pvApplicationReplyData = %x", 1, pConnectCompleteMsg->pvApplicationReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwApplicationReplyDataSize = %u", 1, pConnectCompleteMsg->dwApplicationReplyDataSize);


			// Make sure we expect the completion.
			if (! pContext->fConnectCanComplete)
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_CONNECT_COMPLETE (%x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (message unexpected)


			// Validate the completion.
			if (pConnectCompleteMsg->dwSize != sizeof (DPNMSG_CONNECT_COMPLETE))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CONNECT_COMPLETE is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->dwSize, sizeof (DPNMSG_CONNECT_COMPLETE));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pConnectCompleteMsg->pvUserContext != NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with wrong context (%x != NULL)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg->pvUserContext);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (wrong context)

			if (pConnectCompleteMsg->hResultCode != pContext->hrExpectedResult)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with wrong error code (%x != %x)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->hResultCode, pContext->hrExpectedResult);
				DEBUGBREAK();
				hr = pConnectCompleteMsg->hResultCode;
				goto DONE;
			} // end if (wrong result code)

			if ((pConnectCompleteMsg->pvApplicationReplyData != NULL) ||
				(pConnectCompleteMsg->dwApplicationReplyDataSize != 0))
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with unexpected reply data (ptr %x != NULL or size %u != 0)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->pvApplicationReplyData,
					pConnectCompleteMsg->dwApplicationReplyDataSize);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (unexpected reply data)


			// Make sure this isn't a double completion.
			if (pContext->fCompleted)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed twice (msg = %x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (double completion)

			// Alert the test case that the completion came in.
			pContext->fCompleted = TRUE;

			// Remember the async op handle for comparison by the main thread.
			pContext->dpnhCompletedAsyncOp = pConnectCompleteMsg->hAsyncOp;

			if (pContext->hConnectCompleteEvent != NULL)
			{
				if (! SetEvent(pContext->hConnectCompleteEvent))
				{
					hr = GetLastError();
					DPTEST_TRACE(pContext->hLog, "Couldn't set connect completion event (%x)!  DEBUGBREAK()-ing.",
						1, pContext->hConnectCompleteEvent);

					DEBUGBREAK();

					if (hr == S_OK)
						hr = E_FAIL;

					goto DONE;
				} // end if (couldn't set event)
			} // end if (there's an event to set)
		  break;

		case DPN_MSGID_CREATE_PLAYER:
			PDPNMSG_CREATE_PLAYER	pCreatePlayerMsg;


			pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CREATE_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pCreatePlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pCreatePlayerMsg->dpnidPlayer, pCreatePlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pCreatePlayerMsg->pvPlayerContext);


			// Validate the indication.
			if (pCreatePlayerMsg->dwSize != sizeof (DPNMSG_CREATE_PLAYER))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CREATE_PLAYER is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pCreatePlayerMsg->dwSize, sizeof (DPNMSG_CREATE_PLAYER));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pCreatePlayerMsg->pvPlayerContext == NULL)
			{
				// Assume this is the remote player being created.  Store the
				// player context.
				if (pContext->fHost)
				{
					pCreatePlayerMsg->pvPlayerContext = &(pContext->dpnidClient);
					fSetEvent = TRUE;
				} // end if (host)
				else
				{
					pCreatePlayerMsg->pvPlayerContext = &(pContext->dpnidHost);
				} // end if (not host)
			} // end if (context is not set yet)


			// Make sure this isn't a duplicate message.
			if (*((DPNID*) pCreatePlayerMsg->pvPlayerContext) != 0)
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate CREATE_PLAYER (msg = %x)!  DEBUGBREAK()-ing.",
					1, pCreatePlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (already have ID)

			// Save the player ID.
			*((DPNID*) pCreatePlayerMsg->pvPlayerContext) = pCreatePlayerMsg->dpnidPlayer;


			// Now set the event, if we're supposed too.
			if (fSetEvent)
			{
				if (! SetEvent(pContext->hClientCreatedEvent))
				{
					hr = GetLastError();
					DPTEST_TRACE(pContext->hLog, "Couldn't set client created event (%x)!  DEBUGBREAK()-ing.",
						1, pContext->hClientCreatedEvent);

					DEBUGBREAK();

					if (hr == S_OK)
						hr = E_FAIL;

					goto DONE;
				} // end if (couldn't set event)
			} // end if (should set event)
		  break;

		case DPN_MSGID_DESTROY_PLAYER:
			PDPNMSG_DESTROY_PLAYER	pDestroyPlayerMsg;


			pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_DESTROY_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pDestroyPlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pDestroyPlayerMsg->dpnidPlayer, pDestroyPlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pDestroyPlayerMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    dwReason = %x", 1, pDestroyPlayerMsg->dwReason);


			// Validate the indication.
			if (pDestroyPlayerMsg->dwSize != sizeof (DPNMSG_DESTROY_PLAYER))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_DESTROY_PLAYER is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pDestroyPlayerMsg->dwSize, sizeof (DPNMSG_DESTROY_PLAYER));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pDestroyPlayerMsg->pvPlayerContext == NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Player context is NULL!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (context is wrong)

			if (pDestroyPlayerMsg->dwReason != DPNDESTROYPLAYERREASON_NORMAL)
			{
				DPTEST_TRACE(pContext->hLog, "Player destruction reason is unexpected (%x != %x)!  DEBUGBREAK()-ing.",
					2, pDestroyPlayerMsg->dwReason, DPNDESTROYPLAYERREASON_NORMAL);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (reason is wrong)


			// Make sure this isn't a duplicate or bogus message.
			if ((*((DPNID*) pDestroyPlayerMsg->pvPlayerContext) == 0) ||
				(pDestroyPlayerMsg->dpnidPlayer != *((DPNID*) pDestroyPlayerMsg->pvPlayerContext)))
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate or unexpected DESTROY_PLAYER (msg = %x)!  DEBUGBREAK()-ing.",
					1, pDestroyPlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (already have ID)

			// Clear the player ID.
			*((DPNID*) pDestroyPlayerMsg->pvPlayerContext) = 0;
		  break;

		case DPN_MSGID_INDICATE_CONNECT:
			PDPNMSG_INDICATE_CONNECT	pIndicateConnectMsg;


			pIndicateConnectMsg = (PDPNMSG_INDICATE_CONNECT) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_INDICATE_CONNECT", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pIndicateConnectMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    pvUserConnectData = %x", 1, pIndicateConnectMsg->pvUserConnectData);
			DPTEST_TRACE(pContext->hLog, "    dwUserConnectDataSize = %u", 1, pIndicateConnectMsg->dwUserConnectDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyData = %x", 1, pIndicateConnectMsg->pvReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwReplyDataSize = %u", 1, pIndicateConnectMsg->dwReplyDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyContext = %x", 1, pIndicateConnectMsg->pvReplyContext);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pIndicateConnectMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    pAddressPlayer = 0x%08x", 1, pIndicateConnectMsg->pAddressPlayer);
			DPTEST_TRACE(pContext->hLog, "    pAddressDevice = 0x%08x", 1, pIndicateConnectMsg->pAddressDevice);

#pragma TODO(vanceo, "Validate DPN_MSGID_INDICATE_CONNECT")
		  break;

		default:
			DPTEST_TRACE(pContext->hLog, "Got unexpected message type %x!  DEBUGBREAK()-ing.",
				1, dwMsgType);
			DEBUGBREAK();
			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)


DONE:

	return (hr);
} // ParmVPConnectDPNMessageHandler
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVPSendToDPNMessageHandler()"
//==================================================================================
// ParmVPSendToDPNMessageHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT ParmVPSendToDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT					hr = DPN_OK;
	PPARMVPSENDTOCONTEXT	pContext = (PPARMVPSENDTOCONTEXT) pvContext;


	switch (dwMsgType)
	{
		case DPN_MSGID_CREATE_PLAYER:
			PDPNMSG_CREATE_PLAYER	pCreatePlayerMsg;


			pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CREATE_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pCreatePlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pCreatePlayerMsg->dpnidPlayer, pCreatePlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pCreatePlayerMsg->pvPlayerContext);


			// Validate the indication.
			if (pCreatePlayerMsg->dwSize != sizeof (DPNMSG_CREATE_PLAYER))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CREATE_PLAYER is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pCreatePlayerMsg->dwSize, sizeof (DPNMSG_CREATE_PLAYER));
				DEBUGBREAK();
				break;
			} // end if (size incorrect)

			if (pCreatePlayerMsg->pvPlayerContext == NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Player context is NULL!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				break;
			} // end if (context is wrong)


			// Make sure this isn't a duplicate message.
			if (*((DPNID*) pCreatePlayerMsg->pvPlayerContext) != 0)
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate CREATE_PLAYER (msg = %x)!  DEBUGBREAK()-ing.",
					1, pCreatePlayerMsg);
				DEBUGBREAK();
				break;
			} // end if (already have ID)

			// Save the player ID.
			*((DPNID*) pCreatePlayerMsg->pvPlayerContext) = pCreatePlayerMsg->dpnidPlayer;
		  break;

		case DPN_MSGID_DESTROY_PLAYER:
			PDPNMSG_DESTROY_PLAYER	pDestroyPlayerMsg;


			pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_DESTROY_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pDestroyPlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pDestroyPlayerMsg->dpnidPlayer, pDestroyPlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pDestroyPlayerMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    dwReason = %x", 1, pDestroyPlayerMsg->dwReason);


			// Validate the indication.
			if (pDestroyPlayerMsg->dwSize != sizeof (DPNMSG_DESTROY_PLAYER))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_DESTROY_PLAYER is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pDestroyPlayerMsg->dwSize, sizeof (DPNMSG_DESTROY_PLAYER));
				DEBUGBREAK();
				break;
			} // end if (size incorrect)

			if (pDestroyPlayerMsg->pvPlayerContext == NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Player context is NULL!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				break;
			} // end if (context is wrong)

			if (pDestroyPlayerMsg->dwReason != DPNDESTROYPLAYERREASON_NORMAL)
			{
				DPTEST_TRACE(pContext->hLog, "Player destruction reason is unexpected (%x != %x)!  DEBUGBREAK()-ing.",
					2, pDestroyPlayerMsg->dwReason, DPNDESTROYPLAYERREASON_NORMAL);
				DEBUGBREAK();
				break;
			} // end if (reason is wrong)


			// Make sure this isn't a duplicate or bogus message.
			if ((*((DPNID*) pDestroyPlayerMsg->pvPlayerContext) == 0) ||
				(pDestroyPlayerMsg->dpnidPlayer != *((DPNID*) pDestroyPlayerMsg->pvPlayerContext)))
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate or unexpected DESTROY_PLAYER (msg = %x)!  DEBUGBREAK()-ing.",
					1, pDestroyPlayerMsg);
				DEBUGBREAK();
				break;
			} // end if (already have ID)

			// Clear the player ID.
			*((DPNID*) pDestroyPlayerMsg->pvPlayerContext) = 0;
		  break;

		case DPN_MSGID_RECEIVE:
			PDPNMSG_RECEIVE		pReceiveMsg;


			pReceiveMsg = (PDPNMSG_RECEIVE) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_RECEIVE", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pReceiveMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidSender = %u/%x", 2, pReceiveMsg->dpnidSender, pReceiveMsg->dpnidSender);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pReceiveMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    pReceiveData = %x", 1, pReceiveMsg->pReceiveData);
			DPTEST_TRACE(pContext->hLog, "    dwReceiveDataSize = %u", 1, pReceiveMsg->dwReceiveDataSize);
			DPTEST_TRACE(pContext->hLog, "    hBufferHandle = %x", 1, pReceiveMsg->hBufferHandle);


			// Make sure we expect the receive.
			if (! pContext->fCanReceive)
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_RECEIVE (%x)!  DEBUGBREAK()-ing.",
					1, pReceiveMsg);
				DEBUGBREAK();
				break;
			} // end if (message unexpected)


			// Validate the receive.
			if (pReceiveMsg->dwSize != sizeof (DPNMSG_RECEIVE))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_RECEIVE is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pReceiveMsg->dwSize, sizeof (DPNMSG_RECEIVE));
				DEBUGBREAK();
				break;
			} // end if (size incorrect)

			if (pReceiveMsg->dpnidSender != pContext->dpnidPlayer)
			{
				DPTEST_TRACE(pContext->hLog, "Receive indicated with wrong sender ID (%x/%u != %x/%u)!  DEBUGBREAK()-ing.",
					4, pReceiveMsg->dpnidSender, pReceiveMsg->dpnidSender,
					pContext->dpnidPlayer, pContext->dpnidPlayer);
				DEBUGBREAK();
				break;
			} // end if (player context incorrect)

			if (pReceiveMsg->pvPlayerContext == NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Receive indicated with NULL player context!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				break;
			} // end if (player context incorrect)

			if (pReceiveMsg->pReceiveData == NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Receive indicated with NULL data pointer!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				break;
			} // end if (receive buffer invalid)

			if (pReceiveMsg->dwReceiveDataSize != pContext->dwExpectedReceiveSize)
			{
				DPTEST_TRACE(pContext->hLog, "Receive indicated with wrong size (%u != %u)!  DEBUGBREAK()-ing.",
					2, pReceiveMsg->dwReceiveDataSize, pContext->dwExpectedReceiveSize);
				DEBUGBREAK();
				break;
			} // end if (wrong buffer size)

#pragma TODO(vanceo, "Validate buffer")


			if (pReceiveMsg->hBufferHandle == NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Receive indicated with NULL buffer handle!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				break;
			} // end if (buffer handle invalid)



			// Make sure this isn't a double receive.
			if (pContext->fReceived)
			{
				DPTEST_TRACE(pContext->hLog, "Receive indicated twice (msg = %x)!  DEBUGBREAK()-ing.",
					1, pReceiveMsg);
				DEBUGBREAK();
				break;
			} // end if (double completion)

			// Alert the test case that the receive came in.
			pContext->fReceived = TRUE;

			if (! SetEvent(pContext->hReceiveEvent))
			{
				hr = GetLastError();
				DPTEST_TRACE(pContext->hLog, "Couldn't set receive event (%x)!  DEBUGBREAK()-ing.",
					1, pContext->hReceiveEvent);

				DEBUGBREAK();

				if (hr == S_OK)
					hr = E_FAIL;

				break;
			} // end if (couldn't set event)
		  break;

		case DPN_MSGID_SEND_COMPLETE:
			PDPNMSG_SEND_COMPLETE	pSendCompleteMsg;


			pSendCompleteMsg = (PDPNMSG_SEND_COMPLETE) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_SEND_COMPLETE", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pSendCompleteMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    hAsyncOp = %x", 1, pSendCompleteMsg->hAsyncOp);
			DPTEST_TRACE(pContext->hLog, "    pvUserContext = %x", 1, pSendCompleteMsg->pvUserContext);
			DPTEST_TRACE(pContext->hLog, "    hResultCode = 0x%08x", 1, pSendCompleteMsg->hResultCode);
			DPTEST_TRACE(pContext->hLog, "    dwSendTime = %u", 1, pSendCompleteMsg->dwSendTime);


			// Make sure we expect the completion.
			if (! pContext->fSendCanComplete)
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_SEND_COMPLETE (%x)!  DEBUGBREAK()-ing.",
					1, pSendCompleteMsg);
				DEBUGBREAK();
				break;
			} // end if (message unexpected)


			// Validate the completion.
			if (pSendCompleteMsg->dwSize != sizeof (DPNMSG_SEND_COMPLETE))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_SEND_COMPLETE is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pSendCompleteMsg->dwSize, sizeof (DPNMSG_SEND_COMPLETE));
				DEBUGBREAK();
				break;
			} // end if (size incorrect)

			if (pSendCompleteMsg->pvUserContext != NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Send completed with wrong context (%x != NULL)!  DEBUGBREAK()-ing.",
					1, pSendCompleteMsg->pvUserContext);
				DEBUGBREAK();
				break;
			} // end if (wrong context)

			if (pSendCompleteMsg->hResultCode != pContext->hrExpectedResult)
			{
				DPTEST_TRACE(pContext->hLog, "Send completed with wrong error code (%x != %x)!  DEBUGBREAK()-ing.",
					2, pSendCompleteMsg->hResultCode, pContext->hrExpectedResult);
				DEBUGBREAK();
				break;
			} // end if (wrong result code)



			// Make sure this isn't a double completion.
			if (pContext->fSendCompleted)
			{
				DPTEST_TRACE(pContext->hLog, "Send completed twice (msg = %x)!  DEBUGBREAK()-ing.",
					1, pSendCompleteMsg);
				DEBUGBREAK();
				break;
			} // end if (double completion)

			// Alert the test case that the completion came in.
			pContext->fSendCompleted = TRUE;

			// Remember the async op handle for comparison by the main thread.
			pContext->dpnhCompletedAsyncOp = pSendCompleteMsg->hAsyncOp;

			if (pContext->hSendCompleteEvent != NULL)
			{
				if (! SetEvent(pContext->hSendCompleteEvent))
				{
					hr = GetLastError();
					DPTEST_TRACE(pContext->hLog, "Couldn't set send completion event (%x)!  DEBUGBREAK()-ing.",
						1, pContext->hSendCompleteEvent);

					DEBUGBREAK();

					if (hr == S_OK)
						hr = E_FAIL;

					break;
				} // end if (couldn't set event)
			} // end if (there's an event to set)
		  break;

		default:
			DPTEST_TRACE(pContext->hLog, "Got unexpected message type %x!  DEBUGBREAK()-ing.",
				1, dwMsgType);
			DEBUGBREAK();
			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)

	return (hr);
} // ParmVPSendToDPNMessageHandler
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVPGetSendQInfoDPNMessageHandler()"
//==================================================================================
// ParmVPGetSendQInfoDPNMessageHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT ParmVPGetSendQInfoDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT						hr = DPN_OK;
	PPARMVPGETSENDQINFOCONTEXT	pContext = (PPARMVPGETSENDQINFOCONTEXT) pvContext;
	BOOL						fSetEvent = FALSE;


	switch (dwMsgType)
	{
		case DPN_MSGID_CONNECT_COMPLETE:
			PDPNMSG_CONNECT_COMPLETE	pConnectCompleteMsg;


			pConnectCompleteMsg = (PDPNMSG_CONNECT_COMPLETE) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CONNECT_COMPLETE", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pConnectCompleteMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    hAsyncOp = %x", 1, pConnectCompleteMsg->hAsyncOp);
			DPTEST_TRACE(pContext->hLog, "    pvUserContext = %x", 1, pConnectCompleteMsg->pvUserContext);
			DPTEST_TRACE(pContext->hLog, "    hResultCode = 0x%08x", 1, pConnectCompleteMsg->hResultCode);
			DPTEST_TRACE(pContext->hLog, "    pvApplicationReplyData = %x", 1, pConnectCompleteMsg->pvApplicationReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwApplicationReplyDataSize = %u", 1, pConnectCompleteMsg->dwApplicationReplyDataSize);


			// Make sure we expect the completion.
			if (! pContext->fConnectCanComplete)
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_CONNECT_COMPLETE (%x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (message unexpected)


			// Validate the completion.
			if (pConnectCompleteMsg->dwSize != sizeof (DPNMSG_CONNECT_COMPLETE))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CONNECT_COMPLETE is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->dwSize, sizeof (DPNMSG_CONNECT_COMPLETE));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pConnectCompleteMsg->hResultCode != DPN_OK)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with failure!  DEBUGBREAK()-ing.  0x%08x",
					1, pConnectCompleteMsg->hResultCode);
				DEBUGBREAK();
				hr = pConnectCompleteMsg->hResultCode;
				goto DONE;
			} // end if (wrong result code)

			if ((pConnectCompleteMsg->pvApplicationReplyData != NULL) ||
				(pConnectCompleteMsg->dwApplicationReplyDataSize != 0))
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with unexpected reply data (ptr %x != NULL or size %u != 0)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->pvApplicationReplyData,
					pConnectCompleteMsg->dwApplicationReplyDataSize);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (unexpected reply data)


			// Make sure this isn't a double completion.
			if (pContext->fConnectCompleted)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed twice (msg = %x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (double completion)

			// Alert the test case that the completion came in.
			pContext->fConnectCompleted = TRUE;

			// XBOX - Handle async connect
			if(pConnectCompleteMsg->pvUserContext)
			{
				SetEvent((HANDLE) pConnectCompleteMsg->pvUserContext);
			}

		  break;

		case DPN_MSGID_CREATE_PLAYER:
			PDPNMSG_CREATE_PLAYER	pCreatePlayerMsg;


			pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CREATE_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pCreatePlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pCreatePlayerMsg->dpnidPlayer, pCreatePlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pCreatePlayerMsg->pvPlayerContext);


			// Validate the indication.
			if (pCreatePlayerMsg->dwSize != sizeof (DPNMSG_CREATE_PLAYER))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CREATE_PLAYER is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pCreatePlayerMsg->dwSize, sizeof (DPNMSG_CREATE_PLAYER));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pCreatePlayerMsg->pvPlayerContext == NULL)
			{
				// Assume this is the remote player being created.  Store the
				// player context.
				if (pContext->fHost)
				{
					pCreatePlayerMsg->pvPlayerContext = &(pContext->dpnidClient);
					fSetEvent = TRUE;
				} // end if (host)
				else
				{
					pCreatePlayerMsg->pvPlayerContext = &(pContext->dpnidHost);
				} // end if (not host)
			} // end if (context is not set yet)


			// Make sure this isn't a duplicate message.
			if (*((DPNID*) pCreatePlayerMsg->pvPlayerContext) != 0)
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate CREATE_PLAYER (msg = %x)!  DEBUGBREAK()-ing.",
					1, pCreatePlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (already have ID)

			// Save the player ID.
			*((DPNID*) pCreatePlayerMsg->pvPlayerContext) = pCreatePlayerMsg->dpnidPlayer;


			// Now set the event, if we're supposed too.
			if (fSetEvent)
			{
				if (! SetEvent(pContext->hClientCreatedEvent))
				{
					hr = GetLastError();
					DPTEST_TRACE(pContext->hLog, "Couldn't set client created event (%x)!  DEBUGBREAK()-ing.",
						1, pContext->hClientCreatedEvent);

					DEBUGBREAK();

					if (hr == S_OK)
						hr = E_FAIL;

					goto DONE;
				} // end if (couldn't set event)
			} // end if (should set event)
		  break;

		case DPN_MSGID_DESTROY_PLAYER:
			PDPNMSG_DESTROY_PLAYER	pDestroyPlayerMsg;


			pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_DESTROY_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pDestroyPlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pDestroyPlayerMsg->dpnidPlayer, pDestroyPlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pDestroyPlayerMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    dwReason = %x", 1, pDestroyPlayerMsg->dwReason);


			// Validate the indication.
			if (pDestroyPlayerMsg->dwSize != sizeof (DPNMSG_DESTROY_PLAYER))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_DESTROY_PLAYER is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pDestroyPlayerMsg->dwSize, sizeof (DPNMSG_DESTROY_PLAYER));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pDestroyPlayerMsg->pvPlayerContext == NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Player context is NULL!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (context is wrong)

			if (pDestroyPlayerMsg->dwReason != DPNDESTROYPLAYERREASON_NORMAL)
			{
				DPTEST_TRACE(pContext->hLog, "Player destruction reason is unexpected (%x != %x)!  DEBUGBREAK()-ing.",
					2, pDestroyPlayerMsg->dwReason, DPNDESTROYPLAYERREASON_NORMAL);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (reason is wrong)


			// Make sure this isn't a duplicate or bogus message.
			if ((*((DPNID*) pDestroyPlayerMsg->pvPlayerContext) == 0) ||
				(pDestroyPlayerMsg->dpnidPlayer != *((DPNID*) pDestroyPlayerMsg->pvPlayerContext)))
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate or unexpected DESTROY_PLAYER (msg = %x)!  DEBUGBREAK()-ing.",
					1, pDestroyPlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (already have ID)

			// Clear the player ID.
			*((DPNID*) pDestroyPlayerMsg->pvPlayerContext) = 0;
		  break;

		case DPN_MSGID_INDICATE_CONNECT:
			PDPNMSG_INDICATE_CONNECT	pIndicateConnectMsg;


			pIndicateConnectMsg = (PDPNMSG_INDICATE_CONNECT) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_INDICATE_CONNECT", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pIndicateConnectMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    pvUserConnectData = %x", 1, pIndicateConnectMsg->pvUserConnectData);
			DPTEST_TRACE(pContext->hLog, "    dwUserConnectDataSize = %u", 1, pIndicateConnectMsg->dwUserConnectDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyData = %x", 1, pIndicateConnectMsg->pvReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwReplyDataSize = %u", 1, pIndicateConnectMsg->dwReplyDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyContext = %x", 1, pIndicateConnectMsg->pvReplyContext);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pIndicateConnectMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    pAddressPlayer = 0x%08x", 1, pIndicateConnectMsg->pAddressPlayer);
			DPTEST_TRACE(pContext->hLog, "    pAddressDevice = 0x%08x", 1, pIndicateConnectMsg->pAddressDevice);

#pragma TODO(vanceo, "Validate DPN_MSGID_INDICATE_CONNECT")
		  break;

		default:
			DPTEST_TRACE(pContext->hLog, "Got unexpected message type %x!  DEBUGBREAK()-ing.",
				1, dwMsgType);
			DEBUGBREAK();
			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)


DONE:

	return (hr);
} // ParmVPGetSendQInfoDPNMessageHandler
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVPHostDPNMessageHandler()"
//==================================================================================
// ParmVPHostDPNMessageHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT ParmVPHostDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT				hr = DPN_OK;
	PPARMVPHOSTCONTEXT	pContext = (PPARMVPHOSTCONTEXT) pvContext;


	switch (dwMsgType)
	{
		case DPN_MSGID_CREATE_PLAYER:
			PDPNMSG_CREATE_PLAYER	pCreatePlayerMsg;


			pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CREATE_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pCreatePlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pCreatePlayerMsg->dpnidPlayer, pCreatePlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pCreatePlayerMsg->pvPlayerContext);


			// Make sure getting a CREATE_PLAYER is allowed.
			if (! pContext->fCreatePlayerAllowed)
			{
				DPTEST_TRACE(pContext->hLog, "Getting unexpected CREATE_PLAYER message (%x)!  DEBUGBREAK()-ing.",
					1, pCreatePlayerMsg);
				DEBUGBREAK();
				break;
			} // end if (create player not allowed)


			// Validate the indication.
			if (pCreatePlayerMsg->dwSize != sizeof (DPNMSG_CREATE_PLAYER))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CREATE_PLAYER is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pCreatePlayerMsg->dwSize, sizeof (DPNMSG_CREATE_PLAYER));
				DEBUGBREAK();
				break;
			} // end if (size incorrect)

			if (pCreatePlayerMsg->pvPlayerContext == NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Player context is NULL!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				break;
			} // end if (context is wrong)


			// Make sure this isn't a duplicate message.
			if (*((DPNID*) pCreatePlayerMsg->pvPlayerContext) != 0)
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate CREATE_PLAYER (msg = %x)!  DEBUGBREAK()-ing.",
					1, pCreatePlayerMsg);
				DEBUGBREAK();
				break;
			} // end if (already have ID)

			// Save the player ID.
			*((DPNID*) pCreatePlayerMsg->pvPlayerContext) = pCreatePlayerMsg->dpnidPlayer;
		  break;

		case DPN_MSGID_DESTROY_PLAYER:
			PDPNMSG_DESTROY_PLAYER	pDestroyPlayerMsg;


			pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_DESTROY_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pDestroyPlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pDestroyPlayerMsg->dpnidPlayer, pDestroyPlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pDestroyPlayerMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    dwReason = %x", 1, pDestroyPlayerMsg->dwReason);


			// Validate the indication.
			if (pDestroyPlayerMsg->dwSize != sizeof (DPNMSG_DESTROY_PLAYER))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_DESTROY_PLAYER is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pDestroyPlayerMsg->dwSize, sizeof (DPNMSG_DESTROY_PLAYER));
				DEBUGBREAK();
				break;
			} // end if (size incorrect)

			if (pDestroyPlayerMsg->pvPlayerContext == NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Player context is NULL!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				break;
			} // end if (context is wrong)

			if (pDestroyPlayerMsg->dwReason != DPNDESTROYPLAYERREASON_NORMAL)
			{
				DPTEST_TRACE(pContext->hLog, "Player destruction reason is unexpected (%x != %x)!  DEBUGBREAK()-ing.",
					2, pDestroyPlayerMsg->dwReason, DPNDESTROYPLAYERREASON_NORMAL);
				DEBUGBREAK();
				break;
			} // end if (reason is wrong)


			// Make sure this isn't a duplicate or bogus message.
			if ((*((DPNID*) pDestroyPlayerMsg->pvPlayerContext) == 0) ||
				(pDestroyPlayerMsg->dpnidPlayer != *((DPNID*) pDestroyPlayerMsg->pvPlayerContext)))
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate or unexpected DESTROY_PLAYER (msg = %x)!  DEBUGBREAK()-ing.",
					1, pDestroyPlayerMsg);
				DEBUGBREAK();
				break;
			} // end if (already have ID)

			// Clear the player ID.
			*((DPNID*) pDestroyPlayerMsg->pvPlayerContext) = 0;
		  break;

		default:
			DPTEST_TRACE(pContext->hLog, "Got unexpected message type %x!  DEBUGBREAK()-ing.",
				1, dwMsgType);
			DEBUGBREAK();
			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)

	return (hr);
} // ParmVPHostDPNMessageHandler
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVPGetAppDescDPNMessageHandler()"
//==================================================================================
// ParmVPGetAppDescDPNMessageHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT ParmVPGetAppDescDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT						hr = DPN_OK;
	PPARMVPGETAPPDESCCONTEXT	pContext = (PPARMVPGETAPPDESCCONTEXT) pvContext;
	BOOL						fSetEvent = FALSE;


	switch (dwMsgType)
	{
		case DPN_MSGID_CONNECT_COMPLETE:
			PDPNMSG_CONNECT_COMPLETE	pConnectCompleteMsg;


			pConnectCompleteMsg = (PDPNMSG_CONNECT_COMPLETE) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CONNECT_COMPLETE", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pConnectCompleteMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    hAsyncOp = %x", 1, pConnectCompleteMsg->hAsyncOp);
			DPTEST_TRACE(pContext->hLog, "    pvUserContext = %x", 1, pConnectCompleteMsg->pvUserContext);
			DPTEST_TRACE(pContext->hLog, "    hResultCode = 0x%08x", 1, pConnectCompleteMsg->hResultCode);
			DPTEST_TRACE(pContext->hLog, "    pvApplicationReplyData = %x", 1, pConnectCompleteMsg->pvApplicationReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwApplicationReplyDataSize = %u", 1, pConnectCompleteMsg->dwApplicationReplyDataSize);


			// Make sure we expect the completion.
			if (! pContext->fConnectCanComplete)
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_CONNECT_COMPLETE (%x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (message unexpected)


			// Validate the completion.
			if (pConnectCompleteMsg->dwSize != sizeof (DPNMSG_CONNECT_COMPLETE))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CONNECT_COMPLETE is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->dwSize, sizeof (DPNMSG_CONNECT_COMPLETE));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pConnectCompleteMsg->hAsyncOp != NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with an async op handle (%x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg->hAsyncOp);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (wrong op handle)

			if (pConnectCompleteMsg->pvUserContext != NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with wrong context (%x != NULL)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg->pvUserContext);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (wrong context)

			if (pConnectCompleteMsg->hResultCode != DPN_OK)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with failure!  DEBUGBREAK()-ing.  0x%08x",
					1, pConnectCompleteMsg->hResultCode);
				DEBUGBREAK();
				hr = pConnectCompleteMsg->hResultCode;
				goto DONE;
			} // end if (wrong result code)

			if ((pConnectCompleteMsg->pvApplicationReplyData != NULL) ||
				(pConnectCompleteMsg->dwApplicationReplyDataSize != 0))
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with unexpected reply data (ptr %x != NULL or size %u != 0)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->pvApplicationReplyData,
					pConnectCompleteMsg->dwApplicationReplyDataSize);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (unexpected reply data)


			// Make sure this isn't a double completion.
			if (pContext->fConnectCompleted)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed twice (msg = %x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (double completion)

			// Alert the test case that the completion came in.
			pContext->fConnectCompleted = TRUE;
		  break;

		case DPN_MSGID_CREATE_PLAYER:
			PDPNMSG_CREATE_PLAYER	pCreatePlayerMsg;


			pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CREATE_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pCreatePlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pCreatePlayerMsg->dpnidPlayer, pCreatePlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pCreatePlayerMsg->pvPlayerContext);


			// Validate the indication.
			if (pCreatePlayerMsg->dwSize != sizeof (DPNMSG_CREATE_PLAYER))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CREATE_PLAYER is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pCreatePlayerMsg->dwSize, sizeof (DPNMSG_CREATE_PLAYER));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pCreatePlayerMsg->pvPlayerContext == NULL)
			{
				// Assume this is the remote player being created.  Store the
				// player context.
				if (pContext->fHost)
				{
					pCreatePlayerMsg->pvPlayerContext = &(pContext->dpnidClient);
					fSetEvent = TRUE;
				} // end if (host)
				else
				{
					pCreatePlayerMsg->pvPlayerContext = &(pContext->dpnidHost);
				} // end if (not host)
			} // end if (context is not set yet)


			// Make sure this isn't a duplicate message.
			if (*((DPNID*) pCreatePlayerMsg->pvPlayerContext) != 0)
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate CREATE_PLAYER (msg = %x)!  DEBUGBREAK()-ing.",
					1, pCreatePlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (already have ID)

			// Save the player ID.
			*((DPNID*) pCreatePlayerMsg->pvPlayerContext) = pCreatePlayerMsg->dpnidPlayer;


			// Now set the event, if we're supposed too.
			if (fSetEvent)
			{
				if (! SetEvent(pContext->hClientCreatedEvent))
				{
					hr = GetLastError();
					DPTEST_TRACE(pContext->hLog, "Couldn't set client created event (%x)!  DEBUGBREAK()-ing.",
						1, pContext->hClientCreatedEvent);

					DEBUGBREAK();

					if (hr == S_OK)
						hr = E_FAIL;

					goto DONE;
				} // end if (couldn't set event)
			} // end if (should set event)
		  break;

		case DPN_MSGID_DESTROY_PLAYER:
			PDPNMSG_DESTROY_PLAYER	pDestroyPlayerMsg;


			pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_DESTROY_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pDestroyPlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pDestroyPlayerMsg->dpnidPlayer, pDestroyPlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pDestroyPlayerMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    dwReason = %x", 1, pDestroyPlayerMsg->dwReason);


			// Validate the indication.
			if (pDestroyPlayerMsg->dwSize != sizeof (DPNMSG_DESTROY_PLAYER))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_DESTROY_PLAYER is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pDestroyPlayerMsg->dwSize, sizeof (DPNMSG_DESTROY_PLAYER));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pDestroyPlayerMsg->pvPlayerContext == NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Player context is NULL!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (context is wrong)

			if (pDestroyPlayerMsg->dwReason != DPNDESTROYPLAYERREASON_NORMAL)
			{
				DPTEST_TRACE(pContext->hLog, "Player destruction reason is unexpected (%x != %x)!  DEBUGBREAK()-ing.",
					2, pDestroyPlayerMsg->dwReason, DPNDESTROYPLAYERREASON_NORMAL);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (reason is wrong)


			// Make sure this isn't a duplicate or bogus message.
			if ((*((DPNID*) pDestroyPlayerMsg->pvPlayerContext) == 0) ||
				(pDestroyPlayerMsg->dpnidPlayer != *((DPNID*) pDestroyPlayerMsg->pvPlayerContext)))
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate or unexpected DESTROY_PLAYER (msg = %x)!  DEBUGBREAK()-ing.",
					1, pDestroyPlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (already have ID)

			// Clear the player ID.
			*((DPNID*) pDestroyPlayerMsg->pvPlayerContext) = 0;
		  break;

		case DPN_MSGID_INDICATE_CONNECT:
			PDPNMSG_INDICATE_CONNECT	pIndicateConnectMsg;


			pIndicateConnectMsg = (PDPNMSG_INDICATE_CONNECT) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_INDICATE_CONNECT", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pIndicateConnectMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    pvUserConnectData = %x", 1, pIndicateConnectMsg->pvUserConnectData);
			DPTEST_TRACE(pContext->hLog, "    dwUserConnectDataSize = %u", 1, pIndicateConnectMsg->dwUserConnectDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyData = %x", 1, pIndicateConnectMsg->pvReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwReplyDataSize = %u", 1, pIndicateConnectMsg->dwReplyDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyContext = %x", 1, pIndicateConnectMsg->pvReplyContext);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pIndicateConnectMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    pAddressPlayer = 0x%08x", 1, pIndicateConnectMsg->pAddressPlayer);
			DPTEST_TRACE(pContext->hLog, "    pAddressDevice = 0x%08x", 1, pIndicateConnectMsg->pAddressDevice);

#pragma TODO(vanceo, "Validate DPN_MSGID_INDICATE_CONNECT")
		  break;

		default:
			DPTEST_TRACE(pContext->hLog, "Got unexpected message type %x!  DEBUGBREAK()-ing.",
				1, dwMsgType);
			DEBUGBREAK();
			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)


DONE:

	return (hr);
} // ParmVPGetAppDescDPNMessageHandler
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVPSetAppDescDPNMessageHandler()"
//==================================================================================
// ParmVPSetAppDescDPNMessageHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT ParmVPSetAppDescDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT						hr = DPN_OK;
	PPARMVPSETAPPDESCCONTEXT	pContext = (PPARMVPSETAPPDESCCONTEXT) pvContext;
	BOOL						fSetEvent = FALSE;


	switch (dwMsgType)
	{
		case DPN_MSGID_APPLICATION_DESC:
			// Make sure we expect the indication.
			if (! pContext->fCanGetAppDescUpdate)
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_APPLICATION_DESC!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (message unexpected)


			// Make sure this isn't a double indication.
			if (pContext->fGotAppDescUpdate)
			{
				DPTEST_TRACE(pContext->hLog, "App desc update was indicated twice!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (double completion)

			// Alert the test case that the indication came in.
			pContext->fGotAppDescUpdate = TRUE;

			if (! SetEvent(pContext->hGotAppDescUpdateEvent))
			{
				hr = GetLastError();
				DPTEST_TRACE(pContext->hLog, "Couldn't set got app desc update event (%x)!  DEBUGBREAK()-ing.",
					1, pContext->hGotAppDescUpdateEvent);

				DEBUGBREAK();

				if (hr == S_OK)
					hr = E_FAIL;

				goto DONE;
			} // end if (couldn't set event)
		  break;

		case DPN_MSGID_CONNECT_COMPLETE:
			PDPNMSG_CONNECT_COMPLETE	pConnectCompleteMsg;


			pConnectCompleteMsg = (PDPNMSG_CONNECT_COMPLETE) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CONNECT_COMPLETE", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pConnectCompleteMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    hAsyncOp = %x", 1, pConnectCompleteMsg->hAsyncOp);
			DPTEST_TRACE(pContext->hLog, "    pvUserContext = %x", 1, pConnectCompleteMsg->pvUserContext);
			DPTEST_TRACE(pContext->hLog, "    hResultCode = 0x%08x", 1, pConnectCompleteMsg->hResultCode);
			DPTEST_TRACE(pContext->hLog, "    pvApplicationReplyData = %x", 1, pConnectCompleteMsg->pvApplicationReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwApplicationReplyDataSize = %u", 1, pConnectCompleteMsg->dwApplicationReplyDataSize);


			// Make sure we expect the completion.
			if (! pContext->fConnectCanComplete)
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_CONNECT_COMPLETE (%x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (message unexpected)


			// Validate the completion.
			if (pConnectCompleteMsg->dwSize != sizeof (DPNMSG_CONNECT_COMPLETE))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CONNECT_COMPLETE is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->dwSize, sizeof (DPNMSG_CONNECT_COMPLETE));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pConnectCompleteMsg->hResultCode != DPN_OK)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with failure!  DEBUGBREAK()-ing.  0x%08x",
					1, pConnectCompleteMsg->hResultCode);
				DEBUGBREAK();
				hr = pConnectCompleteMsg->hResultCode;
				goto DONE;
			} // end if (wrong result code)

			if ((pConnectCompleteMsg->pvApplicationReplyData != NULL) ||
				(pConnectCompleteMsg->dwApplicationReplyDataSize != 0))
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with unexpected reply data (ptr %x != NULL or size %u != 0)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->pvApplicationReplyData,
					pConnectCompleteMsg->dwApplicationReplyDataSize);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (unexpected reply data)


			// Make sure this isn't a double completion.
			if (pContext->fConnectCompleted)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed twice (msg = %x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (double completion)

			// Alert the test case that the completion came in.
			pContext->fConnectCompleted = TRUE;

			// XBOX - Handle async connect
			if(pConnectCompleteMsg->pvUserContext)
			{
				SetEvent((HANDLE) pConnectCompleteMsg->pvUserContext);
			}

		  break;

		case DPN_MSGID_CREATE_PLAYER:
			PDPNMSG_CREATE_PLAYER	pCreatePlayerMsg;


			pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CREATE_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pCreatePlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pCreatePlayerMsg->dpnidPlayer, pCreatePlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pCreatePlayerMsg->pvPlayerContext);


			// Validate the indication.
			if (pCreatePlayerMsg->dwSize != sizeof (DPNMSG_CREATE_PLAYER))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CREATE_PLAYER is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pCreatePlayerMsg->dwSize, sizeof (DPNMSG_CREATE_PLAYER));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pCreatePlayerMsg->pvPlayerContext == NULL)
			{
				// Assume this is the remote player being created.  Store the
				// player context.
				if (pContext->fHost)
				{
					pCreatePlayerMsg->pvPlayerContext = &(pContext->dpnidClient);
					fSetEvent = TRUE;
				} // end if (host)
				else
				{
					pCreatePlayerMsg->pvPlayerContext = &(pContext->dpnidHost);
				} // end if (not host)
			} // end if (context is not set yet)


			// Make sure this isn't a duplicate message.
			if (*((DPNID*) pCreatePlayerMsg->pvPlayerContext) != 0)
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate CREATE_PLAYER (msg = %x)!  DEBUGBREAK()-ing.",
					1, pCreatePlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (already have ID)

			// Save the player ID.
			*((DPNID*) pCreatePlayerMsg->pvPlayerContext) = pCreatePlayerMsg->dpnidPlayer;


			// Now set the event, if we're supposed too.
			if (fSetEvent)
			{
				if (! SetEvent(pContext->hClientCreatedEvent))
				{
					hr = GetLastError();
					DPTEST_TRACE(pContext->hLog, "Couldn't set client created event (%x)!  DEBUGBREAK()-ing.",
						1, pContext->hClientCreatedEvent);

					DEBUGBREAK();

					if (hr == S_OK)
						hr = E_FAIL;

					goto DONE;
				} // end if (couldn't set event)
			} // end if (should set event)
		  break;

		case DPN_MSGID_DESTROY_PLAYER:
			PDPNMSG_DESTROY_PLAYER	pDestroyPlayerMsg;


			pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_DESTROY_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pDestroyPlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pDestroyPlayerMsg->dpnidPlayer, pDestroyPlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pDestroyPlayerMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    dwReason = %x", 1, pDestroyPlayerMsg->dwReason);


			// Validate the indication.
			if (pDestroyPlayerMsg->dwSize != sizeof (DPNMSG_DESTROY_PLAYER))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_DESTROY_PLAYER is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pDestroyPlayerMsg->dwSize, sizeof (DPNMSG_DESTROY_PLAYER));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pDestroyPlayerMsg->pvPlayerContext == NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Player context is NULL!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (context is wrong)

			if (pDestroyPlayerMsg->dwReason != DPNDESTROYPLAYERREASON_NORMAL)
			{
				DPTEST_TRACE(pContext->hLog, "Player destruction reason is unexpected (%x != %x)!  DEBUGBREAK()-ing.",
					2, pDestroyPlayerMsg->dwReason, DPNDESTROYPLAYERREASON_NORMAL);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (reason is wrong)


			// Make sure this isn't a duplicate or bogus message.
			if ((*((DPNID*) pDestroyPlayerMsg->pvPlayerContext) == 0) ||
				(pDestroyPlayerMsg->dpnidPlayer != *((DPNID*) pDestroyPlayerMsg->pvPlayerContext)))
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate or unexpected DESTROY_PLAYER (msg = %x)!  DEBUGBREAK()-ing.",
					1, pDestroyPlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (already have ID)

			// Clear the player ID.
			*((DPNID*) pDestroyPlayerMsg->pvPlayerContext) = 0;
		  break;

		case DPN_MSGID_INDICATE_CONNECT:
			PDPNMSG_INDICATE_CONNECT	pIndicateConnectMsg;


			pIndicateConnectMsg = (PDPNMSG_INDICATE_CONNECT) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_INDICATE_CONNECT", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pIndicateConnectMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    pvUserConnectData = %x", 1, pIndicateConnectMsg->pvUserConnectData);
			DPTEST_TRACE(pContext->hLog, "    dwUserConnectDataSize = %u", 1, pIndicateConnectMsg->dwUserConnectDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyData = %x", 1, pIndicateConnectMsg->pvReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwReplyDataSize = %u", 1, pIndicateConnectMsg->dwReplyDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyContext = %x", 1, pIndicateConnectMsg->pvReplyContext);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pIndicateConnectMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    pAddressPlayer = 0x%08x", 1, pIndicateConnectMsg->pAddressPlayer);
			DPTEST_TRACE(pContext->hLog, "    pAddressDevice = 0x%08x", 1, pIndicateConnectMsg->pAddressDevice);

#pragma TODO(vanceo, "Validate DPN_MSGID_INDICATE_CONNECT")
		  break;

		default:
			DPTEST_TRACE(pContext->hLog, "Got unexpected message type %x!  DEBUGBREAK()-ing.",
				1, dwMsgType);
			DEBUGBREAK();
			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)


DONE:

	return (hr);
} // ParmVPSetAppDescDPNMessageHandler
#undef DEBUG_SECTION
#define DEBUG_SECTION	""







#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVPCreateGroupDPNMessageHandler()"
//==================================================================================
// ParmVPCreateGroupDPNMessageHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT ParmVPCreateGroupDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT						hr = DPN_OK;
	PPARMVPCREATEGROUPCONTEXT	pContext = (PPARMVPCREATEGROUPCONTEXT) pvContext;
	BOOL						fSetEvent = FALSE;


	switch (dwMsgType)
	{
		case DPN_MSGID_ASYNC_OP_COMPLETE:
			PDPNMSG_ASYNC_OP_COMPLETE	pAsyncOpCompleteMsg;


			pAsyncOpCompleteMsg = (PDPNMSG_ASYNC_OP_COMPLETE) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_ASYNC_OP_COMPLETE", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pAsyncOpCompleteMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    hAsyncOp = %x", 1, pAsyncOpCompleteMsg->hAsyncOp);
			DPTEST_TRACE(pContext->hLog, "    pvUserContext = %x", 1, pAsyncOpCompleteMsg->pvUserContext);
			DPTEST_TRACE(pContext->hLog, "    hResultCode = 0x%08x", 1, pAsyncOpCompleteMsg->hResultCode);


			// Make sure we expect the completion.
			if (! pContext->fAsyncOpCanComplete)
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_ASYNC_OP_COMPLETE (%x)!  DEBUGBREAK()-ing.",
					1, pAsyncOpCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (message unexpected)


			// Validate the completion.
			if (pAsyncOpCompleteMsg->dwSize != sizeof (DPNMSG_ASYNC_OP_COMPLETE))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_ASYNC_OP_COMPLETE is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pAsyncOpCompleteMsg->dwSize, sizeof (DPNMSG_ASYNC_OP_COMPLETE));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pAsyncOpCompleteMsg->pvUserContext != NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Async op completed with wrong context (%x != NULL)!  DEBUGBREAK()-ing.",
					1, pAsyncOpCompleteMsg->pvUserContext);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (wrong context)

			if (pAsyncOpCompleteMsg->hResultCode != DPN_OK)
			{
				DPTEST_TRACE(pContext->hLog, "Async op completed with failure!  DEBUGBREAK()-ing.  0x%08x",
					1, pAsyncOpCompleteMsg->hResultCode);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (wrong result code)


			// Make sure this isn't a double completion.
			if (pContext->fAsyncOpCompleted)
			{
				DPTEST_TRACE(pContext->hLog, "Async op completed twice (msg = %x)!  DEBUGBREAK()-ing.",
					1, pAsyncOpCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (double completion)

			// Alert the test case that the completion came in.
			pContext->fAsyncOpCompleted = TRUE;

			// Remember the async op handle for comparison by the main thread.
			pContext->dpnhCompletedAsyncOp = pAsyncOpCompleteMsg->hAsyncOp;

			if (! SetEvent(pContext->hAsyncOpCompletedEvent))
			{
				hr = GetLastError();
				DPTEST_TRACE(pContext->hLog, "Couldn't set async op completed event (%x)!  DEBUGBREAK()-ing.",
					1, pContext->hAsyncOpCompletedEvent);

				DEBUGBREAK();

				if (hr == S_OK)
					hr = E_FAIL;

				goto DONE;
			} // end if (couldn't set event)
		  break;

		case DPN_MSGID_CONNECT_COMPLETE:
			PDPNMSG_CONNECT_COMPLETE	pConnectCompleteMsg;


			pConnectCompleteMsg = (PDPNMSG_CONNECT_COMPLETE) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CONNECT_COMPLETE", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pConnectCompleteMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    hAsyncOp = %x", 1, pConnectCompleteMsg->hAsyncOp);
			DPTEST_TRACE(pContext->hLog, "    pvUserContext = %x", 1, pConnectCompleteMsg->pvUserContext);
			DPTEST_TRACE(pContext->hLog, "    hResultCode = 0x%08x", 1, pConnectCompleteMsg->hResultCode);
			DPTEST_TRACE(pContext->hLog, "    pvApplicationReplyData = %x", 1, pConnectCompleteMsg->pvApplicationReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwApplicationReplyDataSize = %u", 1, pConnectCompleteMsg->dwApplicationReplyDataSize);


			// Make sure we expect the completion.
			if (! pContext->fConnectCanComplete)
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_CONNECT_COMPLETE (%x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (message unexpected)


			// Validate the completion.
			if (pConnectCompleteMsg->dwSize != sizeof (DPNMSG_CONNECT_COMPLETE))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CONNECT_COMPLETE is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->dwSize, sizeof (DPNMSG_CONNECT_COMPLETE));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pConnectCompleteMsg->hResultCode != DPN_OK)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with failure!  DEBUGBREAK()-ing.  0x%08x",
					1, pConnectCompleteMsg->hResultCode);
				DEBUGBREAK();
				hr = pConnectCompleteMsg->hResultCode;
				goto DONE;
			} // end if (wrong result code)

			if ((pConnectCompleteMsg->pvApplicationReplyData != NULL) ||
				(pConnectCompleteMsg->dwApplicationReplyDataSize != 0))
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with unexpected reply data (ptr %x != NULL or size %u != 0)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->pvApplicationReplyData,
					pConnectCompleteMsg->dwApplicationReplyDataSize);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (unexpected reply data)


			// Make sure this isn't a double completion.
			if (pContext->fConnectCompleted)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed twice (msg = %x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (double completion)

			// Alert the test case that the completion came in.
			pContext->fConnectCompleted = TRUE;

			// XBOX - Handle async connect
			if(pConnectCompleteMsg->pvUserContext)
			{
				SetEvent((HANDLE) pConnectCompleteMsg->pvUserContext);
			}

		  break;

		case DPN_MSGID_CREATE_GROUP:
			PDPNMSG_CREATE_GROUP	pCreateGroupMsg;


			pCreateGroupMsg = (PDPNMSG_CREATE_GROUP) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CREATE_GROUP", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pCreateGroupMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidGroup = %u/%x", 2, pCreateGroupMsg->dpnidGroup, pCreateGroupMsg->dpnidGroup);
			DPTEST_TRACE(pContext->hLog, "    dpnidOwner = %u/%x", 2, pCreateGroupMsg->dpnidOwner, pCreateGroupMsg->dpnidOwner);
			DPTEST_TRACE(pContext->hLog, "    pvGroupContext = %x", 1, pCreateGroupMsg->pvGroupContext);


			// Make sure we expect the indication.
			if (! pContext->fCanGetCreateGroup)
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_CREATE_GROUP (at %x)!  DEBUGBREAK()-ing.",
					1, pCreateGroupMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (message unexpected)

			// Validate the message.
			if (pCreateGroupMsg->dpnidGroup == 0)
			{
				DPTEST_TRACE(pContext->hLog, "Group created got invalid ID of 0!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (group ID is 0)

			if (pCreateGroupMsg->dpnidOwner != pContext->dpnidExpectedGroupOwner)
			{
				DPTEST_TRACE(pContext->hLog, "Group owner was wrong (%u/%x != %u/%x)!  DEBUGBREAK()-ing.",
					4, pCreateGroupMsg->dpnidOwner, pCreateGroupMsg->dpnidOwner,
					pContext->dpnidExpectedGroupOwner, pContext->dpnidExpectedGroupOwner);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (group owner is wrong)

			if (pCreateGroupMsg->pvGroupContext != NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Group has wrong context (%x != NULL)!  DEBUGBREAK()-ing.",
					1, pCreateGroupMsg->pvGroupContext);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (wrong context)



			// Make sure this isn't a double indication.
			if (pContext->dpnidGroupCreated != 0)
			{
				DPTEST_TRACE(pContext->hLog, "Got create group twice!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (double completion)

			// Alert the test case that the indication came in.
			pContext->dpnidGroupCreated = pCreateGroupMsg->dpnidGroup;

			if (pContext->hGotCreateGroupEvent != NULL)
			{
				if (! SetEvent(pContext->hGotCreateGroupEvent))
				{
					hr = GetLastError();
					DPTEST_TRACE(pContext->hLog, "Couldn't set got create group event (%x)!  DEBUGBREAK()-ing.",
						1, pContext->hGotCreateGroupEvent);

					DEBUGBREAK();

					if (hr == S_OK)
						hr = E_FAIL;

					goto DONE;
				} // end if (couldn't set event)
			} // end if (there's a create group event)
		  break;

		case DPN_MSGID_CREATE_PLAYER:
			PDPNMSG_CREATE_PLAYER	pCreatePlayerMsg;


			pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CREATE_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pCreatePlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pCreatePlayerMsg->dpnidPlayer, pCreatePlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pCreatePlayerMsg->pvPlayerContext);


			// Validate the indication.
			if (pCreatePlayerMsg->dwSize != sizeof (DPNMSG_CREATE_PLAYER))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CREATE_PLAYER is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pCreatePlayerMsg->dwSize, sizeof (DPNMSG_CREATE_PLAYER));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pCreatePlayerMsg->pvPlayerContext == NULL)
			{
				// Assume this is the remote player being created.  Store the
				// player context.
				if (pContext->fHost)
				{
					pCreatePlayerMsg->pvPlayerContext = &(pContext->dpnidClient);
					fSetEvent = TRUE;
				} // end if (host)
				else
				{
					pCreatePlayerMsg->pvPlayerContext = &(pContext->dpnidHost);
				} // end if (not host)
			} // end if (context is not set yet)


			// Make sure this isn't a duplicate message.
			if (*((DPNID*) pCreatePlayerMsg->pvPlayerContext) != 0)
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate CREATE_PLAYER (msg = %x)!  DEBUGBREAK()-ing.",
					1, pCreatePlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (already have ID)

			// Save the player ID.
			*((DPNID*) pCreatePlayerMsg->pvPlayerContext) = pCreatePlayerMsg->dpnidPlayer;


			// Now set the event, if we're supposed too.
			if (fSetEvent)
			{
				if (! SetEvent(pContext->hClientCreatedEvent))
				{
					hr = GetLastError();
					DPTEST_TRACE(pContext->hLog, "Couldn't set client created event (%x)!  DEBUGBREAK()-ing.",
						1, pContext->hClientCreatedEvent);

					DEBUGBREAK();

					if (hr == S_OK)
						hr = E_FAIL;

					goto DONE;
				} // end if (couldn't set event)
			} // end if (should set event)
		  break;

		case DPN_MSGID_DESTROY_GROUP:
			PDPNMSG_DESTROY_GROUP	pDestroyGroupMsg;


			pDestroyGroupMsg = (PDPNMSG_DESTROY_GROUP) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_DESTROY_GROUP", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pDestroyGroupMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidGroup = %u/%x", 2, pDestroyGroupMsg->dpnidGroup, pDestroyGroupMsg->dpnidGroup);
			DPTEST_TRACE(pContext->hLog, "    pvGroupContext = %x", 1, pDestroyGroupMsg->pvGroupContext);
			DPTEST_TRACE(pContext->hLog, "    dwReason = %u", 1, pDestroyGroupMsg->dwReason);

#pragma TODO(vanceo, "Handle/validate destroy group")
		  break;

		case DPN_MSGID_DESTROY_PLAYER:
			PDPNMSG_DESTROY_PLAYER	pDestroyPlayerMsg;


			pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_DESTROY_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pDestroyPlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pDestroyPlayerMsg->dpnidPlayer, pDestroyPlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pDestroyPlayerMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    dwReason = %x", 1, pDestroyPlayerMsg->dwReason);


			// Validate the indication.
			if (pDestroyPlayerMsg->dwSize != sizeof (DPNMSG_DESTROY_PLAYER))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_DESTROY_PLAYER is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pDestroyPlayerMsg->dwSize, sizeof (DPNMSG_DESTROY_PLAYER));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pDestroyPlayerMsg->pvPlayerContext == NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Player context is NULL!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (context is wrong)

			if (pDestroyPlayerMsg->dwReason != DPNDESTROYPLAYERREASON_NORMAL)
			{
				DPTEST_TRACE(pContext->hLog, "Player destruction reason is unexpected (%x != %x)!  DEBUGBREAK()-ing.",
					2, pDestroyPlayerMsg->dwReason, DPNDESTROYPLAYERREASON_NORMAL);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (reason is wrong)


			// Make sure this isn't a duplicate or bogus message.
			if ((*((DPNID*) pDestroyPlayerMsg->pvPlayerContext) == 0) ||
				(pDestroyPlayerMsg->dpnidPlayer != *((DPNID*) pDestroyPlayerMsg->pvPlayerContext)))
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate or unexpected DESTROY_PLAYER (msg = %x)!  DEBUGBREAK()-ing.",
					1, pDestroyPlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (already have ID)

			// Clear the player ID.
			*((DPNID*) pDestroyPlayerMsg->pvPlayerContext) = 0;
		  break;

		case DPN_MSGID_INDICATE_CONNECT:
			PDPNMSG_INDICATE_CONNECT	pIndicateConnectMsg;


			pIndicateConnectMsg = (PDPNMSG_INDICATE_CONNECT) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_INDICATE_CONNECT", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pIndicateConnectMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    pvUserConnectData = %x", 1, pIndicateConnectMsg->pvUserConnectData);
			DPTEST_TRACE(pContext->hLog, "    dwUserConnectDataSize = %u", 1, pIndicateConnectMsg->dwUserConnectDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyData = %x", 1, pIndicateConnectMsg->pvReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwReplyDataSize = %u", 1, pIndicateConnectMsg->dwReplyDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyContext = %x", 1, pIndicateConnectMsg->pvReplyContext);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pIndicateConnectMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    pAddressPlayer = 0x%08x", 1, pIndicateConnectMsg->pAddressPlayer);
			DPTEST_TRACE(pContext->hLog, "    pAddressDevice = 0x%08x", 1, pIndicateConnectMsg->pAddressDevice);

#pragma TODO(vanceo, "Validate DPN_MSGID_INDICATE_CONNECT")
		  break;

		default:
			DPTEST_TRACE(pContext->hLog, "Got unexpected message type %x!  DEBUGBREAK()-ing.",
				1, dwMsgType);
			DEBUGBREAK();
			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)


DONE:

	return (hr);
} // ParmVPCreateGroupDPNMessageHandler
#undef DEBUG_SECTION
#define DEBUG_SECTION	""








#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVPDestroyGroupDPNMessageHandler()"
//==================================================================================
// ParmVPDestroyGroupDPNMessageHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT ParmVPDestroyGroupDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT						hr = DPN_OK;
	PPARMVPDESTROYGROUPCONTEXT	pContext = (PPARMVPDESTROYGROUPCONTEXT) pvContext;
	BOOL						fSetEvent = FALSE;


	switch (dwMsgType)
	{
		case DPN_MSGID_ASYNC_OP_COMPLETE:
			PDPNMSG_ASYNC_OP_COMPLETE	pAsyncOpCompleteMsg;


			pAsyncOpCompleteMsg = (PDPNMSG_ASYNC_OP_COMPLETE) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_ASYNC_OP_COMPLETE", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pAsyncOpCompleteMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    hAsyncOp = %x", 1, pAsyncOpCompleteMsg->hAsyncOp);
			DPTEST_TRACE(pContext->hLog, "    pvUserContext = %x", 1, pAsyncOpCompleteMsg->pvUserContext);
			DPTEST_TRACE(pContext->hLog, "    hResultCode = 0x%08x", 1, pAsyncOpCompleteMsg->hResultCode);


			// Make sure we expect the completion.
			if (! pContext->fAsyncOpCanComplete)
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_ASYNC_OP_COMPLETE (%x)!  DEBUGBREAK()-ing.",
					1, pAsyncOpCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (message unexpected)


			// Validate the completion.
			if (pAsyncOpCompleteMsg->dwSize != sizeof (DPNMSG_ASYNC_OP_COMPLETE))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_ASYNC_OP_COMPLETE is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pAsyncOpCompleteMsg->dwSize, sizeof (DPNMSG_ASYNC_OP_COMPLETE));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pAsyncOpCompleteMsg->hResultCode != DPN_OK)
			{
				DPTEST_TRACE(pContext->hLog, "Async op completed with failure!  DEBUGBREAK()-ing.  0x%08x",
					1, pAsyncOpCompleteMsg->hResultCode);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (wrong result code)


			// Make sure this isn't a double completion.
			if (pContext->fAsyncOpCompleted)
			{
				DPTEST_TRACE(pContext->hLog, "Async op completed twice (msg = %x)!  DEBUGBREAK()-ing.",
					1, pAsyncOpCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (double completion)

			// Alert the test case that the completion came in.
			pContext->fAsyncOpCompleted = TRUE;

			// Remember the async op handle for comparison by the main thread.
			pContext->dpnhCompletedAsyncOp = pAsyncOpCompleteMsg->hAsyncOp;

			if (! SetEvent(pContext->hAsyncOpCompletedEvent))
			{
				hr = GetLastError();
				DPTEST_TRACE(pContext->hLog, "Couldn't set async op completed event (%x)!  DEBUGBREAK()-ing.",
					1, pContext->hAsyncOpCompletedEvent);

				DEBUGBREAK();

				if (hr == S_OK)
					hr = E_FAIL;

				goto DONE;
			} // end if (couldn't set event)

			// XBOX - Handle async op
			if(pAsyncOpCompleteMsg->pvUserContext)
			{
				SetEvent((HANDLE) pAsyncOpCompleteMsg->pvUserContext);
			}

		  break;

		case DPN_MSGID_CONNECT_COMPLETE:
			PDPNMSG_CONNECT_COMPLETE	pConnectCompleteMsg;


			pConnectCompleteMsg = (PDPNMSG_CONNECT_COMPLETE) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CONNECT_COMPLETE", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pConnectCompleteMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    hAsyncOp = %x", 1, pConnectCompleteMsg->hAsyncOp);
			DPTEST_TRACE(pContext->hLog, "    pvUserContext = %x", 1, pConnectCompleteMsg->pvUserContext);
			DPTEST_TRACE(pContext->hLog, "    hResultCode = 0x%08x", 1, pConnectCompleteMsg->hResultCode);
			DPTEST_TRACE(pContext->hLog, "    pvApplicationReplyData = %x", 1, pConnectCompleteMsg->pvApplicationReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwApplicationReplyDataSize = %u", 1, pConnectCompleteMsg->dwApplicationReplyDataSize);


			// Make sure we expect the completion.
			if (! pContext->fConnectCanComplete)
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_CONNECT_COMPLETE (%x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (message unexpected)


			// Validate the completion.
			if (pConnectCompleteMsg->dwSize != sizeof (DPNMSG_CONNECT_COMPLETE))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CONNECT_COMPLETE is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->dwSize, sizeof (DPNMSG_CONNECT_COMPLETE));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pConnectCompleteMsg->hResultCode != DPN_OK)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with failure!  DEBUGBREAK()-ing.  0x%08x",
					1, pConnectCompleteMsg->hResultCode);
				DEBUGBREAK();
				hr = pConnectCompleteMsg->hResultCode;
				goto DONE;
			} // end if (wrong result code)

			if ((pConnectCompleteMsg->pvApplicationReplyData != NULL) ||
				(pConnectCompleteMsg->dwApplicationReplyDataSize != 0))
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with unexpected reply data (ptr %x != NULL or size %u != 0)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->pvApplicationReplyData,
					pConnectCompleteMsg->dwApplicationReplyDataSize);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (unexpected reply data)


			// Make sure this isn't a double completion.
			if (pContext->fConnectCompleted)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed twice (msg = %x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (double completion)

			// Alert the test case that the completion came in.
			pContext->fConnectCompleted = TRUE;

			// XBOX - Handle async connect
			if(pConnectCompleteMsg->pvUserContext)
			{
				SetEvent((HANDLE) pConnectCompleteMsg->pvUserContext);
			}

		  break;

		case DPN_MSGID_CREATE_GROUP:
			PDPNMSG_CREATE_GROUP	pCreateGroupMsg;


			pCreateGroupMsg = (PDPNMSG_CREATE_GROUP) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CREATE_GROUP", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pCreateGroupMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidGroup = %u/%x", 2, pCreateGroupMsg->dpnidGroup, pCreateGroupMsg->dpnidGroup);
			DPTEST_TRACE(pContext->hLog, "    dpnidOwner = %u/%x", 2, pCreateGroupMsg->dpnidOwner, pCreateGroupMsg->dpnidOwner);
			DPTEST_TRACE(pContext->hLog, "    pvGroupContext = %x", 1, pCreateGroupMsg->pvGroupContext);


			// Make sure we expect the indication.
			if (! pContext->fCanGetCreateGroup)
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_CREATE_GROUP (at %x)!  DEBUGBREAK()-ing.",
					1, pCreateGroupMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (message unexpected)

			// Validate the message.
			if (pCreateGroupMsg->dwSize != sizeof (DPNMSG_CREATE_GROUP))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CREATE_GROUP is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pCreateGroupMsg->dwSize, sizeof (DPNMSG_CREATE_GROUP));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pCreateGroupMsg->dpnidGroup == 0)
			{
				DPTEST_TRACE(pContext->hLog, "Group created got invalid ID of 0!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (group ID is 0)

			if (pCreateGroupMsg->dpnidOwner != pContext->dpnidExpectedGroupOwner)
			{
				DPTEST_TRACE(pContext->hLog, "Group owner was wrong (%u/%x != %u/%x)!  DEBUGBREAK()-ing.",
					4, pCreateGroupMsg->dpnidOwner, pCreateGroupMsg->dpnidOwner,
					pContext->dpnidExpectedGroupOwner, pContext->dpnidExpectedGroupOwner);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (group owner is wrong)

			if (pCreateGroupMsg->pvGroupContext != NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Group has wrong context (%x != NULL)!  DEBUGBREAK()-ing.",
					1, pCreateGroupMsg->pvGroupContext);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (wrong context)



			// Make sure this isn't a double indication.
			if (pContext->dpnidGroup != 0)
			{
				DPTEST_TRACE(pContext->hLog, "Got create group twice!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (double completion)

			// Alert the test case that the indication came in.
			pContext->dpnidGroup = pCreateGroupMsg->dpnidGroup;

			if (pContext->hGotGroupMsgEvent != NULL)
			{
				if (! SetEvent(pContext->hGotGroupMsgEvent))
				{
					hr = GetLastError();
					DPTEST_TRACE(pContext->hLog, "Couldn't set got group msg event (%x)!  DEBUGBREAK()-ing.",
						1, pContext->hGotGroupMsgEvent);

					DEBUGBREAK();

					if (hr == S_OK)
						hr = E_FAIL;

					goto DONE;
				} // end if (couldn't set event)
			} // end if (there's a group msg event)
		  break;

		case DPN_MSGID_CREATE_PLAYER:
			PDPNMSG_CREATE_PLAYER	pCreatePlayerMsg;


			pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CREATE_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pCreatePlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pCreatePlayerMsg->dpnidPlayer, pCreatePlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pCreatePlayerMsg->pvPlayerContext);


			// Validate the indication.
			if (pCreatePlayerMsg->dwSize != sizeof (DPNMSG_CREATE_PLAYER))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CREATE_PLAYER is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pCreatePlayerMsg->dwSize, sizeof (DPNMSG_CREATE_PLAYER));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pCreatePlayerMsg->pvPlayerContext == NULL)
			{
				// Assume this is the remote player being created.  Store the
				// player context.
				if (pContext->fHost)
				{
					pCreatePlayerMsg->pvPlayerContext = &(pContext->dpnidClient);
					fSetEvent = TRUE;
				} // end if (host)
				else
				{
					pCreatePlayerMsg->pvPlayerContext = &(pContext->dpnidHost);
				} // end if (not host)
			} // end if (context is not set yet)


			// Make sure this isn't a duplicate message.
			if (*((DPNID*) pCreatePlayerMsg->pvPlayerContext) != 0)
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate CREATE_PLAYER (msg = %x)!  DEBUGBREAK()-ing.",
					1, pCreatePlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (already have ID)

			// Save the player ID.
			*((DPNID*) pCreatePlayerMsg->pvPlayerContext) = pCreatePlayerMsg->dpnidPlayer;


			// Now set the event, if we're supposed too.
			if (fSetEvent)
			{
				if (! SetEvent(pContext->hClientCreatedEvent))
				{
					hr = GetLastError();
					DPTEST_TRACE(pContext->hLog, "Couldn't set client created event (%x)!  DEBUGBREAK()-ing.",
						1, pContext->hClientCreatedEvent);

					DEBUGBREAK();

					if (hr == S_OK)
						hr = E_FAIL;

					goto DONE;
				} // end if (couldn't set event)
			} // end if (should set event)
		  break;

		case DPN_MSGID_DESTROY_GROUP:
			PDPNMSG_DESTROY_GROUP	pDestroyGroupMsg;


			pDestroyGroupMsg = (PDPNMSG_DESTROY_GROUP) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_DESTROY_GROUP", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pDestroyGroupMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidGroup = %u/%x", 2, pDestroyGroupMsg->dpnidGroup, pDestroyGroupMsg->dpnidGroup);
			DPTEST_TRACE(pContext->hLog, "    pvGroupContext = %x", 1, pDestroyGroupMsg->pvGroupContext);
			DPTEST_TRACE(pContext->hLog, "    dwReason = %u", 1, pDestroyGroupMsg->dwReason);


			// Make sure we expect the indication.
			if (! pContext->fCanGetDestroyGroup)
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_DESTROY_GROUP (at %x)!  DEBUGBREAK()-ing.",
					1, pDestroyGroupMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (message unexpected)


			// Validate the message.
			if (pDestroyGroupMsg->dwSize != sizeof (DPNMSG_DESTROY_GROUP))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_DESTROY_GROUP is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pDestroyGroupMsg->dwSize, sizeof (DPNMSG_DESTROY_GROUP));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pDestroyGroupMsg->dpnidGroup != pContext->dpnidGroup)
			{
				DPTEST_TRACE(pContext->hLog, "Group being destroy has wrong ID (%u/%x != %u/%x)!  DEBUGBREAK()-ing.",
					4, pDestroyGroupMsg->dpnidGroup, pDestroyGroupMsg->dpnidGroup,
					pContext->dpnidGroup, pContext->dpnidGroup);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (group ID is wrong)

			if (pDestroyGroupMsg->pvGroupContext != NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Group has wrong context (%x != NULL)!  DEBUGBREAK()-ing.",
					1, pDestroyGroupMsg->pvGroupContext);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (wrong context)

			if (pDestroyGroupMsg->dwReason != DPNDESTROYGROUPREASON_NORMAL)
			{
				DPTEST_TRACE(pContext->hLog, "Reason group being destroyed is wrong (%x != %x)!  DEBUGBREAK()-ing.",
					2, pDestroyGroupMsg->dwReason, DPNDESTROYGROUPREASON_NORMAL);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (reason is wrong)

			// Alert the test case that the indication came in.
			pContext->dpnidGroup = 0;

			if (pContext->hGotGroupMsgEvent != NULL)
			{
				if (! SetEvent(pContext->hGotGroupMsgEvent))
				{
					hr = GetLastError();
					DPTEST_TRACE(pContext->hLog, "Couldn't set got group msg event (%x)!  DEBUGBREAK()-ing.",
						1, pContext->hGotGroupMsgEvent);

					DEBUGBREAK();

					if (hr == S_OK)
						hr = E_FAIL;

					goto DONE;
				} // end if (couldn't set event)
			} // end if (there's a group msg event)
		  break;

		case DPN_MSGID_DESTROY_PLAYER:
			PDPNMSG_DESTROY_PLAYER	pDestroyPlayerMsg;


			pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_DESTROY_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pDestroyPlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pDestroyPlayerMsg->dpnidPlayer, pDestroyPlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pDestroyPlayerMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    dwReason = %x", 1, pDestroyPlayerMsg->dwReason);


			// Validate the indication.
			if (pDestroyPlayerMsg->dwSize != sizeof (DPNMSG_DESTROY_PLAYER))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_DESTROY_PLAYER is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pDestroyPlayerMsg->dwSize, sizeof (DPNMSG_DESTROY_PLAYER));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pDestroyPlayerMsg->pvPlayerContext == NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Player context is NULL!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (context is wrong)

			if (pDestroyPlayerMsg->dwReason != DPNDESTROYPLAYERREASON_NORMAL)
			{
				DPTEST_TRACE(pContext->hLog, "Player destruction reason is unexpected (%x != %x)!  DEBUGBREAK()-ing.",
					2, pDestroyPlayerMsg->dwReason, DPNDESTROYPLAYERREASON_NORMAL);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (reason is wrong)


			// Make sure this isn't a duplicate or bogus message.
			if ((*((DPNID*) pDestroyPlayerMsg->pvPlayerContext) == 0) ||
				(pDestroyPlayerMsg->dpnidPlayer != *((DPNID*) pDestroyPlayerMsg->pvPlayerContext)))
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate or unexpected DESTROY_PLAYER (msg = %x)!  DEBUGBREAK()-ing.",
					1, pDestroyPlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (already have ID)

			// Clear the player ID.
			*((DPNID*) pDestroyPlayerMsg->pvPlayerContext) = 0;
		  break;

		case DPN_MSGID_INDICATE_CONNECT:
			PDPNMSG_INDICATE_CONNECT	pIndicateConnectMsg;


			pIndicateConnectMsg = (PDPNMSG_INDICATE_CONNECT) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_INDICATE_CONNECT", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pIndicateConnectMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    pvUserConnectData = %x", 1, pIndicateConnectMsg->pvUserConnectData);
			DPTEST_TRACE(pContext->hLog, "    dwUserConnectDataSize = %u", 1, pIndicateConnectMsg->dwUserConnectDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyData = %x", 1, pIndicateConnectMsg->pvReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwReplyDataSize = %u", 1, pIndicateConnectMsg->dwReplyDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyContext = %x", 1, pIndicateConnectMsg->pvReplyContext);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pIndicateConnectMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    pAddressPlayer = 0x%08x", 1, pIndicateConnectMsg->pAddressPlayer);
			DPTEST_TRACE(pContext->hLog, "    pAddressDevice = 0x%08x", 1, pIndicateConnectMsg->pAddressDevice);

#pragma TODO(vanceo, "Validate DPN_MSGID_INDICATE_CONNECT")
		  break;

		default:
			DPTEST_TRACE(pContext->hLog, "Got unexpected message type %x!  DEBUGBREAK()-ing.",
				1, dwMsgType);
			DEBUGBREAK();
			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)


DONE:

	return (hr);
} // ParmVPDestroyGroupDPNMessageHandler
#undef DEBUG_SECTION
#define DEBUG_SECTION	""







#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVPAddToGroupDPNMessageHandler()"
//==================================================================================
// ParmVPAddToGroupDPNMessageHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT ParmVPAddToGroupDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT						hr = DPN_OK;
	PPARMVPADDTOGROUPCONTEXT	pContext = (PPARMVPADDTOGROUPCONTEXT) pvContext;
	BOOL						fSetEvent = FALSE;


	switch (dwMsgType)
	{
		case DPN_MSGID_ADD_PLAYER_TO_GROUP:
			PDPNMSG_ADD_PLAYER_TO_GROUP		pAddPlayerToGroupMsg;


			pAddPlayerToGroupMsg = (PDPNMSG_ADD_PLAYER_TO_GROUP) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_ADD_PLAYER_TO_GROUP", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pAddPlayerToGroupMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidGroup = %u/%x", 2, pAddPlayerToGroupMsg->dpnidGroup, pAddPlayerToGroupMsg->dpnidGroup);
			DPTEST_TRACE(pContext->hLog, "    pvGroupContext = %x", 1, pAddPlayerToGroupMsg->pvGroupContext);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pAddPlayerToGroupMsg->dpnidPlayer, pAddPlayerToGroupMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pAddPlayerToGroupMsg->pvPlayerContext);


			// Make sure we expect the indication.
			if (! pContext->fCanGetAddToGroup)
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_ADD_PLAYER_TO_GROUP (at %x)!  DEBUGBREAK()-ing.",
					1, pAddPlayerToGroupMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (message unexpected)


			// Validate the message.
			if (pAddPlayerToGroupMsg->dwSize != sizeof (DPNMSG_ADD_PLAYER_TO_GROUP))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_ADD_PLAYER_TO_GROUP is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pAddPlayerToGroupMsg->dwSize, sizeof (DPNMSG_ADD_PLAYER_TO_GROUP));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pAddPlayerToGroupMsg->dpnidGroup != pContext->dpnidGroup)
			{
				DPTEST_TRACE(pContext->hLog, "Group ID was wrong (%u/%x != %u/%x)!  DEBUGBREAK()-ing.",
					4, pAddPlayerToGroupMsg->dpnidGroup, pAddPlayerToGroupMsg->dpnidGroup,
					pContext->dpnidGroup, pContext->dpnidGroup);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (group ID is wrong)

			if (pAddPlayerToGroupMsg->pvGroupContext != NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Group has wrong context (%x != NULL)!  DEBUGBREAK()-ing.",
					1, pAddPlayerToGroupMsg->pvGroupContext);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (wrong group context)

			if (pAddPlayerToGroupMsg->dpnidPlayer != pContext->dpnidExpectedPlayer)
			{
				DPTEST_TRACE(pContext->hLog, "Player ID was wrong (%u/%x != %u/%x)!  DEBUGBREAK()-ing.",
					4, pAddPlayerToGroupMsg->dpnidPlayer, pAddPlayerToGroupMsg->dpnidPlayer,
					pContext->dpnidExpectedPlayer, pContext->dpnidExpectedPlayer);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (player ID is wrong)

			if (pAddPlayerToGroupMsg->pvPlayerContext != pContext->pvExpectedPlayerContext)
			{
				DPTEST_TRACE(pContext->hLog, "Player has wrong context (%x != %x)!  DEBUGBREAK()-ing.",
					2, pAddPlayerToGroupMsg->pvPlayerContext,
					pContext->pvExpectedPlayerContext);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (wrong player context)



			// Make sure this isn't a double indication.
			if (pContext->fGotAddToGroup)
			{
				DPTEST_TRACE(pContext->hLog, "Got add player to group twice!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (double completion)

			// Alert the test case that the indication came in.
			pContext->fGotAddToGroup = TRUE;

			if (pContext->hGotGroupMsgEvent != NULL)
			{
				if (! SetEvent(pContext->hGotGroupMsgEvent))
				{
					hr = GetLastError();
					DPTEST_TRACE(pContext->hLog, "Couldn't set got group msg event (%x)!  DEBUGBREAK()-ing.",
						1, pContext->hGotGroupMsgEvent);

					DEBUGBREAK();

					if (hr == S_OK)
						hr = E_FAIL;

					goto DONE;
				} // end if (couldn't set event)
			} // end if (there's a group msg event)
		  break;

		case DPN_MSGID_ASYNC_OP_COMPLETE:
			PDPNMSG_ASYNC_OP_COMPLETE	pAsyncOpCompleteMsg;


			pAsyncOpCompleteMsg = (PDPNMSG_ASYNC_OP_COMPLETE) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_ASYNC_OP_COMPLETE", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pAsyncOpCompleteMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    hAsyncOp = %x", 1, pAsyncOpCompleteMsg->hAsyncOp);
			DPTEST_TRACE(pContext->hLog, "    pvUserContext = %x", 1, pAsyncOpCompleteMsg->pvUserContext);
			DPTEST_TRACE(pContext->hLog, "    hResultCode = 0x%08x", 1, pAsyncOpCompleteMsg->hResultCode);


			// Make sure we expect the completion.
			if (! pContext->fAsyncOpCanComplete)
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_ASYNC_OP_COMPLETE (%x)!  DEBUGBREAK()-ing.",
					1, pAsyncOpCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (message unexpected)


			// Validate the completion.
			if (pAsyncOpCompleteMsg->dwSize != sizeof (DPNMSG_ASYNC_OP_COMPLETE))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_ASYNC_OP_COMPLETE is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pAsyncOpCompleteMsg->dwSize, sizeof (DPNMSG_ASYNC_OP_COMPLETE));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pAsyncOpCompleteMsg->hResultCode != DPN_OK)
			{
				DPTEST_TRACE(pContext->hLog, "Async op completed with failure!  DEBUGBREAK()-ing.  0x%08x",
					1, pAsyncOpCompleteMsg->hResultCode);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (wrong result code)


			// Make sure this isn't a double completion.
			if (pContext->fAsyncOpCompleted)
			{
				DPTEST_TRACE(pContext->hLog, "Async op completed twice (msg = %x)!  DEBUGBREAK()-ing.",
					1, pAsyncOpCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (double completion)

			// Alert the test case that the completion came in.
			pContext->fAsyncOpCompleted = TRUE;

			// Remember the async op handle for comparison by the main thread.
			pContext->dpnhCompletedAsyncOp = pAsyncOpCompleteMsg->hAsyncOp;

			if (! SetEvent(pContext->hAsyncOpCompletedEvent))
			{
				hr = GetLastError();
				DPTEST_TRACE(pContext->hLog, "Couldn't set async op completed event (%x)!  DEBUGBREAK()-ing.",
					1, pContext->hAsyncOpCompletedEvent);

				DEBUGBREAK();

				if (hr == S_OK)
					hr = E_FAIL;

				goto DONE;
			} // end if (couldn't set event)

			// XBOX - Handle async connect
			if(pAsyncOpCompleteMsg->pvUserContext)
			{
				SetEvent((HANDLE) pAsyncOpCompleteMsg->pvUserContext);
			}

		  break;

		case DPN_MSGID_CONNECT_COMPLETE:
			PDPNMSG_CONNECT_COMPLETE	pConnectCompleteMsg;


			pConnectCompleteMsg = (PDPNMSG_CONNECT_COMPLETE) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CONNECT_COMPLETE", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pConnectCompleteMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    hAsyncOp = %x", 1, pConnectCompleteMsg->hAsyncOp);
			DPTEST_TRACE(pContext->hLog, "    pvUserContext = %x", 1, pConnectCompleteMsg->pvUserContext);
			DPTEST_TRACE(pContext->hLog, "    hResultCode = 0x%08x", 1, pConnectCompleteMsg->hResultCode);
			DPTEST_TRACE(pContext->hLog, "    pvApplicationReplyData = %x", 1, pConnectCompleteMsg->pvApplicationReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwApplicationReplyDataSize = %u", 1, pConnectCompleteMsg->dwApplicationReplyDataSize);


			// Make sure we expect the completion.
			if (! pContext->fConnectCanComplete)
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_CONNECT_COMPLETE (%x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (message unexpected)


			// Validate the completion.
			if (pConnectCompleteMsg->dwSize != sizeof (DPNMSG_CONNECT_COMPLETE))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CONNECT_COMPLETE is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->dwSize, sizeof (DPNMSG_CONNECT_COMPLETE));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pConnectCompleteMsg->hResultCode != DPN_OK)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with failure!  DEBUGBREAK()-ing.  0x%08x",
					1, pConnectCompleteMsg->hResultCode);
				DEBUGBREAK();
				hr = pConnectCompleteMsg->hResultCode;
				goto DONE;
			} // end if (wrong result code)

			if ((pConnectCompleteMsg->pvApplicationReplyData != NULL) ||
				(pConnectCompleteMsg->dwApplicationReplyDataSize != 0))
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with unexpected reply data (ptr %x != NULL or size %u != 0)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->pvApplicationReplyData,
					pConnectCompleteMsg->dwApplicationReplyDataSize);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (unexpected reply data)


			// Make sure this isn't a double completion.
			if (pContext->fConnectCompleted)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed twice (msg = %x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (double completion)

			// Alert the test case that the completion came in.
			pContext->fConnectCompleted = TRUE;

			if(pConnectCompleteMsg->pvUserContext)
			{
				DPTEST_TRACE(pContext->hLog, "Signalling connect completion on event 0x%08x ", 1, pConnectCompleteMsg->pvUserContext);
				SetEvent((HANDLE) pConnectCompleteMsg->pvUserContext);
			}

		  break;

		case DPN_MSGID_CREATE_GROUP:
			PDPNMSG_CREATE_GROUP	pCreateGroupMsg;


			pCreateGroupMsg = (PDPNMSG_CREATE_GROUP) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CREATE_GROUP", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pCreateGroupMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidGroup = %u/%x", 2, pCreateGroupMsg->dpnidGroup, pCreateGroupMsg->dpnidGroup);
			DPTEST_TRACE(pContext->hLog, "    dpnidOwner = %u/%x", 2, pCreateGroupMsg->dpnidOwner, pCreateGroupMsg->dpnidOwner);
			DPTEST_TRACE(pContext->hLog, "    pvGroupContext = %x", 1, pCreateGroupMsg->pvGroupContext);


			// Make sure we expect the indication.
			if (! pContext->fCanGetCreateGroup)
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_CREATE_GROUP (at %x)!  DEBUGBREAK()-ing.",
					1, pCreateGroupMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (message unexpected)

			// Validate the message.
			if (pCreateGroupMsg->dwSize != sizeof (DPNMSG_CREATE_GROUP))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CREATE_GROUP is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pCreateGroupMsg->dwSize, sizeof (DPNMSG_CREATE_GROUP));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pCreateGroupMsg->dpnidGroup == 0)
			{
				DPTEST_TRACE(pContext->hLog, "Group created got invalid ID of 0!  DEBUGBREAK()-ing.", 0);
				hr = E_FAIL;
				goto DONE;
				break;
			} // end if (group ID is 0)

			if (pCreateGroupMsg->dpnidOwner != pContext->dpnidExpectedGroupOwner)
			{
				DPTEST_TRACE(pContext->hLog, "Group owner was wrong (%u/%x != %u/%x)!  DEBUGBREAK()-ing.",
					4, pCreateGroupMsg->dpnidOwner, pCreateGroupMsg->dpnidOwner,
					pContext->dpnidExpectedGroupOwner, pContext->dpnidExpectedGroupOwner);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (group owner is wrong)

			if (pCreateGroupMsg->pvGroupContext != NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Group has wrong context (%x != NULL)!  DEBUGBREAK()-ing.",
					1, pCreateGroupMsg->pvGroupContext);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (wrong context)



			// Make sure this isn't a double indication.
			if (pContext->dpnidGroup != 0)
			{
				DPTEST_TRACE(pContext->hLog, "Got create group twice!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (double completion)

			// Alert the test case that the indication came in.
			pContext->dpnidGroup = pCreateGroupMsg->dpnidGroup;

			if (pContext->hGotGroupMsgEvent != NULL)
			{
				if (! SetEvent(pContext->hGotGroupMsgEvent))
				{
					hr = GetLastError();
					DPTEST_TRACE(pContext->hLog, "Couldn't set got group msg event (%x)!  DEBUGBREAK()-ing.",
						1, pContext->hGotGroupMsgEvent);

					DEBUGBREAK();

					if (hr == S_OK)
						hr = E_FAIL;

					goto DONE;
				} // end if (couldn't set event)
			} // end if (there's a group msg event)
		  break;

		case DPN_MSGID_CREATE_PLAYER:
			PDPNMSG_CREATE_PLAYER	pCreatePlayerMsg;


			pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CREATE_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pCreatePlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pCreatePlayerMsg->dpnidPlayer, pCreatePlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pCreatePlayerMsg->pvPlayerContext);


			// Validate the indication.
			if (pCreatePlayerMsg->dwSize != sizeof (DPNMSG_CREATE_PLAYER))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CREATE_PLAYER is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pCreatePlayerMsg->dwSize, sizeof (DPNMSG_CREATE_PLAYER));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pCreatePlayerMsg->pvPlayerContext == NULL)
			{
				// Assume this is the remote player being created.  Store the
				// player context.
				if (pContext->fHost)
				{
					pCreatePlayerMsg->pvPlayerContext = &(pContext->dpnidClient);
					fSetEvent = TRUE;
				} // end if (host)
				else
				{
					pCreatePlayerMsg->pvPlayerContext = &(pContext->dpnidHost);
				} // end if (not host)
			} // end if (context is not set yet)


			// Make sure this isn't a duplicate message.
			if (*((DPNID*) pCreatePlayerMsg->pvPlayerContext) != 0)
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate CREATE_PLAYER (msg = %x)!  DEBUGBREAK()-ing.",
					1, pCreatePlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (already have ID)

			// Save the player ID.
			*((DPNID*) pCreatePlayerMsg->pvPlayerContext) = pCreatePlayerMsg->dpnidPlayer;


			// Now set the event, if we're supposed too.
			if (fSetEvent)
			{
				if (! SetEvent(pContext->hClientCreatedEvent))
				{
					hr = GetLastError();
					DPTEST_TRACE(pContext->hLog, "Couldn't set client created event (%x)!  DEBUGBREAK()-ing.",
						1, pContext->hClientCreatedEvent);

					DEBUGBREAK();

					if (hr == S_OK)
						hr = E_FAIL;

					goto DONE;
				} // end if (couldn't set event)
			} // end if (should set event)
		  break;

		case DPN_MSGID_DESTROY_GROUP:
			PDPNMSG_DESTROY_GROUP	pDestroyGroupMsg;


			pDestroyGroupMsg = (PDPNMSG_DESTROY_GROUP) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_DESTROY_GROUP", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pDestroyGroupMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidGroup = %u/%x", 2, pDestroyGroupMsg->dpnidGroup, pDestroyGroupMsg->dpnidGroup);
			DPTEST_TRACE(pContext->hLog, "    pvGroupContext = %x", 1, pDestroyGroupMsg->pvGroupContext);
			DPTEST_TRACE(pContext->hLog, "    dwReason = %u", 1, pDestroyGroupMsg->dwReason);

#pragma TODO(vanceo, "Validate DPN_MSGID_DESTROY_GROUP")
		  break;

		case DPN_MSGID_DESTROY_PLAYER:
			PDPNMSG_DESTROY_PLAYER	pDestroyPlayerMsg;


			pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_DESTROY_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pDestroyPlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pDestroyPlayerMsg->dpnidPlayer, pDestroyPlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pDestroyPlayerMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    dwReason = %x", 1, pDestroyPlayerMsg->dwReason);


			// Validate the indication.
			if (pDestroyPlayerMsg->dwSize != sizeof (DPNMSG_DESTROY_PLAYER))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_DESTROY_PLAYER is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pDestroyPlayerMsg->dwSize, sizeof (DPNMSG_DESTROY_PLAYER));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pDestroyPlayerMsg->pvPlayerContext == NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Player context is NULL!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (context is wrong)

			if (pDestroyPlayerMsg->dwReason != DPNDESTROYPLAYERREASON_NORMAL)
			{
				DPTEST_TRACE(pContext->hLog, "Player destruction reason is unexpected (%x != %x)!  DEBUGBREAK()-ing.",
					2, pDestroyPlayerMsg->dwReason, DPNDESTROYPLAYERREASON_NORMAL);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (reason is wrong)


			// Make sure this isn't a duplicate or bogus message.
			if ((*((DPNID*) pDestroyPlayerMsg->pvPlayerContext) == 0) ||
				(pDestroyPlayerMsg->dpnidPlayer != *((DPNID*) pDestroyPlayerMsg->pvPlayerContext)))
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate or unexpected DESTROY_PLAYER (msg = %x)!  DEBUGBREAK()-ing.",
					1, pDestroyPlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (already have ID)

			// Clear the player ID.
			*((DPNID*) pDestroyPlayerMsg->pvPlayerContext) = 0;
		  break;

		case DPN_MSGID_INDICATE_CONNECT:
			PDPNMSG_INDICATE_CONNECT	pIndicateConnectMsg;


			pIndicateConnectMsg = (PDPNMSG_INDICATE_CONNECT) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_INDICATE_CONNECT", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pIndicateConnectMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    pvUserConnectData = %x", 1, pIndicateConnectMsg->pvUserConnectData);
			DPTEST_TRACE(pContext->hLog, "    dwUserConnectDataSize = %u", 1, pIndicateConnectMsg->dwUserConnectDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyData = %x", 1, pIndicateConnectMsg->pvReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwReplyDataSize = %u", 1, pIndicateConnectMsg->dwReplyDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyContext = %x", 1, pIndicateConnectMsg->pvReplyContext);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pIndicateConnectMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    pAddressPlayer = 0x%08x", 1, pIndicateConnectMsg->pAddressPlayer);
			DPTEST_TRACE(pContext->hLog, "    pAddressDevice = 0x%08x", 1, pIndicateConnectMsg->pAddressDevice);

#pragma TODO(vanceo, "Validate DPN_MSGID_INDICATE_CONNECT")
		  break;

		case DPN_MSGID_REMOVE_PLAYER_FROM_GROUP:
			PDPNMSG_REMOVE_PLAYER_FROM_GROUP	pRemovePlayerFromGroupMsg;


			pRemovePlayerFromGroupMsg = (PDPNMSG_REMOVE_PLAYER_FROM_GROUP) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_REMOVE_PLAYER_FROM_GROUP", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pRemovePlayerFromGroupMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidGroup = %u/%x", 2, pRemovePlayerFromGroupMsg->dpnidGroup, pRemovePlayerFromGroupMsg->dpnidGroup);
			DPTEST_TRACE(pContext->hLog, "    pvGroupContext = %x", 1, pRemovePlayerFromGroupMsg->pvGroupContext);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pRemovePlayerFromGroupMsg->dpnidPlayer, pRemovePlayerFromGroupMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pRemovePlayerFromGroupMsg->pvPlayerContext);

#pragma BUGBUG(vanceo, "Validate DPN_MSGID_REMOVE_PLAYER_FROM_GROUP")
		  break;

		default:
			DPTEST_TRACE(pContext->hLog, "Got unexpected message type %x!  DEBUGBREAK()-ing.",
				1, dwMsgType);
			DEBUGBREAK();
			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)


DONE:

	return (hr);
} // ParmVPAddToGroupDPNMessageHandler
#undef DEBUG_SECTION
#define DEBUG_SECTION	""







#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVPRemoveFromGroupDPNMessageHandler()"
//==================================================================================
// ParmVPRemoveFromGroupDPNMessageHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT ParmVPRemoveFromGroupDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT							hr = DPN_OK;
	PPARMVPREMOVEFROMGROUPCONTEXT	pContext = (PPARMVPREMOVEFROMGROUPCONTEXT) pvContext;
	BOOL							fSetEvent = FALSE;


	switch (dwMsgType)
	{
		case DPN_MSGID_ADD_PLAYER_TO_GROUP:
			PDPNMSG_ADD_PLAYER_TO_GROUP		pAddPlayerToGroupMsg;


			pAddPlayerToGroupMsg = (PDPNMSG_ADD_PLAYER_TO_GROUP) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_ADD_PLAYER_TO_GROUP", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pAddPlayerToGroupMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidGroup = %u/%x", 2, pAddPlayerToGroupMsg->dpnidGroup, pAddPlayerToGroupMsg->dpnidGroup);
			DPTEST_TRACE(pContext->hLog, "    pvGroupContext = %x", 1, pAddPlayerToGroupMsg->pvGroupContext);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pAddPlayerToGroupMsg->dpnidPlayer, pAddPlayerToGroupMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pAddPlayerToGroupMsg->pvPlayerContext);


			// Make sure we expect the indication.
			if (! pContext->fCanGetAddToGroup)
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_ADD_PLAYER_TO_GROUP (at %x)!  DEBUGBREAK()-ing.",
					1, pAddPlayerToGroupMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (message unexpected)


			// Validate the message.
			if (pAddPlayerToGroupMsg->dwSize != sizeof (DPNMSG_ADD_PLAYER_TO_GROUP))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_ADD_PLAYER_TO_GROUP is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pAddPlayerToGroupMsg->dwSize, sizeof (DPNMSG_ADD_PLAYER_TO_GROUP));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pAddPlayerToGroupMsg->dpnidGroup != pContext->dpnidGroup)
			{
				DPTEST_TRACE(pContext->hLog, "Group ID was wrong (%u/%x != %u/%x)!  DEBUGBREAK()-ing.",
					4, pAddPlayerToGroupMsg->dpnidGroup, pAddPlayerToGroupMsg->dpnidGroup,
					pContext->dpnidGroup, pContext->dpnidGroup);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (group ID is wrong)

			if (pAddPlayerToGroupMsg->pvGroupContext != NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Group has wrong context (%x != NULL)!  DEBUGBREAK()-ing.",
					1, pAddPlayerToGroupMsg->pvGroupContext);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (wrong group context)

			if (pAddPlayerToGroupMsg->dpnidPlayer != pContext->dpnidExpectedPlayer)
			{
				DPTEST_TRACE(pContext->hLog, "Player ID was wrong (%u/%x != %u/%x)!  DEBUGBREAK()-ing.",
					4, pAddPlayerToGroupMsg->dpnidPlayer, pAddPlayerToGroupMsg->dpnidPlayer,
					pContext->dpnidExpectedPlayer, pContext->dpnidExpectedPlayer);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (player ID is wrong)

			if (pAddPlayerToGroupMsg->pvPlayerContext != pContext->pvExpectedPlayerContext)
			{
				DPTEST_TRACE(pContext->hLog, "Player has wrong context (%x != %x)!  DEBUGBREAK()-ing.",
					2, pAddPlayerToGroupMsg->pvPlayerContext,
					pContext->pvExpectedPlayerContext);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (wrong player context)



			// Make sure this isn't a double indication.
			if (pContext->fGotAddToGroup)
			{
				DPTEST_TRACE(pContext->hLog, "Got add player to group twice!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (double completion)

			// Alert the test case that the indication came in.
			pContext->fGotAddToGroup = TRUE;

			if (pContext->hGotGroupMsgEvent != NULL)
			{
				if (! SetEvent(pContext->hGotGroupMsgEvent))
				{
					hr = GetLastError();
					DPTEST_TRACE(pContext->hLog, "Couldn't set got group msg event (%x)!  DEBUGBREAK()-ing.",
						1, pContext->hGotGroupMsgEvent);

					DEBUGBREAK();

					if (hr == S_OK)
						hr = E_FAIL;

					goto DONE;
				} // end if (couldn't set event)
			} // end if (there's a group msg event)
		  break;

		case DPN_MSGID_ASYNC_OP_COMPLETE:
			PDPNMSG_ASYNC_OP_COMPLETE	pAsyncOpCompleteMsg;


			pAsyncOpCompleteMsg = (PDPNMSG_ASYNC_OP_COMPLETE) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_ASYNC_OP_COMPLETE", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pAsyncOpCompleteMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    hAsyncOp = %x", 1, pAsyncOpCompleteMsg->hAsyncOp);
			DPTEST_TRACE(pContext->hLog, "    pvUserContext = %x", 1, pAsyncOpCompleteMsg->pvUserContext);
			DPTEST_TRACE(pContext->hLog, "    hResultCode = 0x%08x", 1, pAsyncOpCompleteMsg->hResultCode);


			// Make sure we expect the completion.
			if (! pContext->fAsyncOpCanComplete)
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_ASYNC_OP_COMPLETE (%x)!  DEBUGBREAK()-ing.",
					1, pAsyncOpCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (message unexpected)


			// Validate the completion.
			if (pAsyncOpCompleteMsg->dwSize != sizeof (DPNMSG_ASYNC_OP_COMPLETE))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_ASYNC_OP_COMPLETE is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pAsyncOpCompleteMsg->dwSize, sizeof (DPNMSG_ASYNC_OP_COMPLETE));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pAsyncOpCompleteMsg->hResultCode != DPN_OK)
			{
				DPTEST_TRACE(pContext->hLog, "Async op completed with failure!  DEBUGBREAK()-ing.  0x%08x",
					1, pAsyncOpCompleteMsg->hResultCode);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (wrong result code)


			// Make sure this isn't a double completion.
			if (pContext->fAsyncOpCompleted)
			{
				DPTEST_TRACE(pContext->hLog, "Async op completed twice (msg = %x)!  DEBUGBREAK()-ing.",
					1, pAsyncOpCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (double completion)

			// Alert the test case that the completion came in.
			pContext->fAsyncOpCompleted = TRUE;

			// Remember the async op handle for comparison by the main thread.
			pContext->dpnhCompletedAsyncOp = pAsyncOpCompleteMsg->hAsyncOp;

			if (! SetEvent(pContext->hAsyncOpCompletedEvent))
			{
				hr = GetLastError();
				DPTEST_TRACE(pContext->hLog, "Couldn't set async op completed event (%x)!  DEBUGBREAK()-ing.",
					1, pContext->hAsyncOpCompletedEvent);

				DEBUGBREAK();

				if (hr == S_OK)
					hr = E_FAIL;

				hr = E_FAIL;
				goto DONE;
			} // end if (couldn't set event)

			// XBOX - Handle async ops
			if(pAsyncOpCompleteMsg->pvUserContext)
			{
				SetEvent((HANDLE) pAsyncOpCompleteMsg->pvUserContext);
			}

		  break;

		case DPN_MSGID_CONNECT_COMPLETE:
			PDPNMSG_CONNECT_COMPLETE	pConnectCompleteMsg;


			pConnectCompleteMsg = (PDPNMSG_CONNECT_COMPLETE) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CONNECT_COMPLETE", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pConnectCompleteMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    hAsyncOp = %x", 1, pConnectCompleteMsg->hAsyncOp);
			DPTEST_TRACE(pContext->hLog, "    pvUserContext = %x", 1, pConnectCompleteMsg->pvUserContext);
			DPTEST_TRACE(pContext->hLog, "    hResultCode = 0x%08x", 1, pConnectCompleteMsg->hResultCode);
			DPTEST_TRACE(pContext->hLog, "    pvApplicationReplyData = %x", 1, pConnectCompleteMsg->pvApplicationReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwApplicationReplyDataSize = %u", 1, pConnectCompleteMsg->dwApplicationReplyDataSize);


			// Make sure we expect the completion.
			if (! pContext->fConnectCanComplete)
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_CONNECT_COMPLETE (%x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (message unexpected)


			// Validate the completion.
			if (pConnectCompleteMsg->dwSize != sizeof (DPNMSG_CONNECT_COMPLETE))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CONNECT_COMPLETE is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->dwSize, sizeof (DPNMSG_CONNECT_COMPLETE));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pConnectCompleteMsg->hResultCode != DPN_OK)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with failure!  DEBUGBREAK()-ing.  0x%08x",
					1, pConnectCompleteMsg->hResultCode);
				DEBUGBREAK();
				hr = pConnectCompleteMsg->hResultCode;
				goto DONE;
			} // end if (wrong result code)

			if ((pConnectCompleteMsg->pvApplicationReplyData != NULL) ||
				(pConnectCompleteMsg->dwApplicationReplyDataSize != 0))
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with unexpected reply data (ptr %x != NULL or size %u != 0)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->pvApplicationReplyData,
					pConnectCompleteMsg->dwApplicationReplyDataSize);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (unexpected reply data)


			// Make sure this isn't a double completion.
			if (pContext->fConnectCompleted)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed twice (msg = %x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (double completion)

			// Alert the test case that the completion came in.
			pContext->fConnectCompleted = TRUE;

			// XBOX - Handle async connect
			if(pConnectCompleteMsg->pvUserContext)
			{
				SetEvent((HANDLE) pConnectCompleteMsg->pvUserContext);
			}

		  break;

		case DPN_MSGID_CREATE_GROUP:
			PDPNMSG_CREATE_GROUP	pCreateGroupMsg;


			pCreateGroupMsg = (PDPNMSG_CREATE_GROUP) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CREATE_GROUP", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pCreateGroupMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidGroup = %u/%x", 2, pCreateGroupMsg->dpnidGroup, pCreateGroupMsg->dpnidGroup);
			DPTEST_TRACE(pContext->hLog, "    dpnidOwner = %u/%x", 2, pCreateGroupMsg->dpnidOwner, pCreateGroupMsg->dpnidOwner);
			DPTEST_TRACE(pContext->hLog, "    pvGroupContext = %x", 1, pCreateGroupMsg->pvGroupContext);


			// Make sure we expect the indication.
			if (! pContext->fCanGetCreateGroup)
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_CREATE_GROUP (at %x)!  DEBUGBREAK()-ing.",
					1, pCreateGroupMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (message unexpected)

			// Validate the message.
			if (pCreateGroupMsg->dwSize != sizeof (DPNMSG_CREATE_GROUP))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CREATE_GROUP is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pCreateGroupMsg->dwSize, sizeof (DPNMSG_CREATE_GROUP));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pCreateGroupMsg->dpnidGroup == 0)
			{
				DPTEST_TRACE(pContext->hLog, "Group created got invalid ID of 0!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (group ID is 0)

			if (pCreateGroupMsg->dpnidOwner != pContext->dpnidExpectedGroupOwner)
			{
				DPTEST_TRACE(pContext->hLog, "Group owner was wrong (%u/%x != %u/%x)!  DEBUGBREAK()-ing.",
					4, pCreateGroupMsg->dpnidOwner, pCreateGroupMsg->dpnidOwner,
					pContext->dpnidExpectedGroupOwner, pContext->dpnidExpectedGroupOwner);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (group owner is wrong)

			if (pCreateGroupMsg->pvGroupContext != NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Group has wrong context (%x != NULL)!  DEBUGBREAK()-ing.",
					1, pCreateGroupMsg->pvGroupContext);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (wrong context)



			// Make sure this isn't a double indication.
			if (pContext->dpnidGroup != 0)
			{
				DPTEST_TRACE(pContext->hLog, "Got create group twice!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (double completion)

			// Alert the test case that the indication came in.
			pContext->dpnidGroup = pCreateGroupMsg->dpnidGroup;

			if (pContext->hGotGroupMsgEvent != NULL)
			{
				if (! SetEvent(pContext->hGotGroupMsgEvent))
				{
					hr = GetLastError();
					DPTEST_TRACE(pContext->hLog, "Couldn't set got group msg event (%x)!  DEBUGBREAK()-ing.",
						1, pContext->hGotGroupMsgEvent);

					DEBUGBREAK();

					if (hr == S_OK)
						hr = E_FAIL;

					goto DONE;
				} // end if (couldn't set event)
			} // end if (there's a group msg event)
		  break;

		case DPN_MSGID_CREATE_PLAYER:
			PDPNMSG_CREATE_PLAYER	pCreatePlayerMsg;


			pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CREATE_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pCreatePlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pCreatePlayerMsg->dpnidPlayer, pCreatePlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pCreatePlayerMsg->pvPlayerContext);


			// Validate the indication.
			if (pCreatePlayerMsg->dwSize != sizeof (DPNMSG_CREATE_PLAYER))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CREATE_PLAYER is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pCreatePlayerMsg->dwSize, sizeof (DPNMSG_CREATE_PLAYER));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pCreatePlayerMsg->pvPlayerContext == NULL)
			{
				// Assume this is the remote player being created.  Store the
				// player context.
				if (pContext->fHost)
				{
					pCreatePlayerMsg->pvPlayerContext = &(pContext->dpnidClient);
					fSetEvent = TRUE;
				} // end if (host)
				else
				{
					pCreatePlayerMsg->pvPlayerContext = &(pContext->dpnidHost);
				} // end if (not host)
			} // end if (context is not set yet)


			// Make sure this isn't a duplicate message.
			if (*((DPNID*) pCreatePlayerMsg->pvPlayerContext) != 0)
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate CREATE_PLAYER (msg = %x)!  DEBUGBREAK()-ing.",
					1, pCreatePlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (already have ID)

			// Save the player ID.
			*((DPNID*) pCreatePlayerMsg->pvPlayerContext) = pCreatePlayerMsg->dpnidPlayer;


			// Now set the event, if we're supposed too.
			if (fSetEvent)
			{
				if (! SetEvent(pContext->hClientCreatedEvent))
				{
					hr = GetLastError();
					DPTEST_TRACE(pContext->hLog, "Couldn't set client created event (%x)!  DEBUGBREAK()-ing.",
						1, pContext->hClientCreatedEvent);

					DEBUGBREAK();

					if (hr == S_OK)
						hr = E_FAIL;

					goto DONE;
				} // end if (couldn't set event)
			} // end if (should set event)
		  break;

		case DPN_MSGID_DESTROY_GROUP:
			PDPNMSG_DESTROY_GROUP	pDestroyGroupMsg;


			pDestroyGroupMsg = (PDPNMSG_DESTROY_GROUP) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_DESTROY_GROUP", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pDestroyGroupMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidGroup = %u/%x", 2, pDestroyGroupMsg->dpnidGroup, pDestroyGroupMsg->dpnidGroup);
			DPTEST_TRACE(pContext->hLog, "    pvGroupContext = %x", 1, pDestroyGroupMsg->pvGroupContext);
			DPTEST_TRACE(pContext->hLog, "    dwReason = %u", 1, pDestroyGroupMsg->dwReason);

#pragma TODO(vanceo, "Validate DPN_MSGID_DESTROY_GROUP")
		  break;

		case DPN_MSGID_DESTROY_PLAYER:
			PDPNMSG_DESTROY_PLAYER	pDestroyPlayerMsg;


			pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_DESTROY_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pDestroyPlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pDestroyPlayerMsg->dpnidPlayer, pDestroyPlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pDestroyPlayerMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    dwReason = %x", 1, pDestroyPlayerMsg->dwReason);


			// Validate the indication.
			if (pDestroyPlayerMsg->dwSize != sizeof (DPNMSG_DESTROY_PLAYER))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_DESTROY_PLAYER is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pDestroyPlayerMsg->dwSize, sizeof (DPNMSG_DESTROY_PLAYER));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pDestroyPlayerMsg->pvPlayerContext == NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Player context is NULL!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (context is wrong)

			if (pDestroyPlayerMsg->dwReason != DPNDESTROYPLAYERREASON_NORMAL)
			{
				DPTEST_TRACE(pContext->hLog, "Player destruction reason is unexpected (%x != %x)!  DEBUGBREAK()-ing.",
					2, pDestroyPlayerMsg->dwReason, DPNDESTROYPLAYERREASON_NORMAL);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (reason is wrong)


			// Make sure this isn't a duplicate or bogus message.
			if ((*((DPNID*) pDestroyPlayerMsg->pvPlayerContext) == 0) ||
				(pDestroyPlayerMsg->dpnidPlayer != *((DPNID*) pDestroyPlayerMsg->pvPlayerContext)))
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate or unexpected DESTROY_PLAYER (msg = %x)!  DEBUGBREAK()-ing.",
					1, pDestroyPlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (already have ID)

			// Clear the player ID.
			*((DPNID*) pDestroyPlayerMsg->pvPlayerContext) = 0;
		  break;

		case DPN_MSGID_INDICATE_CONNECT:
			PDPNMSG_INDICATE_CONNECT	pIndicateConnectMsg;


			pIndicateConnectMsg = (PDPNMSG_INDICATE_CONNECT) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_INDICATE_CONNECT", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pIndicateConnectMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    pvUserConnectData = %x", 1, pIndicateConnectMsg->pvUserConnectData);
			DPTEST_TRACE(pContext->hLog, "    dwUserConnectDataSize = %u", 1, pIndicateConnectMsg->dwUserConnectDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyData = %x", 1, pIndicateConnectMsg->pvReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwReplyDataSize = %u", 1, pIndicateConnectMsg->dwReplyDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyContext = %x", 1, pIndicateConnectMsg->pvReplyContext);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pIndicateConnectMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    pAddressPlayer = 0x%08x", 1, pIndicateConnectMsg->pAddressPlayer);
			DPTEST_TRACE(pContext->hLog, "    pAddressDevice = 0x%08x", 1, pIndicateConnectMsg->pAddressDevice);

#pragma TODO(vanceo, "Validate DPN_MSGID_INDICATE_CONNECT")
		  break;

		case DPN_MSGID_REMOVE_PLAYER_FROM_GROUP:
			PDPNMSG_REMOVE_PLAYER_FROM_GROUP	pRemovePlayerFromGroupMsg;


			pRemovePlayerFromGroupMsg = (PDPNMSG_REMOVE_PLAYER_FROM_GROUP) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_REMOVE_PLAYER_FROM_GROUP", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pRemovePlayerFromGroupMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidGroup = %u/%x", 2, pRemovePlayerFromGroupMsg->dpnidGroup, pRemovePlayerFromGroupMsg->dpnidGroup);
			DPTEST_TRACE(pContext->hLog, "    pvGroupContext = %x", 1, pRemovePlayerFromGroupMsg->pvGroupContext);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pRemovePlayerFromGroupMsg->dpnidPlayer, pRemovePlayerFromGroupMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pRemovePlayerFromGroupMsg->pvPlayerContext);


			// Make sure we expect the indication.
			if (! pContext->fCanGetRemoveFromGroup)
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_REMOVE_PLAYER_FROM_GROUP (at %x)!  DEBUGBREAK()-ing.",
					1, pRemovePlayerFromGroupMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (message unexpected)


			// Validate the message.
			if (pRemovePlayerFromGroupMsg->dwSize != sizeof (DPNMSG_REMOVE_PLAYER_FROM_GROUP))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_REMOVE_PLAYER_FROM_GROUP is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pRemovePlayerFromGroupMsg->dwSize, sizeof (DPNMSG_REMOVE_PLAYER_FROM_GROUP));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pRemovePlayerFromGroupMsg->dpnidGroup != pContext->dpnidGroup)
			{
				DPTEST_TRACE(pContext->hLog, "Group ID was wrong (%u/%x != %u/%x)!  DEBUGBREAK()-ing.",
					4, pRemovePlayerFromGroupMsg->dpnidGroup,
					pRemovePlayerFromGroupMsg->dpnidGroup,
					pContext->dpnidGroup, pContext->dpnidGroup);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (group ID is wrong)

			if (pRemovePlayerFromGroupMsg->pvGroupContext != NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Group has wrong context (%x != NULL)!  DEBUGBREAK()-ing.",
					1, pRemovePlayerFromGroupMsg->pvGroupContext);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (wrong group context)

			if (pRemovePlayerFromGroupMsg->dpnidPlayer != pContext->dpnidExpectedPlayer)
			{
				DPTEST_TRACE(pContext->hLog, "Player ID was wrong (%u/%x != %u/%x)!  DEBUGBREAK()-ing.",
					4, pRemovePlayerFromGroupMsg->dpnidPlayer,
					pRemovePlayerFromGroupMsg->dpnidPlayer,
					pContext->dpnidExpectedPlayer, pContext->dpnidExpectedPlayer);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (player ID is wrong)

			if (pRemovePlayerFromGroupMsg->pvPlayerContext != pContext->pvExpectedPlayerContext)
			{
				DPTEST_TRACE(pContext->hLog, "Player has wrong context (%x != %x)!  DEBUGBREAK()-ing.",
					2, pRemovePlayerFromGroupMsg->pvPlayerContext,
					pContext->pvExpectedPlayerContext);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (wrong player context)



			// Make sure this isn't a double indication.
			if (pContext->fGotRemoveFromGroup)
			{
				DPTEST_TRACE(pContext->hLog, "Got remove player from group twice!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (double completion)

			// Alert the test case that the indication came in.
			pContext->fGotRemoveFromGroup = TRUE;

			if (pContext->hGotGroupMsgEvent != NULL)
			{
				if (! SetEvent(pContext->hGotGroupMsgEvent))
				{
					hr = GetLastError();
					DPTEST_TRACE(pContext->hLog, "Couldn't set got group msg event (%x)!  DEBUGBREAK()-ing.",
						1, pContext->hGotGroupMsgEvent);

					DEBUGBREAK();

					if (hr == S_OK)
						hr = E_FAIL;

					goto DONE;
				} // end if (couldn't set event)
			} // end if (there's a group msg event)
		  break;

		default:
			DPTEST_TRACE(pContext->hLog, "Got unexpected message type %x!  DEBUGBREAK()-ing.",
				1, dwMsgType);
			DEBUGBREAK();
			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)


DONE:

	return (hr);
} // ParmVPRemoveFromGroupDPNMessageHandler
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVPSetGroupInfoDPNMessageHandler()"
//==================================================================================
// ParmVPSetGroupInfoDPNMessageHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT ParmVPSetGroupInfoDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT						hr = DPN_OK;
	PPARMVPSETGROUPINFOCONTEXT	pContext = (PPARMVPSETGROUPINFOCONTEXT) pvContext;
	BOOL						fSetEvent = FALSE;


	switch (dwMsgType)
	{
		case DPN_MSGID_ASYNC_OP_COMPLETE:
			PDPNMSG_ASYNC_OP_COMPLETE	pAsyncOpCompleteMsg;


			pAsyncOpCompleteMsg = (PDPNMSG_ASYNC_OP_COMPLETE) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_ASYNC_OP_COMPLETE", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pAsyncOpCompleteMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    hAsyncOp = %x", 1, pAsyncOpCompleteMsg->hAsyncOp);
			DPTEST_TRACE(pContext->hLog, "    pvUserContext = %x", 1, pAsyncOpCompleteMsg->pvUserContext);
			DPTEST_TRACE(pContext->hLog, "    hResultCode = 0x%08x", 1, pAsyncOpCompleteMsg->hResultCode);


			// Make sure we expect the completion.
			if (! pContext->fAsyncOpCanComplete)
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_ASYNC_OP_COMPLETE (%x)!  DEBUGBREAK()-ing.",
					1, pAsyncOpCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (message unexpected)


			// Validate the completion.
			if (pAsyncOpCompleteMsg->dwSize != sizeof (DPNMSG_ASYNC_OP_COMPLETE))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_ASYNC_OP_COMPLETE is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pAsyncOpCompleteMsg->dwSize, sizeof (DPNMSG_ASYNC_OP_COMPLETE));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pAsyncOpCompleteMsg->hResultCode != DPN_OK)
			{
				DPTEST_TRACE(pContext->hLog, "Async op completed with failure!  DEBUGBREAK()-ing.  0x%08x",
					1, pAsyncOpCompleteMsg->hResultCode);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (wrong result code)


			// Make sure this isn't a double completion.
			if (pContext->fAsyncOpCompleted)
			{
				DPTEST_TRACE(pContext->hLog, "Async op completed twice (msg = %x)!  DEBUGBREAK()-ing.",
					1, pAsyncOpCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (double completion)

			// Alert the test case that the completion came in.
			pContext->fAsyncOpCompleted = TRUE;

			// Remember the async op handle for comparison by the main thread.
			pContext->dpnhCompletedAsyncOp = pAsyncOpCompleteMsg->hAsyncOp;

			if (! SetEvent(pContext->hAsyncOpCompletedEvent))
			{
				hr = GetLastError();
				DPTEST_TRACE(pContext->hLog, "Couldn't set async op completed event (%x)!  DEBUGBREAK()-ing.",
					1, pContext->hAsyncOpCompletedEvent);

				DEBUGBREAK();

				if (hr == S_OK)
					hr = E_FAIL;

				goto DONE;
			} // end if (couldn't set event)

			// XBOX - Handle async ops
			if(pAsyncOpCompleteMsg->pvUserContext)
			{
				SetEvent((HANDLE) pAsyncOpCompleteMsg->pvUserContext);
			}
		  break;

		case DPN_MSGID_CONNECT_COMPLETE:
			PDPNMSG_CONNECT_COMPLETE	pConnectCompleteMsg;


			pConnectCompleteMsg = (PDPNMSG_CONNECT_COMPLETE) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CONNECT_COMPLETE", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pConnectCompleteMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    hAsyncOp = %x", 1, pConnectCompleteMsg->hAsyncOp);
			DPTEST_TRACE(pContext->hLog, "    pvUserContext = %x", 1, pConnectCompleteMsg->pvUserContext);
			DPTEST_TRACE(pContext->hLog, "    hResultCode = 0x%08x", 1, pConnectCompleteMsg->hResultCode);
			DPTEST_TRACE(pContext->hLog, "    pvApplicationReplyData = %x", 1, pConnectCompleteMsg->pvApplicationReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwApplicationReplyDataSize = %u", 1, pConnectCompleteMsg->dwApplicationReplyDataSize);


			// Make sure we expect the completion.
			if (! pContext->fConnectCanComplete)
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_CONNECT_COMPLETE (%x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (message unexpected)


			// Validate the completion.
			if (pConnectCompleteMsg->dwSize != sizeof (DPNMSG_CONNECT_COMPLETE))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CONNECT_COMPLETE is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->dwSize, sizeof (DPNMSG_CONNECT_COMPLETE));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pConnectCompleteMsg->hResultCode != DPN_OK)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with failure!  DEBUGBREAK()-ing.  0x%08x",
					1, pConnectCompleteMsg->hResultCode);
				DEBUGBREAK();
				hr = pConnectCompleteMsg->hResultCode;
				goto DONE;
			} // end if (wrong result code)

			if ((pConnectCompleteMsg->pvApplicationReplyData != NULL) ||
				(pConnectCompleteMsg->dwApplicationReplyDataSize != 0))
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with unexpected reply data (ptr %x != NULL or size %u != 0)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->pvApplicationReplyData,
					pConnectCompleteMsg->dwApplicationReplyDataSize);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (unexpected reply data)


			// Make sure this isn't a double completion.
			if (pContext->fConnectCompleted)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed twice (msg = %x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (double completion)

			// Alert the test case that the completion came in.
			pContext->fConnectCompleted = TRUE;

			// XBOX - Handle async connect
			if(pConnectCompleteMsg->pvUserContext)
			{
				SetEvent((HANDLE) pConnectCompleteMsg->pvUserContext);
			}
		  break;

		case DPN_MSGID_CREATE_GROUP:
			PDPNMSG_CREATE_GROUP	pCreateGroupMsg;


			pCreateGroupMsg = (PDPNMSG_CREATE_GROUP) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CREATE_GROUP", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pCreateGroupMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidGroup = %u/%x", 2, pCreateGroupMsg->dpnidGroup, pCreateGroupMsg->dpnidGroup);
			DPTEST_TRACE(pContext->hLog, "    dpnidOwner = %u/%x", 2, pCreateGroupMsg->dpnidOwner, pCreateGroupMsg->dpnidOwner);
			DPTEST_TRACE(pContext->hLog, "    pvGroupContext = %x", 1, pCreateGroupMsg->pvGroupContext);


			// Make sure we expect the indication.
			if (! pContext->fCanGetCreateGroup)
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_CREATE_GROUP (at %x)!  DEBUGBREAK()-ing.",
					1, pCreateGroupMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (message unexpected)

			// Validate the message.
			if (pCreateGroupMsg->dwSize != sizeof (DPNMSG_CREATE_GROUP))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CREATE_GROUP is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pCreateGroupMsg->dwSize, sizeof (DPNMSG_CREATE_GROUP));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pCreateGroupMsg->dpnidGroup == 0)
			{
				DPTEST_TRACE(pContext->hLog, "Group created got invalid ID of 0!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (group ID is 0)

			if (pCreateGroupMsg->dpnidOwner != pContext->dpnidExpectedGroupOwner)
			{
				DPTEST_TRACE(pContext->hLog, "Group owner was wrong (%u/%x != %u/%x)!  DEBUGBREAK()-ing.",
					4, pCreateGroupMsg->dpnidOwner, pCreateGroupMsg->dpnidOwner,
					pContext->dpnidExpectedGroupOwner, pContext->dpnidExpectedGroupOwner);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (group owner is wrong)

			if (pCreateGroupMsg->pvGroupContext != NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Group has wrong context (%x != NULL)!  DEBUGBREAK()-ing.",
					1, pCreateGroupMsg->pvGroupContext);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (wrong context)



			// Make sure this isn't a double indication.
			if (pContext->dpnidGroup != 0)
			{
				DPTEST_TRACE(pContext->hLog, "Got create group twice!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (double completion)

			// Alert the test case that the indication came in.
			pContext->dpnidGroup = pCreateGroupMsg->dpnidGroup;

			if (pContext->hGotGroupMsgEvent != NULL)
			{
				if (! SetEvent(pContext->hGotGroupMsgEvent))
				{
					hr = GetLastError();
					DPTEST_TRACE(pContext->hLog, "Couldn't set got group msg event (%x)!  DEBUGBREAK()-ing.",
						1, pContext->hGotGroupMsgEvent);

					DEBUGBREAK();

					if (hr == S_OK)
						hr = E_FAIL;

					goto DONE;
				} // end if (couldn't set event)
			} // end if (there's a group msg event)
		  break;

		case DPN_MSGID_CREATE_PLAYER:
			PDPNMSG_CREATE_PLAYER	pCreatePlayerMsg;


			pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CREATE_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pCreatePlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pCreatePlayerMsg->dpnidPlayer, pCreatePlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pCreatePlayerMsg->pvPlayerContext);


			// Validate the indication.
			if (pCreatePlayerMsg->dwSize != sizeof (DPNMSG_CREATE_PLAYER))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CREATE_PLAYER is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pCreatePlayerMsg->dwSize, sizeof (DPNMSG_CREATE_PLAYER));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pCreatePlayerMsg->pvPlayerContext == NULL)
			{
				// Assume this is the remote player being created.  Store the
				// player context.
				if (pContext->fHost)
				{
					pCreatePlayerMsg->pvPlayerContext = &(pContext->dpnidClient);
					fSetEvent = TRUE;
				} // end if (host)
				else
				{
					pCreatePlayerMsg->pvPlayerContext = &(pContext->dpnidHost);
				} // end if (not host)
			} // end if (context is not set yet)


			// Make sure this isn't a duplicate message.
			if (*((DPNID*) pCreatePlayerMsg->pvPlayerContext) != 0)
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate CREATE_PLAYER (msg = %x)!  DEBUGBREAK()-ing.",
					1, pCreatePlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (already have ID)

			// Save the player ID.
			*((DPNID*) pCreatePlayerMsg->pvPlayerContext) = pCreatePlayerMsg->dpnidPlayer;


			// Now set the event, if we're supposed too.
			if (fSetEvent)
			{
				if (! SetEvent(pContext->hClientCreatedEvent))
				{
					hr = GetLastError();
					DPTEST_TRACE(pContext->hLog, "Couldn't set client created event (%x)!  DEBUGBREAK()-ing.",
						1, pContext->hClientCreatedEvent);

					DEBUGBREAK();

					if (hr == S_OK)
						hr = E_FAIL;

					goto DONE;
				} // end if (couldn't set event)
			} // end if (should set event)
		  break;

		case DPN_MSGID_DESTROY_GROUP:
			PDPNMSG_DESTROY_GROUP	pDestroyGroupMsg;


			pDestroyGroupMsg = (PDPNMSG_DESTROY_GROUP) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_DESTROY_GROUP", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pDestroyGroupMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidGroup = %u/%x", 2, pDestroyGroupMsg->dpnidGroup, pDestroyGroupMsg->dpnidGroup);
			DPTEST_TRACE(pContext->hLog, "    pvGroupContext = %x", 1, pDestroyGroupMsg->pvGroupContext);
			DPTEST_TRACE(pContext->hLog, "    dwReason = %u", 1, pDestroyGroupMsg->dwReason);

#pragma TODO(vanceo, "Validate DPN_MSGID_DESTROY_GROUP")
		  break;

		case DPN_MSGID_DESTROY_PLAYER:
			PDPNMSG_DESTROY_PLAYER	pDestroyPlayerMsg;


			pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_DESTROY_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pDestroyPlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pDestroyPlayerMsg->dpnidPlayer, pDestroyPlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pDestroyPlayerMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    dwReason = %x", 1, pDestroyPlayerMsg->dwReason);


			// Validate the indication.
			if (pDestroyPlayerMsg->dwSize != sizeof (DPNMSG_DESTROY_PLAYER))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_DESTROY_PLAYER is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pDestroyPlayerMsg->dwSize, sizeof (DPNMSG_DESTROY_PLAYER));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pDestroyPlayerMsg->pvPlayerContext == NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Player context is NULL!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (context is wrong)

			if (pDestroyPlayerMsg->dwReason != DPNDESTROYPLAYERREASON_NORMAL)
			{
				DPTEST_TRACE(pContext->hLog, "Player destruction reason is unexpected (%x != %x)!  DEBUGBREAK()-ing.",
					2, pDestroyPlayerMsg->dwReason, DPNDESTROYPLAYERREASON_NORMAL);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (reason is wrong)


			// Make sure this isn't a duplicate or bogus message.
			if ((*((DPNID*) pDestroyPlayerMsg->pvPlayerContext) == 0) ||
				(pDestroyPlayerMsg->dpnidPlayer != *((DPNID*) pDestroyPlayerMsg->pvPlayerContext)))
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate or unexpected DESTROY_PLAYER (msg = %x)!  DEBUGBREAK()-ing.",
					1, pDestroyPlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (already have ID)

			// Clear the player ID.
			*((DPNID*) pDestroyPlayerMsg->pvPlayerContext) = 0;
		  break;

		case DPN_MSGID_GROUP_INFO:
			PDPNMSG_GROUP_INFO		pGroupInfoMsg;


			pGroupInfoMsg = (PDPNMSG_GROUP_INFO) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_GROUP_INFO", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pGroupInfoMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidGroup = %u/%x", 2, pGroupInfoMsg->dpnidGroup, pGroupInfoMsg->dpnidGroup);
			DPTEST_TRACE(pContext->hLog, "    pvGroupContext = %x", 1, pGroupInfoMsg->pvGroupContext);


			// Make sure we expect the indication.
			if (! pContext->fCanGetGroupInfo)
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_GROUP_INFO!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (message unexpected)

#pragma TODO(vanceo, "Validate DPN_MSGID_GROUP_INFO")

			// Make sure this isn't a double indication.
			if (pContext->fGotGroupInfo)
			{
				DPTEST_TRACE(pContext->hLog, "Group info update was indicated twice!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (double completion)

			// Alert the test case that the indication came in.
			pContext->fGotGroupInfo = TRUE;

			if (pContext->hGotGroupMsgEvent != NULL)
			{
				if (! SetEvent(pContext->hGotGroupMsgEvent))
				{
					hr = GetLastError();
					DPTEST_TRACE(pContext->hLog, "Couldn't set got group msg event (%x)!  DEBUGBREAK()-ing.",
						1, pContext->hGotGroupMsgEvent);

					DEBUGBREAK();

					if (hr == S_OK)
						hr = E_FAIL;

					goto DONE;
				} // end if (couldn't set event)
			} // end if (have event)
		  break;

		case DPN_MSGID_INDICATE_CONNECT:
			PDPNMSG_INDICATE_CONNECT	pIndicateConnectMsg;


			pIndicateConnectMsg = (PDPNMSG_INDICATE_CONNECT) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_INDICATE_CONNECT", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pIndicateConnectMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    pvUserConnectData = %x", 1, pIndicateConnectMsg->pvUserConnectData);
			DPTEST_TRACE(pContext->hLog, "    dwUserConnectDataSize = %u", 1, pIndicateConnectMsg->dwUserConnectDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyData = %x", 1, pIndicateConnectMsg->pvReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwReplyDataSize = %u", 1, pIndicateConnectMsg->dwReplyDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyContext = %x", 1, pIndicateConnectMsg->pvReplyContext);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pIndicateConnectMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    pAddressPlayer = 0x%08x", 1, pIndicateConnectMsg->pAddressPlayer);
			DPTEST_TRACE(pContext->hLog, "    pAddressDevice = 0x%08x", 1, pIndicateConnectMsg->pAddressDevice);

#pragma TODO(vanceo, "Validate DPN_MSGID_INDICATE_CONNECT")
		  break;

		default:
			DPTEST_TRACE(pContext->hLog, "Got unexpected message type %x!  DEBUGBREAK()-ing.",
				1, dwMsgType);
			DEBUGBREAK();
			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)


DONE:

	return (hr);
} // ParmVPSetGroupInfoDPNMessageHandler
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVPGetGroupInfoDPNMessageHandler()"
//==================================================================================
// ParmVPGetGroupInfoDPNMessageHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT ParmVPGetGroupInfoDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT						hr = DPN_OK;
	PPARMVPGETGROUPINFOCONTEXT	pContext = (PPARMVPGETGROUPINFOCONTEXT) pvContext;
	BOOL						fSetEvent = FALSE;


	switch (dwMsgType)
	{
		case DPN_MSGID_ASYNC_OP_COMPLETE:
			PDPNMSG_ASYNC_OP_COMPLETE	pAsyncOpCompleteMsg;


			pAsyncOpCompleteMsg = (PDPNMSG_ASYNC_OP_COMPLETE) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_ASYNC_OP_COMPLETE", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pAsyncOpCompleteMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    hAsyncOp = %x", 1, pAsyncOpCompleteMsg->hAsyncOp);
			DPTEST_TRACE(pContext->hLog, "    pvUserContext = %x", 1, pAsyncOpCompleteMsg->pvUserContext);
			DPTEST_TRACE(pContext->hLog, "    hResultCode = 0x%08x", 1, pAsyncOpCompleteMsg->hResultCode);

			// Validate the completion.
			if (pAsyncOpCompleteMsg->dwSize != sizeof (DPNMSG_ASYNC_OP_COMPLETE))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_ASYNC_OP_COMPLETE is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pAsyncOpCompleteMsg->dwSize, sizeof (DPNMSG_ASYNC_OP_COMPLETE));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pAsyncOpCompleteMsg->hResultCode != DPN_OK)
			{
				DPTEST_TRACE(pContext->hLog, "Async op completed with failure!  DEBUGBREAK()-ing.  0x%08x",
					1, pAsyncOpCompleteMsg->hResultCode);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (wrong result code)

			// XBOX - Handle async ops
			if(pAsyncOpCompleteMsg->pvUserContext)
			{
				SetEvent((HANDLE) pAsyncOpCompleteMsg->pvUserContext);
			}
		  break;

		case DPN_MSGID_CONNECT_COMPLETE:
			PDPNMSG_CONNECT_COMPLETE	pConnectCompleteMsg;


			pConnectCompleteMsg = (PDPNMSG_CONNECT_COMPLETE) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CONNECT_COMPLETE", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pConnectCompleteMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    hAsyncOp = %x", 1, pConnectCompleteMsg->hAsyncOp);
			DPTEST_TRACE(pContext->hLog, "    pvUserContext = %x", 1, pConnectCompleteMsg->pvUserContext);
			DPTEST_TRACE(pContext->hLog, "    hResultCode = 0x%08x", 1, pConnectCompleteMsg->hResultCode);
			DPTEST_TRACE(pContext->hLog, "    pvApplicationReplyData = %x", 1, pConnectCompleteMsg->pvApplicationReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwApplicationReplyDataSize = %u", 1, pConnectCompleteMsg->dwApplicationReplyDataSize);


			// Make sure we expect the completion.
			if (! pContext->fConnectCanComplete)
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_CONNECT_COMPLETE (%x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (message unexpected)


			// Validate the completion.
			if (pConnectCompleteMsg->dwSize != sizeof (DPNMSG_CONNECT_COMPLETE))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CONNECT_COMPLETE is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->dwSize, sizeof (DPNMSG_CONNECT_COMPLETE));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pConnectCompleteMsg->hResultCode != DPN_OK)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with failure!  DEBUGBREAK()-ing.  0x%08x",
					1, pConnectCompleteMsg->hResultCode);
				DEBUGBREAK();
				hr = pConnectCompleteMsg->hResultCode;
				goto DONE;
			} // end if (wrong result code)

			if ((pConnectCompleteMsg->pvApplicationReplyData != NULL) ||
				(pConnectCompleteMsg->dwApplicationReplyDataSize != 0))
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with unexpected reply data (ptr %x != NULL or size %u != 0)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->pvApplicationReplyData,
					pConnectCompleteMsg->dwApplicationReplyDataSize);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (unexpected reply data)


			// Make sure this isn't a double completion.
			if (pContext->fConnectCompleted)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed twice (msg = %x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (double completion)

			// Alert the test case that the completion came in.
			pContext->fConnectCompleted = TRUE;

			// XBOX - Handle async connect
			if(pConnectCompleteMsg->pvUserContext)
			{
				SetEvent((HANDLE) pConnectCompleteMsg->pvUserContext);
			}
		  break;

		case DPN_MSGID_CREATE_GROUP:
			PDPNMSG_CREATE_GROUP	pCreateGroupMsg;


			pCreateGroupMsg = (PDPNMSG_CREATE_GROUP) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CREATE_GROUP", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pCreateGroupMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidGroup = %u/%x", 2, pCreateGroupMsg->dpnidGroup, pCreateGroupMsg->dpnidGroup);
			DPTEST_TRACE(pContext->hLog, "    dpnidOwner = %u/%x", 2, pCreateGroupMsg->dpnidOwner, pCreateGroupMsg->dpnidOwner);
			DPTEST_TRACE(pContext->hLog, "    pvGroupContext = %x", 1, pCreateGroupMsg->pvGroupContext);


			// Make sure we expect the indication.
			if (! pContext->fCanGetCreateGroup)
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_CREATE_GROUP (at %x)!  DEBUGBREAK()-ing.",
					1, pCreateGroupMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (message unexpected)

			// Validate the message.
			if (pCreateGroupMsg->dwSize != sizeof (DPNMSG_CREATE_GROUP))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CREATE_GROUP is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pCreateGroupMsg->dwSize, sizeof (DPNMSG_CREATE_GROUP));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pCreateGroupMsg->dpnidGroup == 0)
			{
				DPTEST_TRACE(pContext->hLog, "Group created got invalid ID of 0!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (group ID is 0)

			if (pCreateGroupMsg->dpnidOwner != pContext->dpnidExpectedGroupOwner)
			{
				DPTEST_TRACE(pContext->hLog, "Group owner was wrong (%u/%x != %u/%x)!  DEBUGBREAK()-ing.",
					4, pCreateGroupMsg->dpnidOwner, pCreateGroupMsg->dpnidOwner,
					pContext->dpnidExpectedGroupOwner, pContext->dpnidExpectedGroupOwner);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (group owner is wrong)

			if (pCreateGroupMsg->pvGroupContext != NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Group has wrong context (%x != NULL)!  DEBUGBREAK()-ing.",
					1, pCreateGroupMsg->pvGroupContext);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (wrong context)



			// Make sure this isn't a double indication.
			if (pContext->dpnidGroup != 0)
			{
				DPTEST_TRACE(pContext->hLog, "Got create group twice!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (double completion)

			// Alert the test case that the indication came in.
			pContext->dpnidGroup = pCreateGroupMsg->dpnidGroup;

			if (pContext->hGotGroupMsgEvent != NULL)
			{
				if (! SetEvent(pContext->hGotGroupMsgEvent))
				{
					hr = GetLastError();
					DPTEST_TRACE(pContext->hLog, "Couldn't set got group msg event (%x)!  DEBUGBREAK()-ing.",
						1, pContext->hGotGroupMsgEvent);

					DEBUGBREAK();

					if (hr == S_OK)
						hr = E_FAIL;

					goto DONE;
				} // end if (couldn't set event)
			} // end if (there's a group msg event)
		  break;

		case DPN_MSGID_CREATE_PLAYER:
			PDPNMSG_CREATE_PLAYER	pCreatePlayerMsg;


			pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CREATE_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pCreatePlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pCreatePlayerMsg->dpnidPlayer, pCreatePlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pCreatePlayerMsg->pvPlayerContext);


			// Validate the indication.
			if (pCreatePlayerMsg->dwSize != sizeof (DPNMSG_CREATE_PLAYER))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CREATE_PLAYER is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pCreatePlayerMsg->dwSize, sizeof (DPNMSG_CREATE_PLAYER));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pCreatePlayerMsg->pvPlayerContext == NULL)
			{
				// Assume this is the remote player being created.  Store the
				// player context.
				if (pContext->fHost)
				{
					pCreatePlayerMsg->pvPlayerContext = &(pContext->dpnidClient);
					fSetEvent = TRUE;
				} // end if (host)
				else
				{
					pCreatePlayerMsg->pvPlayerContext = &(pContext->dpnidHost);
				} // end if (not host)
			} // end if (context is not set yet)


			// Make sure this isn't a duplicate message.
			if (*((DPNID*) pCreatePlayerMsg->pvPlayerContext) != 0)
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate CREATE_PLAYER (msg = %x)!  DEBUGBREAK()-ing.",
					1, pCreatePlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (already have ID)

			// Save the player ID.
			*((DPNID*) pCreatePlayerMsg->pvPlayerContext) = pCreatePlayerMsg->dpnidPlayer;


			// Now set the event, if we're supposed too.
			if (fSetEvent)
			{
				if (! SetEvent(pContext->hClientCreatedEvent))
				{
					hr = GetLastError();
					DPTEST_TRACE(pContext->hLog, "Couldn't set client created event (%x)!  DEBUGBREAK()-ing.",
						1, pContext->hClientCreatedEvent);

					DEBUGBREAK();

					if (hr == S_OK)
						hr = E_FAIL;

					goto DONE;
				} // end if (couldn't set event)
			} // end if (should set event)
		  break;

		case DPN_MSGID_DESTROY_GROUP:
			PDPNMSG_DESTROY_GROUP	pDestroyGroupMsg;


			pDestroyGroupMsg = (PDPNMSG_DESTROY_GROUP) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_DESTROY_GROUP", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pDestroyGroupMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidGroup = %u/%x", 2, pDestroyGroupMsg->dpnidGroup, pDestroyGroupMsg->dpnidGroup);
			DPTEST_TRACE(pContext->hLog, "    pvGroupContext = %x", 1, pDestroyGroupMsg->pvGroupContext);
			DPTEST_TRACE(pContext->hLog, "    dwReason = %u", 1, pDestroyGroupMsg->dwReason);

#pragma TODO(vanceo, "Validate DPN_MSGID_DESTROY_GROUP")
		  break;

		case DPN_MSGID_DESTROY_PLAYER:
			PDPNMSG_DESTROY_PLAYER	pDestroyPlayerMsg;


			pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_DESTROY_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pDestroyPlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pDestroyPlayerMsg->dpnidPlayer, pDestroyPlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pDestroyPlayerMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    dwReason = %x", 1, pDestroyPlayerMsg->dwReason);


			// Validate the indication.
			if (pDestroyPlayerMsg->dwSize != sizeof (DPNMSG_DESTROY_PLAYER))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_DESTROY_PLAYER is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pDestroyPlayerMsg->dwSize, sizeof (DPNMSG_DESTROY_PLAYER));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pDestroyPlayerMsg->pvPlayerContext == NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Player context is NULL!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (context is wrong)

			if (pDestroyPlayerMsg->dwReason != DPNDESTROYPLAYERREASON_NORMAL)
			{
				DPTEST_TRACE(pContext->hLog, "Player destruction reason is unexpected (%x != %x)!  DEBUGBREAK()-ing.",
					2, pDestroyPlayerMsg->dwReason, DPNDESTROYPLAYERREASON_NORMAL);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (reason is wrong)


			// Make sure this isn't a duplicate or bogus message.
			if ((*((DPNID*) pDestroyPlayerMsg->pvPlayerContext) == 0) ||
				(pDestroyPlayerMsg->dpnidPlayer != *((DPNID*) pDestroyPlayerMsg->pvPlayerContext)))
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate or unexpected DESTROY_PLAYER (msg = %x)!  DEBUGBREAK()-ing.",
					1, pDestroyPlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (already have ID)

			// Clear the player ID.
			*((DPNID*) pDestroyPlayerMsg->pvPlayerContext) = 0;
		  break;

		case DPN_MSGID_INDICATE_CONNECT:
			PDPNMSG_INDICATE_CONNECT	pIndicateConnectMsg;


			pIndicateConnectMsg = (PDPNMSG_INDICATE_CONNECT) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_INDICATE_CONNECT", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pIndicateConnectMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    pvUserConnectData = %x", 1, pIndicateConnectMsg->pvUserConnectData);
			DPTEST_TRACE(pContext->hLog, "    dwUserConnectDataSize = %u", 1, pIndicateConnectMsg->dwUserConnectDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyData = %x", 1, pIndicateConnectMsg->pvReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwReplyDataSize = %u", 1, pIndicateConnectMsg->dwReplyDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyContext = %x", 1, pIndicateConnectMsg->pvReplyContext);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pIndicateConnectMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    pAddressPlayer = 0x%08x", 1, pIndicateConnectMsg->pAddressPlayer);
			DPTEST_TRACE(pContext->hLog, "    pAddressDevice = 0x%08x", 1, pIndicateConnectMsg->pAddressDevice);

#pragma TODO(vanceo, "Validate DPN_MSGID_INDICATE_CONNECT")
		  break;

		default:
			DPTEST_TRACE(pContext->hLog, "Got unexpected message type %x!  DEBUGBREAK()-ing.",
				1, dwMsgType);
			DEBUGBREAK();
			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)


DONE:

	return (hr);
} // ParmVPGetGroupInfoDPNMessageHandler
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVPEnumPAndGDPNMessageHandler()"
//==================================================================================
// ParmVPEnumPAndGDPNMessageHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT ParmVPEnumPAndGDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT						hr = DPN_OK;
	PPARMVPENUMPANDGCONTEXT		pContext = (PPARMVPENUMPANDGCONTEXT) pvContext;
	BOOL						fSetEvent = FALSE;


	switch (dwMsgType)
	{
		case DPN_MSGID_ASYNC_OP_COMPLETE:
			PDPNMSG_ASYNC_OP_COMPLETE	pAsyncOpCompleteMsg;


			pAsyncOpCompleteMsg = (PDPNMSG_ASYNC_OP_COMPLETE) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_ASYNC_OP_COMPLETE", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pAsyncOpCompleteMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    hAsyncOp = %x", 1, pAsyncOpCompleteMsg->hAsyncOp);
			DPTEST_TRACE(pContext->hLog, "    pvUserContext = %x", 1, pAsyncOpCompleteMsg->pvUserContext);
			DPTEST_TRACE(pContext->hLog, "    hResultCode = 0x%08x", 1, pAsyncOpCompleteMsg->hResultCode);

			// Validate the completion.
			if (pAsyncOpCompleteMsg->dwSize != sizeof (DPNMSG_ASYNC_OP_COMPLETE))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_ASYNC_OP_COMPLETE is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pAsyncOpCompleteMsg->dwSize, sizeof (DPNMSG_ASYNC_OP_COMPLETE));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pAsyncOpCompleteMsg->hResultCode != DPN_OK)
			{
				DPTEST_TRACE(pContext->hLog, "Async op completed with failure!  DEBUGBREAK()-ing.  0x%08x",
					1, pAsyncOpCompleteMsg->hResultCode);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (wrong result code)

			// XBOX - Handle async ops
			if(pAsyncOpCompleteMsg->pvUserContext)
			{
				SetEvent((HANDLE) pAsyncOpCompleteMsg->pvUserContext);
			}
		  break;

		case DPN_MSGID_CONNECT_COMPLETE:
			PDPNMSG_CONNECT_COMPLETE	pConnectCompleteMsg;


			pConnectCompleteMsg = (PDPNMSG_CONNECT_COMPLETE) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CONNECT_COMPLETE", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pConnectCompleteMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    hAsyncOp = %x", 1, pConnectCompleteMsg->hAsyncOp);
			DPTEST_TRACE(pContext->hLog, "    pvUserContext = %x", 1, pConnectCompleteMsg->pvUserContext);
			DPTEST_TRACE(pContext->hLog, "    hResultCode = 0x%08x", 1, pConnectCompleteMsg->hResultCode);
			DPTEST_TRACE(pContext->hLog, "    pvApplicationReplyData = %x", 1, pConnectCompleteMsg->pvApplicationReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwApplicationReplyDataSize = %u", 1, pConnectCompleteMsg->dwApplicationReplyDataSize);


			// Make sure we expect the completion.
			if (! pContext->fConnectCanComplete)
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_CONNECT_COMPLETE (%x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (message unexpected)


			// Validate the completion.
			if (pConnectCompleteMsg->dwSize != sizeof (DPNMSG_CONNECT_COMPLETE))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CONNECT_COMPLETE is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->dwSize, sizeof (DPNMSG_CONNECT_COMPLETE));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pConnectCompleteMsg->hResultCode != DPN_OK)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with failure!  DEBUGBREAK()-ing.  0x%08x",
					1, pConnectCompleteMsg->hResultCode);
				DEBUGBREAK();
				hr = pConnectCompleteMsg->hResultCode;
				goto DONE;
			} // end if (wrong result code)

			if ((pConnectCompleteMsg->pvApplicationReplyData != NULL) ||
				(pConnectCompleteMsg->dwApplicationReplyDataSize != 0))
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with unexpected reply data (ptr %x != NULL or size %u != 0)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->pvApplicationReplyData,
					pConnectCompleteMsg->dwApplicationReplyDataSize);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (unexpected reply data)


			// Make sure this isn't a double completion.
			if (pContext->fConnectCompleted)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed twice (msg = %x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (double completion)

			// Alert the test case that the completion came in.
			pContext->fConnectCompleted = TRUE;

			// XBOX - Handle async connect
			if(pConnectCompleteMsg->pvUserContext)
			{
				SetEvent((HANDLE) pConnectCompleteMsg->pvUserContext);
			}

		  break;

		case DPN_MSGID_CREATE_GROUP:
			PDPNMSG_CREATE_GROUP	pCreateGroupMsg;


			pCreateGroupMsg = (PDPNMSG_CREATE_GROUP) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CREATE_GROUP", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pCreateGroupMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidGroup = %u/%x", 2, pCreateGroupMsg->dpnidGroup, pCreateGroupMsg->dpnidGroup);
			DPTEST_TRACE(pContext->hLog, "    dpnidOwner = %u/%x", 2, pCreateGroupMsg->dpnidOwner, pCreateGroupMsg->dpnidOwner);
			DPTEST_TRACE(pContext->hLog, "    pvGroupContext = %x", 1, pCreateGroupMsg->pvGroupContext);


			// Make sure we expect the indication.
			if ((! pContext->fCanGetCreateGroup) && (! pContext->fCanGetCreateGroup2))
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_CREATE_GROUP (at %x)!  DEBUGBREAK()-ing.",
					1, pCreateGroupMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (message unexpected)

			// Validate the message.
			if (pCreateGroupMsg->dwSize != sizeof (DPNMSG_CREATE_GROUP))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CREATE_GROUP is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pCreateGroupMsg->dwSize, sizeof (DPNMSG_CREATE_GROUP));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pCreateGroupMsg->dpnidGroup == 0)
			{
				DPTEST_TRACE(pContext->hLog, "Group created got invalid ID of 0!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (group ID is 0)

			if (pCreateGroupMsg->dpnidOwner != pContext->dpnidExpectedGroupOwner)
			{
				DPTEST_TRACE(pContext->hLog, "Group owner was wrong (%u/%x != %u/%x)!  DEBUGBREAK()-ing.",
					4, pCreateGroupMsg->dpnidOwner, pCreateGroupMsg->dpnidOwner,
					pContext->dpnidExpectedGroupOwner, pContext->dpnidExpectedGroupOwner);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (group owner is wrong)

			if (pCreateGroupMsg->pvGroupContext != NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Group has wrong context (%x != NULL)!  DEBUGBREAK()-ing.",
					1, pCreateGroupMsg->pvGroupContext);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (wrong context)



			// Make sure this isn't a double indication.
			if (pContext->fCanGetCreateGroup)
			{
				if (pContext->dpnidGroup != 0)
				{
					DPTEST_TRACE(pContext->hLog, "Got create group #1 twice!  DEBUGBREAK()-ing.", 0);
					DEBUGBREAK();
					hr = E_FAIL;
					goto DONE;
				} // end if (double completion)

				// Alert the test case that the indication came in.
				pContext->dpnidGroup = pCreateGroupMsg->dpnidGroup;
			} // end if (first create group)
			else
			{
				if (pContext->dpnidGroup2 != 0)
				{
					DPTEST_TRACE(pContext->hLog, "Got create group #2 twice!  DEBUGBREAK()-ing.", 0);
					DEBUGBREAK();
					hr = E_FAIL;
					goto DONE;
				} // end if (double completion)

				// Alert the test case that the indication came in.
				pContext->dpnidGroup2 = pCreateGroupMsg->dpnidGroup;
			} // end else (second create group)

			if (pContext->hGotGroupMsgEvent != NULL)
			{
				if (! SetEvent(pContext->hGotGroupMsgEvent))
				{
					hr = GetLastError();
					DPTEST_TRACE(pContext->hLog, "Couldn't set got group msg event (%x)!  DEBUGBREAK()-ing.",
						1, pContext->hGotGroupMsgEvent);

					DEBUGBREAK();

					if (hr == S_OK)
						hr = E_FAIL;

					goto DONE;
				} // end if (couldn't set event)
			} // end if (there's a group msg event)
		  break;

		case DPN_MSGID_CREATE_PLAYER:
			PDPNMSG_CREATE_PLAYER	pCreatePlayerMsg;


			pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CREATE_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pCreatePlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pCreatePlayerMsg->dpnidPlayer, pCreatePlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pCreatePlayerMsg->pvPlayerContext);


			// Validate the indication.
			if (pCreatePlayerMsg->dwSize != sizeof (DPNMSG_CREATE_PLAYER))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CREATE_PLAYER is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pCreatePlayerMsg->dwSize, sizeof (DPNMSG_CREATE_PLAYER));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pCreatePlayerMsg->pvPlayerContext == NULL)
			{
				// Assume this is the remote player being created.  Store the
				// player context.
				if (pContext->fHost)
				{
					pCreatePlayerMsg->pvPlayerContext = &(pContext->dpnidClient);
					fSetEvent = TRUE;
				} // end if (host)
				else
				{
					pCreatePlayerMsg->pvPlayerContext = &(pContext->dpnidHost);
				} // end if (not host)
			} // end if (context is not set yet)


			// Make sure this isn't a duplicate message.
			if (*((DPNID*) pCreatePlayerMsg->pvPlayerContext) != 0)
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate CREATE_PLAYER (msg = %x)!  DEBUGBREAK()-ing.",
					1, pCreatePlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (already have ID)

			// Save the player ID.
			*((DPNID*) pCreatePlayerMsg->pvPlayerContext) = pCreatePlayerMsg->dpnidPlayer;


			// Now set the event, if we're supposed too.
			if (fSetEvent)
			{
				if (! SetEvent(pContext->hClientCreatedEvent))
				{
					hr = GetLastError();
					DPTEST_TRACE(pContext->hLog, "Couldn't set client created event (%x)!  DEBUGBREAK()-ing.",
						1, pContext->hClientCreatedEvent);

					DEBUGBREAK();

					if (hr == S_OK)
						hr = E_FAIL;

					goto DONE;
				} // end if (couldn't set event)
			} // end if (should set event)
		  break;

		case DPN_MSGID_DESTROY_GROUP:
			PDPNMSG_DESTROY_GROUP	pDestroyGroupMsg;


			pDestroyGroupMsg = (PDPNMSG_DESTROY_GROUP) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_DESTROY_GROUP", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pDestroyGroupMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidGroup = %u/%x", 2, pDestroyGroupMsg->dpnidGroup, pDestroyGroupMsg->dpnidGroup);
			DPTEST_TRACE(pContext->hLog, "    pvGroupContext = %x", 1, pDestroyGroupMsg->pvGroupContext);
			DPTEST_TRACE(pContext->hLog, "    dwReason = %u", 1, pDestroyGroupMsg->dwReason);

#pragma TODO(vanceo, "Validate DPN_MSGID_DESTROY_GROUP")
		  break;

		case DPN_MSGID_DESTROY_PLAYER:
			PDPNMSG_DESTROY_PLAYER	pDestroyPlayerMsg;


			pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_DESTROY_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pDestroyPlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pDestroyPlayerMsg->dpnidPlayer, pDestroyPlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pDestroyPlayerMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    dwReason = %x", 1, pDestroyPlayerMsg->dwReason);


			// Validate the indication.
			if (pDestroyPlayerMsg->dwSize != sizeof (DPNMSG_DESTROY_PLAYER))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_DESTROY_PLAYER is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pDestroyPlayerMsg->dwSize, sizeof (DPNMSG_DESTROY_PLAYER));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pDestroyPlayerMsg->pvPlayerContext == NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Player context is NULL!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (context is wrong)

			if (pDestroyPlayerMsg->dwReason != DPNDESTROYPLAYERREASON_NORMAL)
			{
				DPTEST_TRACE(pContext->hLog, "Player destruction reason is unexpected (%x != %x)!  DEBUGBREAK()-ing.",
					2, pDestroyPlayerMsg->dwReason, DPNDESTROYPLAYERREASON_NORMAL);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (reason is wrong)


			// Make sure this isn't a duplicate or bogus message.
			if ((*((DPNID*) pDestroyPlayerMsg->pvPlayerContext) == 0) ||
				(pDestroyPlayerMsg->dpnidPlayer != *((DPNID*) pDestroyPlayerMsg->pvPlayerContext)))
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate or unexpected DESTROY_PLAYER (msg = %x)!  DEBUGBREAK()-ing.",
					1, pDestroyPlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (already have ID)

			// Clear the player ID.
			*((DPNID*) pDestroyPlayerMsg->pvPlayerContext) = 0;
		  break;

		case DPN_MSGID_INDICATE_CONNECT:
			PDPNMSG_INDICATE_CONNECT	pIndicateConnectMsg;


			pIndicateConnectMsg = (PDPNMSG_INDICATE_CONNECT) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_INDICATE_CONNECT", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pIndicateConnectMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    pvUserConnectData = %x", 1, pIndicateConnectMsg->pvUserConnectData);
			DPTEST_TRACE(pContext->hLog, "    dwUserConnectDataSize = %u", 1, pIndicateConnectMsg->dwUserConnectDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyData = %x", 1, pIndicateConnectMsg->pvReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwReplyDataSize = %u", 1, pIndicateConnectMsg->dwReplyDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyContext = %x", 1, pIndicateConnectMsg->pvReplyContext);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pIndicateConnectMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    pAddressPlayer = 0x%08x", 1, pIndicateConnectMsg->pAddressPlayer);
			DPTEST_TRACE(pContext->hLog, "    pAddressDevice = 0x%08x", 1, pIndicateConnectMsg->pAddressDevice);

#pragma TODO(vanceo, "Validate DPN_MSGID_INDICATE_CONNECT")
		  break;

		default:
			DPTEST_TRACE(pContext->hLog, "Got unexpected message type %x!  DEBUGBREAK()-ing.",
				1, dwMsgType);
			DEBUGBREAK();
			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)


DONE:

	return (hr);
} // ParmVPEnumPAndGDPNMessageHandler
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVPEnumGroupMembersDPNMessageHandler()"
//==================================================================================
// ParmVPEnumGroupMembersDPNMessageHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT ParmVPEnumGroupMembersDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT							hr = DPN_OK;
	PPARMVPENUMGROUPMEMBERSCONTEXT	pContext = (PPARMVPENUMGROUPMEMBERSCONTEXT) pvContext;
	BOOL							fSetEvent = FALSE;


	switch (dwMsgType)
	{
		case DPN_MSGID_ASYNC_OP_COMPLETE:
			PDPNMSG_ASYNC_OP_COMPLETE	pAsyncOpCompleteMsg;


			pAsyncOpCompleteMsg = (PDPNMSG_ASYNC_OP_COMPLETE) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_ASYNC_OP_COMPLETE", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pAsyncOpCompleteMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    hAsyncOp = %x", 1, pAsyncOpCompleteMsg->hAsyncOp);
			DPTEST_TRACE(pContext->hLog, "    pvUserContext = %x", 1, pAsyncOpCompleteMsg->pvUserContext);
			DPTEST_TRACE(pContext->hLog, "    hResultCode = 0x%08x", 1, pAsyncOpCompleteMsg->hResultCode);

			// Validate the completion.
			if (pAsyncOpCompleteMsg->dwSize != sizeof (DPNMSG_ASYNC_OP_COMPLETE))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_ASYNC_OP_COMPLETE is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pAsyncOpCompleteMsg->dwSize, sizeof (DPNMSG_ASYNC_OP_COMPLETE));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pAsyncOpCompleteMsg->hResultCode != DPN_OK)
			{
				DPTEST_TRACE(pContext->hLog, "Async op completed with failure!  DEBUGBREAK()-ing.  0x%08x",
					1, pAsyncOpCompleteMsg->hResultCode);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (wrong result code)

			// XBOX - Handle async ops
			if(pAsyncOpCompleteMsg->pvUserContext)
			{
				SetEvent((HANDLE) pAsyncOpCompleteMsg->pvUserContext);
			}
		  break;

		case DPN_MSGID_ADD_PLAYER_TO_GROUP:
			PDPNMSG_ADD_PLAYER_TO_GROUP		pAddPlayerToGroupMsg;


			pAddPlayerToGroupMsg = (PDPNMSG_ADD_PLAYER_TO_GROUP) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_ADD_PLAYER_TO_GROUP", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pAddPlayerToGroupMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidGroup = %u/%x", 2, pAddPlayerToGroupMsg->dpnidGroup, pAddPlayerToGroupMsg->dpnidGroup);
			DPTEST_TRACE(pContext->hLog, "    pvGroupContext = %x", 1, pAddPlayerToGroupMsg->pvGroupContext);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pAddPlayerToGroupMsg->dpnidPlayer, pAddPlayerToGroupMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pAddPlayerToGroupMsg->pvPlayerContext);


			// Make sure we expect the indication.
			if (! pContext->fCanGetAddToGroup)
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_ADD_PLAYER_TO_GROUP (at %x)!  DEBUGBREAK()-ing.",
					1, pAddPlayerToGroupMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (message unexpected)


			// Validate the message.
			if (pAddPlayerToGroupMsg->dwSize != sizeof (DPNMSG_ADD_PLAYER_TO_GROUP))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_ADD_PLAYER_TO_GROUP is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pAddPlayerToGroupMsg->dwSize, sizeof (DPNMSG_ADD_PLAYER_TO_GROUP));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pAddPlayerToGroupMsg->dpnidGroup != pContext->dpnidGroup)
			{
				DPTEST_TRACE(pContext->hLog, "Group ID was wrong (%u/%x != %u/%x)!  DEBUGBREAK()-ing.",
					4, pAddPlayerToGroupMsg->dpnidGroup, pAddPlayerToGroupMsg->dpnidGroup,
					pContext->dpnidGroup, pContext->dpnidGroup);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (group ID is wrong)

			if (pAddPlayerToGroupMsg->pvGroupContext != NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Group has wrong context (%x != NULL)!  DEBUGBREAK()-ing.",
					1, pAddPlayerToGroupMsg->pvGroupContext);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (wrong group context)

			if (pAddPlayerToGroupMsg->dpnidPlayer != pContext->dpnidExpectedPlayer)
			{
				DPTEST_TRACE(pContext->hLog, "Player ID was wrong (%u/%x != %u/%x)!  DEBUGBREAK()-ing.",
					4, pAddPlayerToGroupMsg->dpnidPlayer, pAddPlayerToGroupMsg->dpnidPlayer,
					pContext->dpnidExpectedPlayer, pContext->dpnidExpectedPlayer);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (player ID is wrong)

			if (pAddPlayerToGroupMsg->pvPlayerContext != pContext->pvExpectedPlayerContext)
			{
				DPTEST_TRACE(pContext->hLog, "Player has wrong context (%x != %x)!  DEBUGBREAK()-ing.",
					2, pAddPlayerToGroupMsg->pvPlayerContext,
					pContext->pvExpectedPlayerContext);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (wrong player context)



			// Make sure this isn't a double indication.
			if (pContext->fGotAddToGroup)
			{
				DPTEST_TRACE(pContext->hLog, "Got add player to group twice!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (double completion)

			// Alert the test case that the indication came in.
			pContext->fGotAddToGroup = TRUE;

			if (pContext->hGotGroupMsgEvent != NULL)
			{
				if (! SetEvent(pContext->hGotGroupMsgEvent))
				{
					hr = GetLastError();
					DPTEST_TRACE(pContext->hLog, "Couldn't set got group msg event (%x)!  DEBUGBREAK()-ing.",
						1, pContext->hGotGroupMsgEvent);

					DEBUGBREAK();

					if (hr == S_OK)
						hr = E_FAIL;

					goto DONE;
				} // end if (couldn't set event)
			} // end if (there's a group msg event)
		  break;

		case DPN_MSGID_CONNECT_COMPLETE:
			PDPNMSG_CONNECT_COMPLETE	pConnectCompleteMsg;


			pConnectCompleteMsg = (PDPNMSG_CONNECT_COMPLETE) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CONNECT_COMPLETE", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pConnectCompleteMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    hAsyncOp = %x", 1, pConnectCompleteMsg->hAsyncOp);
			DPTEST_TRACE(pContext->hLog, "    pvUserContext = %x", 1, pConnectCompleteMsg->pvUserContext);
			DPTEST_TRACE(pContext->hLog, "    hResultCode = 0x%08x", 1, pConnectCompleteMsg->hResultCode);
			DPTEST_TRACE(pContext->hLog, "    pvApplicationReplyData = %x", 1, pConnectCompleteMsg->pvApplicationReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwApplicationReplyDataSize = %u", 1, pConnectCompleteMsg->dwApplicationReplyDataSize);


			// Make sure we expect the completion.
			if (! pContext->fConnectCanComplete)
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_CONNECT_COMPLETE (%x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (message unexpected)


			// Validate the completion.
			if (pConnectCompleteMsg->dwSize != sizeof (DPNMSG_CONNECT_COMPLETE))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CONNECT_COMPLETE is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->dwSize, sizeof (DPNMSG_CONNECT_COMPLETE));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pConnectCompleteMsg->hResultCode != DPN_OK)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with failure!  DEBUGBREAK()-ing.  0x%08x",
					1, pConnectCompleteMsg->hResultCode);
				DEBUGBREAK();
				hr = pConnectCompleteMsg->hResultCode;
				goto DONE;
			} // end if (wrong result code)

			if ((pConnectCompleteMsg->pvApplicationReplyData != NULL) ||
				(pConnectCompleteMsg->dwApplicationReplyDataSize != 0))
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with unexpected reply data (ptr %x != NULL or size %u != 0)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->pvApplicationReplyData,
					pConnectCompleteMsg->dwApplicationReplyDataSize);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (unexpected reply data)


			// Make sure this isn't a double completion.
			if (pContext->fConnectCompleted)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed twice (msg = %x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (double completion)

			// Alert the test case that the completion came in.
			pContext->fConnectCompleted = TRUE;

			// XBOX - Handle async connect
			if(pConnectCompleteMsg->pvUserContext)
			{
				SetEvent((HANDLE) pConnectCompleteMsg->pvUserContext);
			}
		  break;

		case DPN_MSGID_CREATE_GROUP:
			PDPNMSG_CREATE_GROUP	pCreateGroupMsg;


			pCreateGroupMsg = (PDPNMSG_CREATE_GROUP) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CREATE_GROUP", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pCreateGroupMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidGroup = %u/%x", 2, pCreateGroupMsg->dpnidGroup, pCreateGroupMsg->dpnidGroup);
			DPTEST_TRACE(pContext->hLog, "    dpnidOwner = %u/%x", 2, pCreateGroupMsg->dpnidOwner, pCreateGroupMsg->dpnidOwner);
			DPTEST_TRACE(pContext->hLog, "    pvGroupContext = %x", 1, pCreateGroupMsg->pvGroupContext);


			// Make sure we expect the indication.
			if (! pContext->fCanGetCreateGroup)
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_CREATE_GROUP (at %x)!  DEBUGBREAK()-ing.",
					1, pCreateGroupMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (message unexpected)

			// Validate the message.
			if (pCreateGroupMsg->dwSize != sizeof (DPNMSG_CREATE_GROUP))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CREATE_GROUP is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pCreateGroupMsg->dwSize, sizeof (DPNMSG_CREATE_GROUP));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pCreateGroupMsg->dpnidGroup == 0)
			{
				DPTEST_TRACE(pContext->hLog, "Group created got invalid ID of 0!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (group ID is 0)

			if (pCreateGroupMsg->dpnidOwner != pContext->dpnidExpectedGroupOwner)
			{
				DPTEST_TRACE(pContext->hLog, "Group owner was wrong (%u/%x != %u/%x)!  DEBUGBREAK()-ing.",
					4, pCreateGroupMsg->dpnidOwner, pCreateGroupMsg->dpnidOwner,
					pContext->dpnidExpectedGroupOwner, pContext->dpnidExpectedGroupOwner);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (group owner is wrong)

			if (pCreateGroupMsg->pvGroupContext != NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Group has wrong context (%x != NULL)!  DEBUGBREAK()-ing.",
					1, pCreateGroupMsg->pvGroupContext);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (wrong context)



			// Make sure this isn't a double indication.
			if (pContext->dpnidGroup != 0)
			{
				DPTEST_TRACE(pContext->hLog, "Got create group twice!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (double completion)

			// Alert the test case that the indication came in.
			pContext->dpnidGroup = pCreateGroupMsg->dpnidGroup;

			if (pContext->hGotGroupMsgEvent != NULL)
			{
				if (! SetEvent(pContext->hGotGroupMsgEvent))
				{
					hr = GetLastError();
					DPTEST_TRACE(pContext->hLog, "Couldn't set got group msg event (%x)!  DEBUGBREAK()-ing.",
						1, pContext->hGotGroupMsgEvent);

					DEBUGBREAK();

					if (hr == S_OK)
						hr = E_FAIL;

					goto DONE;
				} // end if (couldn't set event)
			} // end if (there's a group msg event)
		  break;

		case DPN_MSGID_CREATE_PLAYER:
			PDPNMSG_CREATE_PLAYER	pCreatePlayerMsg;


			pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CREATE_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pCreatePlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pCreatePlayerMsg->dpnidPlayer, pCreatePlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pCreatePlayerMsg->pvPlayerContext);


			// Validate the indication.
			if (pCreatePlayerMsg->dwSize != sizeof (DPNMSG_CREATE_PLAYER))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CREATE_PLAYER is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pCreatePlayerMsg->dwSize, sizeof (DPNMSG_CREATE_PLAYER));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pCreatePlayerMsg->pvPlayerContext == NULL)
			{
				// Assume this is the remote player being created.  Store the
				// player context.
				if (pContext->fHost)
				{
					pCreatePlayerMsg->pvPlayerContext = &(pContext->dpnidClient);
					fSetEvent = TRUE;
				} // end if (host)
				else
				{
					pCreatePlayerMsg->pvPlayerContext = &(pContext->dpnidHost);
				} // end if (not host)
			} // end if (context is not set yet)


			// Make sure this isn't a duplicate message.
			if (*((DPNID*) pCreatePlayerMsg->pvPlayerContext) != 0)
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate CREATE_PLAYER (msg = %x)!  DEBUGBREAK()-ing.",
					1, pCreatePlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (already have ID)

			// Save the player ID.
			*((DPNID*) pCreatePlayerMsg->pvPlayerContext) = pCreatePlayerMsg->dpnidPlayer;


			// Now set the event, if we're supposed too.
			if (fSetEvent)
			{
				if (! SetEvent(pContext->hClientCreatedEvent))
				{
					hr = GetLastError();
					DPTEST_TRACE(pContext->hLog, "Couldn't set client created event (%x)!  DEBUGBREAK()-ing.",
						1, pContext->hClientCreatedEvent);

					DEBUGBREAK();

					if (hr == S_OK)
						hr = E_FAIL;

					goto DONE;
				} // end if (couldn't set event)
			} // end if (should set event)
		  break;

		case DPN_MSGID_DESTROY_GROUP:
			PDPNMSG_DESTROY_GROUP	pDestroyGroupMsg;


			pDestroyGroupMsg = (PDPNMSG_DESTROY_GROUP) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_DESTROY_GROUP", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pDestroyGroupMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidGroup = %u/%x", 2, pDestroyGroupMsg->dpnidGroup, pDestroyGroupMsg->dpnidGroup);
			DPTEST_TRACE(pContext->hLog, "    pvGroupContext = %x", 1, pDestroyGroupMsg->pvGroupContext);
			DPTEST_TRACE(pContext->hLog, "    dwReason = %u", 1, pDestroyGroupMsg->dwReason);

#pragma TODO(vanceo, "Validate DPN_MSGID_DESTROY_GROUP")
		  break;

		case DPN_MSGID_DESTROY_PLAYER:
			PDPNMSG_DESTROY_PLAYER	pDestroyPlayerMsg;


			pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_DESTROY_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pDestroyPlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pDestroyPlayerMsg->dpnidPlayer, pDestroyPlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pDestroyPlayerMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    dwReason = %x", 1, pDestroyPlayerMsg->dwReason);


			// Validate the indication.
			if (pDestroyPlayerMsg->dwSize != sizeof (DPNMSG_DESTROY_PLAYER))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_DESTROY_PLAYER is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pDestroyPlayerMsg->dwSize, sizeof (DPNMSG_DESTROY_PLAYER));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pDestroyPlayerMsg->pvPlayerContext == NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Player context is NULL!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (context is wrong)

			if (pDestroyPlayerMsg->dwReason != DPNDESTROYPLAYERREASON_NORMAL)
			{
				DPTEST_TRACE(pContext->hLog, "Player destruction reason is unexpected (%x != %x)!  DEBUGBREAK()-ing.",
					2, pDestroyPlayerMsg->dwReason, DPNDESTROYPLAYERREASON_NORMAL);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (reason is wrong)


			// Make sure this isn't a duplicate or bogus message.
			if ((*((DPNID*) pDestroyPlayerMsg->pvPlayerContext) == 0) ||
				(pDestroyPlayerMsg->dpnidPlayer != *((DPNID*) pDestroyPlayerMsg->pvPlayerContext)))
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate or unexpected DESTROY_PLAYER (msg = %x)!  DEBUGBREAK()-ing.",
					1, pDestroyPlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (already have ID)

			// Clear the player ID.
			*((DPNID*) pDestroyPlayerMsg->pvPlayerContext) = 0;
		  break;

		case DPN_MSGID_INDICATE_CONNECT:
			PDPNMSG_INDICATE_CONNECT	pIndicateConnectMsg;


			pIndicateConnectMsg = (PDPNMSG_INDICATE_CONNECT) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_INDICATE_CONNECT", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pIndicateConnectMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    pvUserConnectData = %x", 1, pIndicateConnectMsg->pvUserConnectData);
			DPTEST_TRACE(pContext->hLog, "    dwUserConnectDataSize = %u", 1, pIndicateConnectMsg->dwUserConnectDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyData = %x", 1, pIndicateConnectMsg->pvReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwReplyDataSize = %u", 1, pIndicateConnectMsg->dwReplyDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyContext = %x", 1, pIndicateConnectMsg->pvReplyContext);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pIndicateConnectMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    pAddressPlayer = 0x%08x", 1, pIndicateConnectMsg->pAddressPlayer);
			DPTEST_TRACE(pContext->hLog, "    pAddressDevice = 0x%08x", 1, pIndicateConnectMsg->pAddressDevice);

#pragma TODO(vanceo, "Validate DPN_MSGID_INDICATE_CONNECT")
		  break;

		case DPN_MSGID_REMOVE_PLAYER_FROM_GROUP:
			PDPNMSG_REMOVE_PLAYER_FROM_GROUP	pRemovePlayerFromGroupMsg;


			pRemovePlayerFromGroupMsg = (PDPNMSG_REMOVE_PLAYER_FROM_GROUP) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_REMOVE_PLAYER_FROM_GROUP", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pRemovePlayerFromGroupMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidGroup = %u/%x", 2, pRemovePlayerFromGroupMsg->dpnidGroup, pRemovePlayerFromGroupMsg->dpnidGroup);
			DPTEST_TRACE(pContext->hLog, "    pvGroupContext = %x", 1, pRemovePlayerFromGroupMsg->pvGroupContext);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pRemovePlayerFromGroupMsg->dpnidPlayer, pRemovePlayerFromGroupMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pRemovePlayerFromGroupMsg->pvPlayerContext);

#pragma BUGBUG(vanceo, "Validate DPN_MSGID_REMOVE_PLAYER_FROM_GROUP")
		  break;

		default:
			DPTEST_TRACE(pContext->hLog, "Got unexpected message type %x!  DEBUGBREAK()-ing.",
				1, dwMsgType);
			DEBUGBREAK();
			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)


DONE:

	return (hr);
} // ParmVPEnumGroupMembersDPNMessageHandler
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVPSetPeerInfoDPNMessageHandler()"
//==================================================================================
// ParmVPSetPeerInfoDPNMessageHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT ParmVPSetPeerInfoDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT						hr = DPN_OK;
	PPARMVPSETPEERINFOCONTEXT	pContext = (PPARMVPSETPEERINFOCONTEXT) pvContext;
	PDPN_PLAYER_INFO			pdpnpi = NULL;
	DWORD						dwSize = 0;
	BOOL						fSetEvent = FALSE;


	switch (dwMsgType)
	{
		case DPN_MSGID_ASYNC_OP_COMPLETE:
			PDPNMSG_ASYNC_OP_COMPLETE	pAsyncOpCompleteMsg;


			pAsyncOpCompleteMsg = (PDPNMSG_ASYNC_OP_COMPLETE) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_ASYNC_OP_COMPLETE", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pAsyncOpCompleteMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    hAsyncOp = %x", 1, pAsyncOpCompleteMsg->hAsyncOp);
			DPTEST_TRACE(pContext->hLog, "    pvUserContext = %x", 1, pAsyncOpCompleteMsg->pvUserContext);
			DPTEST_TRACE(pContext->hLog, "    hResultCode = 0x%08x", 1, pAsyncOpCompleteMsg->hResultCode);


			// Make sure we expect the completion.
			if (! pContext->fAsyncOpCanComplete)
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_ASYNC_OP_COMPLETE (%x)!  DEBUGBREAK()-ing.",
					1, pAsyncOpCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (message unexpected)


			// Validate the completion.
			if (pAsyncOpCompleteMsg->dwSize != sizeof (DPNMSG_ASYNC_OP_COMPLETE))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_ASYNC_OP_COMPLETE is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pAsyncOpCompleteMsg->dwSize, sizeof (DPNMSG_ASYNC_OP_COMPLETE));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pAsyncOpCompleteMsg->hResultCode != DPN_OK)
			{
				DPTEST_TRACE(pContext->hLog, "Async op completed with failure!  DEBUGBREAK()-ing.  0x%08x",
					1, pAsyncOpCompleteMsg->hResultCode);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (wrong result code)


			// Make sure this isn't a double completion.
			if (pContext->fAsyncOpCompleted)
			{
				DPTEST_TRACE(pContext->hLog, "Async op completed twice (msg = %x)!  DEBUGBREAK()-ing.",
					1, pAsyncOpCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (double completion)

			// Alert the test case that the completion came in.
			pContext->fAsyncOpCompleted = TRUE;

			// Remember the async op handle for comparison by the main thread.
			pContext->dpnhCompletedAsyncOp = pAsyncOpCompleteMsg->hAsyncOp;

			if (! SetEvent(pContext->hAsyncOpCompletedEvent))
			{
				hr = GetLastError();
				DPTEST_TRACE(pContext->hLog, "Couldn't set async op completed event (%x)!  DEBUGBREAK()-ing.",
					1, pContext->hAsyncOpCompletedEvent);

				DEBUGBREAK();

				if (hr == S_OK)
					hr = E_FAIL;

				hr = E_FAIL;
				goto DONE;
			} // end if (couldn't set event)

			// XBOX - Handle async ops
			if(pAsyncOpCompleteMsg->pvUserContext)
			{
				SetEvent((HANDLE) pAsyncOpCompleteMsg->pvUserContext);
			}
		  break;

		case DPN_MSGID_CONNECT_COMPLETE:
			PDPNMSG_CONNECT_COMPLETE	pConnectCompleteMsg;


			pConnectCompleteMsg = (PDPNMSG_CONNECT_COMPLETE) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CONNECT_COMPLETE", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pConnectCompleteMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    hAsyncOp = %x", 1, pConnectCompleteMsg->hAsyncOp);
			DPTEST_TRACE(pContext->hLog, "    pvUserContext = %x", 1, pConnectCompleteMsg->pvUserContext);
			DPTEST_TRACE(pContext->hLog, "    hResultCode = 0x%08x", 1, pConnectCompleteMsg->hResultCode);
			DPTEST_TRACE(pContext->hLog, "    pvApplicationReplyData = %x", 1, pConnectCompleteMsg->pvApplicationReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwApplicationReplyDataSize = %u", 1, pConnectCompleteMsg->dwApplicationReplyDataSize);


			// Make sure we expect the completion.
			if (! pContext->fConnectCanComplete)
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_CONNECT_COMPLETE (%x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (message unexpected)


			// Validate the completion.
			if (pConnectCompleteMsg->dwSize != sizeof (DPNMSG_CONNECT_COMPLETE))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CONNECT_COMPLETE is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->dwSize, sizeof (DPNMSG_CONNECT_COMPLETE));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pConnectCompleteMsg->hResultCode != DPN_OK)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with failure!  DEBUGBREAK()-ing.  0x%08x",
					1, pConnectCompleteMsg->hResultCode);
				DEBUGBREAK();
				hr = pConnectCompleteMsg->hResultCode;
				goto DONE;
			} // end if (wrong result code)

			if ((pConnectCompleteMsg->pvApplicationReplyData != NULL) ||
				(pConnectCompleteMsg->dwApplicationReplyDataSize != 0))
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with unexpected reply data (ptr %x != NULL or size %u != 0)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->pvApplicationReplyData,
					pConnectCompleteMsg->dwApplicationReplyDataSize);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (unexpected reply data)


			// Make sure this isn't a double completion.
			if (pContext->fConnectCompleted)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed twice (msg = %x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (double completion)

			// Alert the test case that the completion came in.
			pContext->fConnectCompleted = TRUE;

			// XBOX - Handle async connect
			if(pConnectCompleteMsg->pvUserContext)
			{
				SetEvent((HANDLE) pConnectCompleteMsg->pvUserContext);
			}

		  break;

		case DPN_MSGID_CREATE_PLAYER:
			PDPNMSG_CREATE_PLAYER	pCreatePlayerMsg;


			pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CREATE_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pCreatePlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pCreatePlayerMsg->dpnidPlayer, pCreatePlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pCreatePlayerMsg->pvPlayerContext);


			// Validate the indication.
			if (pCreatePlayerMsg->dwSize != sizeof (DPNMSG_CREATE_PLAYER))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CREATE_PLAYER is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pCreatePlayerMsg->dwSize, sizeof (DPNMSG_CREATE_PLAYER));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pCreatePlayerMsg->pvPlayerContext == NULL)
			{
				// Assume this is the remote player being created.  Store the
				// player context.
				if (pContext->fHost)
				{
					pCreatePlayerMsg->pvPlayerContext = &(pContext->dpnidClient);
					fSetEvent = TRUE;
				} // end if (host)
				else
				{
					pCreatePlayerMsg->pvPlayerContext = &(pContext->dpnidHost);
				} // end if (not host)
			} // end if (context is not set yet)


			// Make sure this isn't a duplicate message.
			if (*((DPNID*) pCreatePlayerMsg->pvPlayerContext) != 0)
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate CREATE_PLAYER (msg = %x)!  DEBUGBREAK()-ing.",
					1, pCreatePlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (already have ID)

			// Save the player ID.
			*((DPNID*) pCreatePlayerMsg->pvPlayerContext) = pCreatePlayerMsg->dpnidPlayer;


			// Now set the event, if we're supposed too.
			if (fSetEvent)
			{
				if (! SetEvent(pContext->hClientCreatedEvent))
				{
					hr = GetLastError();
					DPTEST_TRACE(pContext->hLog, "Couldn't set client created event (%x)!  DEBUGBREAK()-ing.",
						1, pContext->hClientCreatedEvent);

					DEBUGBREAK();

					if (hr == S_OK)
						hr = E_FAIL;

					goto DONE;
				} // end if (couldn't set event)
			} // end if (should set event)
		  break;

		case DPN_MSGID_DESTROY_PLAYER:
			PDPNMSG_DESTROY_PLAYER	pDestroyPlayerMsg;


			pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_DESTROY_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pDestroyPlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pDestroyPlayerMsg->dpnidPlayer, pDestroyPlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pDestroyPlayerMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    dwReason = %x", 1, pDestroyPlayerMsg->dwReason);


			// Validate the indication.
			if (pDestroyPlayerMsg->dwSize != sizeof (DPNMSG_DESTROY_PLAYER))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_DESTROY_PLAYER is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pDestroyPlayerMsg->dwSize, sizeof (DPNMSG_DESTROY_PLAYER));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pDestroyPlayerMsg->pvPlayerContext == NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Player context is NULL!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (context is wrong)

			if (pDestroyPlayerMsg->dwReason != DPNDESTROYPLAYERREASON_NORMAL)
			{
				DPTEST_TRACE(pContext->hLog, "Player destruction reason is unexpected (%x != %x)!  DEBUGBREAK()-ing.",
					2, pDestroyPlayerMsg->dwReason, DPNDESTROYPLAYERREASON_NORMAL);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (reason is wrong)


			// Make sure this isn't a duplicate or bogus message.
			if ((*((DPNID*) pDestroyPlayerMsg->pvPlayerContext) == 0) ||
				(pDestroyPlayerMsg->dpnidPlayer != *((DPNID*) pDestroyPlayerMsg->pvPlayerContext)))
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate or unexpected DESTROY_PLAYER (msg = %x)!  DEBUGBREAK()-ing.",
					1, pDestroyPlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (already have ID)

			// Clear the player ID.
			*((DPNID*) pDestroyPlayerMsg->pvPlayerContext) = 0;
		  break;

		case DPN_MSGID_INDICATE_CONNECT:
			PDPNMSG_INDICATE_CONNECT	pIndicateConnectMsg;


			pIndicateConnectMsg = (PDPNMSG_INDICATE_CONNECT) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_INDICATE_CONNECT", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pIndicateConnectMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    pvUserConnectData = %x", 1, pIndicateConnectMsg->pvUserConnectData);
			DPTEST_TRACE(pContext->hLog, "    dwUserConnectDataSize = %u", 1, pIndicateConnectMsg->dwUserConnectDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyData = %x", 1, pIndicateConnectMsg->pvReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwReplyDataSize = %u", 1, pIndicateConnectMsg->dwReplyDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyContext = %x", 1, pIndicateConnectMsg->pvReplyContext);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pIndicateConnectMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    pAddressPlayer = 0x%08x", 1, pIndicateConnectMsg->pAddressPlayer);
			DPTEST_TRACE(pContext->hLog, "    pAddressDevice = 0x%08x", 1, pIndicateConnectMsg->pAddressDevice);

#pragma TODO(vanceo, "Validate DPN_MSGID_INDICATE_CONNECT")
		  break;

		case DPN_MSGID_PEER_INFO:
			PDPNMSG_PEER_INFO	pPeerInfoMsg;


			pPeerInfoMsg = (PDPNMSG_PEER_INFO) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_PEER_INFO", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pPeerInfoMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPeer = %u/%x", 2, pPeerInfoMsg->dpnidPeer, pPeerInfoMsg->dpnidPeer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pPeerInfoMsg->pvPlayerContext);


			// Make sure we expect the indication.
			if (! pContext->fCanGetPeerInfoUpdate)
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_PEER_INFO!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (message unexpected)


			// Validate the indication.
			if (pPeerInfoMsg->dwSize != sizeof (DPNMSG_PEER_INFO))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_PEER_INFO is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pPeerInfoMsg->dwSize, sizeof (DPNMSG_PEER_INFO));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

#pragma BUGBUG(vanceo, "Validate player ID and context")
			/*
			if (pPeerInfoMsg->dpnidPeer != ?)
			{
				DPTEST_TRACE(pContext->hLog, "Peer ID is not expected (%u/%x != %u/%x)!  DEBUGBREAK()-ing.",
					4, pPeerInfoMsg->dpnidPeer, pPeerInfoMsg->dpnidPeer,
					?, ?);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (player ID is available)

			if (pPeerInfoMsg->pvPlayerContext != ?)
			{
				DPTEST_TRACE(pContext->hLog, "Player context is not expected (%x != %x)!  DEBUGBREAK()-ing.",
					2, pPeerInfoMsg->pvPlayerContext, ?);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (player context is wrong)
			*/


			// Retrieve the peer info.
			hr = pContext->pDP8Peer->DP8P_GetPeerInfo(pPeerInfoMsg->dpnidPeer,
														NULL, &dwSize, 0);
			if (hr != DPNERR_BUFFERTOOSMALL)
			{
				DPTEST_TRACE(pContext->hLog, "Getting peer info size didn't return expected error BUFFERTOOSMALL!  DEBUGBREAK()-ing.  0x%08x",
					1, hr);
				DEBUGBREAK();
				goto DONE;
			} // end if (couldn't get peer info)

			pdpnpi = (PDPN_PLAYER_INFO) MemAlloc(dwSize);
			if (pdpnpi == NULL)
			{
				hr = E_OUTOFMEMORY;
				goto DONE;
			} // end if (couldn't allocate memory)

			pdpnpi->dwSize = sizeof (DPN_PLAYER_INFO);

			hr = pContext->pDP8Peer->DP8P_GetPeerInfo(pPeerInfoMsg->dpnidPeer,
														pdpnpi, &dwSize, 0);
			if (hr != DPN_OK)
			{
				DPTEST_TRACE(pContext->hLog, "Getting peer info failed!  DEBUGBREAK()-ing.  0x%08x",
					1, hr);
				DEBUGBREAK();
				goto DONE;
			} // end if (couldn't get peer info)

			// Validate the peer info.
			if (pdpnpi->dwSize != sizeof (DPN_PLAYER_INFO))
			{
				DPTEST_TRACE(pContext->hLog, "Player info structure size modified (%u != %u)!  DEBUGBREAK()-ing.",
					2, pdpnpi->dwSize, sizeof (DPN_PLAYER_INFO));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (player structure size modified)

			if (pdpnpi->dwInfoFlags != (DPNINFO_NAME | DPNINFO_DATA))
			{
				DPTEST_TRACE(pContext->hLog, "Player info info flags don't match expected (%x != %x)!  DEBUGBREAK()-ing.",
					2, pdpnpi->dwInfoFlags, (DPNINFO_NAME | DPNINFO_DATA));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (player info info flags unexpected)

			if (pContext->pwszExpectedPeerInfoName == NULL)
			{
				if (pdpnpi->pwszName != NULL)
				{
					DPTEST_TRACE(pContext->hLog, "Player info contains an unexpected name string \"%S\"!  DEBUGBREAK()-ing.",
						1, pdpnpi->pwszName);
					DEBUGBREAK();
					hr = E_FAIL;
					goto DONE;
				} // end if (name was returned)
			} // end if (no name is expected)
			else
			{
				if ((pdpnpi->pwszName == NULL) ||
					(wcscmp(pdpnpi->pwszName, pContext->pwszExpectedPeerInfoName) != 0))
				{
					DPTEST_TRACE(pContext->hLog, "Player info name string doesn't match expected (\"%S\" != \"%S\")!  DEBUGBREAK()-ing.",
						2, pdpnpi->pwszName, pContext->pwszExpectedPeerInfoName);
					DEBUGBREAK();
					hr = E_FAIL;
					goto DONE;
				} // end if (player info name doesn't match)
			} // end else (name is expected)

			if (pContext->pvExpectedPeerInfoData == NULL)
			{
				if (pdpnpi->pvData != NULL)
				{
					DPTEST_TRACE(pContext->hLog, "Player info contains unexpected data %x (size = %u)!  DEBUGBREAK()-ing.",
						2, pdpnpi->pvData, pdpnpi->dwDataSize);
					DEBUGBREAK();
					hr = E_FAIL;
					goto DONE;
				} // end if (name was returned)
			} // end if (no name is expected)
			else
			{
				if ((pdpnpi->pvData == NULL) ||
					(pdpnpi->dwDataSize != pContext->dwExpectedPeerInfoDataSize) ||
					(memcmp(pdpnpi->pvData, pContext->pvExpectedPeerInfoData, pdpnpi->dwDataSize) != 0))
				{
					DPTEST_TRACE(pContext->hLog, "Player info data doesn't match expected (%u bytes at %x != %u bytes at %x)!  DEBUGBREAK()-ing.",
						4, pdpnpi->pvData,
						pdpnpi->dwDataSize,
						pContext->pvExpectedPeerInfoData,
						pContext->dwExpectedPeerInfoDataSize);
					DEBUGBREAK();
					hr = E_FAIL;
					goto DONE;
				} // end if (player data doesn't match)
			} // end else (name is expected)

			if (pdpnpi->dwPlayerFlags != pContext->dwExpectedPeerInfoPlayerFlags)
			{
				DPTEST_TRACE(pContext->hLog, "Player info player flags don't match expected (%x != %x)!  DEBUGBREAK()-ing.",
					2, pdpnpi->dwPlayerFlags, pContext->dwExpectedPeerInfoPlayerFlags);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (player info player flags unexpected)


			// Make sure this isn't a double indication.
			if (pContext->fGotPeerInfoUpdate)
			{
				DPTEST_TRACE(pContext->hLog, "Peer info update was indicated twice!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (double completion)

			// Alert the test case that the indication came in.
			pContext->fGotPeerInfoUpdate = TRUE;

			if (pContext->hGotPeerInfoUpdateEvent != NULL)
			{
				if (! SetEvent(pContext->hGotPeerInfoUpdateEvent))
				{
					hr = GetLastError();
					DPTEST_TRACE(pContext->hLog, "Couldn't set got peer info update event (%x)!  DEBUGBREAK()-ing.",
						1, pContext->hGotPeerInfoUpdateEvent);

					DEBUGBREAK();

					if (hr == S_OK)
						hr = E_FAIL;

					hr = E_FAIL;
					goto DONE;
				} // end if (couldn't set event)
			} // end if (there's an event)
		  break;

		default:
			DPTEST_TRACE(pContext->hLog, "Got unexpected message type %x!  DEBUGBREAK()-ing.",
				1, dwMsgType);
			DEBUGBREAK();
			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)


DONE:

	SAFE_LOCALFREE(pdpnpi);

	return (hr);
} // ParmVPSetPeerInfoDPNMessageHandler
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVPGetPeerInfoDPNMessageHandler()"
//==================================================================================
// ParmVPGetPeerInfoDPNMessageHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT ParmVPGetPeerInfoDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT						hr = DPN_OK;
	PPARMVPGETPEERINFOCONTEXT	pContext = (PPARMVPGETPEERINFOCONTEXT) pvContext;
	BOOL						fSetEvent = FALSE;


	switch (dwMsgType)
	{
		case DPN_MSGID_CONNECT_COMPLETE:
			PDPNMSG_CONNECT_COMPLETE	pConnectCompleteMsg;


			pConnectCompleteMsg = (PDPNMSG_CONNECT_COMPLETE) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CONNECT_COMPLETE", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pConnectCompleteMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    hAsyncOp = %x", 1, pConnectCompleteMsg->hAsyncOp);
			DPTEST_TRACE(pContext->hLog, "    pvUserContext = %x", 1, pConnectCompleteMsg->pvUserContext);
			DPTEST_TRACE(pContext->hLog, "    hResultCode = 0x%08x", 1, pConnectCompleteMsg->hResultCode);
			DPTEST_TRACE(pContext->hLog, "    pvApplicationReplyData = %x", 1, pConnectCompleteMsg->pvApplicationReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwApplicationReplyDataSize = %u", 1, pConnectCompleteMsg->dwApplicationReplyDataSize);


			// Make sure we expect the completion.
			if (! pContext->fConnectCanComplete)
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_CONNECT_COMPLETE (%x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (message unexpected)


			// Validate the completion.
			if (pConnectCompleteMsg->dwSize != sizeof (DPNMSG_CONNECT_COMPLETE))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CONNECT_COMPLETE is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->dwSize, sizeof (DPNMSG_CONNECT_COMPLETE));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pConnectCompleteMsg->hResultCode != DPN_OK)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with failure!  DEBUGBREAK()-ing.  0x%08x",
					1, pConnectCompleteMsg->hResultCode);
				DEBUGBREAK();
				hr = pConnectCompleteMsg->hResultCode;
				goto DONE;
			} // end if (wrong result code)

			if ((pConnectCompleteMsg->pvApplicationReplyData != NULL) ||
				(pConnectCompleteMsg->dwApplicationReplyDataSize != 0))
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with unexpected reply data (ptr %x != NULL or size %u != 0)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->pvApplicationReplyData,
					pConnectCompleteMsg->dwApplicationReplyDataSize);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (unexpected reply data)


			// Make sure this isn't a double completion.
			if (pContext->fConnectCompleted)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed twice (msg = %x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (double completion)

			// Alert the test case that the completion came in.
			pContext->fConnectCompleted = TRUE;

			// XBOX - Handle async connect
			if(pConnectCompleteMsg->pvUserContext)
			{
				SetEvent((HANDLE) pConnectCompleteMsg->pvUserContext);
			}
		  break;

		case DPN_MSGID_CREATE_PLAYER:
			PDPNMSG_CREATE_PLAYER	pCreatePlayerMsg;


			pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CREATE_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pCreatePlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pCreatePlayerMsg->dpnidPlayer, pCreatePlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pCreatePlayerMsg->pvPlayerContext);


			// Validate the indication.
			if (pCreatePlayerMsg->dwSize != sizeof (DPNMSG_CREATE_PLAYER))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CREATE_PLAYER is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pCreatePlayerMsg->dwSize, sizeof (DPNMSG_CREATE_PLAYER));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pCreatePlayerMsg->pvPlayerContext == NULL)
			{
				// Assume this is the remote player being created.  Store the
				// player context.
				if (pContext->fHost)
				{
					pCreatePlayerMsg->pvPlayerContext = &(pContext->dpnidClient);
					fSetEvent = TRUE;
				} // end if (host)
				else
				{
					pCreatePlayerMsg->pvPlayerContext = &(pContext->dpnidHost);
				} // end if (not host)
			} // end if (context is not set yet)


			// Make sure this isn't a duplicate message.
			if (*((DPNID*) pCreatePlayerMsg->pvPlayerContext) != 0)
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate CREATE_PLAYER (msg = %x)!  DEBUGBREAK()-ing.",
					1, pCreatePlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (already have ID)

			// Save the player ID.
			*((DPNID*) pCreatePlayerMsg->pvPlayerContext) = pCreatePlayerMsg->dpnidPlayer;


			// Now set the event, if we're supposed too.
			if (fSetEvent)
			{
				if (! SetEvent(pContext->hClientCreatedEvent))
				{
					hr = GetLastError();
					DPTEST_TRACE(pContext->hLog, "Couldn't set client created event (%x)!  DEBUGBREAK()-ing.",
						1, pContext->hClientCreatedEvent);

					DEBUGBREAK();

					if (hr == S_OK)
						hr = E_FAIL;

					goto DONE;
				} // end if (couldn't set event)
			} // end if (should set event)
		  break;

		case DPN_MSGID_DESTROY_PLAYER:
			PDPNMSG_DESTROY_PLAYER	pDestroyPlayerMsg;


			pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_DESTROY_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pDestroyPlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pDestroyPlayerMsg->dpnidPlayer, pDestroyPlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pDestroyPlayerMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    dwReason = %x", 1, pDestroyPlayerMsg->dwReason);


			// Validate the indication.
			if (pDestroyPlayerMsg->dwSize != sizeof (DPNMSG_DESTROY_PLAYER))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_DESTROY_PLAYER is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pDestroyPlayerMsg->dwSize, sizeof (DPNMSG_DESTROY_PLAYER));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pDestroyPlayerMsg->pvPlayerContext == NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Player context is NULL!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (context is wrong)

			if (pDestroyPlayerMsg->dwReason != DPNDESTROYPLAYERREASON_NORMAL)
			{
				DPTEST_TRACE(pContext->hLog, "Player destruction reason is unexpected (%x != %x)!  DEBUGBREAK()-ing.",
					2, pDestroyPlayerMsg->dwReason, DPNDESTROYPLAYERREASON_NORMAL);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (reason is wrong)


			// Make sure this isn't a duplicate or bogus message.
			if ((*((DPNID*) pDestroyPlayerMsg->pvPlayerContext) == 0) ||
				(pDestroyPlayerMsg->dpnidPlayer != *((DPNID*) pDestroyPlayerMsg->pvPlayerContext)))
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate or unexpected DESTROY_PLAYER (msg = %x)!  DEBUGBREAK()-ing.",
					1, pDestroyPlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (already have ID)

			// Clear the player ID.
			*((DPNID*) pDestroyPlayerMsg->pvPlayerContext) = 0;
		  break;

		case DPN_MSGID_INDICATE_CONNECT:
			PDPNMSG_INDICATE_CONNECT	pIndicateConnectMsg;


			pIndicateConnectMsg = (PDPNMSG_INDICATE_CONNECT) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_INDICATE_CONNECT", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pIndicateConnectMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    pvUserConnectData = %x", 1, pIndicateConnectMsg->pvUserConnectData);
			DPTEST_TRACE(pContext->hLog, "    dwUserConnectDataSize = %u", 1, pIndicateConnectMsg->dwUserConnectDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyData = %x", 1, pIndicateConnectMsg->pvReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwReplyDataSize = %u", 1, pIndicateConnectMsg->dwReplyDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyContext = %x", 1, pIndicateConnectMsg->pvReplyContext);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pIndicateConnectMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    pAddressPlayer = 0x%08x", 1, pIndicateConnectMsg->pAddressPlayer);
			DPTEST_TRACE(pContext->hLog, "    pAddressDevice = 0x%08x", 1, pIndicateConnectMsg->pAddressDevice);

#pragma TODO(vanceo, "Validate DPN_MSGID_INDICATE_CONNECT")
		  break;

		default:
			DPTEST_TRACE(pContext->hLog, "Got unexpected message type %x!  DEBUGBREAK()-ing.",
				1, dwMsgType);
			DEBUGBREAK();
			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)


DONE:

	return (hr);
} // ParmVPGetPeerInfoDPNMessageHandler
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVPGetPeerAddressDPNMessageHandler()"
//==================================================================================
// ParmVPGetPeerAddressDPNMessageHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT ParmVPGetPeerAddressDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT							hr = DPN_OK;
	PPARMVPGETPEERADDRESSCONTEXT	pContext = (PPARMVPGETPEERADDRESSCONTEXT) pvContext;
	BOOL							fSetEvent = FALSE;


	switch (dwMsgType)
	{
		case DPN_MSGID_CONNECT_COMPLETE:
			PDPNMSG_CONNECT_COMPLETE	pConnectCompleteMsg;


			pConnectCompleteMsg = (PDPNMSG_CONNECT_COMPLETE) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CONNECT_COMPLETE", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pConnectCompleteMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    hAsyncOp = %x", 1, pConnectCompleteMsg->hAsyncOp);
			DPTEST_TRACE(pContext->hLog, "    pvUserContext = %x", 1, pConnectCompleteMsg->pvUserContext);
			DPTEST_TRACE(pContext->hLog, "    hResultCode = 0x%08x", 1, pConnectCompleteMsg->hResultCode);
			DPTEST_TRACE(pContext->hLog, "    pvApplicationReplyData = %x", 1, pConnectCompleteMsg->pvApplicationReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwApplicationReplyDataSize = %u", 1, pConnectCompleteMsg->dwApplicationReplyDataSize);


			// Make sure we expect the completion.
			if (! pContext->fConnectCanComplete)
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_CONNECT_COMPLETE (%x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (message unexpected)


			// Validate the completion.
			if (pConnectCompleteMsg->dwSize != sizeof (DPNMSG_CONNECT_COMPLETE))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CONNECT_COMPLETE is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->dwSize, sizeof (DPNMSG_CONNECT_COMPLETE));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pConnectCompleteMsg->hResultCode != DPN_OK)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with failure!  DEBUGBREAK()-ing.  0x%08x",
					1, pConnectCompleteMsg->hResultCode);
				DEBUGBREAK();
				hr = pConnectCompleteMsg->hResultCode;
				goto DONE;
			} // end if (wrong result code)

			if ((pConnectCompleteMsg->pvApplicationReplyData != NULL) ||
				(pConnectCompleteMsg->dwApplicationReplyDataSize != 0))
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with unexpected reply data (ptr %x != NULL or size %u != 0)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->pvApplicationReplyData,
					pConnectCompleteMsg->dwApplicationReplyDataSize);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (unexpected reply data)


			// Make sure this isn't a double completion.
			if (pContext->fConnectCompleted)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed twice (msg = %x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (double completion)

			// Alert the test case that the completion came in.
			pContext->fConnectCompleted = TRUE;

			// XBOX - Handle async connect
			if(pConnectCompleteMsg->pvUserContext)
			{
				SetEvent((HANDLE) pConnectCompleteMsg->pvUserContext);
			}
		  break;

		case DPN_MSGID_CREATE_PLAYER:
			PDPNMSG_CREATE_PLAYER	pCreatePlayerMsg;


			pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CREATE_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pCreatePlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pCreatePlayerMsg->dpnidPlayer, pCreatePlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pCreatePlayerMsg->pvPlayerContext);


			// Validate the indication.
			if (pCreatePlayerMsg->dwSize != sizeof (DPNMSG_CREATE_PLAYER))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CREATE_PLAYER is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pCreatePlayerMsg->dwSize, sizeof (DPNMSG_CREATE_PLAYER));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pCreatePlayerMsg->pvPlayerContext == NULL)
			{
				// Assume this is the remote player being created.  Store the
				// player context.
				if (pContext->fHost)
				{
					pCreatePlayerMsg->pvPlayerContext = &(pContext->dpnidClient);
					fSetEvent = TRUE;
				} // end if (host)
				else
				{
					pCreatePlayerMsg->pvPlayerContext = &(pContext->dpnidHost);
				} // end if (not host)
			} // end if (context is not set yet)


			// Make sure this isn't a duplicate message.
			if (*((DPNID*) pCreatePlayerMsg->pvPlayerContext) != 0)
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate CREATE_PLAYER (msg = %x)!  DEBUGBREAK()-ing.",
					1, pCreatePlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (already have ID)

			// Save the player ID.
			*((DPNID*) pCreatePlayerMsg->pvPlayerContext) = pCreatePlayerMsg->dpnidPlayer;


			// Now set the event, if we're supposed too.
			if (fSetEvent)
			{
				if (! SetEvent(pContext->hClientCreatedEvent))
				{
					hr = GetLastError();
					DPTEST_TRACE(pContext->hLog, "Couldn't set client created event (%x)!  DEBUGBREAK()-ing.",
						1, pContext->hClientCreatedEvent);

					DEBUGBREAK();

					if (hr == S_OK)
						hr = E_FAIL;

					goto DONE;
				} // end if (couldn't set event)
			} // end if (should set event)
		  break;

		case DPN_MSGID_DESTROY_PLAYER:
			PDPNMSG_DESTROY_PLAYER	pDestroyPlayerMsg;


			pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_DESTROY_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pDestroyPlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pDestroyPlayerMsg->dpnidPlayer, pDestroyPlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pDestroyPlayerMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    dwReason = %x", 1, pDestroyPlayerMsg->dwReason);


			// Validate the indication.
			if (pDestroyPlayerMsg->dwSize != sizeof (DPNMSG_DESTROY_PLAYER))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_DESTROY_PLAYER is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pDestroyPlayerMsg->dwSize, sizeof (DPNMSG_DESTROY_PLAYER));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pDestroyPlayerMsg->pvPlayerContext == NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Player context is NULL!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (context is wrong)

			if (pDestroyPlayerMsg->dwReason != DPNDESTROYPLAYERREASON_NORMAL)
			{
				DPTEST_TRACE(pContext->hLog, "Player destruction reason is unexpected (%x != %x)!  DEBUGBREAK()-ing.",
					2, pDestroyPlayerMsg->dwReason, DPNDESTROYPLAYERREASON_NORMAL);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (reason is wrong)


			// Make sure this isn't a duplicate or bogus message.
			if ((*((DPNID*) pDestroyPlayerMsg->pvPlayerContext) == 0) ||
				(pDestroyPlayerMsg->dpnidPlayer != *((DPNID*) pDestroyPlayerMsg->pvPlayerContext)))
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate or unexpected DESTROY_PLAYER (msg = %x)!  DEBUGBREAK()-ing.",
					1, pDestroyPlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (already have ID)

			// Clear the player ID.
			*((DPNID*) pDestroyPlayerMsg->pvPlayerContext) = 0;
		  break;

		case DPN_MSGID_INDICATE_CONNECT:
			PDPNMSG_INDICATE_CONNECT	pIndicateConnectMsg;


			pIndicateConnectMsg = (PDPNMSG_INDICATE_CONNECT) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_INDICATE_CONNECT", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pIndicateConnectMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    pvUserConnectData = %x", 1, pIndicateConnectMsg->pvUserConnectData);
			DPTEST_TRACE(pContext->hLog, "    dwUserConnectDataSize = %u", 1, pIndicateConnectMsg->dwUserConnectDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyData = %x", 1, pIndicateConnectMsg->pvReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwReplyDataSize = %u", 1, pIndicateConnectMsg->dwReplyDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyContext = %x", 1, pIndicateConnectMsg->pvReplyContext);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pIndicateConnectMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    pAddressPlayer = 0x%08x", 1, pIndicateConnectMsg->pAddressPlayer);
			DPTEST_TRACE(pContext->hLog, "    pAddressDevice = 0x%08x", 1, pIndicateConnectMsg->pAddressDevice);

#pragma TODO(vanceo, "Validate DPN_MSGID_INDICATE_CONNECT")
		  break;

		default:
			DPTEST_TRACE(pContext->hLog, "Got unexpected message type %x!  DEBUGBREAK()-ing.",
				1, dwMsgType);
			DEBUGBREAK();
			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)


DONE:

	return (hr);
} // ParmVPGetPeerAddressDPNMessageHandler
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVPGetLHostAddressesDPNMessageHandler()"
//==================================================================================
// ParmVPGetLHostAddressesDPNMessageHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT ParmVPGetLHostAddressesDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT								hr = DPN_OK;
	PPARMVPGETLHOSTADDRESSESCONTEXT		pContext = (PPARMVPGETLHOSTADDRESSESCONTEXT) pvContext;
	BOOL								fSetEvent = FALSE;


	switch (dwMsgType)
	{
		case DPN_MSGID_CONNECT_COMPLETE:
			PDPNMSG_CONNECT_COMPLETE	pConnectCompleteMsg;


			pConnectCompleteMsg = (PDPNMSG_CONNECT_COMPLETE) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CONNECT_COMPLETE", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pConnectCompleteMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    hAsyncOp = %x", 1, pConnectCompleteMsg->hAsyncOp);
			DPTEST_TRACE(pContext->hLog, "    pvUserContext = %x", 1, pConnectCompleteMsg->pvUserContext);
			DPTEST_TRACE(pContext->hLog, "    hResultCode = 0x%08x", 1, pConnectCompleteMsg->hResultCode);
			DPTEST_TRACE(pContext->hLog, "    pvApplicationReplyData = %x", 1, pConnectCompleteMsg->pvApplicationReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwApplicationReplyDataSize = %u", 1, pConnectCompleteMsg->dwApplicationReplyDataSize);


			// Make sure we expect the completion.
			if (! pContext->fConnectCanComplete)
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_CONNECT_COMPLETE (%x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (message unexpected)


			// Validate the completion.
			if (pConnectCompleteMsg->dwSize != sizeof (DPNMSG_CONNECT_COMPLETE))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CONNECT_COMPLETE is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->dwSize, sizeof (DPNMSG_CONNECT_COMPLETE));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pConnectCompleteMsg->hResultCode != DPN_OK)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with failure!  DEBUGBREAK()-ing.  0x%08x",
					1, pConnectCompleteMsg->hResultCode);
				DEBUGBREAK();
				hr = pConnectCompleteMsg->hResultCode;
				goto DONE;
			} // end if (wrong result code)

			if ((pConnectCompleteMsg->pvApplicationReplyData != NULL) ||
				(pConnectCompleteMsg->dwApplicationReplyDataSize != 0))
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with unexpected reply data (ptr %x != NULL or size %u != 0)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->pvApplicationReplyData,
					pConnectCompleteMsg->dwApplicationReplyDataSize);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (unexpected reply data)


			// Make sure this isn't a double completion.
			if (pContext->fConnectCompleted)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed twice (msg = %x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (double completion)

			// Alert the test case that the completion came in.
			pContext->fConnectCompleted = TRUE;

			// XBOX - Handle async connect
			if(pConnectCompleteMsg->pvUserContext)
			{
				SetEvent((HANDLE) pConnectCompleteMsg->pvUserContext);
			}
		  break;

		case DPN_MSGID_CREATE_PLAYER:
			PDPNMSG_CREATE_PLAYER	pCreatePlayerMsg;


			pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CREATE_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pCreatePlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pCreatePlayerMsg->dpnidPlayer, pCreatePlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pCreatePlayerMsg->pvPlayerContext);


			// Validate the indication.
			if (pCreatePlayerMsg->dwSize != sizeof (DPNMSG_CREATE_PLAYER))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CREATE_PLAYER is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pCreatePlayerMsg->dwSize, sizeof (DPNMSG_CREATE_PLAYER));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pCreatePlayerMsg->pvPlayerContext == NULL)
			{
				// Assume this is the remote player being created.  Store the
				// player context.
				if (pContext->fHost)
				{
					pCreatePlayerMsg->pvPlayerContext = &(pContext->dpnidClient);
					fSetEvent = TRUE;
				} // end if (host)
				else
				{
					pCreatePlayerMsg->pvPlayerContext = &(pContext->dpnidHost);
				} // end if (not host)
			} // end if (context is not set yet)


			// Make sure this isn't a duplicate message.
			if (*((DPNID*) pCreatePlayerMsg->pvPlayerContext) != 0)
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate CREATE_PLAYER (msg = %x)!  DEBUGBREAK()-ing.",
					1, pCreatePlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (already have ID)

			// Save the player ID.
			*((DPNID*) pCreatePlayerMsg->pvPlayerContext) = pCreatePlayerMsg->dpnidPlayer;


			// Now set the event, if we're supposed too.
			if (fSetEvent)
			{
				if (! SetEvent(pContext->hClientCreatedEvent))
				{
					hr = GetLastError();
					DPTEST_TRACE(pContext->hLog, "Couldn't set client created event (%x)!  DEBUGBREAK()-ing.",
						1, pContext->hClientCreatedEvent);

					DEBUGBREAK();

					if (hr == S_OK)
						hr = E_FAIL;

					goto DONE;
				} // end if (couldn't set event)
			} // end if (should set event)
		  break;

		case DPN_MSGID_DESTROY_PLAYER:
			PDPNMSG_DESTROY_PLAYER	pDestroyPlayerMsg;


			pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_DESTROY_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pDestroyPlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pDestroyPlayerMsg->dpnidPlayer, pDestroyPlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pDestroyPlayerMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    dwReason = %x", 1, pDestroyPlayerMsg->dwReason);


			// Validate the indication.
			if (pDestroyPlayerMsg->dwSize != sizeof (DPNMSG_DESTROY_PLAYER))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_DESTROY_PLAYER is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pDestroyPlayerMsg->dwSize, sizeof (DPNMSG_DESTROY_PLAYER));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pDestroyPlayerMsg->pvPlayerContext == NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Player context is NULL!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (context is wrong)

			if (pDestroyPlayerMsg->dwReason != DPNDESTROYPLAYERREASON_NORMAL)
			{
				DPTEST_TRACE(pContext->hLog, "Player destruction reason is unexpected (%x != %x)!  DEBUGBREAK()-ing.",
					2, pDestroyPlayerMsg->dwReason, DPNDESTROYPLAYERREASON_NORMAL);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (reason is wrong)


			// Make sure this isn't a duplicate or bogus message.
			if ((*((DPNID*) pDestroyPlayerMsg->pvPlayerContext) == 0) ||
				(pDestroyPlayerMsg->dpnidPlayer != *((DPNID*) pDestroyPlayerMsg->pvPlayerContext)))
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate or unexpected DESTROY_PLAYER (msg = %x)!  DEBUGBREAK()-ing.",
					1, pDestroyPlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (already have ID)

			// Clear the player ID.
			*((DPNID*) pDestroyPlayerMsg->pvPlayerContext) = 0;
		  break;

		case DPN_MSGID_INDICATE_CONNECT:
			PDPNMSG_INDICATE_CONNECT	pIndicateConnectMsg;


			pIndicateConnectMsg = (PDPNMSG_INDICATE_CONNECT) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_INDICATE_CONNECT", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pIndicateConnectMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    pvUserConnectData = %x", 1, pIndicateConnectMsg->pvUserConnectData);
			DPTEST_TRACE(pContext->hLog, "    dwUserConnectDataSize = %u", 1, pIndicateConnectMsg->dwUserConnectDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyData = %x", 1, pIndicateConnectMsg->pvReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwReplyDataSize = %u", 1, pIndicateConnectMsg->dwReplyDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyContext = %x", 1, pIndicateConnectMsg->pvReplyContext);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pIndicateConnectMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    pAddressPlayer = 0x%08x", 1, pIndicateConnectMsg->pAddressPlayer);
			DPTEST_TRACE(pContext->hLog, "    pAddressDevice = 0x%08x", 1, pIndicateConnectMsg->pAddressDevice);

#pragma TODO(vanceo, "Validate DPN_MSGID_INDICATE_CONNECT")
		  break;

		default:
			DPTEST_TRACE(pContext->hLog, "Got unexpected message type %x!  DEBUGBREAK()-ing.",
				1, dwMsgType);
			DEBUGBREAK();
			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)


DONE:

	return (hr);
} // ParmVPGetLHostAddressesDPNMessageHandler
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVPCloseDPNMessageHandler()"
//==================================================================================
// ParmVPCloseDPNMessageHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT ParmVPCloseDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT					hr = DPN_OK;
	PPARMVPCLOSECONTEXT		pContext = (PPARMVPCLOSECONTEXT) pvContext;


	switch (dwMsgType)
	{
		case DPN_MSGID_ASYNC_OP_COMPLETE:
			PDPNMSG_ASYNC_OP_COMPLETE	pAsyncOpCompleteMsg;


			pAsyncOpCompleteMsg = (PDPNMSG_ASYNC_OP_COMPLETE) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_ASYNC_OP_COMPLETE", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pAsyncOpCompleteMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    hAsyncOp = %x", 1, pAsyncOpCompleteMsg->hAsyncOp);
			DPTEST_TRACE(pContext->hLog, "    pvUserContext = %x", 1, pAsyncOpCompleteMsg->pvUserContext);
			DPTEST_TRACE(pContext->hLog, "    hResultCode = 0x%08x", 1, pAsyncOpCompleteMsg->hResultCode);


			// Make sure we expect the completion.
			if (! pContext->fAsyncOpCanComplete)
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_ASYNC_OP_COMPLETE (%x)!  DEBUGBREAK()-ing.",
					1, pAsyncOpCompleteMsg);
				DEBUGBREAK();
				break;
			} // end if (message unexpected)


			// Validate the completion.
			if (pAsyncOpCompleteMsg->dwSize != sizeof (DPNMSG_ASYNC_OP_COMPLETE))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_ASYNC_OP_COMPLETE is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pAsyncOpCompleteMsg->dwSize, sizeof (DPNMSG_ASYNC_OP_COMPLETE));
				DEBUGBREAK();
				break;
			} // end if (size incorrect)

			if (pAsyncOpCompleteMsg->pvUserContext != NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Async op completed with wrong context (%x != NULL)!  DEBUGBREAK()-ing.",
					1, pAsyncOpCompleteMsg->pvUserContext);
				DEBUGBREAK();
				break;
			} // end if (wrong context)

			if (pAsyncOpCompleteMsg->hResultCode != DPNERR_USERCANCEL)
			{
				DPTEST_TRACE(pContext->hLog, "Async op didn't complete with expected error DPNERR_USERCANCEL!  0x%08x",
					1, pAsyncOpCompleteMsg->hResultCode);
				DEBUGBREAK();
				break;
			} // end if (wrong result code)


			// Make sure this isn't a double completion.
			if (pContext->fAsyncOpCompleted)
			{
				DPTEST_TRACE(pContext->hLog, "Async op completed twice (msg = %x)!  DEBUGBREAK()-ing.",
					1, pAsyncOpCompleteMsg);
				DEBUGBREAK();
				break;
			} // end if (double completion)

			// Alert the test case that the completion came in.
			pContext->fAsyncOpCompleted = TRUE;

			// Remember the async op handle for comparison by the main thread.
			pContext->dpnhCompletedAsyncOp = pAsyncOpCompleteMsg->hAsyncOp;
		  break;

		case DPN_MSGID_CONNECT_COMPLETE:
			PDPNMSG_CONNECT_COMPLETE	pConnectCompleteMsg;


			pConnectCompleteMsg = (PDPNMSG_CONNECT_COMPLETE) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CONNECT_COMPLETE", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pConnectCompleteMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    hAsyncOp = %x", 1, pConnectCompleteMsg->hAsyncOp);
			DPTEST_TRACE(pContext->hLog, "    pvUserContext = %x", 1, pConnectCompleteMsg->pvUserContext);
			DPTEST_TRACE(pContext->hLog, "    hResultCode = 0x%08x", 1, pConnectCompleteMsg->hResultCode);
			DPTEST_TRACE(pContext->hLog, "    pvApplicationReplyData = %x", 1, pConnectCompleteMsg->pvApplicationReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwApplicationReplyDataSize = %u", 1, pConnectCompleteMsg->dwApplicationReplyDataSize);


			// Make sure we expect the completion.
			if (! pContext->fConnectCanComplete)
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_CONNECT_COMPLETE (%x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				break;
			} // end if (message unexpected)


			// Validate the completion.
			if (pConnectCompleteMsg->dwSize != sizeof (DPNMSG_CONNECT_COMPLETE))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CONNECT_COMPLETE is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->dwSize, sizeof (DPNMSG_CONNECT_COMPLETE));
				DEBUGBREAK();
				break;
			} // end if (size incorrect)

			if (pConnectCompleteMsg->hAsyncOp != NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with an async op handle (%x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg->hAsyncOp);
				DEBUGBREAK();
				break;
			} // end if (wrong op handle)

			if (pConnectCompleteMsg->pvUserContext != NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with wrong context (%x != NULL)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg->pvUserContext);
				DEBUGBREAK();
				break;
			} // end if (wrong context)

			if (pConnectCompleteMsg->hResultCode != DPN_OK)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with failure!  DEBUGBREAK()-ing.  0x%08x",
					1, pConnectCompleteMsg->hResultCode);
				DEBUGBREAK();
				break;
			} // end if (wrong result code)

			if ((pConnectCompleteMsg->pvApplicationReplyData != NULL) ||
				(pConnectCompleteMsg->dwApplicationReplyDataSize != 0))
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with unexpected reply data (ptr %x != NULL or size %u != 0)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->pvApplicationReplyData,
					pConnectCompleteMsg->dwApplicationReplyDataSize);
				DEBUGBREAK();
				break;
			} // end if (unexpected reply data)


			// Make sure this isn't a double completion.
			if (pContext->fConnectCompleted)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed twice (msg = %x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				break;
			} // end if (double completion)

			// Alert the test case that the completion came in.
			pContext->fConnectCompleted = TRUE;
		  break;

		case DPN_MSGID_CREATE_PLAYER:
			PDPNMSG_CREATE_PLAYER	pCreatePlayerMsg;


			pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CREATE_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pCreatePlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pCreatePlayerMsg->dpnidPlayer, pCreatePlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pCreatePlayerMsg->pvPlayerContext);

#pragma TODO(vanceo, "Validate CREATE_PLAYER")
		  break;

		case DPN_MSGID_DESTROY_PLAYER:
			PDPNMSG_DESTROY_PLAYER	pDestroyPlayerMsg;


			pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_DESTROY_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pDestroyPlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pDestroyPlayerMsg->dpnidPlayer, pDestroyPlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pDestroyPlayerMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    dwReason = %x", 1, pDestroyPlayerMsg->dwReason);

#pragma TODO(vanceo, "Validate DPN_MSGID_DESTROY_PLAYER")
		  break;

		case DPN_MSGID_INDICATE_CONNECT:
			PDPNMSG_INDICATE_CONNECT	pIndicateConnectMsg;


			pIndicateConnectMsg = (PDPNMSG_INDICATE_CONNECT) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_INDICATE_CONNECT", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pIndicateConnectMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    pvUserConnectData = %x", 1, pIndicateConnectMsg->pvUserConnectData);
			DPTEST_TRACE(pContext->hLog, "    dwUserConnectDataSize = %u", 1, pIndicateConnectMsg->dwUserConnectDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyData = %x", 1, pIndicateConnectMsg->pvReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwReplyDataSize = %u", 1, pIndicateConnectMsg->dwReplyDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyContext = %x", 1, pIndicateConnectMsg->pvReplyContext);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pIndicateConnectMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    pAddressPlayer = 0x%08x", 1, pIndicateConnectMsg->pAddressPlayer);
			DPTEST_TRACE(pContext->hLog, "    pAddressDevice = 0x%08x", 1, pIndicateConnectMsg->pAddressDevice);

#pragma TODO(vanceo, "Validate DPN_MSGID_INDICATE_CONNECT")
		  break;

		default:
			DPTEST_TRACE(pContext->hLog, "Got unexpected message type %x!  DEBUGBREAK()-ing.",
				1, dwMsgType);
			DEBUGBREAK();
			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)

	return (hr);
} // ParmVPCloseDPNMessageHandler
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVPEnumHostsDPNMessageHandler()"
//==================================================================================
// ParmVPEnumHostsDPNMessageHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT ParmVPEnumHostsDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT						hr = DPN_OK;
	PPARMVPENUMHOSTSCONTEXT		pContext = (PPARMVPENUMHOSTSCONTEXT) pvContext;
	DWORD						dwOp;
	BOOL						fSetEvent = FALSE;


	switch (dwMsgType)
	{
		case DPN_MSGID_ASYNC_OP_COMPLETE:
			PDPNMSG_ASYNC_OP_COMPLETE	pAsyncOpCompleteMsg;


			pAsyncOpCompleteMsg = (PDPNMSG_ASYNC_OP_COMPLETE) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_ASYNC_OP_COMPLETE", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pAsyncOpCompleteMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    hAsyncOp = %x", 1, pAsyncOpCompleteMsg->hAsyncOp);
			DPTEST_TRACE(pContext->hLog, "    pvUserContext = %x", 1, pAsyncOpCompleteMsg->pvUserContext);
			DPTEST_TRACE(pContext->hLog, "    hResultCode = 0x%08x", 1, pAsyncOpCompleteMsg->hResultCode);


			dwOp = (DWORD) ((DWORD_PTR) pAsyncOpCompleteMsg->pvUserContext);
			if ((dwOp != 1) && (dwOp != 2))
			{
				DPTEST_TRACE(pContext->hLog, "Got invalid context for async op completion (%x)!  DEBUGBREAK()-ing.",
					1, pAsyncOpCompleteMsg->pvUserContext);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (got invalid context)

			dwOp--; // make it a zero based index


			// Make sure we expect the completion.
			if (! pContext->afAsyncOpCanComplete[dwOp])
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_ASYNC_OP_COMPLETE (%x)!  DEBUGBREAK()-ing.",
					1, pAsyncOpCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (message unexpected)


			// Validate the completion.
			if (pAsyncOpCompleteMsg->dwSize != sizeof (DPNMSG_ASYNC_OP_COMPLETE))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_ASYNC_OP_COMPLETE is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pAsyncOpCompleteMsg->dwSize, sizeof (DPNMSG_ASYNC_OP_COMPLETE));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pAsyncOpCompleteMsg->hResultCode != pContext->ahrExpectedResult[dwOp])
			{
				DPTEST_TRACE(pContext->hLog, "Async op didn't complete with expected return code (%x != %x)!",
					2, pAsyncOpCompleteMsg->hResultCode,
					pContext->ahrExpectedResult[dwOp]);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (wrong result code)


			// Make sure this isn't a double completion.
			if (pContext->afAsyncOpCompleted[dwOp])
			{
				DPTEST_TRACE(pContext->hLog, "Async op completed twice (msg = %x)!  DEBUGBREAK()-ing.",
					1, pAsyncOpCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (double completion)

			// Alert the test case that the completion came in.
			pContext->afAsyncOpCompleted[dwOp] = TRUE;

			// Remember the async op handle for comparison by the main thread.
			pContext->adpnhCompletedAsyncOp[dwOp] = pAsyncOpCompleteMsg->hAsyncOp;

			if (! SetEvent(pContext->ahAsyncOpCompletedEvent[dwOp]))
			{
				hr = GetLastError();
				DPTEST_TRACE(pContext->hLog, "Couldn't set async op completed event (%x)!  DEBUGBREAK()-ing.",
					1, pContext->ahAsyncOpCompletedEvent[dwOp]);

				DEBUGBREAK();

				if (hr == S_OK)
					hr = E_FAIL;

				goto DONE;
			} // end if (couldn't set event)
		  break;

		case DPN_MSGID_CONNECT_COMPLETE:
			PDPNMSG_CONNECT_COMPLETE	pConnectCompleteMsg;


			pConnectCompleteMsg = (PDPNMSG_CONNECT_COMPLETE) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CONNECT_COMPLETE", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pConnectCompleteMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    hAsyncOp = %x", 1, pConnectCompleteMsg->hAsyncOp);
			DPTEST_TRACE(pContext->hLog, "    pvUserContext = %x", 1, pConnectCompleteMsg->pvUserContext);
			DPTEST_TRACE(pContext->hLog, "    hResultCode = 0x%08x", 1, pConnectCompleteMsg->hResultCode);
			DPTEST_TRACE(pContext->hLog, "    pvApplicationReplyData = %x", 1, pConnectCompleteMsg->pvApplicationReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwApplicationReplyDataSize = %u", 1, pConnectCompleteMsg->dwApplicationReplyDataSize);


			// Make sure we expect the completion.
			if (! pContext->fConnectCanComplete)
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_CONNECT_COMPLETE (%x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (message unexpected)


			// Validate the completion.
			if (pConnectCompleteMsg->dwSize != sizeof (DPNMSG_CONNECT_COMPLETE))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CONNECT_COMPLETE is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->dwSize, sizeof (DPNMSG_CONNECT_COMPLETE));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pConnectCompleteMsg->hResultCode != DPN_OK)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with failure!  DEBUGBREAK()-ing.  0x%08x",
					1, pConnectCompleteMsg->hResultCode);
				DEBUGBREAK();
				hr = pConnectCompleteMsg->hResultCode;
				goto DONE;
			} // end if (wrong result code)

			if ((pConnectCompleteMsg->pvApplicationReplyData != NULL) ||
				(pConnectCompleteMsg->dwApplicationReplyDataSize != 0))
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with unexpected reply data (ptr %x != NULL or size %u != 0)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->pvApplicationReplyData,
					pConnectCompleteMsg->dwApplicationReplyDataSize);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (unexpected reply data)


			// Make sure this isn't a double completion.
			if (pContext->fConnectCompleted)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed twice (msg = %x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (double completion)

			// Alert the test case that the completion came in.
			pContext->fConnectCompleted = TRUE;

			// XBOX - Handle async connect
			if(pConnectCompleteMsg->pvUserContext)
			{
				SetEvent((HANDLE) pConnectCompleteMsg->pvUserContext);
			}
		  break;

		case DPN_MSGID_CREATE_PLAYER:
			PDPNMSG_CREATE_PLAYER	pCreatePlayerMsg;


			pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CREATE_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pCreatePlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pCreatePlayerMsg->dpnidPlayer, pCreatePlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pCreatePlayerMsg->pvPlayerContext);


			// Validate the indication.
			if (pCreatePlayerMsg->dwSize != sizeof (DPNMSG_CREATE_PLAYER))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CREATE_PLAYER is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pCreatePlayerMsg->dwSize, sizeof (DPNMSG_CREATE_PLAYER));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pCreatePlayerMsg->pvPlayerContext == NULL)
			{
				// Assume this is the remote player being created.  Store the
				// player context.
				if (pContext->fHost)
				{
					pCreatePlayerMsg->pvPlayerContext = &(pContext->dpnidClient);
					fSetEvent = TRUE;
				} // end if (host)
				else
				{
					pCreatePlayerMsg->pvPlayerContext = &(pContext->dpnidHost);
				} // end if (not host)
			} // end if (context is not set yet)


			// Make sure this isn't a duplicate message.
			if (*((DPNID*) pCreatePlayerMsg->pvPlayerContext) != 0)
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate CREATE_PLAYER (msg = %x)!  DEBUGBREAK()-ing.",
					1, pCreatePlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (already have ID)

			// Save the player ID.
			*((DPNID*) pCreatePlayerMsg->pvPlayerContext) = pCreatePlayerMsg->dpnidPlayer;


			// Now set the event, if we're supposed too.
			if (fSetEvent)
			{
				if (! SetEvent(pContext->hClientCreatedEvent))
				{
					hr = GetLastError();
					DPTEST_TRACE(pContext->hLog, "Couldn't set client created event (%x)!  DEBUGBREAK()-ing.",
						1, pContext->hClientCreatedEvent);

					DEBUGBREAK();

					if (hr == S_OK)
						hr = E_FAIL;

					goto DONE;
				} // end if (couldn't set event)
			} // end if (should set event)
		  break;

		case DPN_MSGID_DESTROY_PLAYER:
			PDPNMSG_DESTROY_PLAYER	pDestroyPlayerMsg;


			pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_DESTROY_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pDestroyPlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pDestroyPlayerMsg->dpnidPlayer, pDestroyPlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pDestroyPlayerMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    dwReason = %x", 1, pDestroyPlayerMsg->dwReason);


			// Validate the indication.
			if (pDestroyPlayerMsg->dwSize != sizeof (DPNMSG_DESTROY_PLAYER))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_DESTROY_PLAYER is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pDestroyPlayerMsg->dwSize, sizeof (DPNMSG_DESTROY_PLAYER));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pDestroyPlayerMsg->pvPlayerContext == NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Player context is NULL!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (context is wrong)

			if (pDestroyPlayerMsg->dwReason != DPNDESTROYPLAYERREASON_NORMAL)
			{
				DPTEST_TRACE(pContext->hLog, "Player destruction reason is unexpected (%x != %x)!  DEBUGBREAK()-ing.",
					2, pDestroyPlayerMsg->dwReason, DPNDESTROYPLAYERREASON_NORMAL);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (reason is wrong)


			// Make sure this isn't a duplicate or bogus message.
			if ((*((DPNID*) pDestroyPlayerMsg->pvPlayerContext) == 0) ||
				(pDestroyPlayerMsg->dpnidPlayer != *((DPNID*) pDestroyPlayerMsg->pvPlayerContext)))
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate or unexpected DESTROY_PLAYER (msg = %x)!  DEBUGBREAK()-ing.",
					1, pDestroyPlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (already have ID)

			// Clear the player ID.
			*((DPNID*) pDestroyPlayerMsg->pvPlayerContext) = 0;
		  break;

		case DPN_MSGID_ENUM_HOSTS_QUERY:
			PDPNMSG_ENUM_HOSTS_QUERY	pEnumQueryMsg;



			pEnumQueryMsg = (PDPNMSG_ENUM_HOSTS_QUERY) pvMsg;
			
			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_ENUM_HOSTS_QUERY", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pEnumQueryMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    pAddressSender = 0x%08x", 1, pEnumQueryMsg->pAddressSender);
			DPTEST_TRACE(pContext->hLog, "    pAddressDevice = 0x%08x", 1, pEnumQueryMsg->pAddressDevice);
			DPTEST_TRACE(pContext->hLog, "    pvReceivedData = %x", 1, pEnumQueryMsg->pvReceivedData);
			DPTEST_TRACE(pContext->hLog, "    dwReceivedDataSize = %u", 1, pEnumQueryMsg->dwReceivedDataSize);
			DPTEST_TRACE(pContext->hLog, "    dwMaxResponseDataSize = %u", 1, pEnumQueryMsg->dwMaxResponseDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvResponseData = %x", 1, pEnumQueryMsg->pvResponseData);
			DPTEST_TRACE(pContext->hLog, "    dwResponseDataSize = %u", 1, pEnumQueryMsg->dwResponseDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvResponseContext = %x", 1, pEnumQueryMsg->pvResponseContext);


			// Verify the incoming data.
			if ((pEnumQueryMsg->pvReceivedData != NULL) ||
				(pEnumQueryMsg->dwResponseDataSize != 0))
			{
				DPTEST_TRACE(pContext->hLog, "%u bytes of query user data was received (%x) but none was expected!  DEBUGBREAK()-ing.",
					2, pEnumQueryMsg->dwReceivedDataSize,
					pEnumQueryMsg->pvReceivedData);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (incoming data)


#pragma TODO(vanceo, "Validate addresses")

			InterlockedIncrement((LPLONG) &(pContext->dwNumQueries));
		  break;

		case DPN_MSGID_ENUM_HOSTS_RESPONSE:
			PDPNMSG_ENUM_HOSTS_RESPONSE		pEnumHostsResponseMsg;



			pEnumHostsResponseMsg = (PDPNMSG_ENUM_HOSTS_RESPONSE) pvMsg;
			
			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_ENUM_HOSTS_RESPONSE", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pEnumHostsResponseMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    pAddressSender = 0x%08x", 1, pEnumHostsResponseMsg->pAddressSender);
			DPTEST_TRACE(pContext->hLog, "    pAddressDevice = 0x%08x", 1, pEnumHostsResponseMsg->pAddressDevice);
			DPTEST_TRACE(pContext->hLog, "    pApplicationDescription = %x", 1, pEnumHostsResponseMsg->pApplicationDescription);
			DPTEST_TRACE(pContext->hLog, "    pvResponseData = %x", 1, pEnumHostsResponseMsg->pvResponseData);
			DPTEST_TRACE(pContext->hLog, "    dwResponseDataSize = %u", 1, pEnumHostsResponseMsg->dwResponseDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvUserContext = %x", 1, pEnumHostsResponseMsg->pvUserContext);
			DPTEST_TRACE(pContext->hLog, "    dwRoundTripLatencyMS = %u", 1, pEnumHostsResponseMsg->dwRoundTripLatencyMS);



			dwOp = (DWORD) ((DWORD_PTR) pEnumHostsResponseMsg->pvUserContext);
			if ((dwOp != 1) && (dwOp != 2))
			{
				DPTEST_TRACE(pContext->hLog, "Got invalid context for async op completion (%x)!  DEBUGBREAK()-ing.",
					1, pEnumHostsResponseMsg->pvUserContext);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (got invalid context)

			dwOp--; // make it a zero based index


			// Make sure we expect responses.
			if (! pContext->afCanGetResponses[dwOp])
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_ENUM_HOSTS_RESPONSE (%x)!  DEBUGBREAK()-ing.",
					1, pEnumHostsResponseMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (message unexpected)


#pragma TODO(vanceo, "Validate addresses")
			/*
			hr = pEnumHostsResponseMsg->pAddressSender->IsEqual(pContext->apExpectedDP8AddressSender[dwOp]);
			if (hr != DPNSUCCESS_EQUAL)
			{
				DPTEST_TRACE(pContext->hLog, "Enum response sender is not expected (0x%08x != 0x%08x)!  DEBUGBREAK()-ing.",
					2, pEnumHostsResponseMsg->pAddressSender,
					pContext->apExpectedDP8AddressSender[dwOp]);
				DEBUGBREAK();
				if (hr == S_OK)
					hr = E_FAIL;
				goto DONE;
			} // end if (sender address is different)

			hr = pEnumHostsResponseMsg->pAddressDevice->IsEqual(pContext->apExpectedDP8AddressDevice[dwOp]);
			if (hr != DPNSUCCESS_EQUAL)
			{
				DPTEST_TRACE(pContext->hLog, "Enum response device is not expected (0x%08x != 0x%08x)!  DEBUGBREAK()-ing.",
					2, pEnumHostsResponseMsg->pAddressDevice,
					pContext->apExpectedDP8AddressDevice[dwOp]);
				DEBUGBREAK();
				if (hr == S_OK)
					hr = E_FAIL;
				goto DONE;
			} // end if (device address is different)
			*/

			hr = DPN_OK;



			if (pEnumHostsResponseMsg->pApplicationDescription->dwSize != sizeof (DPN_APPLICATION_DESC))
			{
				DPTEST_TRACE(pContext->hLog, "Size of application desc is wrong (%u != %u)!  DEBUGBREAK()-ing.",
					2, pEnumHostsResponseMsg->pApplicationDescription->dwSize,
					sizeof (DPN_APPLICATION_DESC));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (app desc size is wrong)

#pragma TODO(vanceo, "Validate app desc dwFlags and guidInstance")

			if (memcmp(&(pEnumHostsResponseMsg->pApplicationDescription->guidApplication), pContext->pguidExpectedApplication, sizeof (GUID)) != 0)
			{
				DPTEST_TRACE(pContext->hLog, "Application desc app guid is wrong (%g != %g)!  DEBUGBREAK()-ing.",
					2, &pEnumHostsResponseMsg->pApplicationDescription->guidApplication,
					&GUID_ENUMS_SIMPLE);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (app desc size is wrong)

			if (pEnumHostsResponseMsg->pApplicationDescription->dwMaxPlayers != 0)
			{
				DPTEST_TRACE(pContext->hLog, "Application desc max players is wrong (%u != 0)!  DEBUGBREAK()-ing.",
					1, pEnumHostsResponseMsg->pApplicationDescription->dwMaxPlayers);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (app desc max players is wrong)

			if (pEnumHostsResponseMsg->pApplicationDescription->dwCurrentPlayers != pContext->adwExpectedCurrentPlayers[dwOp])
			{
				DPTEST_TRACE(pContext->hLog, "Application desc current players is wrong (%u != %u)!  DEBUGBREAK()-ing.",
					2, pEnumHostsResponseMsg->pApplicationDescription->dwCurrentPlayers,
					pContext->adwExpectedCurrentPlayers[dwOp]);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (app desc current players is wrong)

			if (pEnumHostsResponseMsg->pApplicationDescription->pwszSessionName != NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Application desc session name is not NULL (%S)!  DEBUGBREAK()-ing.",
					1, pEnumHostsResponseMsg->pApplicationDescription->pwszSessionName);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (app desc session name is wrong)

			if (pEnumHostsResponseMsg->pApplicationDescription->pwszPassword != NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Application desc password is not NULL (%S)!  DEBUGBREAK()-ing.",
					1, pEnumHostsResponseMsg->pApplicationDescription->pwszPassword);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (app desc password is wrong)

			if ((pEnumHostsResponseMsg->pApplicationDescription->pvReservedData != NULL) ||
				(pEnumHostsResponseMsg->pApplicationDescription->dwReservedDataSize != 0))
			{
				DPTEST_TRACE(pContext->hLog, "Application desc reserved data is not NULL/0 (%x, %u)!  DEBUGBREAK()-ing.",
					2, pEnumHostsResponseMsg->pApplicationDescription->pvReservedData,
					pEnumHostsResponseMsg->pApplicationDescription->dwReservedDataSize);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (app desc reserved data is wrong)


			// Verify the app desc data.
			if ((pEnumHostsResponseMsg->pApplicationDescription->pvApplicationReservedData != NULL) ||
				(pEnumHostsResponseMsg->pApplicationDescription->dwApplicationReservedDataSize != 0))
			{
				DPTEST_TRACE(pContext->hLog, "%u bytes of application desc data was received (%x) but none was expected!  DEBUGBREAK()-ing.",
					2, pEnumHostsResponseMsg->pApplicationDescription->dwApplicationReservedDataSize,
					pEnumHostsResponseMsg->pApplicationDescription->pvApplicationReservedData);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (appdesc data)


			// Verify the incoming data.
			if ((pEnumHostsResponseMsg->pvResponseData != NULL) ||
				(pEnumHostsResponseMsg->dwResponseDataSize != 0))
			{
				DPTEST_TRACE(pContext->hLog, "%u bytes of response user data was received (%x) but none was expected!  DEBUGBREAK()-ing.",
					2, pEnumHostsResponseMsg->dwResponseDataSize,
					pEnumHostsResponseMsg->pvResponseData);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (incoming data)

			InterlockedIncrement((LPLONG) &(pContext->adwNumResponses[dwOp]));
		  break;

		case DPN_MSGID_INDICATE_CONNECT:
			PDPNMSG_INDICATE_CONNECT	pIndicateConnectMsg;


			pIndicateConnectMsg = (PDPNMSG_INDICATE_CONNECT) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_INDICATE_CONNECT", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pIndicateConnectMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    pvUserConnectData = %x", 1, pIndicateConnectMsg->pvUserConnectData);
			DPTEST_TRACE(pContext->hLog, "    dwUserConnectDataSize = %u", 1, pIndicateConnectMsg->dwUserConnectDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyData = %x", 1, pIndicateConnectMsg->pvReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwReplyDataSize = %u", 1, pIndicateConnectMsg->dwReplyDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyContext = %x", 1, pIndicateConnectMsg->pvReplyContext);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pIndicateConnectMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    pAddressPlayer = 0x%08x", 1, pIndicateConnectMsg->pAddressPlayer);
			DPTEST_TRACE(pContext->hLog, "    pAddressDevice = 0x%08x", 1, pIndicateConnectMsg->pAddressDevice);

#pragma TODO(vanceo, "Validate DPN_MSGID_INDICATE_CONNECT")
		  break;

		default:
			DPTEST_TRACE(pContext->hLog, "Got unexpected message type %x!  DEBUGBREAK()-ing.",
				1, dwMsgType);
			DEBUGBREAK();
			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)


DONE:

	return (hr);
} // ParmVPEnumHostsDPNMessageHandler
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVPDestroyPeerDPNMessageHandler()"
//==================================================================================
// ParmVPDestroyPeerDPNMessageHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT ParmVPDestroyPeerDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT						hr = DPN_OK;
	PPARMVPDESTROYPEERCONTEXT	pContext = (PPARMVPDESTROYPEERCONTEXT) pvContext;
	DWORD						dwPlayer;


	switch (dwMsgType)
	{
		case DPN_MSGID_CONNECT_COMPLETE:
			PDPNMSG_CONNECT_COMPLETE	pConnectCompleteMsg;


			pConnectCompleteMsg = (PDPNMSG_CONNECT_COMPLETE) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CONNECT_COMPLETE", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pConnectCompleteMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    hAsyncOp = %x", 1, pConnectCompleteMsg->hAsyncOp);
			DPTEST_TRACE(pContext->hLog, "    pvUserContext = %x", 1, pConnectCompleteMsg->pvUserContext);
			DPTEST_TRACE(pContext->hLog, "    hResultCode = 0x%08x", 1, pConnectCompleteMsg->hResultCode);
			DPTEST_TRACE(pContext->hLog, "    pvApplicationReplyData = %x", 1, pConnectCompleteMsg->pvApplicationReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwApplicationReplyDataSize = %u", 1, pConnectCompleteMsg->dwApplicationReplyDataSize);


			// Make sure we expect the completion.
			if (! pContext->fConnectCanComplete)
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_CONNECT_COMPLETE (%x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				break;
			} // end if (message unexpected)


			// Validate the completion.
			if (pConnectCompleteMsg->dwSize != sizeof (DPNMSG_CONNECT_COMPLETE))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CONNECT_COMPLETE is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->dwSize, sizeof (DPNMSG_CONNECT_COMPLETE));
				DEBUGBREAK();
				break;
			} // end if (size incorrect)

			if (pConnectCompleteMsg->hResultCode != DPN_OK)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with failure!  DEBUGBREAK()-ing.  0x%08x",
					1, pConnectCompleteMsg->hResultCode);
				DEBUGBREAK();
				break;
			} // end if (wrong result code)

			if ((pConnectCompleteMsg->pvApplicationReplyData != NULL) ||
				(pConnectCompleteMsg->dwApplicationReplyDataSize != 0))
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with unexpected reply data (ptr %x != NULL or size %u != 0)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->pvApplicationReplyData,
					pConnectCompleteMsg->dwApplicationReplyDataSize);
				DEBUGBREAK();
				break;
			} // end if (unexpected reply data)


			// Make sure this isn't a double completion.
			if (pContext->fConnectCompleted)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed twice (msg = %x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				break;
			} // end if (double completion)

			// Alert the test case that the completion came in.
			pContext->fConnectCompleted = TRUE;

			// XBOX - Handle async connect
			if(pConnectCompleteMsg->pvUserContext)
			{
				SetEvent((HANDLE) pConnectCompleteMsg->pvUserContext);
			}
		  break;

		case DPN_MSGID_CREATE_PLAYER:
			PDPNMSG_CREATE_PLAYER	pCreatePlayerMsg;


			pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CREATE_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pCreatePlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pCreatePlayerMsg->dpnidPlayer, pCreatePlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pCreatePlayerMsg->pvPlayerContext);


			dwPlayer = (pCreatePlayerMsg->pvPlayerContext == NULL) ? 1 : 0;

			// Make sure we expect the message.
			if (! pContext->afExpectCreatePlayer[dwPlayer])
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_CREATE_PLAYER (%x)!  DEBUGBREAK()-ing.",
					1, pCreatePlayerMsg);
				DEBUGBREAK();
				break;
			} // end if (message unexpected)


			// Validate the completion.
			if (pCreatePlayerMsg->dwSize != sizeof (DPNMSG_CREATE_PLAYER))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CREATE_PLAYER is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pCreatePlayerMsg->dwSize, sizeof (DPNMSG_CREATE_PLAYER));
				DEBUGBREAK();
				break;
			} // end if (size incorrect)


			// Make sure this isn't a double indication.
			if (pContext->adpnidPlayers[dwPlayer] != 0)
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate create player (msg = %x)!  DEBUGBREAK()-ing.",
					1, pCreatePlayerMsg);
				DEBUGBREAK();
				break;
			} // end if (double indication)

			// Save the player ID.
			pContext->adpnidPlayers[dwPlayer] = pCreatePlayerMsg->dpnidPlayer;

			// Alert the test thread, if we have to.
			if (pContext->hLastPlayerMsgEvent != NULL)
			{
				if (! SetEvent(pContext->hLastPlayerMsgEvent))
				{
					hr = GetLastError();
					DPTEST_TRACE(pContext->hLog, "Couldn't set last player msg event (%x)!  DEBUGBREAK()-ing.",
						1, pContext->hLastPlayerMsgEvent);

					DEBUGBREAK();

					if (hr == S_OK)
						hr = E_FAIL;

					break;
				} // end if (couldn't set event)
			} // end if (have event)
		  break;

		case DPN_MSGID_DESTROY_PLAYER:
			PDPNMSG_DESTROY_PLAYER	pDestroyPlayerMsg;


			pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_DESTROY_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pDestroyPlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pDestroyPlayerMsg->dpnidPlayer, pDestroyPlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pDestroyPlayerMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    dwReason = %x", 1, pDestroyPlayerMsg->dwReason);


			dwPlayer = (pDestroyPlayerMsg->pvPlayerContext == NULL) ? 1 : 0;

			// Make sure we expect the message.
			if (! pContext->afExpectDestroyPlayer[dwPlayer])
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_DESTROY_PLAYER (%x)!  DEBUGBREAK()-ing.",
					1, pDestroyPlayerMsg);
				DEBUGBREAK();
				break;
			} // end if (message unexpected)


			// Validate the completion.
			if (pDestroyPlayerMsg->dwSize != sizeof (DPNMSG_DESTROY_PLAYER))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_DESTROY_PLAYER is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pDestroyPlayerMsg->dwSize, sizeof (DPNMSG_DESTROY_PLAYER));
				DEBUGBREAK();
				break;
			} // end if (size incorrect)


			// Make sure this isn't a double indication.
			if (pContext->adpnidPlayers[dwPlayer] == 0)
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate destroy player (msg = %x)!  DEBUGBREAK()-ing.",
					1, pDestroyPlayerMsg);
				DEBUGBREAK();
				break;
			} // end if (double indication)

			// Zero out the player ID.
			pContext->adpnidPlayers[dwPlayer] = 0;

			if (InterlockedDecrement((LPLONG) (&pContext->dwNumDestroyPlayersRemaining)) == 0)
			{
				// Alert the test thread, if we have to.
				if (pContext->hLastPlayerMsgEvent != NULL)
				{
					if (! SetEvent(pContext->hLastPlayerMsgEvent))
					{
						hr = GetLastError();
						DPTEST_TRACE(pContext->hLog, "Couldn't set last player msg event (%x)!  DEBUGBREAK()-ing.",
							1, pContext->hLastPlayerMsgEvent);

						DEBUGBREAK();

						if (hr == S_OK)
							hr = E_FAIL;

						break;
					} // end if (couldn't set event)
				} // end if (have event)
			} // end if (no more destroy players expected)
		  break;

		case DPN_MSGID_INDICATE_CONNECT:
			PDPNMSG_INDICATE_CONNECT	pIndicateConnectMsg;


			pIndicateConnectMsg = (PDPNMSG_INDICATE_CONNECT) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_INDICATE_CONNECT", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pIndicateConnectMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    pvUserConnectData = %x", 1, pIndicateConnectMsg->pvUserConnectData);
			DPTEST_TRACE(pContext->hLog, "    dwUserConnectDataSize = %u", 1, pIndicateConnectMsg->dwUserConnectDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyData = %x", 1, pIndicateConnectMsg->pvReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwReplyDataSize = %u", 1, pIndicateConnectMsg->dwReplyDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyContext = %x", 1, pIndicateConnectMsg->pvReplyContext);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pIndicateConnectMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    pAddressPlayer = 0x%08x", 1, pIndicateConnectMsg->pAddressPlayer);
			DPTEST_TRACE(pContext->hLog, "    pAddressDevice = 0x%08x", 1, pIndicateConnectMsg->pAddressDevice);

#pragma TODO(vanceo, "Validate DPN_MSGID_INDICATE_CONNECT")
		  break;

		case DPN_MSGID_TERMINATE_SESSION:
			PDPNMSG_TERMINATE_SESSION	pTerminateSessionMsg;


			pTerminateSessionMsg = (PDPNMSG_TERMINATE_SESSION) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_TERMINATE_SESSION", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pTerminateSessionMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    hResultCode = %x", 1, pTerminateSessionMsg->hResultCode);
			DPTEST_TRACE(pContext->hLog, "    pvTerminateData = %x", 1, pTerminateSessionMsg->pvTerminateData);
			DPTEST_TRACE(pContext->hLog, "    dwTerminateDataSize = %u", 1, pTerminateSessionMsg->dwTerminateDataSize);


			// Make sure we expect the message.
			if (! pContext->fExpectTerminateSession)
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_TERMINATE_SESSION (%x)!  DEBUGBREAK()-ing.",
					1, pTerminateSessionMsg);
				DEBUGBREAK();
				break;
			} // end if (message unexpected)


			// Validate the indication.
			if (pTerminateSessionMsg->dwSize != sizeof (DPNMSG_TERMINATE_SESSION))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_TERMINATE_SESSION is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pTerminateSessionMsg->dwSize, sizeof (DPNMSG_TERMINATE_SESSION));
				DEBUGBREAK();
				break;
			} // end if (size incorrect)

			if ((pTerminateSessionMsg->pvTerminateData != NULL) ||
				(pTerminateSessionMsg->dwTerminateDataSize != 0))
			{
				DPTEST_TRACE(pContext->hLog, "Terminate session indicated with unexpected data (ptr %x != NULL or size %u != 0)!  DEBUGBREAK()-ing.",
					2, pTerminateSessionMsg->pvTerminateData,
					pTerminateSessionMsg->dwTerminateDataSize);
				DEBUGBREAK();
				break;
			} // end if (unexpected data)


			// Make sure this isn't a double indication.
			if (pContext->fGotTerminateSession)
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate indication of terminate session (msg = %x)!  DEBUGBREAK()-ing.",
					1, pTerminateSessionMsg);
				DEBUGBREAK();
				break;
			} // end if (double completion)

			// Alert the test case that the indication came in.
			pContext->fGotTerminateSession = TRUE;
		  break;

		case DPN_MSGID_RECEIVE:
			PDPNMSG_RECEIVE		pReceiveMsg;


			pReceiveMsg = (PDPNMSG_RECEIVE) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_RECEIVE", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pReceiveMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidSender = %u/%x", 2, pReceiveMsg->dpnidSender, pReceiveMsg->dpnidSender);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pReceiveMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    pReceiveData = %x", 1, pReceiveMsg->pReceiveData);
			DPTEST_TRACE(pContext->hLog, "    dwReceiveDataSize = %u", 1, pReceiveMsg->dwReceiveDataSize);
			DPTEST_TRACE(pContext->hLog, "    hBufferHandle = %x", 1, pReceiveMsg->hBufferHandle);
			
//			DEBUGBREAK();

		  break;

		case DPN_MSGID_SEND_COMPLETE:
			PDPNMSG_SEND_COMPLETE	pSendCompleteMsg;


			pSendCompleteMsg = (PDPNMSG_SEND_COMPLETE) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_SEND_COMPLETE", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pSendCompleteMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    hAsyncOp = %x", 1, pSendCompleteMsg->hAsyncOp);
			DPTEST_TRACE(pContext->hLog, "    pvUserContext = %x", 1, pSendCompleteMsg->pvUserContext);
			DPTEST_TRACE(pContext->hLog, "    hResultCode = 0x%08x", 1, pSendCompleteMsg->hResultCode);
			DPTEST_TRACE(pContext->hLog, "    dwSendTime = %u", 1, pSendCompleteMsg->dwSendTime);

			// Make sure we expect the completion.
			if (! pContext->fSendCanComplete)
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_SEND_COMPLETE (%x)!  DEBUGBREAK()-ing.",
					1, pSendCompleteMsg);
				DEBUGBREAK();
				break;
			} // end if (message unexpected)

			pContext->hrActualResult = pSendCompleteMsg->hResultCode;

			if (pContext->hSendCompleteEvent != NULL)
			{
				if (! SetEvent(pContext->hSendCompleteEvent))
				{
					hr = GetLastError();
					DPTEST_TRACE(pContext->hLog, "Couldn't set send completion event (%x)!  DEBUGBREAK()-ing.",
						1, pContext->hSendCompleteEvent);

					DEBUGBREAK();

					if (hr == S_OK)
						hr = E_FAIL;
				} // end if (couldn't set event)
			} // end if (there's an event to set)
		  break;

		default:
			DPTEST_TRACE(pContext->hLog, "Got unexpected message type %x!  DEBUGBREAK()-ing.",
				1, dwMsgType);
			DEBUGBREAK();
			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)

	return (hr);
} // ParmVPDestroyPeerDPNMessageHandler
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVPReturnDPNMessageHandler()"
//==================================================================================
// ParmVPReturnDPNMessageHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT ParmVPReturnDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT					hr = DPN_OK;
	PPARMVPRETURNCONTEXT	pContext = (PPARMVPRETURNCONTEXT) pvContext;


	switch (dwMsgType)
	{
		case DPN_MSGID_CREATE_PLAYER:
			PDPNMSG_CREATE_PLAYER	pCreatePlayerMsg;


			pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CREATE_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pCreatePlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pCreatePlayerMsg->dpnidPlayer, pCreatePlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pCreatePlayerMsg->pvPlayerContext);


			// Validate the indication.
			if (pCreatePlayerMsg->dwSize != sizeof (DPNMSG_CREATE_PLAYER))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CREATE_PLAYER is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pCreatePlayerMsg->dwSize, sizeof (DPNMSG_CREATE_PLAYER));
				DEBUGBREAK();
				break;
			} // end if (size incorrect)

			if (pCreatePlayerMsg->pvPlayerContext == NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Player context is NULL!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				break;
			} // end if (context is not set yet)

			pCreatePlayerMsg->pvPlayerContext = &(pContext->dpnidPlayer);


			// Make sure this isn't a duplicate message.
			if (*((DPNID*) pCreatePlayerMsg->pvPlayerContext) != 0)
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate CREATE_PLAYER (msg = %x)!  DEBUGBREAK()-ing.",
					1, pCreatePlayerMsg);
				DEBUGBREAK();
				break;
			} // end if (already have ID)

			// Save the player ID.
			*((DPNID*) pCreatePlayerMsg->pvPlayerContext) = pCreatePlayerMsg->dpnidPlayer;
		  break;

		case DPN_MSGID_DESTROY_PLAYER:
			PDPNMSG_DESTROY_PLAYER	pDestroyPlayerMsg;


			pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_DESTROY_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pDestroyPlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pDestroyPlayerMsg->dpnidPlayer, pDestroyPlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pDestroyPlayerMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    dwReason = %x", 1, pDestroyPlayerMsg->dwReason);


			// Validate the indication.
			if (pDestroyPlayerMsg->dwSize != sizeof (DPNMSG_DESTROY_PLAYER))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_DESTROY_PLAYER is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pDestroyPlayerMsg->dwSize, sizeof (DPNMSG_DESTROY_PLAYER));
				DEBUGBREAK();
				break;
			} // end if (size incorrect)

			if (pDestroyPlayerMsg->pvPlayerContext == NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Player context is NULL!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				break;
			} // end if (context is wrong)

			if (pDestroyPlayerMsg->dwReason != DPNDESTROYPLAYERREASON_NORMAL)
			{
				DPTEST_TRACE(pContext->hLog, "Player destruction reason is unexpected (%x != %x)!  DEBUGBREAK()-ing.",
					2, pDestroyPlayerMsg->dwReason, DPNDESTROYPLAYERREASON_NORMAL);
				DEBUGBREAK();
				break;
			} // end if (reason is wrong)


			// Make sure this isn't a duplicate or bogus message.
			if ((*((DPNID*) pDestroyPlayerMsg->pvPlayerContext) == 0) ||
				(pDestroyPlayerMsg->dpnidPlayer != *((DPNID*) pDestroyPlayerMsg->pvPlayerContext)))
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate or unexpected DESTROY_PLAYER (msg = %x)!  DEBUGBREAK()-ing.",
					1, pDestroyPlayerMsg);
				DEBUGBREAK();
				break;
			} // end if (already have ID)

			// Clear the player ID.
			*((DPNID*) pDestroyPlayerMsg->pvPlayerContext) = 0;
		  break;

		case DPN_MSGID_RECEIVE:
			PDPNMSG_RECEIVE		pReceiveMsg;


			pReceiveMsg = (PDPNMSG_RECEIVE) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_RECEIVE", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pReceiveMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidSender = %u/%x", 2, pReceiveMsg->dpnidSender, pReceiveMsg->dpnidSender);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pReceiveMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    pReceiveData = %x", 1, pReceiveMsg->pReceiveData);
			DPTEST_TRACE(pContext->hLog, "    dwReceiveDataSize = %u", 1, pReceiveMsg->dwReceiveDataSize);
			DPTEST_TRACE(pContext->hLog, "    hBufferHandle = %x", 1, pReceiveMsg->hBufferHandle);


			// Make sure we can get receive indications.
			if (! pContext->fExpectReceive)
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_RECEIVE (%x)!  DEBUGBREAK()-ing.",
					1, pReceiveMsg);
				DEBUGBREAK();
				break;
			} // end if (message unexpected)


			// Validate the receive.
			if (pReceiveMsg->dwSize != sizeof (DPNMSG_RECEIVE))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_RECEIVE is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pReceiveMsg->dwSize, sizeof (DPNMSG_RECEIVE));
				DEBUGBREAK();
				break;
			} // end if (size incorrect)

			if (pReceiveMsg->dpnidSender != pContext->dpnidPlayer)
			{
				DPTEST_TRACE(pContext->hLog, "Receive indicated with wrong player ID (%x/%u != %x/%u)!  DEBUGBREAK()-ing.",
					4, pReceiveMsg->dpnidSender, pReceiveMsg->dpnidSender,
					pContext->dpnidPlayer, pContext->dpnidPlayer);
				DEBUGBREAK();
				break;
			} // end if (player context incorrect)

			if (pReceiveMsg->pvPlayerContext != &(pContext->dpnidPlayer))
			{
				DPTEST_TRACE(pContext->hLog, "Receive indicated with wrong player context (%x != %x)!  DEBUGBREAK()-ing.",
					2, pReceiveMsg->pvPlayerContext,
					&(pContext->dpnidPlayer));
				DEBUGBREAK();
				break;
			} // end if (player context incorrect)

			if (pReceiveMsg->pReceiveData == NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Receive indicated with NULL data pointer!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				break;
			} // end if (receive buffer invalid)

			if (pReceiveMsg->dwReceiveDataSize != (strlen("This is the send string which we will use.") + 1))
			{
				DPTEST_TRACE(pContext->hLog, "Receive indicated with wrong size (%u != %u)!  DEBUGBREAK()-ing.",
					2, pReceiveMsg->dwReceiveDataSize,
					(strlen("This is the send string which we will use.") + 1));
				DEBUGBREAK();
				break;
			} // end if (wrong buffer size)

			if (strcmp((char*) pReceiveMsg->pReceiveData, "This is the send string which we will use.") != 0)
			{
				DPTEST_TRACE(pContext->hLog, "Receive buffer is wrong (data at %x != data at %x)!  DEBUGBREAK()-ing.",
					2, pReceiveMsg->pReceiveData,
					"This is the send string which we will use.");
				DEBUGBREAK();
				break;
			} // end if (wrong buffer)
			
			if (pReceiveMsg->hBufferHandle == NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Receive indicated with NULL buffer handle!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				break;
			} // end if (buffer handle invalid)


			// Make sure this isn't a double receive.
			if (pContext->dpnhBuffer != NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Receive indicated twice (msg = %x)!  DEBUGBREAK()-ing.",
					1, pReceiveMsg);
				DEBUGBREAK();
				break;
			} // end if (double completion)

			// Alert the test case that the receive came in.
			pContext->dpnhBuffer = pReceiveMsg->hBufferHandle;

			if (! SetEvent(pContext->hReceivedMsgEvent))
			{
				hr = GetLastError();
				DPTEST_TRACE(pContext->hLog, "Couldn't set received msg event (%x)!  DEBUGBREAK()-ing.",
					1, pContext->hReceivedMsgEvent);

				DEBUGBREAK();

				if (hr == S_OK)
					hr = E_FAIL;

				break;
			} // end if (couldn't set event)


			// We're keeping the buffer.
			hr = (HRESULT) DPNSUCCESS_PENDING;
		  break;

		default:
			DPTEST_TRACE(pContext->hLog, "Got unexpected message type %x!  DEBUGBREAK()-ing.",
				1, dwMsgType);
			DEBUGBREAK();
			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)

	return (hr);
} // ParmVPReturnDPNMessageHandler
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVPGetPlayerContextDPNMessageHandler()"
//==================================================================================
// ParmVPGetPlayerContextDPNMessageHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT ParmVPGetPlayerContextDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT							hr = DPN_OK;
	PPARMVPGETPLAYERCONTEXTCONTEXT	pContext = (PPARMVPGETPLAYERCONTEXTCONTEXT) pvContext;
	DWORD							dwPlayer;


	switch (dwMsgType)
	{
		case DPN_MSGID_CONNECT_COMPLETE:
			PDPNMSG_CONNECT_COMPLETE	pConnectCompleteMsg;


			pConnectCompleteMsg = (PDPNMSG_CONNECT_COMPLETE) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CONNECT_COMPLETE", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pConnectCompleteMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    hAsyncOp = %x", 1, pConnectCompleteMsg->hAsyncOp);
			DPTEST_TRACE(pContext->hLog, "    pvUserContext = %x", 1, pConnectCompleteMsg->pvUserContext);
			DPTEST_TRACE(pContext->hLog, "    hResultCode = 0x%08x", 1, pConnectCompleteMsg->hResultCode);
			DPTEST_TRACE(pContext->hLog, "    pvApplicationReplyData = %x", 1, pConnectCompleteMsg->pvApplicationReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwApplicationReplyDataSize = %u", 1, pConnectCompleteMsg->dwApplicationReplyDataSize);


			// Make sure we expect the completion.
			if (! pContext->fConnectCanComplete)
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_CONNECT_COMPLETE (%x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				break;
			} // end if (message unexpected)


			// Validate the completion.
			if (pConnectCompleteMsg->dwSize != sizeof (DPNMSG_CONNECT_COMPLETE))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CONNECT_COMPLETE is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->dwSize, sizeof (DPNMSG_CONNECT_COMPLETE));
				DEBUGBREAK();
				break;
			} // end if (size incorrect)

			if (pConnectCompleteMsg->hResultCode != DPN_OK)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with failure!  DEBUGBREAK()-ing.  0x%08x",
					1, pConnectCompleteMsg->hResultCode);
				DEBUGBREAK();
				break;
			} // end if (wrong result code)

			if ((pConnectCompleteMsg->pvApplicationReplyData != NULL) ||
				(pConnectCompleteMsg->dwApplicationReplyDataSize != 0))
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with unexpected reply data (ptr %x != NULL or size %u != 0)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->pvApplicationReplyData,
					pConnectCompleteMsg->dwApplicationReplyDataSize);
				DEBUGBREAK();
				break;
			} // end if (unexpected reply data)


			// Make sure this isn't a double completion.
			if (pContext->fConnectCompleted)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed twice (msg = %x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				break;
			} // end if (double completion)

			// Alert the test case that the completion came in.
			pContext->fConnectCompleted = TRUE;

			// XBOX - Handle async connect
			if(pConnectCompleteMsg->pvUserContext)
			{
				SetEvent((HANDLE) pConnectCompleteMsg->pvUserContext);
			}
		  break;

		case DPN_MSGID_CREATE_PLAYER:
			PDPNMSG_CREATE_PLAYER	pCreatePlayerMsg;


			pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CREATE_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pCreatePlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pCreatePlayerMsg->dpnidPlayer, pCreatePlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pCreatePlayerMsg->pvPlayerContext);


			dwPlayer = (pCreatePlayerMsg->pvPlayerContext == NULL) ? 1 : 0;

			// Make sure we expect the message.
			if (! pContext->afExpectCreatePlayer[dwPlayer])
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_CREATE_PLAYER (%x)!  DEBUGBREAK()-ing.",
					1, pCreatePlayerMsg);
				DEBUGBREAK();
				break;
			} // end if (message unexpected)


			// Validate the completion.
			if (pCreatePlayerMsg->dwSize != sizeof (DPNMSG_CREATE_PLAYER))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CREATE_PLAYER is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pCreatePlayerMsg->dwSize, sizeof (DPNMSG_CREATE_PLAYER));
				DEBUGBREAK();
				break;
			} // end if (size incorrect)


			// Make sure this isn't a double indication.
			if (pContext->adpnidPlayers[dwPlayer] != 0)
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate create player (msg = %x)!  DEBUGBREAK()-ing.",
					1, pCreatePlayerMsg);
				DEBUGBREAK();
				break;
			} // end if (double indication)

			// Save the player ID.
			pContext->adpnidPlayers[dwPlayer] = pCreatePlayerMsg->dpnidPlayer;

			// Alert the test thread, if we have to.
			if (pContext->hLastPlayerMsgEvent != NULL)
			{
				if (! SetEvent(pContext->hLastPlayerMsgEvent))
				{
					hr = GetLastError();
					DPTEST_TRACE(pContext->hLog, "Couldn't set last player msg event (%x)!  DEBUGBREAK()-ing.",
						1, pContext->hLastPlayerMsgEvent);

					DEBUGBREAK();

					if (hr == S_OK)
						hr = E_FAIL;

					break;
				} // end if (couldn't set event)
			} // end if (have event)
		  break;

		case DPN_MSGID_DESTROY_PLAYER:
			PDPNMSG_DESTROY_PLAYER	pDestroyPlayerMsg;


			pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_DESTROY_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pDestroyPlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pDestroyPlayerMsg->dpnidPlayer, pDestroyPlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pDestroyPlayerMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    dwReason = %x", 1, pDestroyPlayerMsg->dwReason);


			dwPlayer = (pDestroyPlayerMsg->pvPlayerContext == NULL) ? 1 : 0;

			// Make sure we expect the message.
			if (! pContext->afExpectDestroyPlayer[dwPlayer])
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_DESTROY_PLAYER (%x)!  DEBUGBREAK()-ing.",
					1, pDestroyPlayerMsg);
				DEBUGBREAK();
				break;
			} // end if (message unexpected)


			// Validate the completion.
			if (pDestroyPlayerMsg->dwSize != sizeof (DPNMSG_DESTROY_PLAYER))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_DESTROY_PLAYER is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pDestroyPlayerMsg->dwSize, sizeof (DPNMSG_DESTROY_PLAYER));
				DEBUGBREAK();
				break;
			} // end if (size incorrect)


			// Make sure this isn't a double indication.
			if (pContext->adpnidPlayers[dwPlayer] == 0)
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate destroy player (msg = %x)!  DEBUGBREAK()-ing.",
					1, pDestroyPlayerMsg);
				DEBUGBREAK();
				break;
			} // end if (double indication)

			// Zero out the player ID.
			pContext->adpnidPlayers[dwPlayer] = 0;

			if (InterlockedDecrement((LPLONG) (&pContext->dwNumDestroyPlayersRemaining)) == 0)
			{
				// Alert the test thread, if we have to.
				if (pContext->hLastPlayerMsgEvent != NULL)
				{
					if (! SetEvent(pContext->hLastPlayerMsgEvent))
					{
						hr = GetLastError();
						DPTEST_TRACE(pContext->hLog, "Couldn't set last player msg event (%x)!  DEBUGBREAK()-ing.",
							1, pContext->hLastPlayerMsgEvent);

						DEBUGBREAK();

						if (hr == S_OK)
							hr = E_FAIL;

						break;
					} // end if (couldn't set event)
				} // end if (have event)
			} // end if (no more destroy players expected)
		  break;

		case DPN_MSGID_INDICATE_CONNECT:
			PDPNMSG_INDICATE_CONNECT	pIndicateConnectMsg;


			pIndicateConnectMsg = (PDPNMSG_INDICATE_CONNECT) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_INDICATE_CONNECT", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pIndicateConnectMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    pvUserConnectData = %x", 1, pIndicateConnectMsg->pvUserConnectData);
			DPTEST_TRACE(pContext->hLog, "    dwUserConnectDataSize = %u", 1, pIndicateConnectMsg->dwUserConnectDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyData = %x", 1, pIndicateConnectMsg->pvReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwReplyDataSize = %u", 1, pIndicateConnectMsg->dwReplyDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyContext = %x", 1, pIndicateConnectMsg->pvReplyContext);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pIndicateConnectMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    pAddressPlayer = 0x%08x", 1, pIndicateConnectMsg->pAddressPlayer);
			DPTEST_TRACE(pContext->hLog, "    pAddressDevice = 0x%08x", 1, pIndicateConnectMsg->pAddressDevice);

#pragma TODO(vanceo, "Validate DPN_MSGID_INDICATE_CONNECT")
		  break;

		default:
			DPTEST_TRACE(pContext->hLog, "Got unexpected message type %x!  DEBUGBREAK()-ing.",
				1, dwMsgType);
			DEBUGBREAK();
			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)

	return (hr);
} // ParmVPGetPlayerContextDPNMessageHandler
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVPGetGroupContextDPNMessageHandler()"
//==================================================================================
// ParmVPGetGroupContextDPNMessageHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT ParmVPGetGroupContextDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT							hr = DPN_OK;
	PPARMVPGETGROUPCONTEXTCONTEXT	pContext = (PPARMVPGETGROUPCONTEXTCONTEXT) pvContext;
	BOOL							fSetEvent = FALSE;


	switch (dwMsgType)
	{
		case DPN_MSGID_ASYNC_OP_COMPLETE:
			PDPNMSG_ASYNC_OP_COMPLETE	pAsyncOpCompleteMsg;


			pAsyncOpCompleteMsg = (PDPNMSG_ASYNC_OP_COMPLETE) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_ASYNC_OP_COMPLETE", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pAsyncOpCompleteMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    hAsyncOp = %x", 1, pAsyncOpCompleteMsg->hAsyncOp);
			DPTEST_TRACE(pContext->hLog, "    pvUserContext = %x", 1, pAsyncOpCompleteMsg->pvUserContext);
			DPTEST_TRACE(pContext->hLog, "    hResultCode = 0x%08x", 1, pAsyncOpCompleteMsg->hResultCode);

			// Validate the completion.
			if (pAsyncOpCompleteMsg->dwSize != sizeof (DPNMSG_ASYNC_OP_COMPLETE))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_ASYNC_OP_COMPLETE is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pAsyncOpCompleteMsg->dwSize, sizeof (DPNMSG_ASYNC_OP_COMPLETE));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pAsyncOpCompleteMsg->hResultCode != DPN_OK)
			{
				DPTEST_TRACE(pContext->hLog, "Async op completed with failure!  DEBUGBREAK()-ing.  0x%08x",
					1, pAsyncOpCompleteMsg->hResultCode);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (wrong result code)

			// XBOX - Handle async ops
			if(pAsyncOpCompleteMsg->pvUserContext)
			{
				SetEvent((HANDLE) pAsyncOpCompleteMsg->pvUserContext);
			}
		  break;

		case DPN_MSGID_CONNECT_COMPLETE:
			PDPNMSG_CONNECT_COMPLETE	pConnectCompleteMsg;


			pConnectCompleteMsg = (PDPNMSG_CONNECT_COMPLETE) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CONNECT_COMPLETE", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pConnectCompleteMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    hAsyncOp = %x", 1, pConnectCompleteMsg->hAsyncOp);
			DPTEST_TRACE(pContext->hLog, "    pvUserContext = %x", 1, pConnectCompleteMsg->pvUserContext);
			DPTEST_TRACE(pContext->hLog, "    hResultCode = 0x%08x", 1, pConnectCompleteMsg->hResultCode);
			DPTEST_TRACE(pContext->hLog, "    pvApplicationReplyData = %x", 1, pConnectCompleteMsg->pvApplicationReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwApplicationReplyDataSize = %u", 1, pConnectCompleteMsg->dwApplicationReplyDataSize);


			// Make sure we expect the completion.
			if (! pContext->fConnectCanComplete)
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_CONNECT_COMPLETE (%x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (message unexpected)


			// Validate the completion.
			if (pConnectCompleteMsg->dwSize != sizeof (DPNMSG_CONNECT_COMPLETE))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CONNECT_COMPLETE is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->dwSize, sizeof (DPNMSG_CONNECT_COMPLETE));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pConnectCompleteMsg->hResultCode != DPN_OK)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with failure!  DEBUGBREAK()-ing.  0x%08x",
					1, pConnectCompleteMsg->hResultCode);
				DEBUGBREAK();
				hr = pConnectCompleteMsg->hResultCode;
				goto DONE;
			} // end if (wrong result code)

			if ((pConnectCompleteMsg->pvApplicationReplyData != NULL) ||
				(pConnectCompleteMsg->dwApplicationReplyDataSize != 0))
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with unexpected reply data (ptr %x != NULL or size %u != 0)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->pvApplicationReplyData,
					pConnectCompleteMsg->dwApplicationReplyDataSize);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (unexpected reply data)


			// Make sure this isn't a double completion.
			if (pContext->fConnectCompleted)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed twice (msg = %x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (double completion)

			// Alert the test case that the completion came in.
			pContext->fConnectCompleted = TRUE;

			// XBOX - Handle async connect
			if(pConnectCompleteMsg->pvUserContext)
			{
				SetEvent((HANDLE) pConnectCompleteMsg->pvUserContext);
			}
		  break;

		case DPN_MSGID_CREATE_GROUP:
			PDPNMSG_CREATE_GROUP	pCreateGroupMsg;


			pCreateGroupMsg = (PDPNMSG_CREATE_GROUP) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CREATE_GROUP", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pCreateGroupMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidGroup = %u/%x", 2, pCreateGroupMsg->dpnidGroup, pCreateGroupMsg->dpnidGroup);
			DPTEST_TRACE(pContext->hLog, "    dpnidOwner = %u/%x", 2, pCreateGroupMsg->dpnidOwner, pCreateGroupMsg->dpnidOwner);
			DPTEST_TRACE(pContext->hLog, "    pvGroupContext = %x", 1, pCreateGroupMsg->pvGroupContext);


			// Make sure we expect the indication.
			if (! pContext->fCanGetCreateGroup)
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_CREATE_GROUP (at %x)!  DEBUGBREAK()-ing.",
					1, pCreateGroupMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (message unexpected)

			// Validate the message.
			if (pCreateGroupMsg->dwSize != sizeof (DPNMSG_CREATE_GROUP))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CREATE_GROUP is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pCreateGroupMsg->dwSize, sizeof (DPNMSG_CREATE_GROUP));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pCreateGroupMsg->dpnidGroup == 0)
			{
				DPTEST_TRACE(pContext->hLog, "Group created got invalid ID of 0!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (group ID is 0)

			if (pCreateGroupMsg->dpnidOwner != pContext->dpnidExpectedGroupOwner)
			{
				DPTEST_TRACE(pContext->hLog, "Group owner was wrong (%u/%x != %u/%x)!  DEBUGBREAK()-ing.",
					4, pCreateGroupMsg->dpnidOwner, pCreateGroupMsg->dpnidOwner,
					pContext->dpnidExpectedGroupOwner, pContext->dpnidExpectedGroupOwner);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (group owner is wrong)


			if (pCreateGroupMsg->pvGroupContext == NULL)
			{
				// Set the group context to something else.
				pCreateGroupMsg->pvGroupContext = &(pContext->dpnidGroup);
			} // end if (no group context)
			else if (pCreateGroupMsg->pvGroupContext != &(pContext->dpnidGroup))
			{
				DPTEST_TRACE(pContext->hLog, "Group ID %u/%x created with bogus context (%x != %x)!  DEBUGBREAK()-ing.",
					4, pCreateGroupMsg->dpnidGroup, pCreateGroupMsg->dpnidGroup,
					pCreateGroupMsg->pvGroupContext, &(pContext->dpnidGroup));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end else (unexpected group context)


			// Make sure this isn't a double indication.
			if (pContext->dpnidGroup != 0)
			{
				DPTEST_TRACE(pContext->hLog, "Got create group twice!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (double completion)

			// Alert the test case that the indication came in.
			pContext->dpnidGroup = pCreateGroupMsg->dpnidGroup;

			if (pContext->hGotGroupMsgEvent != NULL)
			{
				if (! SetEvent(pContext->hGotGroupMsgEvent))
				{
					hr = GetLastError();
					DPTEST_TRACE(pContext->hLog, "Couldn't set got group msg event (%x)!  DEBUGBREAK()-ing.",
						1, pContext->hGotGroupMsgEvent);

					DEBUGBREAK();

					if (hr == S_OK)
						hr = E_FAIL;

					goto DONE;
				} // end if (couldn't set event)
			} // end if (there's a group msg event)
		  break;

		case DPN_MSGID_CREATE_PLAYER:
			PDPNMSG_CREATE_PLAYER	pCreatePlayerMsg;


			pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CREATE_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pCreatePlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pCreatePlayerMsg->dpnidPlayer, pCreatePlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pCreatePlayerMsg->pvPlayerContext);


			// Validate the indication.
			if (pCreatePlayerMsg->dwSize != sizeof (DPNMSG_CREATE_PLAYER))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CREATE_PLAYER is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pCreatePlayerMsg->dwSize, sizeof (DPNMSG_CREATE_PLAYER));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pCreatePlayerMsg->pvPlayerContext == NULL)
			{
				// Assume this is the remote player being created.  Store the
				// player context.
				if (pContext->fHost)
				{
					pCreatePlayerMsg->pvPlayerContext = &(pContext->dpnidClient);
					fSetEvent = TRUE;
				} // end if (host)
				else
				{
					pCreatePlayerMsg->pvPlayerContext = &(pContext->dpnidHost);
				} // end if (not host)
			} // end if (context is not set yet)


			// Make sure this isn't a duplicate message.
			if (*((DPNID*) pCreatePlayerMsg->pvPlayerContext) != 0)
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate CREATE_PLAYER (msg = %x)!  DEBUGBREAK()-ing.",
					1, pCreatePlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (already have ID)

			// Save the player ID.
			*((DPNID*) pCreatePlayerMsg->pvPlayerContext) = pCreatePlayerMsg->dpnidPlayer;


			// Now set the event, if we're supposed too.
			if (fSetEvent)
			{
				if (! SetEvent(pContext->hClientCreatedEvent))
				{
					hr = GetLastError();
					DPTEST_TRACE(pContext->hLog, "Couldn't set client created event (%x)!  DEBUGBREAK()-ing.",
						1, pContext->hClientCreatedEvent);

					DEBUGBREAK();

					if (hr == S_OK)
						hr = E_FAIL;

					goto DONE;
				} // end if (couldn't set event)
			} // end if (should set event)
		  break;

		case DPN_MSGID_DESTROY_GROUP:
			PDPNMSG_DESTROY_GROUP	pDestroyGroupMsg;


			pDestroyGroupMsg = (PDPNMSG_DESTROY_GROUP) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_DESTROY_GROUP", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pDestroyGroupMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidGroup = %u/%x", 2, pDestroyGroupMsg->dpnidGroup, pDestroyGroupMsg->dpnidGroup);
			DPTEST_TRACE(pContext->hLog, "    pvGroupContext = %x", 1, pDestroyGroupMsg->pvGroupContext);
			DPTEST_TRACE(pContext->hLog, "    dwReason = %u", 1, pDestroyGroupMsg->dwReason);

#pragma TODO(vanceo, "Validate DPN_MSGID_DESTROY_GROUP")
		  break;

		case DPN_MSGID_DESTROY_PLAYER:
			PDPNMSG_DESTROY_PLAYER	pDestroyPlayerMsg;


			pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_DESTROY_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pDestroyPlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pDestroyPlayerMsg->dpnidPlayer, pDestroyPlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pDestroyPlayerMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    dwReason = %x", 1, pDestroyPlayerMsg->dwReason);


			// Validate the indication.
			if (pDestroyPlayerMsg->dwSize != sizeof (DPNMSG_DESTROY_PLAYER))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_DESTROY_PLAYER is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pDestroyPlayerMsg->dwSize, sizeof (DPNMSG_DESTROY_PLAYER));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pDestroyPlayerMsg->pvPlayerContext == NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Player context is NULL!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (context is wrong)

			if (pDestroyPlayerMsg->dwReason != DPNDESTROYPLAYERREASON_NORMAL)
			{
				DPTEST_TRACE(pContext->hLog, "Player destruction reason is unexpected (%x != %x)!  DEBUGBREAK()-ing.",
					2, pDestroyPlayerMsg->dwReason, DPNDESTROYPLAYERREASON_NORMAL);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (reason is wrong)


			// Make sure this isn't a duplicate or bogus message.
			if ((*((DPNID*) pDestroyPlayerMsg->pvPlayerContext) == 0) ||
				(pDestroyPlayerMsg->dpnidPlayer != *((DPNID*) pDestroyPlayerMsg->pvPlayerContext)))
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate or unexpected DESTROY_PLAYER (msg = %x)!  DEBUGBREAK()-ing.",
					1, pDestroyPlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (already have ID)

			// Clear the player ID.
			*((DPNID*) pDestroyPlayerMsg->pvPlayerContext) = 0;
		  break;

		case DPN_MSGID_INDICATE_CONNECT:
			PDPNMSG_INDICATE_CONNECT	pIndicateConnectMsg;


			pIndicateConnectMsg = (PDPNMSG_INDICATE_CONNECT) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_INDICATE_CONNECT", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pIndicateConnectMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    pvUserConnectData = %x", 1, pIndicateConnectMsg->pvUserConnectData);
			DPTEST_TRACE(pContext->hLog, "    dwUserConnectDataSize = %u", 1, pIndicateConnectMsg->dwUserConnectDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyData = %x", 1, pIndicateConnectMsg->pvReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwReplyDataSize = %u", 1, pIndicateConnectMsg->dwReplyDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyContext = %x", 1, pIndicateConnectMsg->pvReplyContext);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pIndicateConnectMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    pAddressPlayer = 0x%08x", 1, pIndicateConnectMsg->pAddressPlayer);
			DPTEST_TRACE(pContext->hLog, "    pAddressDevice = 0x%08x", 1, pIndicateConnectMsg->pAddressDevice);

#pragma TODO(vanceo, "Validate DPN_MSGID_INDICATE_CONNECT")
		  break;

		default:
			DPTEST_TRACE(pContext->hLog, "Got unexpected message type %x!  DEBUGBREAK()-ing.",
				1, dwMsgType);
			DEBUGBREAK();
			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)


DONE:

	return (hr);
} // ParmVPGetGroupContextDPNMessageHandler
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVPGetCapsDPNMessageHandler()"
//==================================================================================
// ParmVPGetCapsDPNMessageHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT ParmVPGetCapsDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT					hr = DPN_OK;
	PPARMVPGENERICCONTEXT	pContext = (PPARMVPGENERICCONTEXT) pvContext;


	switch (dwMsgType)
	{
		case DPN_MSGID_CREATE_PLAYER:
			PDPNMSG_CREATE_PLAYER	pCreatePlayerMsg;


			pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CREATE_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pCreatePlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pCreatePlayerMsg->dpnidPlayer, pCreatePlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pCreatePlayerMsg->pvPlayerContext);
		  break;

		case DPN_MSGID_DESTROY_PLAYER:
			PDPNMSG_DESTROY_PLAYER	pDestroyPlayerMsg;


			pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_DESTROY_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pDestroyPlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pDestroyPlayerMsg->dpnidPlayer, pDestroyPlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pDestroyPlayerMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    dwReason = %x", 1, pDestroyPlayerMsg->dwReason);
		  break;

		case DPN_MSGID_INDICATE_CONNECT:
			PDPNMSG_INDICATE_CONNECT	pIndicateConnectMsg;


			pIndicateConnectMsg = (PDPNMSG_INDICATE_CONNECT) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_INDICATE_CONNECT", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pIndicateConnectMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    pvUserConnectData = %x", 1, pIndicateConnectMsg->pvUserConnectData);
			DPTEST_TRACE(pContext->hLog, "    dwUserConnectDataSize = %u", 1, pIndicateConnectMsg->dwUserConnectDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyData = %x", 1, pIndicateConnectMsg->pvReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwReplyDataSize = %u", 1, pIndicateConnectMsg->dwReplyDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyContext = %x", 1, pIndicateConnectMsg->pvReplyContext);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pIndicateConnectMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    pAddressPlayer = 0x%08x", 1, pIndicateConnectMsg->pAddressPlayer);
			DPTEST_TRACE(pContext->hLog, "    pAddressDevice = 0x%08x", 1, pIndicateConnectMsg->pAddressDevice);
		  break;

		default:
			DPTEST_TRACE(pContext->hLog, "Got unexpected message type %x!  DEBUGBREAK()-ing.",
				1, dwMsgType);
			DEBUGBREAK();
			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)

	return (hr);
} // ParmVPGetCapsDPNMessageHandler
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVPSetCapsDPNMessageHandler()"
//==================================================================================
// ParmVPSetCapsDPNMessageHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT ParmVPSetCapsDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT					hr = DPN_OK;
	PPARMVPGENERICCONTEXT	pContext = (PPARMVPGENERICCONTEXT) pvContext;


	switch (dwMsgType)
	{
		case DPN_MSGID_CREATE_PLAYER:
			PDPNMSG_CREATE_PLAYER	pCreatePlayerMsg;


			pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CREATE_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pCreatePlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pCreatePlayerMsg->dpnidPlayer, pCreatePlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pCreatePlayerMsg->pvPlayerContext);
		  break;

		case DPN_MSGID_DESTROY_PLAYER:
			PDPNMSG_DESTROY_PLAYER	pDestroyPlayerMsg;


			pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_DESTROY_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pDestroyPlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pDestroyPlayerMsg->dpnidPlayer, pDestroyPlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pDestroyPlayerMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    dwReason = %x", 1, pDestroyPlayerMsg->dwReason);
		  break;

		case DPN_MSGID_INDICATE_CONNECT:
			PDPNMSG_INDICATE_CONNECT	pIndicateConnectMsg;


			pIndicateConnectMsg = (PDPNMSG_INDICATE_CONNECT) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_INDICATE_CONNECT", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pIndicateConnectMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    pvUserConnectData = %x", 1, pIndicateConnectMsg->pvUserConnectData);
			DPTEST_TRACE(pContext->hLog, "    dwUserConnectDataSize = %u", 1, pIndicateConnectMsg->dwUserConnectDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyData = %x", 1, pIndicateConnectMsg->pvReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwReplyDataSize = %u", 1, pIndicateConnectMsg->dwReplyDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyContext = %x", 1, pIndicateConnectMsg->pvReplyContext);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pIndicateConnectMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    pAddressPlayer = 0x%08x", 1, pIndicateConnectMsg->pAddressPlayer);
			DPTEST_TRACE(pContext->hLog, "    pAddressDevice = 0x%08x", 1, pIndicateConnectMsg->pAddressDevice);
		  break;

		default:
			DPTEST_TRACE(pContext->hLog, "Got unexpected message type %x!  DEBUGBREAK()-ing.",
				1, dwMsgType);
			DEBUGBREAK();
			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)

	return (hr);
} // ParmVPSetCapsDPNMessageHandler
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVPGetSPCapsDPNMessageHandler()"
//==================================================================================
// ParmVPGetSPCapsDPNMessageHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT ParmVPGetSPCapsDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT					hr = DPN_OK;
	PPARMVPGENERICCONTEXT	pContext = (PPARMVPGENERICCONTEXT) pvContext;


	switch (dwMsgType)
	{
		case DPN_MSGID_CREATE_PLAYER:
			PDPNMSG_CREATE_PLAYER	pCreatePlayerMsg;


			pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CREATE_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pCreatePlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pCreatePlayerMsg->dpnidPlayer, pCreatePlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pCreatePlayerMsg->pvPlayerContext);
		  break;

		case DPN_MSGID_DESTROY_PLAYER:
			PDPNMSG_DESTROY_PLAYER	pDestroyPlayerMsg;


			pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_DESTROY_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pDestroyPlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pDestroyPlayerMsg->dpnidPlayer, pDestroyPlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pDestroyPlayerMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    dwReason = %x", 1, pDestroyPlayerMsg->dwReason);
		  break;

		case DPN_MSGID_INDICATE_CONNECT:
			PDPNMSG_INDICATE_CONNECT	pIndicateConnectMsg;


			pIndicateConnectMsg = (PDPNMSG_INDICATE_CONNECT) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_INDICATE_CONNECT", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pIndicateConnectMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    pvUserConnectData = %x", 1, pIndicateConnectMsg->pvUserConnectData);
			DPTEST_TRACE(pContext->hLog, "    dwUserConnectDataSize = %u", 1, pIndicateConnectMsg->dwUserConnectDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyData = %x", 1, pIndicateConnectMsg->pvReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwReplyDataSize = %u", 1, pIndicateConnectMsg->dwReplyDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyContext = %x", 1, pIndicateConnectMsg->pvReplyContext);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pIndicateConnectMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    pAddressPlayer = 0x%08x", 1, pIndicateConnectMsg->pAddressPlayer);
			DPTEST_TRACE(pContext->hLog, "    pAddressDevice = 0x%08x", 1, pIndicateConnectMsg->pAddressDevice);
		  break;

		default:
			DPTEST_TRACE(pContext->hLog, "Got unexpected message type %x!  DEBUGBREAK()-ing.",
				1, dwMsgType);
			DEBUGBREAK();
			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)

	return (hr);
} // ParmVPGetSPCapsDPNMessageHandler
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVPSetSPCapsDPNMessageHandler()"
//==================================================================================
// ParmVPSetSPCapsDPNMessageHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT ParmVPSetSPCapsDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT					hr = DPN_OK;
	PPARMVPGENERICCONTEXT	pContext = (PPARMVPGENERICCONTEXT) pvContext;


	switch (dwMsgType)
	{
		case DPN_MSGID_CREATE_PLAYER:
			PDPNMSG_CREATE_PLAYER	pCreatePlayerMsg;


			pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CREATE_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pCreatePlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pCreatePlayerMsg->dpnidPlayer, pCreatePlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pCreatePlayerMsg->pvPlayerContext);
		  break;

		case DPN_MSGID_DESTROY_PLAYER:
			PDPNMSG_DESTROY_PLAYER	pDestroyPlayerMsg;


			pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_DESTROY_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pDestroyPlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pDestroyPlayerMsg->dpnidPlayer, pDestroyPlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pDestroyPlayerMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    dwReason = %x", 1, pDestroyPlayerMsg->dwReason);
		  break;

		case DPN_MSGID_INDICATE_CONNECT:
			PDPNMSG_INDICATE_CONNECT	pIndicateConnectMsg;


			pIndicateConnectMsg = (PDPNMSG_INDICATE_CONNECT) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_INDICATE_CONNECT", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pIndicateConnectMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    pvUserConnectData = %x", 1, pIndicateConnectMsg->pvUserConnectData);
			DPTEST_TRACE(pContext->hLog, "    dwUserConnectDataSize = %u", 1, pIndicateConnectMsg->dwUserConnectDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyData = %x", 1, pIndicateConnectMsg->pvReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwReplyDataSize = %u", 1, pIndicateConnectMsg->dwReplyDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyContext = %x", 1, pIndicateConnectMsg->pvReplyContext);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pIndicateConnectMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    pAddressPlayer = 0x%08x", 1, pIndicateConnectMsg->pAddressPlayer);
			DPTEST_TRACE(pContext->hLog, "    pAddressDevice = 0x%08x", 1, pIndicateConnectMsg->pAddressDevice);
		  break;

		default:
			DPTEST_TRACE(pContext->hLog, "Got unexpected message type %x!  DEBUGBREAK()-ing.",
				1, dwMsgType);
			DEBUGBREAK();
			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)

	return (hr);
} // ParmVPSetSPCapsDPNMessageHandler
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVPGetConnInfoDPNMessageHandler()"
//==================================================================================
// ParmVPGetConnInfoDPNMessageHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT ParmVPGetConnInfoDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT						hr = DPN_OK;
	PPARMVPGETCONNINFOCONTEXT	pContext = (PPARMVPGETCONNINFOCONTEXT) pvContext;
	BOOL						fSetEvent = FALSE;


	switch (dwMsgType)
	{
		case DPN_MSGID_CONNECT_COMPLETE:
			PDPNMSG_CONNECT_COMPLETE	pConnectCompleteMsg;


			pConnectCompleteMsg = (PDPNMSG_CONNECT_COMPLETE) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CONNECT_COMPLETE", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pConnectCompleteMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    hAsyncOp = %x", 1, pConnectCompleteMsg->hAsyncOp);
			DPTEST_TRACE(pContext->hLog, "    pvUserContext = %x", 1, pConnectCompleteMsg->pvUserContext);
			DPTEST_TRACE(pContext->hLog, "    hResultCode = 0x%08x", 1, pConnectCompleteMsg->hResultCode);
			DPTEST_TRACE(pContext->hLog, "    pvApplicationReplyData = %x", 1, pConnectCompleteMsg->pvApplicationReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwApplicationReplyDataSize = %u", 1, pConnectCompleteMsg->dwApplicationReplyDataSize);


			// Make sure we expect the completion.
			if (! pContext->fConnectCanComplete)
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_CONNECT_COMPLETE (%x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (message unexpected)


			// Validate the completion.
			if (pConnectCompleteMsg->dwSize != sizeof (DPNMSG_CONNECT_COMPLETE))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CONNECT_COMPLETE is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->dwSize, sizeof (DPNMSG_CONNECT_COMPLETE));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pConnectCompleteMsg->hResultCode != DPN_OK)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with failure!  DEBUGBREAK()-ing.  0x%08x",
					1, pConnectCompleteMsg->hResultCode);
				DEBUGBREAK();
				hr = pConnectCompleteMsg->hResultCode;
				goto DONE;
			} // end if (wrong result code)

			if ((pConnectCompleteMsg->pvApplicationReplyData != NULL) ||
				(pConnectCompleteMsg->dwApplicationReplyDataSize != 0))
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with unexpected reply data (ptr %x != NULL or size %u != 0)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->pvApplicationReplyData,
					pConnectCompleteMsg->dwApplicationReplyDataSize);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (unexpected reply data)


			// Make sure this isn't a double completion.
			if (pContext->fConnectCompleted)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed twice (msg = %x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (double completion)

			// Alert the test case that the completion came in.
			pContext->fConnectCompleted = TRUE;

			// XBOX - Handle async connect
			if(pConnectCompleteMsg->pvUserContext)
			{
				SetEvent((HANDLE) pConnectCompleteMsg->pvUserContext);
			}
		  break;

		case DPN_MSGID_CREATE_PLAYER:
			PDPNMSG_CREATE_PLAYER	pCreatePlayerMsg;


			pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CREATE_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pCreatePlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pCreatePlayerMsg->dpnidPlayer, pCreatePlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pCreatePlayerMsg->pvPlayerContext);


			// Validate the indication.
			if (pCreatePlayerMsg->dwSize != sizeof (DPNMSG_CREATE_PLAYER))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CREATE_PLAYER is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pCreatePlayerMsg->dwSize, sizeof (DPNMSG_CREATE_PLAYER));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pCreatePlayerMsg->pvPlayerContext == NULL)
			{
				// Assume this is the remote player being created.  Store the
				// player context.
				if (pContext->fHost)
				{
					pCreatePlayerMsg->pvPlayerContext = &(pContext->dpnidClient);
					fSetEvent = TRUE;
				} // end if (host)
				else
				{
					pCreatePlayerMsg->pvPlayerContext = &(pContext->dpnidHost);
				} // end if (not host)
			} // end if (context is not set yet)


			// Make sure this isn't a duplicate message.
			if (*((DPNID*) pCreatePlayerMsg->pvPlayerContext) != 0)
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate CREATE_PLAYER (msg = %x)!  DEBUGBREAK()-ing.",
					1, pCreatePlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (already have ID)

			// Save the player ID.
			*((DPNID*) pCreatePlayerMsg->pvPlayerContext) = pCreatePlayerMsg->dpnidPlayer;


			// Now set the event, if we're supposed too.
			if (fSetEvent)
			{
				if (! SetEvent(pContext->hClientCreatedEvent))
				{
					hr = GetLastError();
					DPTEST_TRACE(pContext->hLog, "Couldn't set client created event (%x)!  DEBUGBREAK()-ing.",
						1, pContext->hClientCreatedEvent);

					DEBUGBREAK();

					if (hr == S_OK)
						hr = E_FAIL;

					goto DONE;
				} // end if (couldn't set event)
			} // end if (should set event)
		  break;

		case DPN_MSGID_DESTROY_PLAYER:
			PDPNMSG_DESTROY_PLAYER	pDestroyPlayerMsg;


			pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_DESTROY_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pDestroyPlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pDestroyPlayerMsg->dpnidPlayer, pDestroyPlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pDestroyPlayerMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    dwReason = %x", 1, pDestroyPlayerMsg->dwReason);


			// Validate the indication.
			if (pDestroyPlayerMsg->dwSize != sizeof (DPNMSG_DESTROY_PLAYER))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_DESTROY_PLAYER is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pDestroyPlayerMsg->dwSize, sizeof (DPNMSG_DESTROY_PLAYER));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pDestroyPlayerMsg->pvPlayerContext == NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Player context is NULL!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (context is wrong)

			if (pDestroyPlayerMsg->dwReason != DPNDESTROYPLAYERREASON_NORMAL)
			{
				DPTEST_TRACE(pContext->hLog, "Player destruction reason is unexpected (%x != %x)!  DEBUGBREAK()-ing.",
					2, pDestroyPlayerMsg->dwReason, DPNDESTROYPLAYERREASON_NORMAL);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (reason is wrong)


			// Make sure this isn't a duplicate or bogus message.
			if ((*((DPNID*) pDestroyPlayerMsg->pvPlayerContext) == 0) ||
				(pDestroyPlayerMsg->dpnidPlayer != *((DPNID*) pDestroyPlayerMsg->pvPlayerContext)))
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate or unexpected DESTROY_PLAYER (msg = %x)!  DEBUGBREAK()-ing.",
					1, pDestroyPlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (already have ID)

			// Clear the player ID.
			*((DPNID*) pDestroyPlayerMsg->pvPlayerContext) = 0;
		  break;

		case DPN_MSGID_INDICATE_CONNECT:
			PDPNMSG_INDICATE_CONNECT	pIndicateConnectMsg;


			pIndicateConnectMsg = (PDPNMSG_INDICATE_CONNECT) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_INDICATE_CONNECT", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pIndicateConnectMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    pvUserConnectData = %x", 1, pIndicateConnectMsg->pvUserConnectData);
			DPTEST_TRACE(pContext->hLog, "    dwUserConnectDataSize = %u", 1, pIndicateConnectMsg->dwUserConnectDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyData = %x", 1, pIndicateConnectMsg->pvReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwReplyDataSize = %u", 1, pIndicateConnectMsg->dwReplyDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyContext = %x", 1, pIndicateConnectMsg->pvReplyContext);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pIndicateConnectMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    pAddressPlayer = 0x%08x", 1, pIndicateConnectMsg->pAddressPlayer);
			DPTEST_TRACE(pContext->hLog, "    pAddressDevice = 0x%08x", 1, pIndicateConnectMsg->pAddressDevice);

#pragma TODO(vanceo, "Validate DPN_MSGID_INDICATE_CONNECT")
		  break;

		default:
			DPTEST_TRACE(pContext->hLog, "Got unexpected message type %x!  DEBUGBREAK()-ing.",
				1, dwMsgType);
			DEBUGBREAK();
			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)


DONE:

	return (hr);
} // ParmVPGetConnInfoDPNMessageHandler
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVPTerminateDPNMessageHandler()"
//==================================================================================
// ParmVPTerminateDPNMessageHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT ParmVPTerminateDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT						hr = DPN_OK;
	PPARMVPTERMINATECONTEXT		pContext = (PPARMVPTERMINATECONTEXT) pvContext;
	DWORD						dwPlayer;

	DPTEST_TRACE(pContext->hLog, "Callback entered with context 0x%08x", 1, pvContext);

	switch (dwMsgType)
	{
		case DPN_MSGID_CONNECT_COMPLETE:
			PDPNMSG_CONNECT_COMPLETE	pConnectCompleteMsg;


			pConnectCompleteMsg = (PDPNMSG_CONNECT_COMPLETE) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CONNECT_COMPLETE", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pConnectCompleteMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    hAsyncOp = %x", 1, pConnectCompleteMsg->hAsyncOp);
			DPTEST_TRACE(pContext->hLog, "    pvUserContext = %x", 1, pConnectCompleteMsg->pvUserContext);
			DPTEST_TRACE(pContext->hLog, "    hResultCode = 0x%08x", 1, pConnectCompleteMsg->hResultCode);
			DPTEST_TRACE(pContext->hLog, "    pvApplicationReplyData = %x", 1, pConnectCompleteMsg->pvApplicationReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwApplicationReplyDataSize = %u", 1, pConnectCompleteMsg->dwApplicationReplyDataSize);


			// Make sure we expect the completion.
			if (! pContext->fConnectCanComplete)
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_CONNECT_COMPLETE (%x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				break;
			} // end if (message unexpected)


			// Validate the completion.
			if (pConnectCompleteMsg->dwSize != sizeof (DPNMSG_CONNECT_COMPLETE))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CONNECT_COMPLETE is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->dwSize, sizeof (DPNMSG_CONNECT_COMPLETE));
				DEBUGBREAK();
				break;
			} // end if (size incorrect)

			if (pConnectCompleteMsg->hResultCode != DPN_OK)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with failure!  DEBUGBREAK()-ing.  0x%08x",
					1, pConnectCompleteMsg->hResultCode);
				DEBUGBREAK();
				break;
			} // end if (wrong result code)

			if ((pConnectCompleteMsg->pvApplicationReplyData != NULL) ||
				(pConnectCompleteMsg->dwApplicationReplyDataSize != 0))
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with unexpected reply data (ptr %x != NULL or size %u != 0)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->pvApplicationReplyData,
					pConnectCompleteMsg->dwApplicationReplyDataSize);
				DEBUGBREAK();
				break;
			} // end if (unexpected reply data)


			// Make sure this isn't a double completion.
			if (pContext->fConnectCompleted)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed twice (msg = %x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				break;
			} // end if (double completion)

			// Alert the test case that the completion came in.
			pContext->fConnectCompleted = TRUE;

			// XBOX - Handle async connect
			if(pConnectCompleteMsg->pvUserContext)
			{
				SetEvent((HANDLE) pConnectCompleteMsg->pvUserContext);
			}
		  break;

		case DPN_MSGID_CREATE_PLAYER:
			PDPNMSG_CREATE_PLAYER	pCreatePlayerMsg;


			pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CREATE_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pCreatePlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pCreatePlayerMsg->dpnidPlayer, pCreatePlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pCreatePlayerMsg->pvPlayerContext);


			dwPlayer = (pCreatePlayerMsg->pvPlayerContext == NULL) ? 1 : 0;

			// Make sure we expect the message.
			if (! pContext->afExpectCreatePlayer[dwPlayer])
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_CREATE_PLAYER (%x)!  DEBUGBREAK()-ing.",
					1, pCreatePlayerMsg);
				DEBUGBREAK();
				break;
			} // end if (message unexpected)


			// Validate the completion.
			if (pCreatePlayerMsg->dwSize != sizeof (DPNMSG_CREATE_PLAYER))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CREATE_PLAYER is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pCreatePlayerMsg->dwSize, sizeof (DPNMSG_CREATE_PLAYER));
				DEBUGBREAK();
				break;
			} // end if (size incorrect)


			// Make sure this isn't a double indication.
			if (pContext->adpnidPlayers[dwPlayer] != 0)
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate create player (msg = %x)!  DEBUGBREAK()-ing.",
					1, pCreatePlayerMsg);
				DEBUGBREAK();
				break;
			} // end if (double indication)

			// Save the player ID.
			pContext->adpnidPlayers[dwPlayer] = pCreatePlayerMsg->dpnidPlayer;

			// Alert the test thread, if we have to.
			if (pContext->hLastPlayerMsgEvent != NULL)
			{
				if (! SetEvent(pContext->hLastPlayerMsgEvent))
				{
					hr = GetLastError();
					DPTEST_TRACE(pContext->hLog, "Couldn't set last player msg event (%x)!  DEBUGBREAK()-ing.",
						1, pContext->hLastPlayerMsgEvent);

					DEBUGBREAK();

					if (hr == S_OK)
						hr = E_FAIL;

					break;
				} // end if (couldn't set event)
			} // end if (have event)
		  break;

		case DPN_MSGID_DESTROY_PLAYER:
			PDPNMSG_DESTROY_PLAYER	pDestroyPlayerMsg;


			pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_DESTROY_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pDestroyPlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pDestroyPlayerMsg->dpnidPlayer, pDestroyPlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pDestroyPlayerMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    dwReason = %x", 1, pDestroyPlayerMsg->dwReason);


			dwPlayer = (pDestroyPlayerMsg->pvPlayerContext == NULL) ? 1 : 0;

			// Make sure we expect the message.
			if (! pContext->afExpectDestroyPlayer[dwPlayer])
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_DESTROY_PLAYER (%x)!  DEBUGBREAK()-ing.",
					1, pDestroyPlayerMsg);
				DEBUGBREAK();
				break;
			} // end if (message unexpected)


			// Validate the completion.
			if (pDestroyPlayerMsg->dwSize != sizeof (DPNMSG_DESTROY_PLAYER))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_DESTROY_PLAYER is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pDestroyPlayerMsg->dwSize, sizeof (DPNMSG_DESTROY_PLAYER));
				DEBUGBREAK();
				break;
			} // end if (size incorrect)


			// Make sure this isn't a double indication.
			if (pContext->adpnidPlayers[dwPlayer] == 0)
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate destroy player (msg = %x)!  DEBUGBREAK()-ing.",
					1, pDestroyPlayerMsg);
				DEBUGBREAK();
				break;
			} // end if (double indication)

			// Zero out the player ID.
			pContext->adpnidPlayers[dwPlayer] = 0;

			if (InterlockedDecrement((LPLONG) (&pContext->dwNumDestroyPlayersRemaining)) == 0)
			{
				// Alert the test thread, if we have to.
				if (pContext->hLastPlayerMsgEvent != NULL)
				{
					if (! SetEvent(pContext->hLastPlayerMsgEvent))
					{
						hr = GetLastError();
						DPTEST_TRACE(pContext->hLog, "Couldn't set last player msg event (%x)!  DEBUGBREAK()-ing.",
							1, pContext->hLastPlayerMsgEvent);

						DEBUGBREAK();

						if (hr == S_OK)
							hr = E_FAIL;

						break;
					} // end if (couldn't set event)
				} // end if (have event)
			} // end if (no more destroy players expected)
		  break;

		case DPN_MSGID_INDICATE_CONNECT:
			PDPNMSG_INDICATE_CONNECT	pIndicateConnectMsg;


			pIndicateConnectMsg = (PDPNMSG_INDICATE_CONNECT) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_INDICATE_CONNECT", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pIndicateConnectMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    pvUserConnectData = %x", 1, pIndicateConnectMsg->pvUserConnectData);
			DPTEST_TRACE(pContext->hLog, "    dwUserConnectDataSize = %u", 1, pIndicateConnectMsg->dwUserConnectDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyData = %x", 1, pIndicateConnectMsg->pvReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwReplyDataSize = %u", 1, pIndicateConnectMsg->dwReplyDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyContext = %x", 1, pIndicateConnectMsg->pvReplyContext);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pIndicateConnectMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    pAddressPlayer = 0x%08x", 1, pIndicateConnectMsg->pAddressPlayer);
			DPTEST_TRACE(pContext->hLog, "    pAddressDevice = 0x%08x", 1, pIndicateConnectMsg->pAddressDevice);

#pragma TODO(vanceo, "Validate DPN_MSGID_INDICATE_CONNECT")
		  break;

		case DPN_MSGID_TERMINATE_SESSION:
			PDPNMSG_TERMINATE_SESSION	pTerminateSessionMsg;


			pTerminateSessionMsg = (PDPNMSG_TERMINATE_SESSION) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_TERMINATE_SESSION", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pTerminateSessionMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    hResultCode = %x", 1, pTerminateSessionMsg->hResultCode);
			DPTEST_TRACE(pContext->hLog, "    pvTerminateData = %x", 1, pTerminateSessionMsg->pvTerminateData);
			DPTEST_TRACE(pContext->hLog, "    dwTerminateDataSize = %u", 1, pTerminateSessionMsg->dwTerminateDataSize);


			// Make sure we expect the message.
			if (! pContext->fExpectTerminateSession)
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_TERMINATE_SESSION (%x)!  DEBUGBREAK()-ing.",
					1, pTerminateSessionMsg);
				DEBUGBREAK();
				break;
			} // end if (message unexpected)


			// Validate the indication.
			if (pTerminateSessionMsg->dwSize != sizeof (DPNMSG_TERMINATE_SESSION))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_TERMINATE_SESSION is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pTerminateSessionMsg->dwSize, sizeof (DPNMSG_TERMINATE_SESSION));
				DEBUGBREAK();
				break;
			} // end if (size incorrect)

			if ((pTerminateSessionMsg->pvTerminateData != NULL) ||
				(pTerminateSessionMsg->dwTerminateDataSize != 0))
			{
				DPTEST_TRACE(pContext->hLog, "Terminate session indicated with unexpected data (ptr %x != NULL or size %u != 0)!  DEBUGBREAK()-ing.",
					2, pTerminateSessionMsg->pvTerminateData,
					pTerminateSessionMsg->dwTerminateDataSize);
				DEBUGBREAK();
				break;
			} // end if (unexpected data)


			// Make sure this isn't a double indication.
			if (pContext->fGotTerminateSession)
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate indication of terminate session (msg = %x)!  DEBUGBREAK()-ing.",
					1, pTerminateSessionMsg);
				DEBUGBREAK();
				break;
			} // end if (double completion)

			// Alert the test case that the indication came in.
			pContext->fGotTerminateSession = TRUE;
		  break;

		default:
			DPTEST_TRACE(pContext->hLog, "Got unexpected message type %x!  DEBUGBREAK()-ing.",
				1, dwMsgType);
			DEBUGBREAK();
			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)

	return (hr);
} // ParmVPTerminateDPNMessageHandler
#undef DEBUG_SECTION
#define DEBUG_SECTION	""

} // namespace DPlayCoreNamespace